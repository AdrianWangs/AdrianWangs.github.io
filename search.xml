<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>字节跳动 后端开发工程师 一面</title>
    <url>/2025/08/03/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/2025-08-03-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: 字节跳动（互联网大厂）</li>
<li><strong>职位</strong>: 后端开发工程师（抖音生活服务平台治理）</li>
<li><strong>面试轮次</strong>: 一面（技术面）</li>
<li><strong>面试形式</strong>: 线上视频面试</li>
<li><strong>面试时长</strong>: 约53分钟</li>
<li><strong>面试官</strong>: 技术leader，负责平台治理业务</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：自我介绍">问题1：自我介绍</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“先简单自我介绍一下”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“你好，我是王宇哲，来自华东师范大学的软件工程硕士。我考研的话是排70人中排名第二，本科的话是专业排名第一，获得过国家奖学金以及蓝桥杯国赛二等奖之类的荣誉。我简历上的话主要的项目都是基于Go语言去构建的分布式应用…”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>其实自我介绍可以更简洁有力一些。可以这样回答：</p>
<p>&quot;你好，我是王宇哲，华东师范大学软件工程硕士在读。在校期间成绩优秀，获得过国家奖学金和蓝桥杯国赛二等奖。主要技术栈是Go语言，有丰富的分布式系统开发经验。</p>
<p>我的项目经历包括：</p>
<ol>
<li>独立开发的分布式缓存系统，单节点性能超过5000QPS</li>
<li>字节跳动青训营的抖音商城微服务项目，担任队长</li>
<li>目前在上海人工智能实验室实习，参与开源项目开发</li>
</ol>
<p>对分布式系统、缓存机制、微服务架构都有较深的理解。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答比较详细，但可以更结构化</li>
<li>面试官耐心听完，没有打断</li>
<li>应该突出技术栈和核心项目</li>
</ul>
<h3 id="问题2：项目经历详细询问">问题2：项目经历详细询问</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“能稍微讲一下在人工智能实验室里面做的那个项目是干什么呢？他要解决什么问题，然后我做的是什么呢？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“这个项目的话，目前它其实也在一个探索场景的阶段。然后它能想到最常见的场景，就是现在很多人需要做自己的RAG向量数据库。但是那个数据库做切片什么的，其实一般来说都是用markdown去做。就是用markdown这个文件去做数据分片什么的会比较好一些。但是大多数人手上的其实都是PDF文件，然后我们的话是可以把PDF转化成markdown…”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题回答可以更清晰一些：</p>
<p>&quot;我们做的是一个PDF转Markdown的工具，主要解决AI时代的文档处理问题。</p>
<p>背景是这样的：现在很多人需要构建自己的向量数据库来做RAG应用，但大多数人的原始文档都是PDF格式。而向量数据库的切片处理，用Markdown格式会更合适。</p>
<p>我们的项目可以：</p>
<ol>
<li>将PDF转换为Markdown格式</li>
<li>保留完整的图片和表格结构</li>
<li>精准识别LaTeX数学公式</li>
<li>支持复杂表格的跨行跨列识别</li>
</ol>
<p>我在其中主要负责后端开发，包括模型部署、异步任务调度、性能优化等工作。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答比较口语化，逻辑不够清晰</li>
<li>面试官继续追问了技术细节</li>
<li>应该先说明背景，再介绍解决方案</li>
</ul>
<h3 id="问题3：MySQL索引数据结构">问题3：MySQL索引数据结构</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你这边了解过mysql索引的数据结构吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“MySQL索引的数据结构的话主要就是B+树。然后如果说它的引擎是哈希的话，它的数据结构就是哈希表。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题可以回答得更全面：</p>
<p>&quot;MySQL的索引数据结构主要有两种：</p>
<ol>
<li>
<p><strong>B+树索引</strong>：这是InnoDB存储引擎的默认索引结构，也是应用最广泛的。B+树的特点是：</p>
<ul>
<li>支持范围查询和排序</li>
<li>适合频繁的增删改查操作</li>
<li>查询时间复杂度是O(log n)</li>
</ul>
</li>
<li>
<p><strong>哈希索引</strong>：主要用于Memory存储引擎，特点是：</p>
<ul>
<li>查询速度极快，时间复杂度O(1)</li>
<li>只支持等值查询，不支持范围查询</li>
<li>适合只有插入和查询的场景</li>
</ul>
</li>
</ol>
<p>实际应用中，B+树索引更通用，因为大多数业务都需要支持范围查询和排序操作。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答比较基础，没有深入分析</li>
<li>面试官继续追问了优劣势对比</li>
<li>应该准备更详细的应用场景分析</li>
</ul>
<h3 id="问题4：哈希索引的优化">问题4：哈希索引的优化</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“那如果说让你优化的话，你觉你会怎么优化这个地方？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“让我优化的话，我可能会把哈希跟其他数据结构结合在一起。就比如说哈希下面连一棵树，把链表改成树，这种树的话就比较方便定位到数据，就比较好删除。比如说连个什么B+树什么的。但是的话，对哈希跟B+树最大的优缺点在于哈希我感觉它是更适合用于内存型数据库的。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题可以回答得更具体一些：</p>
<p>&quot;如果要优化哈希索引的删除性能，我考虑几种方案：</p>
<ol>
<li>
<p><strong>哈希+红黑树</strong>：将哈希冲突的链表改为红黑树，这样删除的时间复杂度从O(n)降到O(log n)</p>
</li>
<li>
<p><strong>计数哈希</strong>：在哈希表中存储计数器而不是布尔值，这样可以支持删除操作</p>
</li>
<li>
<p><strong>分层设计</strong>：将热点数据放在内存中，冷数据放在磁盘上</p>
</li>
</ol>
<p>但是哈希索引最大的问题是它只适合内存数据库，因为随机访问对磁盘IO不友好。所以实际应用中，B+树索引仍然是主流选择。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答有创新性，但不够系统</li>
<li>面试官对优化方案感兴趣</li>
<li>应该结合实际应用场景来分析</li>
</ul>
<h3 id="问题5：跳表数据结构">问题5：跳表数据结构</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你这边了解过跳表这个数据结构吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“跳表了解过，但是没有那么熟悉。它查询的时间复杂度应该是O(log n)。它的删除的话只要找到了以后，它的删除的时间复杂度我感觉应该是O(1)。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>跳表是一个很重要的数据结构，可以这样回答：</p>
<p>&quot;跳表是一种概率性的数据结构，可以看作是链表的多层版本。</p>
<p><strong>查询时间复杂度</strong>：平均O(log n)，最坏O(n)</p>
<p><strong>删除时间复杂度</strong>：找到节点后删除是O(1)，但找到节点需要O(log n)，所以总体是O(log n)</p>
<p><strong>插入时间复杂度</strong>：O(log n)</p>
<p>跳表的优势是：</p>
<ol>
<li>实现相对简单</li>
<li>支持范围查询</li>
<li>空间复杂度是O(n)</li>
</ol>
<p>Redis的Sorted Set就是用跳表实现的，因为它比红黑树更容易实现，而且性能相当。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时对跳表了解不够深入</li>
<li>面试官没有继续追问</li>
<li>应该提前准备Redis等实际应用案例</li>
</ul>
<h3 id="问题6：Redis缓存问题">问题6：Redis缓存问题</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你这边能之前了解过像缓存雪崩、击穿、穿透这些概念”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“这些我是了解的，因为我项目里面就有，比如说缓存雪崩的话就是一大批的数据它可能同时过期，导致大量的请求直接越过缓存，直接打到数据库上面去了，导致数据库可能会宕机。然后缓存击穿的话，缓存击穿的话就是当有一个热点数据，这个热点数据访问的频率非常高，但它突然过期了。然后就导致了一个问题，就导致大量的请求直接打到了数据库上。然后缓存穿透的话，它就是大量的请求打到了不存在缓存的数据上面…”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题回答得比较全面，可以稍微补充一下：</p>
<p>&quot;是的，我了解这三种缓存问题：</p>
<p><strong>缓存穿透</strong>：大量请求查询不存在的数据，绕过缓存直接访问数据库</p>
<ul>
<li>解决方案：布隆过滤器、缓存空值</li>
</ul>
<p><strong>缓存击穿</strong>：热点数据过期，大量请求直接访问数据库</p>
<ul>
<li>解决方案：互斥锁、永不过期、提前更新</li>
</ul>
<p><strong>缓存雪崩</strong>：大量缓存同时过期，导致数据库压力激增</p>
<ul>
<li>解决方案：随机过期时间、熔断机制、多级缓存</li>
</ul>
<p>我在项目中就实现了SingleFlight机制来解决缓存击穿问题。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答比较详细，覆盖了主要概念</li>
<li>面试官继续追问了具体解决方案</li>
<li>回答质量较好，体现了实践经验</li>
</ul>
<h3 id="问题7：布隆过滤器">问题7：布隆过滤器</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你这边能稍微讲一下这个布隆过滤器它是做什么？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“布隆过滤器的话，它有很多种应用场景。就比如说过滤掉那些不常见的数据，过滤掉系统中不存在的数据，这是刚刚一种解法。还有一种的话，它其实是可以做一些模糊查询，可以对字符串进行模糊查询，这也是一种应用场景。就是说它可以对一个字符串进行N种哈希。如果说它怎么说呢？它有个叫局部敏感哈希，可以对多个字符串进行局部敏感哈希，这样可以匹配到相似的字符串。就是通过哈希关系，我主要了解是这两种应用场景。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>布隆过滤器的回答可以更准确一些：</p>
<p>&quot;布隆过滤器是一种概率性的数据结构，主要用于快速判断一个元素是否在集合中。</p>
<p><strong>工作原理</strong>：</p>
<ol>
<li>使用k个哈希函数对元素进行哈希</li>
<li>将k个位置都标记为1</li>
<li>查询时检查k个位置是否都为1</li>
</ol>
<p><strong>应用场景</strong>：</p>
<ol>
<li><strong>缓存穿透防护</strong>：快速过滤不存在的key</li>
<li><strong>垃圾邮件过滤</strong>：判断邮件地址是否在黑名单</li>
<li><strong>网页爬虫去重</strong>：判断URL是否已访问</li>
<li><strong>数据库查询优化</strong>：减少不必要的数据库查询</li>
</ol>
<p><strong>特点</strong>：</p>
<ul>
<li>空间效率高</li>
<li>查询速度快O(k)</li>
<li>有假阳性，无假阴性</li>
<li>不支持删除（除非使用计数布隆过滤器）&quot;</li>
</ul>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答有些概念混淆</li>
<li>面试官追问了删除支持问题</li>
<li>应该更准确地描述工作原理</li>
</ul>
<h3 id="问题8：Go语言垃圾回收">问题8：Go语言垃圾回收</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“那你能稍微讲一下那个Golang的垃圾回收机制吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“Go语言垃圾回收机制的话，我记得它好像有一个演变过程。首先它一开始的垃圾回收的话，它是直接叫stop the world。就是他在垃圾回收之前，他会把整个程序暂停，然后把垃圾全都回收了。就是从根节点出发，然后把它一个个标记那些可以访问到的那些内存，然后把那些访问不到内存直接给它清除掉，这是第一种方式。然后后面的话就发现这种方式的话，它对性能的影响会比较大。于是他就后面衍生出了一个三色标记法的一种垃圾回收机制…”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Go的垃圾回收机制可以这样回答：</p>
<p>&quot;Go语言的垃圾回收经历了几个阶段：</p>
<p><strong>1. Go 1.3之前 - Stop The World</strong></p>
<ul>
<li>暂停整个程序进行垃圾回收</li>
<li>对性能影响很大</li>
</ul>
<p><strong>2. Go 1.5 - 三色标记法</strong></p>
<ul>
<li>白色：未被访问的对象</li>
<li>灰色：已被访问但子对象未访问的对象</li>
<li>黑色：已被访问且子对象已访问的对象</li>
</ul>
<p><strong>3. Go 1.8 - 混合写屏障</strong></p>
<ul>
<li>减少并发标记时的写屏障开销</li>
</ul>
<p><strong>4. Go 1.12 - 标记清除</strong></p>
<ul>
<li>进一步优化标记阶段</li>
</ul>
<p><strong>5. Go 1.14 - 并发标记清除</strong></p>
<ul>
<li>标记和清除阶段都可以并发执行</li>
</ul>
<p>现在的Go使用三色标记+并发回收，大大减少了GC对程序性能的影响。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答比较详细，体现了对Go GC的了解</li>
<li>面试官没有继续追问</li>
<li>回答质量较好，体现了技术深度</li>
</ul>
<h3 id="问题9：乐观锁和悲观锁">问题9：乐观锁和悲观锁</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你这边了解过乐观锁和悲观锁吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“乐观锁的话，乐观锁的话他认为他是一种很乐观的想法，就是他预先把事情做好了，然后再加锁，这样性能会好一点。然后悲观锁的话就是认为所有的请求它都有可能会失败，所以说它会提前加锁，加锁以后再执行，这样对性能的影响会比较大。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题可以回答得更具体一些：</p>
<p>&quot;乐观锁和悲观锁是两种不同的并发控制策略：</p>
<p><strong>乐观锁</strong>：</p>
<ul>
<li>假设冲突很少发生，先执行操作，再检查冲突</li>
<li>实现方式：版本号、时间戳、CAS操作</li>
<li>适用场景：读多写少、冲突较少的场景</li>
<li>性能：并发性能好，但冲突时重试开销大</li>
</ul>
<p><strong>悲观锁</strong>：</p>
<ul>
<li>假设冲突经常发生，先加锁再执行操作</li>
<li>实现方式：数据库行锁、表锁、分布式锁</li>
<li>适用场景：写多读少、冲突较多的场景</li>
<li>性能：并发性能差，但无重试开销</li>
</ul>
<p>实际应用中要根据业务特点选择，比如库存扣减用悲观锁，用户信息更新用乐观锁。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答比较抽象，缺乏具体例子</li>
<li>面试官追问了应用场景</li>
<li>应该准备更多实际应用案例</li>
</ul>
<h3 id="问题10：TCP报文格式">问题10：TCP报文格式</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你这边能稍微讲一下就比如说像TCP它的报文格式，你这个之前了解过吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“TCP的报文格式的话，首先第一个就是第一行，它是32字节。然后前32个位，然后前面16位的话是源端口，后面16位的话是目标端口。然后接下来的话好像是序列号。2个32位它分别应该代表的是一个是序列号，还有一个是确认号，然后后面好像就是有一部分空出来的那接下来就是什么ACK、SYN之类的标志位，然后再往后的话应该是一些校验位，但具体的也记不太清楚了。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>TCP报文格式可以这样回答：</p>
<p>&quot;TCP报文格式包含以下字段：</p>
<p><strong>源端口和目的端口</strong>：各16位，标识发送和接收的进程</p>
<p><strong>序列号</strong>：32位，标识本报文段第一个字节的序号</p>
<p><strong>确认号</strong>：32位，期望收到对方下一个报文段的第一个字节序号</p>
<p><strong>数据偏移</strong>：4位，指出TCP报文段的数据起始处距离TCP报文段起始处有多远</p>
<p><strong>保留字段</strong>：6位，保留为今后使用</p>
<p><strong>控制位</strong>：6位，包括URG、ACK、PSH、RST、SYN、FIN</p>
<p><strong>窗口大小</strong>：16位，告诉对方本报文段发送方的接收窗口大小</p>
<p><strong>校验和</strong>：16位，检验整个TCP报文段</p>
<p><strong>紧急指针</strong>：16位，仅在URG=1时有效</p>
<p><strong>选项和填充</strong>：可变长度&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答比较混乱，记忆不够准确</li>
<li>面试官没有继续追问</li>
<li>应该提前复习网络协议的基础知识</li>
</ul>
<h3 id="问题11：算法题-链表对折">问题11：算法题 - 链表对折</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“我这边给你准备一道算法题，能看到这个页面变化吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我想的最简单的解法就是把它给拆成两个链表。先把它按中间拆成两个链表，然后另一个链表它拆的过程中，它是使用头插法，这样就可以把它反转了，然后它时间复杂度也会很低，然后再把这两个链表再拼起来。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这道链表对折题可以这样解决：</p>
<p>&quot;我的思路是：</p>
<ol>
<li>使用快慢指针找到链表中间节点</li>
<li>将后半部分链表反转</li>
<li>将两个链表交替合并</li>
</ol>
<p>具体实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reorderList</span><span class="params">(head *ListNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到中间节点</span></span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &amp;&amp; fast.Next.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反转后半部分</span></span><br><span class="line">    second := reverseList(slow.Next)</span><br><span class="line">    slow.Next = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交替合并</span></span><br><span class="line">    first := head</span><br><span class="line">    <span class="keyword">for</span> second != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp1, temp2 := first.Next, second.Next</span><br><span class="line">        first.Next = second</span><br><span class="line">        second.Next = temp1</span><br><span class="line">        first, second = temp1, temp2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，空间复杂度：O(1)&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时思路正确，但表达不够清晰</li>
<li>面试官让我现场实现</li>
<li>应该提前准备代码实现</li>
</ul>
<h3 id="问题12：并发编程题">问题12：并发编程题</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“另外还有一个是你这边做过，就像比如说是我现在有两个协程，然后想一个打印奇数，一个打印偶数，然后你能做到让他们两个交替输出吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“可以，我上次的面试也是这个，上次字节的面试也是这个题。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这道并发编程题可以这样解决：</p>
<p>&quot;这道题可以用channel来实现两个goroutine的交替执行：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alternatePrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印奇数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">99</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">            &lt;-ch1</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            ch2 &lt;- <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印偶数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">            &lt;-ch2</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            ch1 &lt;- <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    ch1 &lt;- <span class="number">1</span> <span class="comment">// 启动第一个goroutine</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键点：</p>
<ol>
<li>使用两个channel进行同步</li>
<li>用WaitGroup等待两个goroutine完成</li>
<li>通过channel控制执行顺序&quot;</li>
</ol>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时有经验，但实现时出现了死锁</li>
<li>面试官追问了死锁原因</li>
<li>应该更仔细地检查channel的使用</li>
</ul>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中，主要考察基础知识和实际编程能力</li>
<li><strong>面试官风格</strong>: 友善专业，会引导思考，不会刻意刁难</li>
<li><strong>题目类型</strong>: 技术基础（数据库、缓存、网络）+ 算法编程 + 项目经历</li>
<li><strong>准备建议</strong>: 重点复习Go语言、数据库、缓存机制，准备算法题和并发编程</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官表示会和HR沟通，没有当场给出明确结果</li>
<li><strong>后续流程</strong>: 技术面一般有三轮，等待HR通知</li>
<li><strong>个人感受</strong>: 整体表现还可以，基础知识掌握较好，但有些细节需要加强</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ol>
<li><strong>项目经历丰富</strong>：有实际的项目经验，能详细说明技术细节</li>
<li><strong>基础知识扎实</strong>：对缓存机制、数据库索引等概念理解较好</li>
<li><strong>学习能力强</strong>：能快速理解面试官的问题并给出合理回答</li>
</ol>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ol>
<li><strong>表达不够清晰</strong>：有些回答比较口语化，逻辑不够清晰</li>
<li><strong>细节掌握不够</strong>：对TCP报文格式、跳表等细节了解不够深入</li>
<li><strong>代码实现能力</strong>：算法题的代码实现需要更加熟练</li>
</ol>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>系统复习基础知识</strong>：重点复习网络协议、数据结构、并发编程</li>
<li><strong>准备项目细节</strong>：对项目中的技术选型和实现细节要了如指掌</li>
<li><strong>练习算法编程</strong>：多练习链表、树、并发编程等常见题型</li>
<li><strong>提升表达能力</strong>：练习用更清晰的语言表达技术概念</li>
</ol>
<h3 id="知识点复习">知识点复习</h3>
<ul>
<li><strong>数据库</strong>：B+树索引、哈希索引、乐观锁悲观锁</li>
<li><strong>缓存机制</strong>：缓存穿透、击穿、雪崩及解决方案</li>
<li><strong>数据结构</strong>：布隆过滤器、跳表、链表操作</li>
<li><strong>网络协议</strong>：TCP报文格式、三次握手四次挥手</li>
<li><strong>并发编程</strong>：Go语言GMP模型、垃圾回收、channel使用</li>
<li><strong>算法题</strong>：链表操作、并发编程题</li>
</ul>
<p>这次面试让我意识到在技术深度和表达能力上还有提升空间，需要继续加强基础知识的掌握和实际编程能力的训练。</p>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
        <tag>一面</tag>
        <tag>后端开发</tag>
        <tag>抖音生活服务</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 239 - 滑动窗口最大值（Sliding Window Maximum）</title>
    <url>/2025/07/26/LeetCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="核心算法：单调队列">核心算法：单调队列</h3>
<p>这道题的核心思想是使用<strong>单调递减队列</strong>来维护滑动窗口中的最大值。单调队列的特点是队列中的元素按照从大到小的顺序排列，队首元素始终是当前窗口的最大值。</p>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li><strong>初始化单调队列</strong>：创建一个双端队列来存储数组索引</li>
<li><strong>维护单调性</strong>：每次添加新元素时，从队尾移除所有小于等于当前元素的值</li>
<li><strong>处理窗口滑动</strong>：当窗口左边界移动时，移除队列中已经不在窗口内的元素</li>
<li><strong>获取最大值</strong>：队首元素始终是当前窗口的最大值</li>
</ol>
<h3 id="关键洞见">关键洞见</h3>
<ul>
<li><strong>单调队列的优势</strong>：不需要遍历整个窗口来找到最大值，时间复杂度从 O(k) 降低到 O(1)</li>
<li><strong>索引存储</strong>：存储索引而不是值，便于判断元素是否还在窗口内</li>
<li><strong>延迟删除</strong>：只有当队首元素确实不在窗口内时才删除，避免频繁操作</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以 <code>nums = [1,3,-1,-3,5,3,6,7], k = 3</code> 为例：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>当前元素</th>
<th>队列状态</th>
<th>窗口</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>[0]</td>
<td>[1]</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>[1]</td>
<td>[1,3]</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>-1</td>
<td>[1,2]</td>
<td>[1,3,-1]</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>-3</td>
<td>[1,2,3]</td>
<td>[3,-1,-3]</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>[4]</td>
<td>[-1,-3,5]</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
<td>[4,5]</td>
<td>[-3,5,3]</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>6</td>
<td>[6]</td>
<td>[5,3,6]</td>
<td>6</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
<td>[7]</td>
<td>[3,6,7]</td>
<td>7</td>
</tr>
</tbody>
</table>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || k == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n-k+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 单调递减队列，存储索引</span></span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 移除队列中已经不在窗口内的元素</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; queue[<span class="number">0</span>] &lt;= i-k &#123;</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护单调递减性质：移除所有小于等于当前元素的值</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; nums[queue[<span class="built_in">len</span>(queue)<span class="number">-1</span>]] &lt;= nums[i] &#123;</span><br><span class="line">            queue = queue[:<span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前元素索引加入队列</span></span><br><span class="line">        queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当窗口大小达到k时，开始记录结果</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k<span class="number">-1</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, nums[queue[<span class="number">0</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码优化版本">代码优化版本</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, n-k+<span class="number">1</span>)</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 移除过期元素</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; queue[<span class="number">0</span>] &lt;= i-k &#123;</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 维护单调递减队列</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &amp;&amp; nums[queue[<span class="built_in">len</span>(queue)<span class="number">-1</span>]] &lt; nums[i] &#123;</span><br><span class="line">            queue = queue[:<span class="built_in">len</span>(queue)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= k<span class="number">-1</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, nums[queue[<span class="number">0</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>暴力解法</th>
<th>单调队列解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(nk)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(k)</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单，容易理解</td>
<td>高效，适合大数据量</td>
</tr>
<tr>
<td>缺点</td>
<td>时间复杂度过高</td>
<td>实现相对复杂</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：O-n">时间复杂度：O(n)</h3>
<ul>
<li><strong>每个元素最多入队一次</strong>：每个索引最多被加入队列一次</li>
<li><strong>每个元素最多出队一次</strong>：每个索引最多被移除队列一次</li>
<li><strong>总操作次数</strong>：每个元素最多进行 2 次队列操作</li>
<li><strong>结论</strong>：时间复杂度为 O(n)</li>
</ul>
<h3 id="空间复杂度：O-k">空间复杂度：O(k)</h3>
<ul>
<li><strong>队列大小</strong>：最坏情况下队列中存储 k 个元素</li>
<li><strong>结果数组</strong>：需要存储 n-k+1 个结果</li>
<li><strong>总空间</strong>：O(k) + O(n-k+1) = O(n)</li>
<li><strong>优化后</strong>：只考虑队列空间，为 O(k)</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<h3 id="算法技巧">算法技巧</h3>
<ol>
<li>
<p><strong>单调队列的应用场景</strong>：</p>
<ul>
<li>滑动窗口最大值/最小值</li>
<li>区间最值查询</li>
<li>单调栈的变种应用</li>
</ul>
</li>
<li>
<p><strong>索引存储的优势</strong>：</p>
<ul>
<li>便于判断元素是否在窗口内</li>
<li>避免重复计算</li>
<li>提高代码可读性</li>
</ul>
</li>
<li>
<p><strong>延迟删除策略</strong>：</p>
<ul>
<li>减少不必要的队列操作</li>
<li>提高算法效率</li>
<li>简化实现逻辑</li>
</ul>
</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li>
<p><strong>边界条件处理</strong>：</p>
<ul>
<li>数组为空或 k 为 0 的情况</li>
<li>窗口大小等于数组长度的情况</li>
</ul>
</li>
<li>
<p><strong>队列操作顺序</strong>：</p>
<ul>
<li>先移除过期元素，再维护单调性</li>
<li>避免在错误时机删除元素</li>
</ul>
</li>
<li>
<p><strong>结果记录时机</strong>：</p>
<ul>
<li>只有当窗口大小达到 k 时才记录结果</li>
<li>注意索引的边界条件</li>
</ul>
</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><a href="https://leetcode.com/problems/min-stack/">LeetCode 155 - 最小栈</a></li>
<li><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">LeetCode 84 - 柱状图中最大的矩形</a></li>
<li><a href="https://leetcode.com/problems/trapping-rain-water/">LeetCode 42 - 接雨水</a></li>
</ul>
<p>这些题目都涉及单调栈/队列的应用，是很好的练习材料。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 560 - 和为 K 的子数组（Subarray Sum Equals K）</title>
    <url>/2025/07/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，请你统计并返回该数组中和为 <code>k</code> 的子数组的个数。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：和为 2 的子数组有 [1,1] 和 [1,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：和为 3 的子数组有 [1,2] 和 [3]</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-10^7 &lt;= k &lt;= 10^7</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心思想是使用<strong>前缀和</strong>和<strong>哈希表</strong>的组合来解决。</p>
<h3 id="核心洞见">核心洞见</h3>
<p><strong>关键洞见</strong>：如果存在两个位置 <code>i</code> 和 <code>j</code>（<code>i &lt; j</code>），使得前缀和 <code>prefix[j] - prefix[i] = k</code>，那么子数组 <code>nums[i+1...j]</code> 的和就是 <code>k</code>。</p>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li>
<p><strong>初始化</strong>：</p>
<ul>
<li>创建一个哈希表 <code>count</code> 来记录每个前缀和出现的次数</li>
<li>初始化 <code>count[0] = 1</code>，表示空前缀和出现 1 次</li>
<li>初始化 <code>prefix_sum = 0</code> 和 <code>result = 0</code></li>
</ul>
</li>
<li>
<p><strong>遍历数组</strong>：</p>
<ul>
<li>对于每个元素 <code>nums[i]</code>，计算当前的前缀和 <code>prefix_sum += nums[i]</code></li>
<li>检查是否存在 <code>prefix_sum - k</code> 在哈希表中</li>
<li>如果存在，将对应的次数加到结果中</li>
<li>将当前前缀和及其出现次数更新到哈希表中</li>
</ul>
</li>
<li>
<p><strong>统计结果</strong>：</p>
<ul>
<li>返回所有满足条件的子数组数量</li>
</ul>
</li>
</ol>
<h3 id="可视化示例">可视化示例</h3>
<p>以 <code>nums = [1, 1, 1], k = 2</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">索引:    0  1  2</span><br><span class="line">数组:   [1, 1, 1]</span><br><span class="line">前缀和:   1  2  3</span><br><span class="line"></span><br><span class="line">步骤分析：</span><br><span class="line">i=0: prefix_sum=1, 查找 1-2=-1, count[-1]=0, 结果=0, count[1]=1</span><br><span class="line">i=1: prefix_sum=2, 查找 2-2=0,  count[0]=1,  结果=1, count[2]=1  </span><br><span class="line">i=2: prefix_sum=3, 查找 3-2=1,  count[1]=1,  结果=2, count[3]=1</span><br><span class="line"></span><br><span class="line">最终结果：2</span><br></pre></td></tr></table></figure>
<h2 id="实现细节">实现细节</h2>
<h3 id="为什么需要-count-0-1？">为什么需要 <code>count[0] = 1</code>？</h3>
<p>这是为了处理从数组开头开始的子数组。例如，如果 <code>nums[0] = k</code>，那么我们需要找到 <code>prefix_sum - k = 0</code>，即 <code>prefix_sum = k</code>。如果没有初始化 <code>count[0] = 1</code>，这种情况会被遗漏。</p>
<h3 id="哈希表的作用">哈希表的作用</h3>
<p>哈希表 <code>count</code> 用于快速查找某个前缀和值之前出现过多少次，这样我们就能知道有多少个子数组的和为 <code>k</code>。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraySum</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    count[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment">// 初始化空前缀和</span></span><br><span class="line">    </span><br><span class="line">    prefixSum := <span class="number">0</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        prefixSum += num</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找是否存在 prefixSum - k 的前缀和</span></span><br><span class="line">        <span class="keyword">if</span> freq, exists := count[prefixSum-k]; exists &#123;</span><br><span class="line">            result += freq</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新当前前缀和的出现次数</span></span><br><span class="line">        count[prefixSum]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码执行过程分析">代码执行过程分析</h3>
<p>以 <code>nums = [1, 1, 1], k = 2</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态：</span><br><span class="line">count = &#123;0: 1&#125;</span><br><span class="line">prefixSum = 0</span><br><span class="line">result = 0</span><br><span class="line"></span><br><span class="line">i=0, num=1:</span><br><span class="line">prefixSum = 1</span><br><span class="line">查找 count[1-2] = count[-1] = 0</span><br><span class="line">result = 0</span><br><span class="line">count = &#123;0: 1, 1: 1&#125;</span><br><span class="line"></span><br><span class="line">i=1, num=1:</span><br><span class="line">prefixSum = 2</span><br><span class="line">查找 count[2-2] = count[0] = 1</span><br><span class="line">result = 1</span><br><span class="line">count = &#123;0: 1, 1: 1, 2: 1&#125;</span><br><span class="line"></span><br><span class="line">i=2, num=1:</span><br><span class="line">prefixSum = 3</span><br><span class="line">查找 count[3-2] = count[1] = 1</span><br><span class="line">result = 2</span><br><span class="line">count = &#123;0: 1, 1: 1, 2: 1, 3: 1&#125;</span><br><span class="line"></span><br><span class="line">返回 result = 2</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>前缀和 + 哈希表</th>
<th>暴力枚举</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n²)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>高效，一次遍历解决</td>
<td>直观易懂</td>
</tr>
<tr>
<td>缺点</td>
<td>需要额外空间</td>
<td>时间复杂度过高</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★☆☆☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：O-n">时间复杂度：O(n)</h3>
<ul>
<li>只需要遍历数组一次</li>
<li>哈希表的查找和插入操作平均时间复杂度为 O(1)</li>
<li>总体时间复杂度为 O(n)</li>
</ul>
<h3 id="空间复杂度：O-n">空间复杂度：O(n)</h3>
<ul>
<li>哈希表最多存储 n 个不同的前缀和值</li>
<li>在最坏情况下，所有前缀和都不同，需要 O(n) 空间</li>
</ul>
<h3 id="数学推导">数学推导</h3>
<p>对于长度为 n 的数组，前缀和的计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T(n) = n × O(1) = O(n)</span><br></pre></td></tr></table></figure>
<p>哈希表空间使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S(n) = O(n)  // 最坏情况下所有前缀和都不同</span><br></pre></td></tr></table></figure>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>前缀和技巧</strong>：当需要频繁计算子数组和时，前缀和是一个非常有用的技巧</li>
<li><strong>哈希表应用</strong>：哈希表不仅可以用于去重，还可以用于快速统计和查找</li>
<li><strong>边界条件处理</strong>：初始化 <code>count[0] = 1</code> 是处理边界情况的关键</li>
<li><strong>数学思维</strong>：将问题转化为 <code>prefix[j] - prefix[i] = k</code> 的形式，大大简化了求解过程</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>忘记初始化</strong>：没有设置 <code>count[0] = 1</code> 会导致从开头开始的子数组被遗漏</li>
<li><strong>顺序错误</strong>：应该先查找再更新哈希表，避免重复计算</li>
<li><strong>整数溢出</strong>：对于大数组，前缀和可能超出 int 范围，需要注意数据类型</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/">LeetCode 53: Maximum Subarray</a> - 最大子数组和</li>
<li><a href="https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/">LeetCode 325: Maximum Size Subarray Sum Equals k</a> - 和为k的最长子数组长度</li>
<li><a href="https://leetcode.com/problems/minimum-size-subarray-sum/">LeetCode 209: Minimum Size Subarray Sum</a> - 和大于等于目标值的最短子数组</li>
</ul>
<p>这道题是前缀和技巧的经典应用，掌握这个思路对于解决类似的子数组问题非常有帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 149 - 直线上最多的点数（Max Points on a Line）</title>
    <url>/2025/07/20/LeetCode-149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个二维平面上的点数组 <code>points</code>，其中 <code>points[i] = [xi, yi]</code>，返回位于同一直线上的最大点数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,1],[2,2],[3,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">所有点都在直线 y = x 上</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最多有 4 个点在同一直线上</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 300</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-10^4 &lt;= xi, yi &lt;= 10^4</code></li>
<li>所有点都是唯一的</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="核心算法概念">核心算法概念</h3>
<p>这道题的核心思想是：<strong>对于每个点，计算它与所有其他点形成的直线斜率，统计具有相同斜率的点的数量</strong>。</p>
<h3 id="关键洞见">关键洞见</h3>
<ol>
<li><strong>斜率表示直线</strong>：两点确定一条直线，斜率是直线的唯一标识</li>
<li><strong>避免浮点数精度问题</strong>：直接使用分数表示斜率，而不是浮点数</li>
<li><strong>处理重复点</strong>：需要单独统计与基准点重合的点</li>
<li><strong>最简分数</strong>：使用最大公约数将斜率化为最简形式</li>
</ol>
<h3 id="解题步骤">解题步骤</h3>
<h4 id="步骤-1：枚举基准点">步骤 1：枚举基准点</h4>
<ul>
<li>遍历每个点作为基准点</li>
<li>对于每个基准点，计算它与所有其他点形成的直线</li>
</ul>
<h4 id="步骤-2：计算斜率">步骤 2：计算斜率</h4>
<ul>
<li>对于基准点 <code>(x1, y1)</code> 和另一个点 <code>(x2, y2)</code></li>
<li>斜率 = <code>(y2 - y1) / (x2 - x1)</code></li>
<li>使用最简分数表示：<code>(dy/gcd(dx, dy), dx/gcd(dx, dy))</code></li>
</ul>
<h4 id="步骤-3：统计共线点">步骤 3：统计共线点</h4>
<ul>
<li>使用哈希表记录每个斜率对应的点数</li>
<li>同时统计与基准点重合的点数</li>
<li>最终结果 = 重合点数 + 最大斜率对应的点数</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="斜率计算优化">斜率计算优化</h3>
<p>为了避免浮点数精度问题，我们使用最简分数表示斜率：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dx := points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]</span><br><span class="line">dy := points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]</span><br><span class="line">g := gcd(dx, dy)</span><br><span class="line">slope := [<span class="number">2</span>]<span class="type">int</span>&#123;dx / g, dy / g&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重复点处理">重复点处理</h3>
<p>对于与基准点重合的点，我们需要单独统计：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> points[j][<span class="number">0</span>] == points[i][<span class="number">0</span>] &amp;&amp; points[j][<span class="number">1</span>] == points[i][<span class="number">1</span>] &#123;</span><br><span class="line">    duplicates++</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="边界情况处理">边界情况处理</h3>
<ul>
<li>当点数 ≤ 2 时，直接返回点数</li>
<li>处理垂直线（dx = 0）和水平线（dy = 0）的情况</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPoints</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举每个点作为基准点</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        hashTable := <span class="keyword">map</span>[[<span class="number">2</span>]<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">        duplicates := <span class="number">1</span>  <span class="comment">// 统计与基准点重合的点数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算与其他点形成的直线斜率</span></span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 处理重复点</span></span><br><span class="line">            <span class="keyword">if</span> points[j][<span class="number">0</span>] == points[i][<span class="number">0</span>] &amp;&amp; points[j][<span class="number">1</span>] == points[i][<span class="number">1</span>] &#123;</span><br><span class="line">                duplicates++</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算斜率（使用最简分数表示）</span></span><br><span class="line">            dx := points[j][<span class="number">0</span>] - points[i][<span class="number">0</span>]</span><br><span class="line">            dy := points[j][<span class="number">1</span>] - points[i][<span class="number">1</span>]</span><br><span class="line">            g := gcd(dx, dy)</span><br><span class="line">            hashTable[[<span class="number">2</span>]<span class="type">int</span>&#123;dx / g, dy / g&#125;]++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新结果</span></span><br><span class="line">        <span class="keyword">if</span> res &lt; duplicates &#123;</span><br><span class="line">            res = duplicates</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, count := <span class="keyword">range</span> hashTable &#123;</span><br><span class="line">            <span class="keyword">if</span> res &lt; count + duplicates &#123;</span><br><span class="line">                res = count + duplicates</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        a, b = b, a % b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析">执行过程分析</h3>
<p>以示例 2 为例：<code>[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</code></p>
<ol>
<li>
<p><strong>基准点 (1,1)</strong>：</p>
<ul>
<li>与 (3,2) 的斜率：<code>(2-1)/(3-1) = 1/2</code></li>
<li>与 (5,3) 的斜率：<code>(3-1)/(5-1) = 2/4 = 1/2</code></li>
<li>与 (4,1) 的斜率：<code>(1-1)/(4-1) = 0/3 = 0/1</code></li>
<li>与 (2,3) 的斜率：<code>(3-1)/(2-1) = 2/1</code></li>
<li>与 (1,4) 的斜率：<code>(4-1)/(1-1) = 3/0</code>（垂直线）</li>
</ul>
<p>结果：最多 2 个点共线（斜率为 1/2）</p>
</li>
<li>
<p><strong>基准点 (3,2)</strong>：</p>
<ul>
<li>与 (5,3) 的斜率：<code>(3-2)/(5-3) = 1/2</code></li>
<li>与 (4,1) 的斜率：<code>(1-2)/(4-3) = -1/1</code></li>
<li>与 (2,3) 的斜率：<code>(3-2)/(2-3) = 1/-1 = -1/1</code></li>
<li>与 (1,4) 的斜率：<code>(4-2)/(1-3) = 2/-2 = -1/1</code></li>
</ul>
<p>结果：最多 3 个点共线（斜率为 -1/1）</p>
</li>
</ol>
<p>最终答案为 4。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>哈希表法</th>
<th>暴力枚举法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n²)</td>
<td>O(n³)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>高效，避免重复计算</td>
<td>直观易懂</td>
</tr>
<tr>
<td>缺点</td>
<td>实现相对复杂</td>
<td>运行时间过长</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★☆☆☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：O-n²">时间复杂度：O(n²)</h3>
<ul>
<li>外层循环：O(n)</li>
<li>内层循环：O(n)</li>
<li>总时间复杂度：O(n²)</li>
</ul>
<h3 id="空间复杂度：O-n">空间复杂度：O(n)</h3>
<ul>
<li>哈希表存储斜率信息：O(n)</li>
<li>在最坏情况下，所有点都不共线，哈希表大小为 O(n)</li>
</ul>
<h3 id="详细推导">详细推导</h3>
<p>对于每个基准点，我们需要：</p>
<ol>
<li>计算与 n-1 个其他点的斜率：O(n)</li>
<li>哈希表操作（插入和查找）：O(1) 平均情况</li>
<li>总操作数：n × (n-1) = O(n²)</li>
</ol>
<h2 id="关键收获">关键收获</h2>
<h3 id="重要算法概念">重要算法概念</h3>
<ol>
<li><strong>几何问题的数学建模</strong>：将几何问题转化为数学计算</li>
<li><strong>哈希表的应用</strong>：使用哈希表高效统计和查找</li>
<li><strong>精度处理技巧</strong>：避免浮点数精度问题，使用分数表示</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>浮点数精度问题</strong>：直接使用浮点数计算斜率可能导致精度误差</li>
<li><strong>重复点处理</strong>：忘记统计与基准点重合的点</li>
<li><strong>边界情况</strong>：没有正确处理垂直线和水平线</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><strong>LeetCode 1232</strong>：检查点是否在直线上</li>
<li><strong>LeetCode 1037</strong>：有效的回旋镖</li>
<li><strong>LeetCode 939</strong>：最小面积矩形</li>
</ul>
<h3 id="应用场景">应用场景</h3>
<ul>
<li>计算机图形学中的直线检测</li>
<li>图像处理中的特征点匹配</li>
<li>地理信息系统中的路径规划</li>
</ul>
<hr>
<p><strong>总结</strong>：这道题通过巧妙使用哈希表和数学技巧，将几何问题转化为高效的算法问题。关键在于理解斜率作为直线唯一标识的概念，以及如何避免浮点数精度问题。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>几何</tag>
        <tag>哈希表</tag>
        <tag>数学</tag>
        <tag>Hard</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 50 - Pow(x, n)（快速幂算法）</title>
    <url>/2025/07/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-50-Pow-x-n/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>实现 <code>pow(x, n)</code>，即计算 x 的 n 次幂函数（即，$x^n$）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2^(-2) = 1/2^2 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>$-100.0 &lt; x &lt; 100.0$</li>
<li>$-2^{31} \leq n \leq 2^{31}-1$</li>
<li>$n$ 是一个整数</li>
<li>$-10^4 \leq x^n \leq 10^4$</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="核心算法：快速幂（Fast-Power）">核心算法：快速幂（Fast Power）</h3>
<p>这道题的核心是使用<strong>快速幂算法</strong>，也称为<strong>二进制幂算法</strong>。这是一个经典的数学优化技巧，可以将幂运算的时间复杂度从 $O(n)$ 优化到 $O(\log n)$。</p>
<p><strong>关键洞见：</strong> 任何整数都可以表示为二进制形式，利用这个性质可以将幂运算分解为多个平方运算的组合。</p>
<h3 id="算法原理">算法原理</h3>
<ol>
<li><strong>二进制分解</strong>：将指数 n 转换为二进制形式</li>
<li><strong>平方递推</strong>：利用 $x^{2k} = (x^k)^2$ 的性质</li>
<li><strong>累乘结果</strong>：根据二进制位是否为 1 决定是否累乘</li>
</ol>
<h3 id="具体步骤">具体步骤</h3>
<ol>
<li><strong>处理负数指数</strong>：如果 n &lt; 0，将 x 取倒数，n 取绝对值</li>
<li><strong>初始化</strong>：设置 base = x，result = 1</li>
<li><strong>循环处理</strong>：当 n &gt; 0 时：
<ul>
<li>如果 n 的最低位为 1，将 base 乘到 result 中</li>
<li>base 自乘（相当于 base = base²）</li>
<li>n 右移一位（相当于 n = n/2）</li>
</ul>
</li>
<li><strong>返回结果</strong>：最终 result 即为 $x^n$</li>
</ol>
<h3 id="数学推导">数学推导</h3>
<p>对于任意正整数 n，可以表示为：<br>
$$n = \sum_{i=0}^{k} b_i \cdot 2^i$$</p>
<p>其中 $b_i \in {0, 1}$ 是 n 的二进制表示。</p>
<p>因此：<br>
$$x^n = x^{\sum_{i=0}^{k} b_i \cdot 2^i} = \prod_{i=0}^{k} x^{b_i \cdot 2^i} = \prod_{i=0}^{k} (x^{2^i})^{b_i}$$</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="位运算技巧">位运算技巧</h3>
<ul>
<li><code>n &amp; 1</code>：检查 n 的最低位是否为 1</li>
<li><code>n &gt;&gt;= 1</code>：将 n 右移一位，相当于 n/2</li>
<li>每次循环 base 自乘，相当于计算 $x^{2^i}$</li>
</ul>
<h3 id="边界情况处理">边界情况处理</h3>
<ol>
<li><strong>n = 0</strong>：任何数的 0 次方都是 1</li>
<li><strong>n &lt; 0</strong>：转换为正数处理，最后取倒数</li>
<li><strong>x = 0</strong>：0 的任何正次方都是 0，0 的 0 次方是 1</li>
<li><strong>n = -2^31</strong>：需要特殊处理，因为取绝对值会溢出</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="type">float64</span>, n <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理负数指数</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        x = <span class="number">1</span> / x</span><br><span class="line">        n = -n</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    base := x</span><br><span class="line">    res := <span class="number">1.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快速幂算法</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前位为 1，累乘到结果中</span></span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            res *= base</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base 自乘，相当于 base = base²</span></span><br><span class="line">        base *= base</span><br><span class="line">        <span class="comment">// n 右移一位，相当于 n = n/2</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以计算 $2^{10}$ 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始：base = 2, res = 1, n = 10 (二进制：1010)</span><br><span class="line"></span><br><span class="line">第1轮：n = 10 (1010)</span><br><span class="line">- n&amp;1 = 0，不累乘</span><br><span class="line">- base = 2² = 4</span><br><span class="line">- n = 5 (101)</span><br><span class="line"></span><br><span class="line">第2轮：n = 5 (101)  </span><br><span class="line">- n&amp;1 = 1，res = 1 × 4 = 4</span><br><span class="line">- base = 4² = 16</span><br><span class="line">- n = 2 (10)</span><br><span class="line"></span><br><span class="line">第3轮：n = 2 (10)</span><br><span class="line">- n&amp;1 = 0，不累乘</span><br><span class="line">- base = 16² = 256</span><br><span class="line">- n = 1 (1)</span><br><span class="line"></span><br><span class="line">第4轮：n = 1 (1)</span><br><span class="line">- n&amp;1 = 1，res = 4 × 256 = 1024</span><br><span class="line">- base = 256² = 65536</span><br><span class="line">- n = 0，结束</span><br><span class="line"></span><br><span class="line">结果：1024</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>暴力法</th>
<th>快速幂算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n)$</td>
<td>$O(\log n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>优点</td>
<td>简单直观</td>
<td>高效，适合大指数</td>
</tr>
<tr>
<td>缺点</td>
<td>效率低，容易超时</td>
<td>实现稍复杂</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-log-n">时间复杂度：$O(\log n)$</h3>
<ul>
<li>每次循环 n 都会减半（右移一位）</li>
<li>循环次数等于 n 的二进制位数</li>
<li>对于 32 位整数，最多循环 32 次</li>
</ul>
<h3 id="空间复杂度：-O-1">空间复杂度：$O(1)$</h3>
<ul>
<li>只使用了常数个变量</li>
<li>不依赖输入规模</li>
</ul>
<h3 id="数学证明">数学证明</h3>
<p>设 n 的二进制位数为 k，则：<br>
$$k = \lfloor \log_2 n \rfloor + 1$$</p>
<p>因此时间复杂度为 $O(\log n)$。</p>
<h2 id="关键收获">关键收获</h2>
<h3 id="重要概念">重要概念</h3>
<ol>
<li><strong>快速幂算法</strong>：将幂运算的时间复杂度从线性优化到对数级</li>
<li><strong>二进制分解</strong>：利用整数的二进制表示进行算法优化</li>
<li><strong>位运算技巧</strong>：使用位运算进行高效的数值操作</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>整数溢出</strong>：当 n = -2^31 时，取绝对值会溢出</li>
<li><strong>精度问题</strong>：浮点数运算可能存在精度误差</li>
<li><strong>边界情况</strong>：需要正确处理 n = 0 和 x = 0 的情况</li>
</ol>
<h3 id="相关应用">相关应用</h3>
<ul>
<li><strong>密码学</strong>：RSA 算法中的模幂运算</li>
<li><strong>大数运算</strong>：处理超大整数的幂运算</li>
<li><strong>矩阵快速幂</strong>：计算矩阵的高次幂</li>
<li><strong>斐波那契数列</strong>：使用矩阵快速幂计算第 n 项</li>
</ul>
<h3 id="扩展思考">扩展思考</h3>
<p>快速幂算法的思想可以扩展到：</p>
<ul>
<li><strong>矩阵快速幂</strong>：计算矩阵的高次幂</li>
<li><strong>多项式快速幂</strong>：计算多项式的幂</li>
<li><strong>模运算快速幂</strong>：在模运算下计算幂</li>
</ul>
<p>这个算法是数学计算中的经典优化技巧，在面试中经常被考察，掌握它对于解决相关问题非常有帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>位运算</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 172 - 阶乘后的零（Factorial Trailing Zeroes）</title>
    <url>/2025/07/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个整数 <code>n</code>，返回 <code>n!</code> 结果中尾随零的数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：0</span><br><span class="line">解释：3! = 6，不含尾随零。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：1</span><br><span class="line">解释：5! = 120，有一个尾随零。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 10^4</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="核心洞见">核心洞见</h3>
<p><strong>阶乘末尾的零是由因子中的 2 和 5 配对产生的</strong>。在阶乘中，2 的个数总是比 5 多，因此我们只需要统计因子中 5 的个数即可。</p>
<h3 id="详细分析">详细分析</h3>
<ol>
<li><strong>零的产生原理</strong>：每个尾随零都对应一个因子 10，而 10 = 2 × 5</li>
<li><strong>2 和 5 的分布</strong>：在阶乘中，偶数比 5 的倍数更频繁，所以 2 的个数总是足够多</li>
<li><strong>5 的来源</strong>：
<ul>
<li>直接包含因子 5 的数：5, 10, 15, 20, …</li>
<li>包含因子 25 的数：25, 50, 75, …（贡献两个 5）</li>
<li>包含因子 125 的数：125, 250, …（贡献三个 5）</li>
</ul>
</li>
</ol>
<h3 id="计算方法">计算方法</h3>
<p>对于每个 5 的幂次，我们需要统计其贡献：</p>
<ul>
<li>5¹ 的贡献：<code>⌊n/5⌋</code></li>
<li>5² 的贡献：<code>⌊n/25⌋</code></li>
<li>5³ 的贡献：<code>⌊n/125⌋</code></li>
<li>…</li>
</ul>
<p>总零的个数 = <code>⌊n/5⌋ + ⌊n/25⌋ + ⌊n/125⌋ + ...</code></p>
<h2 id="实现细节">实现细节</h2>
<h3 id="方法一：迭代计算">方法一：迭代计算</h3>
<p>通过不断除以 5 来计算所有 5 的幂次的贡献：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trailingZeroes</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n /= <span class="number">5</span></span><br><span class="line">        ans += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：直接计算（优化版本）">方法二：直接计算（优化版本）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trailingZeroes</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt;= <span class="number">5</span> &#123;</span><br><span class="line">        count += n / <span class="number">5</span></span><br><span class="line">        n /= <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=172 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [172] 阶乘后的零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trailingZeroes</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n /= <span class="number">5</span></span><br><span class="line">		ans += n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以 <code>n = 25</code> 为例：</p>
<ol>
<li>
<p>第一次循环：<code>n = 25, ans = 0</code></p>
<ul>
<li><code>n = 25 / 5 = 5</code></li>
<li><code>ans = 0 + 5 = 5</code></li>
</ul>
</li>
<li>
<p>第二次循环：<code>n = 5, ans = 5</code></p>
<ul>
<li><code>n = 5 / 5 = 1</code></li>
<li><code>ans = 5 + 1 = 6</code></li>
</ul>
</li>
<li>
<p>第三次循环：<code>n = 1, ans = 6</code></p>
<ul>
<li><code>n = 1 / 5 = 0</code></li>
<li><code>ans = 6 + 0 = 6</code></li>
</ul>
</li>
<li>
<p>循环结束，返回 <code>ans = 6</code></p>
</li>
</ol>
<p>验证：25! = 15511210043330985984000000，末尾确实有 6 个零。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>迭代计算法</th>
<th>直接计算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>代码简洁</td>
<td>逻辑清晰</td>
</tr>
<tr>
<td>缺点</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p><strong>O(log n)</strong></p>
<ul>
<li>每次循环都将 n 除以 5</li>
<li>循环次数为 log₅(n)</li>
<li>由于 5 &gt; 1，所以 log₅(n) &lt; log₂(n) = O(log n)</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<p><strong>O(1)</strong></p>
<ul>
<li>只使用了常数个变量</li>
<li>不依赖输入规模</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<h3 id="重要概念">重要概念</h3>
<ol>
<li><strong>阶乘末尾零的本质</strong>：由因子 2 和 5 配对产生</li>
<li><strong>数学优化</strong>：通过分析因子分布，将问题转化为统计 5 的个数</li>
<li><strong>迭代技巧</strong>：通过不断除以 5 来统计所有 5 的幂次贡献</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>直接计算阶乘</strong>：对于大数会导致溢出</li>
<li><strong>忽略高次幂</strong>：只考虑单个 5 而忽略 25、125 等的贡献</li>
<li><strong>边界情况</strong>：n = 0 时应该返回 0</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><a href="https://leetcode.com/problems/preimage-size-of-factorial-zeroes-function/">LeetCode 793: 阶乘函数后 K 个零</a></li>
<li><a href="https://leetcode.com/problems/count-primes/">LeetCode 204: 计数质数</a></li>
</ul>
<h3 id="实际应用">实际应用</h3>
<ul>
<li>大数阶乘计算中的零统计</li>
<li>数学竞赛中的数论问题</li>
<li>算法复杂度分析中的对数计算</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-23-合并 K 个升序链表</title>
    <url>/2025/07/09/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>
<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="方法一：最小堆">方法一：最小堆</h3>
<p>我们可以使用一个最小堆来维护 <code>k</code> 个链表的头节点。每次从堆中取出最小的节点，将其加入到结果链表中，然后将该节点的下一个节点加入到堆中。</p>
<p>这个过程重复进行，直到堆为空。</p>
<ul>
<li><strong>时间复杂度：</strong> O(N log k)，其中 <code>N</code> 是所有链表中元素的总数，<code>k</code> 是链表的数量。</li>
<li><strong>空间复杂度：</strong> O(k)，堆中最多存储 <code>k</code> 个元素。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=23 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [23] 合并 K 个升序链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 最小堆</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(nlogk)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(k)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListItem <span class="keyword">struct</span> &#123;</span><br><span class="line">	index <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListMinHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	data  []*ListItem</span><br><span class="line">	lists *[]*ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewListMinHeap</span><span class="params">(lists *[]*ListNode)</span></span> *ListMinHeap &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ListMinHeap&#123;</span><br><span class="line">		data:  []*ListItem&#123;&#125;,</span><br><span class="line">		lists: lists,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(heap *ListMinHeap)</span></span> Smaller(index1, index2 <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (*(heap.lists))[heap.data[index1].index].Val &lt; (*(heap.lists))[heap.data[index2].index].Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(heap *ListMinHeap)</span></span> Push(x *ListItem) &#123;</span><br><span class="line">	heap.data = <span class="built_in">append</span>(heap.data, x)</span><br><span class="line">	n := <span class="built_in">len</span>(heap.data) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> n != <span class="number">0</span> &amp;&amp; heap.Smaller(n, (n<span class="number">-1</span>)/<span class="number">2</span>) &#123;</span><br><span class="line">		heap.data[n], heap.data[(n<span class="number">-1</span>)/<span class="number">2</span>] = heap.data[(n<span class="number">-1</span>)/<span class="number">2</span>], heap.data[n]</span><br><span class="line">		n = (n - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(heap *ListMinHeap)</span></span> Pop() *ListItem &#123;</span><br><span class="line">	top := heap.data[<span class="number">0</span>]</span><br><span class="line">	heap.data[<span class="number">0</span>] = heap.data[<span class="built_in">len</span>(heap.data)<span class="number">-1</span>]</span><br><span class="line">	heap.data = heap.data[:<span class="built_in">len</span>(heap.data)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">	index := <span class="number">0</span></span><br><span class="line">	heapLen := <span class="built_in">len</span>(heap.data)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		leftChildren := <span class="number">2</span>*index + <span class="number">1</span></span><br><span class="line">		rightChildren := <span class="number">2</span>*index + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">		minIndex := index</span><br><span class="line">		<span class="keyword">if</span> leftChildren &lt; heapLen &amp;&amp; heap.Smaller(leftChildren, minIndex) &#123;</span><br><span class="line">			minIndex = leftChildren</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> rightChildren &lt; heapLen &amp;&amp; heap.Smaller(rightChildren, minIndex) &#123;</span><br><span class="line">			minIndex = rightChildren</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> minIndex == index &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		heap.data[index], heap.data[minIndex] = heap.data[minIndex], heap.data[index]</span><br><span class="line"></span><br><span class="line">		index = minIndex</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dummyHead := &amp;ListNode&#123;&#125;</span><br><span class="line"></span><br><span class="line">	h := NewListMinHeap(&amp;lists)</span><br><span class="line"></span><br><span class="line">	remain := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(lists); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> lists[i] == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		remain++</span><br><span class="line">		h.Push(&amp;ListItem&#123;index: i&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur := dummyHead</span><br><span class="line">	<span class="keyword">for</span> remain != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 处理最后一个链表</span></span><br><span class="line">		<span class="keyword">if</span> remain == <span class="number">1</span> &#123;</span><br><span class="line">			cur.Next = lists[h.Pop().index]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		top := h.Pop()</span><br><span class="line">		minIndex := top.index</span><br><span class="line"></span><br><span class="line">		cur.Next = lists[minIndex]</span><br><span class="line"></span><br><span class="line">		lists[minIndex] = lists[minIndex].Next</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> lists[minIndex] == <span class="literal">nil</span> &#123;</span><br><span class="line">			remain--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 放回去重新排序</span></span><br><span class="line">			h.Push(top)</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur.Next</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：顺序合并">方法二：顺序合并</h3>
<p>我们也可以通过两两合并链表的方式来实现。每次将两个链表合并成一个新的链表，直到所有链表都合并完毕。</p>
<ul>
<li><strong>时间复杂度：</strong> O(N*k)，其中 <code>N</code> 是所有链表中元素的总数，<code>k</code> 是链表的数量。</li>
<li><strong>空间复杂度：</strong> O(1)。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序合并</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(n*k)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(1)顺序合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKListsSequential</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    merge := <span class="function"><span class="keyword">func</span><span class="params">(l1, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">        dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">        cur := dummy</span><br><span class="line">        <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">                cur.Next = l1</span><br><span class="line">                l1 = l1.Next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.Next = l2</span><br><span class="line">                l2 = l2.Next</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur.Next = l1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur.Next = l2</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := lists[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(lists); i++ &#123;</span><br><span class="line">        res = merge(res, lists[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>本文介绍了两种解决 “合并 K 个升序链表” 问题的方法。</p>
<ul>
<li><strong>最小堆</strong> 的方法在时间和空间上都表现得更优，尤其是在 <code>k</code> 值较大的情况下。</li>
<li><strong>顺序合并</strong> 的方法实现起来更简单直观，但时间复杂度较高。</li>
</ul>
<p>在实际应用中，推荐使用最小堆的方法。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: 悲观锁与乐观锁</title>
    <url>/2025/07/06/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h1>5.5 什么是悲观锁、乐观锁？</h1>
<p>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。</p>
<p>最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。</p>
<p>如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。</p>
<p>所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。</p>
<p>对症下药，才能减少锁对高并发性能的影响。</p>
<p>那接下来，针对不同的应用场景，谈一谈「<strong>互斥锁、自旋锁、读写锁、乐观锁、悲观锁</strong>」的选择和使用。</p>
<h2 id="互斥锁与自旋锁">互斥锁与自旋锁</h2>
<p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p>
<p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p>
<p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p>
<ul>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
</ul>
<p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p>
<p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p>
<p><img src="/2025/07/06/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/1751786419492.png" alt="1751786419492"></p>
<p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p>
<p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p>
<ul>
<li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</li>
<li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li>
</ul>
<p>线程的上下文切换的是什么？当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></p>
<p>上下文切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p>
<p>所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p>
<p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p>
<p>一般加锁的过程，包含两个步骤：</p>
<ul>
<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>
<li>第二步，将锁设置为当前线程持有；</li>
</ul>
<p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p>
<p>比如，设锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程 ID，那么 CAS(lock, 0, pid) 就表示自旋锁的加锁操作，CAS(lock, pid, 0) 则表示解锁操作。</p>
<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>
<p>自旋锁是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p>
<p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p>
<p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p>
<p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p>
<hr>
<h2 id="读写锁">读写锁</h2>
<p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p>
<p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p>
<p>读写锁的工作原理是：</p>
<ul>
<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li>
<li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li>
</ul>
<p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p>
<p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</p>
<p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p>
<p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</p>
<p><img src="/2025/07/06/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/1751786434195.png" alt="1751786434195"></p>
<p>而「写优先锁」是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。如下图：</p>
<p><img src="/2025/07/06/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/1751786441472.png" alt="1751786441472"></p>
<p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p>
<p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p>
<p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p>
<p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p>
<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>
<hr>
<h2 id="乐观锁与悲观锁">乐观锁与悲观锁</h2>
<p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p>
<p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</p>
<p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p>
<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</p>
<p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p>
<p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</p>
<p>这里举一个场景例子：在线文档。</p>
<p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p>
<p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p>
<p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交早，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p>
<p>服务端要怎么验证是否冲突了呢？通常方案如下：</p>
<ul>
<li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li>
<li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号不一致则提交失败，如果版本号一致则修改成功，然后服务端版本号更新到最新的版本号。</li>
</ul>
<p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p>
<p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p>
<hr>
<h2 id="总结">总结</h2>
<p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p>
<p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p>
<p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p>
<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>
<p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p>
<p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>
<p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p>
<p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p>
<h2 id="读者问答">读者问答</h2>
<blockquote>
<p>CAS 不是乐观锁吗，为什么基于 CAS 实现的自旋锁是悲观锁？</p>
</blockquote>
<p>乐观锁是先修改同步资源，再验证有没有发生冲突。</p>
<p>悲观锁是修改共享数据前，都要先加锁，防止竞争。</p>
<p>CAS 是乐观锁没错，但是 CAS 和自旋锁不同之处，自旋锁基于 CAS 加了 while 或者睡眠 CPU 的操作而产生自旋的效果，加锁失败会忙等待直到拿到锁，自旋锁是要需要事先拿到锁才能修改数据的，所以算悲观锁。</p>
<hr>
<h2 id="关注作者">关注作者</h2>
<p>这周末忙里偷闲了下，看了三部电影，简单说一下感受。</p>
<p>首先看了「利刃出鞘」，这部电影是悬疑类型，也是豆瓣高分电影，电影虽然没有什么大场面，但是单纯靠缜密的剧情铺设，全程无尿点，结尾也各种翻转，如果喜欢悬疑类电影朋友，不妨抽个时间看看。</p>
<p>再来，看了「花木兰」，这电影我特喵无法可说，烂片中的战斗鸡，演员都是中国人却全在说英文（导演是美国迪士尼的），这种感觉就很奇怪很别扭，好比你看西游记、水浒传英文版那样的别扭。别扭也就算了，关键剧情平淡无奇，各种无厘头的地方，反正看完之后，我非常后悔把我生命中非常珍贵的 2 个小时献给了它，如果能重来，我选择用这 2 小时睡觉。</p>
<p>最后，当然看了「信条」，诺兰用巨资拍摄出来的电影，花钱买飞机来撞，画面非常震撼，可以说非常有诚意了。诺兰钟爱时间的概念，这次则以时间倒流方式来呈现，非常的烧脑，反正我看完后脑袋懵懵的，我就是要这种感觉，嘻嘻。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>锁</tag>
        <tag>悲观锁</tag>
        <tag>乐观锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 148 - 排序链表（Sort List）</title>
    <url>/2025/07/03/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-148-Sort-List/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你链表的头结点 <code>head</code>，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong>。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<h3 id="提示">提示</h3>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 10^4]</code> 内</li>
<li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li>
</ul>
<h3 id="进阶">进阶</h3>
<p>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<h2 id="解题思路">解题思路</h2>
<p>要排序链表，最直观的方法是先转换成数组，排序后再转回链表。但是这种方法需要 O(n) 的额外空间。如果要满足进阶要求，我们需要使用对链表友好的归并排序。</p>
<p>对于链表排序，可以考虑两种归并排序实现方式：</p>
<ol>
<li><strong>自顶向下</strong>：递归实现，空间复杂度为 O(log n)</li>
<li><strong>自底向上</strong>：迭代实现，空间复杂度为 O(1)</li>
</ol>
<h3 id="方法一：自底向上归并排序">方法一：自底向上归并排序</h3>
<p>自底向上的归并排序是一种非递归的归并排序，它的基本思想是：</p>
<ol>
<li>先将链表拆分成长度为 1 的多个子链表</li>
<li>然后两两合并成长度为 2 的子链表</li>
<li>再两两合并成长度为 4 的子链表</li>
<li>以此类推，直到整个链表排序完成</li>
</ol>
<p>这种方法的空间复杂度是 O(1)，满足进阶要求。</p>
<h2 id="代码实现（优化版）">代码实现（优化版）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 处理空链表或单节点链表</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    length := getLength(head)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建哑节点，简化边界情况处理</span></span><br><span class="line">    dummy := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自底向上归并排序</span></span><br><span class="line">    <span class="comment">// 每次迭代子链表长度乘以2（1-&gt;2-&gt;4-&gt;8...）</span></span><br><span class="line">    <span class="keyword">for</span> subLength := <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span> &#123;</span><br><span class="line">        prev, curr := dummy, dummy.Next</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每轮迭代处理整个链表</span></span><br><span class="line">        <span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个子链表的头节点</span></span><br><span class="line">            head1 := curr</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 切割第一个子链表</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">nil</span> &amp;&amp; curr.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">                curr = curr.Next</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第二个子链表的头节点</span></span><br><span class="line">            head2 := curr.Next</span><br><span class="line">            curr.Next = <span class="literal">nil</span> <span class="comment">// 断开第一个子链表</span></span><br><span class="line">            curr = head2</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 切割第二个子链表</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">nil</span> &amp;&amp; curr.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">                curr = curr.Next</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录下一次要处理的节点</span></span><br><span class="line">            <span class="keyword">var</span> next *ListNode = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">if</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">                next = curr.Next</span><br><span class="line">                curr.Next = <span class="literal">nil</span> <span class="comment">// 断开第二个子链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 合并两个子链表</span></span><br><span class="line">            merged := mergeTwoLists(head1, head2)</span><br><span class="line">            prev.Next = merged</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动prev到合并后链表的末尾</span></span><br><span class="line">            <span class="keyword">for</span> prev.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">                prev = prev.Next</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理下一对子链表</span></span><br><span class="line">            curr = next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLength</span><span class="params">(head *ListNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> node := head; node != <span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">        length++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    curr := dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">            curr.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接剩余部分</span></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        curr.Next = l1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：自顶向下归并排序">方法二：自顶向下归并排序</h3>
<p>自顶向下的归并排序是一种递归实现，它的基本思想是：</p>
<ol>
<li>使用快慢指针找到链表中点，将链表分为两半</li>
<li>递归排序两个子链表</li>
<li>合并两个排序后的子链表</li>
</ol>
<p>这种方法的空间复杂度是 O(log n)，因为递归栈的深度是 log n。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用快慢指针找到链表中点</span></span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 切分链表</span></span><br><span class="line">    mid := slow.Next</span><br><span class="line">    slow.Next = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归排序两个子链表</span></span><br><span class="line">    left := sortList(head)</span><br><span class="line">    right := sortList(mid)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并排序后的子链表</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    curr := dummy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">            curr.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接剩余部分</span></span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        curr.Next = l1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curr.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>自底向上（迭代）</th>
<th>自顶向下（递归）</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>优点</td>
<td>常数空间复杂度</td>
<td>代码简洁易懂</td>
</tr>
<tr>
<td>缺点</td>
<td>实现较复杂</td>
<td>需要额外的递归栈空间</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
</tr>
</tbody>
</table>
<h2 id="错误分析与总结">错误分析与总结</h2>
<p>在尝试实现自底向上归并排序时，我遇到了几个典型的链表操作边界问题。以下是我的错误代码和具体分析，希望能帮助我（以及他人）避免重蹈覆辙。</p>
<h3 id="初始错误代码">初始错误代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line">	dummyHead := &amp;ListNode&#123;&#125;</span><br><span class="line">	dummyHead.Next = head</span><br><span class="line">	length := <span class="number">0</span></span><br><span class="line">	cur := head</span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		cur = cur.Next</span><br><span class="line">		length++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">1</span>; k &lt; length; k &lt;&lt;= <span class="number">1</span> &#123;</span><br><span class="line">		prev, cur := dummyHead, dummyHead.Next</span><br><span class="line">		<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">			head1 := cur</span><br><span class="line">			<span class="comment">// 这里应该是1开始</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k &amp;&amp; cur.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">				cur = cur.Next</span><br><span class="line">			&#125;</span><br><span class="line">			head2 := cur.Next</span><br><span class="line">			cur.Next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 可能会带来cur = nil</span></span><br><span class="line">			cur = head2</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k &amp;&amp; cur != <span class="literal">nil</span> &amp;&amp; cur.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">				cur = cur.Next</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> next *ListNode</span><br><span class="line">			<span class="keyword">if</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">				next = cur.Next</span><br><span class="line">				cur.Next = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			prev.Next = mergeSorted(head1, head2)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> prev.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">				prev = prev.Next</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这里没必要加，因为后面的处理完自然会加上</span></span><br><span class="line">			prev.Next = next</span><br><span class="line">			cur = next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSorted</span><span class="params">(head1, head2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	dummyHead := &amp;ListNode&#123;&#125;</span><br><span class="line">	cur := dummyHead</span><br><span class="line">	<span class="keyword">for</span> head1 != <span class="literal">nil</span> &amp;&amp; head2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> head1.Val &lt; head2.Val &#123;</span><br><span class="line">			cur.Next = head1</span><br><span class="line">			head1 = head1.Next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cur.Next = head2</span><br><span class="line">			head2 = head2.Next</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> head1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		cur.Next = head1</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cur.Next = head2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误点分析">错误点分析</h3>
<p>我在代码注释中标记了几个疑点，经过分析，主要有两个核心错误：</p>
<h4 id="1-子链表切分错误">1. 子链表切分错误</h4>
<p><strong>问题所在</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">head1 := cur</span><br><span class="line"><span class="comment">// 这里应该是1开始</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k &amp;&amp; cur.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">    cur = cur.Next</span><br><span class="line">&#125;</span><br><span class="line">head2 := cur.Next</span><br><span class="line">cur.Next = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>用于切分长度为 <code>k</code> 的子链表的循环 <code>for i := 0; i &lt; k &amp;&amp; ...</code> 执行了 <code>k</code> 次，这使得 <code>cur</code> 指针前进了 <code>k</code> 步。正确的做法是，从 <code>head1</code> 开始，指针需要前进 <code>k-1</code> 步才能到达长度为 <code>k</code> 的子链表的尾部。</p>
<p><strong>原因分析</strong>：<br>
当子链表长度为 <code>k</code> 时，我们需要找到第 <code>k</code> 个节点作为尾部。如果 <code>cur</code> 初始指向第 1 个节点，那么前进 <code>k-1</code> 步后，<code>cur</code> 会指向第 <code>k</code> 个节点。而 <code>for i := 0; i &lt; k</code> 这个循环会执行 <code>k</code> 次，导致 <code>cur</code> 指向了第 <code>k+1</code> 个节点，这是不正确的。例如，当 <code>k=1</code> 时，循环会执行一次，<code>cur</code> 前进了一步，导致切分出的 <code>head1</code> 包含了两个节点，而我们期望的是一个节点。</p>
<p><strong>正确实现</strong>：<br>
循环应该从 <code>1</code> 开始，到 <code>k</code> 结束（不包括 <code>k</code>），即循环 <code>k-1</code> 次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的切分逻辑</span></span><br><span class="line">curr := head1</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; k &amp;&amp; curr != <span class="literal">nil</span> &amp;&amp; curr.Next != <span class="literal">nil</span>; i++ &#123;</span><br><span class="line">    curr = curr.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时 curr 是第一个子链表的尾节点</span></span><br><span class="line">head2 := curr.Next</span><br><span class="line">curr.Next = <span class="literal">nil</span> <span class="comment">// 断开</span></span><br></pre></td></tr></table></figure>
<h4 id="2-对链表连接方式的误解">2. 对链表连接方式的误解</h4>
<p><strong>问题所在</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">for</span> prev.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">    prev = prev.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我曾认为这里没必要加，因为后面的处理完自然会加上</span></span><br><span class="line">prev.Next = next</span><br><span class="line">cur = next</span><br></pre></td></tr></table></figure>
<p>我曾认为 <code>prev.Next = next</code> 这一行是多余的，理由是在下一次循环中，<code>prev.Next</code> 会被 <code>mergeSorted</code> 的结果自然覆盖。</p>
<p><strong>原因分析</strong>：<br>
这个想法是错误的。在 <code>for cur != nil</code> 的整个循环过程中，我们需要维护一个指向 <strong>已排序部分尾部</strong> 的指针 <code>prev</code>，并将后续处理好的片段依次连接到它后面。</p>
<p>我写的 <code>prev.Next = next</code> 这行代码本身是一种有效的连接方式，它确保在处理下一对子链表 <em>之前</em>，将刚合并完的链表与后面还未处理的链表部分先连接起来，从而保证链表的完整性。我的错误在于，我误以为这行代码是多余的，如果将其删除，那么在处理完最后一对子链表后，如果原始链表长度不是2的幂，剩余的尾部 <code>next</code> 就会丢失。</p>
<p><strong>正确逻辑</strong>：<br>
正确的做法是在 <code>for cur != nil</code> 循环中，始终维护 <code>prev</code> 作为已处理部分的尾巴。</p>
<ol>
<li><code>prev.Next = mergedList</code> 将新合并的链表接在 <code>prev</code> 后面。</li>
<li>然后 <code>prev</code> 自身前进到新合并链表的尾部（<code>while (prev.Next != nil) &#123; prev = prev.Next; &#125;</code>）。</li>
<li><code>cur</code> 更新为 <code>next</code>，开始下一对子链表的处理。<br>
在下一次循环中，<code>prev.Next = mergedList</code> 会再次将新的合并结果连接到更新后的 <code>prev</code> 之后，从而将所有部分串联起来。我的代码实现了类似的效果，但我的注释却反映了我对这个关键连接步骤的误解。</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度</strong>：O(n log n)</p>
<ul>
<li>归并排序的时间复杂度是 O(n log n)</li>
<li>每次合并操作的时间复杂度是 O(n)，总共需要进行 log n 次合并</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：</p>
<ul>
<li>自底向上方法：O(1)，只需要常数级的额外空间</li>
<li>自顶向下方法：O(log n)，因为递归调用栈的深度是 log n</li>
</ul>
</li>
</ul>
<h2 id="关键学习点">关键学习点</h2>
<ol>
<li><strong>链表归并排序的实现</strong>：学习如何对链表而非数组应用归并排序</li>
<li><strong>自底向上与自顶向下对比</strong>：理解两种归并排序实现方式的区别</li>
<li><strong>链表操作技巧</strong>：
<ul>
<li>使用哑节点（dummy node）简化头节点处理</li>
<li>使用快慢指针找链表中点</li>
<li>链表的切分与合并技巧</li>
</ul>
</li>
</ol>
<p>排序链表是一道很好的练习题，它不仅考察了链表操作，还考察了排序算法的实现。通过这道题，我们可以学习如何在链表这种线性数据结构上实现高效的排序算法。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
        <tag>归并排序</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: I/O多路复用详解 - select/poll/epoll原理与对比</title>
    <url>/2025/07/02/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1>I/O多路复用技术详解：从select到epoll的演进</h1>
<h2 id="概述">概述</h2>
<p>I/O多路复用是一种高效的网络编程技术，允许单个进程同时监控多个文件描述符的I/O事件。它是解决<strong>C10K问题</strong>（单机同时处理一万个连接）的核心技术，也是现代高性能服务器的基础。</p>
<h3 id="为什么需要I-O多路复用？">为什么需要I/O多路复用？</h3>
<p>在传统的阻塞I/O模型中，每个连接都需要一个独立的进程或线程来处理，这种方式在面对大量并发连接时会遇到严重的性能瓶颈：</p>
<ul>
<li><strong>资源消耗巨大</strong>：每个进程/线程都会占用大量内存</li>
<li><strong>上下文切换开销</strong>：频繁的进程/线程切换影响性能</li>
<li><strong>系统限制</strong>：操作系统对进程/线程数量有限制</li>
</ul>
<hr>
<h2 id="基础概念：Socket网络编程模型">基础概念：Socket网络编程模型</h2>
<h3 id="最基本的Socket模型">最基本的Socket模型</h3>
<p>Socket是进程间通信的一种特殊方式，特别之处在于它支持跨主机通信。在Linux系统中，Socket遵循&quot;一切皆文件&quot;的理念，每个Socket都对应一个文件描述符。</p>
<p><strong>TCP Socket编程的基本流程：</strong></p>
<p><img src="/2025/07/02/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1751383613218.png" alt="1751383613218"></p>
<p><strong>服务端流程：</strong></p>
<ol>
<li><code>socket()</code> - 创建Socket</li>
<li><code>bind()</code> - 绑定IP地址和端口</li>
<li><code>listen()</code> - 进入监听状态</li>
<li><code>accept()</code> - 接受客户端连接</li>
<li><code>read()/write()</code> - 数据传输</li>
</ol>
<p><strong>客户端流程：</strong></p>
<ol>
<li><code>socket()</code> - 创建Socket</li>
<li><code>connect()</code> - 连接服务器</li>
<li><code>read()/write()</code> - 数据传输</li>
</ol>
<h3 id="重要概念：两种Socket">重要概念：两种Socket</h3>
<ul>
<li><strong>监听Socket</strong>：用于监听客户端连接请求</li>
<li><strong>已连接Socket</strong>：用于与特定客户端进行数据传输</li>
</ul>
<h3 id="TCP连接队列机制">TCP连接队列机制</h3>
<p>服务器内核为每个Socket维护两个队列：</p>
<ul>
<li><strong>半连接队列</strong>：存储未完成三次握手的连接（SYN_RCVD状态）</li>
<li><strong>全连接队列</strong>：存储已完成三次握手的连接（ESTABLISHED状态）</li>
</ul>
<hr>
<h2 id="服务器并发模型的演进">服务器并发模型的演进</h2>
<h3 id="理论最大连接数">理论最大连接数</h3>
<p>TCP连接由四元组唯一确定：<code>(本机IP, 本机端口, 对端IP, 对端端口)</code></p>
<p><strong>理论最大连接数 = 客户端IP数 × 客户端端口数</strong></p>
<p>对于IPv4：<strong>2^32 × 2^16 = 2^48</strong> 个连接</p>
<h3 id="实际限制因素">实际限制因素</h3>
<ol>
<li><strong>文件描述符限制</strong>：每个连接占用一个文件描述符</li>
<li><strong>系统内存限制</strong>：每个连接在内核中都有对应的数据结构</li>
</ol>
<h3 id="C10K问题">C10K问题</h3>
<p><strong>C10K问题</strong>：单机同时处理10,000个并发连接的挑战</p>
<p><strong>硬件要求估算：</strong></p>
<ul>
<li>内存：每个连接 &lt; 200KB → 10K连接需要约2GB内存</li>
<li>带宽：每个连接 &lt; 100Kbit → 10K连接需要约1Gbps带宽</li>
</ul>
<hr>
<h2 id="传统并发模型及其局限">传统并发模型及其局限</h2>
<h3 id="多进程模型">多进程模型</h3>
<p><strong>工作原理：</strong></p>
<ul>
<li>主进程监听连接</li>
<li>每个客户端连接fork一个子进程处理</li>
</ul>
<p><img src="/2025/07/02/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1751383641741.png" alt="1751383641741"></p>
<p><strong>优点：</strong></p>
<ul>
<li>进程隔离，稳定性好</li>
<li>实现简单</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>内存开销大（每个进程独立地址空间）</li>
<li>上下文切换开销重</li>
<li>进程创建/销毁成本高</li>
<li>易产生僵尸进程</li>
</ul>
<h3 id="多线程模型">多线程模型</h3>
<p><strong>改进方案：</strong></p>
<ul>
<li>使用线程替代进程</li>
<li>引入线程池避免频繁创建/销毁</li>
</ul>
<p><img src="/2025/07/02/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1751383651750.png" alt="1751383651750"></p>
<p><strong>优点：</strong></p>
<ul>
<li>相比进程，开销更小</li>
<li>共享内存空间，通信方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>仍然无法解决C10K问题</li>
<li>线程安全问题</li>
<li>上下文切换仍有开销</li>
</ul>
<hr>
<h2 id="I-O多路复用技术核心">I/O多路复用技术核心</h2>
<h3 id="基本思想">基本思想</h3>
<p><strong>时分多路复用</strong>：一个进程在极短时间内轮流处理多个连接的I/O事件，从宏观上看实现了&quot;并发&quot;处理。</p>
<p><img src="/2025/07/02/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1751383661511.png" alt="1751383661511"></p>
<h3 id="核心优势">核心优势</h3>
<ul>
<li><strong>资源利用率高</strong>：单进程处理多连接</li>
<li><strong>减少上下文切换</strong>：避免大量进程/线程切换</li>
<li><strong>内存友好</strong>：显著降低内存占用</li>
</ul>
<hr>
<h2 id="select-poll详解">select/poll详解</h2>
<h3 id="select实现机制">select实现机制</h3>
<p><strong>工作流程：</strong></p>
<ol>
<li>将文件描述符集合从用户态<strong>拷贝</strong>到内核态</li>
<li>内核<strong>遍历</strong>文件描述符集合，检查I/O事件</li>
<li>将结果从内核态<strong>拷贝</strong>回用户态</li>
<li>用户态再次<strong>遍历</strong>找到就绪的文件描述符</li>
</ol>
<p><strong>核心问题：</strong></p>
<ul>
<li><strong>2次拷贝</strong>：用户态 ↔ 内核态</li>
<li><strong>2次遍历</strong>：内核态 + 用户态</li>
<li><strong>文件描述符数量限制</strong>：默认最大1024个</li>
</ul>
<h3 id="poll改进">poll改进</h3>
<p><strong>主要改进：</strong></p>
<ul>
<li>使用动态数组替代固定长度BitMap</li>
<li>突破文件描述符数量限制</li>
</ul>
<p><strong>本质问题未解决：</strong></p>
<ul>
<li>仍然需要拷贝和遍历</li>
<li>时间复杂度仍为O(n)</li>
</ul>
<h3 id="性能分析">性能分析</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>select</th>
<th>poll</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件描述符限制</td>
<td>1024</td>
<td>无硬编码限制</td>
</tr>
<tr>
<td>数据结构</td>
<td>BitMap</td>
<td>动态数组</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>内核拷贝</td>
<td>需要</td>
<td>需要</td>
</tr>
<tr>
<td>遍历次数</td>
<td>2次</td>
<td>2次</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="epoll革命性改进">epoll革命性改进</h2>
<h3 id="核心创新点">核心创新点</h3>
<p><strong>第一点：红黑树管理文件描述符</strong></p>
<ul>
<li>使用红黑树存储待监控的文件描述符</li>
<li>增删查时间复杂度：O(log n)</li>
<li>避免每次传入整个集合，减少拷贝</li>
</ul>
<p><strong>第二点：事件驱动机制</strong></p>
<ul>
<li>维护就绪事件链表</li>
<li>通过回调函数更新就绪列表</li>
<li>只返回有事件的文件描述符</li>
</ul>
<p><img src="/2025/07/02/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1751383673424.png" alt="1751383673424"></p>
<h3 id="epoll接口详解">epoll接口详解</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建epoll实例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制epoll实例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="触发模式对比">触发模式对比</h3>
<h4 id="水平触发（Level-Triggered-LT）">水平触发（Level Triggered, LT）</h4>
<ul>
<li><strong>特点</strong>：只要满足条件就持续触发</li>
<li><strong>行为</strong>：数据可读时会不断通知，直到数据被读完</li>
<li><strong>优点</strong>：编程简单，不易出错</li>
<li><strong>缺点</strong>：可能产生多余的系统调用</li>
</ul>
<h4 id="边缘触发（Edge-Triggered-ET）">边缘触发（Edge Triggered, ET）</h4>
<ul>
<li><strong>特点</strong>：只在状态变化时触发一次</li>
<li><strong>行为</strong>：数据到达时只通知一次，必须一次性读完</li>
<li><strong>优点</strong>：减少系统调用次数，效率更高</li>
<li><strong>缺点</strong>：编程复杂，必须配合非阻塞I/O使用</li>
</ul>
<p><strong>实际应用建议：</strong></p>
<ul>
<li>边缘触发 + 非阻塞I/O + 循环读写</li>
<li>检查EAGAIN/EWOULDBLOCK错误</li>
</ul>
<hr>
<h2 id="性能对比与选择指南">性能对比与选择指南</h2>
<h3 id="综合性能对比">综合性能对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>连接数限制</td>
<td>1024</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>内存拷贝</td>
<td>每次全量</td>
<td>每次全量</td>
<td>增量</td>
</tr>
<tr>
<td>事件复杂度</td>
<td>线性扫描</td>
<td>线性扫描</td>
<td>事件驱动</td>
</tr>
<tr>
<td>跨平台性</td>
<td>最好</td>
<td>较好</td>
<td>Linux专有</td>
</tr>
</tbody>
</table>
<h3 id="应用场景选择">应用场景选择</h3>
<p><strong>select适用场景：</strong></p>
<ul>
<li>连接数少（&lt; 100）</li>
<li>跨平台兼容性要求高</li>
<li>临时性/简单应用</li>
</ul>
<p><strong>poll适用场景：</strong></p>
<ul>
<li>连接数中等（&lt; 1000）</li>
<li>需要突破select的1024限制</li>
<li>不要求最高性能</li>
</ul>
<p><strong>epoll适用场景：</strong></p>
<ul>
<li>高并发服务器（&gt; 1000连接）</li>
<li>对性能要求极高</li>
<li>Linux平台专用应用</li>
</ul>
<hr>
<h2 id="常见面试问题与解答">常见面试问题与解答</h2>
<h3 id="Q1-为什么epoll比select-poll性能更好？">Q1: 为什么epoll比select/poll性能更好？</h3>
<p><strong>A:</strong> 主要有两个方面的改进：</p>
<ol>
<li>
<p><strong>数据结构优化</strong>：</p>
<ul>
<li>select/poll使用线性结构，需要O(n)遍历</li>
<li>epoll使用红黑树，增删查为O(log n)</li>
</ul>
</li>
<li>
<p><strong>事件通知机制</strong>：</p>
<ul>
<li>select/poll采用轮询方式，每次都要遍历全部文件描述符</li>
<li>epoll采用事件驱动，只返回活跃的文件描述符</li>
</ul>
</li>
</ol>
<h3 id="Q2-epoll的ET和LT模式有什么区别？">Q2: epoll的ET和LT模式有什么区别？</h3>
<p><strong>A:</strong></p>
<ul>
<li><strong>LT（水平触发）</strong>：只要有数据就持续通知，类似&quot;快递箱反复发短信&quot;</li>
<li><strong>ET（边缘触发）</strong>：只在数据到达瞬间通知一次，类似&quot;快递箱只发一次短信&quot;</li>
</ul>
<p>ET模式效率更高但编程更复杂，必须配合非阻塞I/O使用。</p>
<h3 id="Q3-I-O多路复用是否一定要配合非阻塞I-O？">Q3: I/O多路复用是否一定要配合非阻塞I/O？</h3>
<p><strong>A:</strong> 强烈建议配合使用，原因：</p>
<ul>
<li>多路复用返回的&quot;就绪&quot;事件可能是假的</li>
<li>使用阻塞I/O可能导致程序意外阻塞</li>
<li>非阻塞I/O能够及时处理EAGAIN错误</li>
</ul>
<h3 id="Q4-epoll是否使用了共享内存？">Q4: epoll是否使用了共享内存？</h3>
<p><strong>A:</strong> <strong>错误的常见误解！</strong> epoll并没有使用共享内存。查看内核源码可以发现，<code>epoll_wait</code>中调用了<code>__put_user</code>函数，这明确表明数据是从内核拷贝到用户空间的。</p>
<h3 id="Q5-如何选择合适的I-O多路复用技术？">Q5: 如何选择合适的I/O多路复用技术？</h3>
<p><strong>A:</strong> 选择依据：</p>
<ul>
<li><strong>连接数量</strong>：少量用select，中等用poll，大量用epoll</li>
<li><strong>平台兼容性</strong>：跨平台选select/poll，Linux专用选epoll</li>
<li><strong>性能要求</strong>：高性能选epoll，一般需求可用poll</li>
<li><strong>开发复杂度</strong>：简单应用用select，复杂应用用epoll</li>
</ul>
<hr>
<h2 id="最佳实践与优化建议">最佳实践与优化建议</h2>
<h3 id="1-合理设置超时时间">1. 合理设置超时时间</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 避免无限阻塞，设置合理超时</span></span><br><span class="line"><span class="type">int</span> timeout = <span class="number">1000</span>; <span class="comment">// 1秒超时</span></span><br><span class="line">epoll_wait(epfd, events, MAX_EVENTS, timeout);</span><br></pre></td></tr></table></figure>
<h3 id="2-边缘触发模式最佳实践">2. 边缘触发模式最佳实践</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ET模式必须循环读取直到EAGAIN</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 数据读完</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理其他错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理读取的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-错误处理">3. 错误处理</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查spurious wakeup</span></span><br><span class="line"><span class="keyword">if</span> (epoll_wait(...) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 验证文件描述符确实可读/可写</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_GETFL) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件描述符已关闭</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-资源管理">4. 资源管理</h3>
<ul>
<li>及时关闭不再使用的文件描述符</li>
<li>使用EPOLL_CTL_DEL移除监控</li>
<li>避免文件描述符泄漏</li>
</ul>
<hr>
<h2 id="相关技术延伸">相关技术延伸</h2>
<h3 id="与异步I-O的关系">与异步I/O的关系</h3>
<ul>
<li>I/O多路复用仍属于同步I/O</li>
<li>真正的异步I/O：AIO、io_uring</li>
</ul>
<h3 id="现代框架应用">现代框架应用</h3>
<ul>
<li><strong>Nginx</strong>：基于epoll的事件驱动</li>
<li><strong>Redis</strong>：事件循环 + epoll</li>
<li><strong>Node.js</strong>：libuv事件循环</li>
</ul>
<h3 id="性能调优要点">性能调优要点</h3>
<ul>
<li>合理设置文件描述符限制</li>
<li>优化内核参数</li>
<li>使用CPU亲和性绑定</li>
<li>考虑NUMA架构影响</li>
</ul>
<hr>
<h2 id="总结">总结</h2>
<p>I/O多路复用技术经历了从select到poll再到epoll的演进过程，每一步都在解决前一代技术的性能瓶颈。epoll以其事件驱动和红黑树管理的创新设计，成功解决了C10K问题，为现代高性能服务器奠定了基础。</p>
<p><strong>关键记忆点：</strong></p>
<ul>
<li>select/poll：线性遍历，O(n)复杂度，有拷贝开销</li>
<li>epoll：事件驱动，O(1)复杂度，减少拷贝</li>
<li>ET模式配合非阻塞I/O实现最优性能</li>
<li>选择标准：连接数、平台、性能需求</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>操作系统</tag>
        <tag>网络编程</tag>
        <tag>IO多路复用</tag>
        <tag>select</tag>
        <tag>poll</tag>
        <tag>epoll</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 212 - 单词搜索 II（Word Search II）</title>
    <url>/2025/07/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-ii/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个单词列表 <code>words</code>，返回所有在二维网格中可以找到的单词。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中&quot;相邻&quot;单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],</span><br><span class="line">              [&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],</span><br><span class="line">              [&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],</span><br><span class="line">              [&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], </span><br><span class="line">     words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">输出：[&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],</span><br><span class="line">              [&quot;c&quot;,&quot;d&quot;]], </span><br><span class="line">     words = [&quot;abcb&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n == board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 12</code></li>
<li><code>board[i][j]</code> 是一个小写英文字母</li>
<li><code>1 &lt;= words.length &lt;= 3 * 10^4</code></li>
<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
<li><code>words[i]</code> 由小写英文字母组成</li>
<li><code>words</code> 中的所有字符串互不相同</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题是<strong>单词搜索问题的升级版</strong>，需要在同一个二维网格中搜索多个单词。如果我们对每个单词都进行一次 DFS 搜索，时间复杂度会非常高。因此，我们需要使用**字典树（Trie）**来优化搜索过程。</p>
<h3 id="核心思路">核心思路</h3>
<p><strong>关键洞见</strong>：使用字典树将所有目标单词存储在一个数据结构中，然后只需要对网格进行一次 DFS 遍历，在遍历过程中同时匹配字典树中的所有单词。</p>
<h3 id="算法步骤">算法步骤</h3>
<h4 id="1-构建字典树">1. 构建字典树</h4>
<ul>
<li>将所有待搜索的单词插入到字典树中</li>
<li>在叶子节点存储完整的单词，便于识别完整匹配</li>
</ul>
<h4 id="2-DFS-搜索策略">2. DFS 搜索策略</h4>
<ul>
<li>从网格的每个位置开始进行 DFS</li>
<li>在 DFS 过程中，根据当前路径的字符在字典树中进行匹配</li>
<li>如果当前路径无法在字典树中继续匹配，则提前剪枝</li>
<li>如果匹配到完整单词，则记录结果</li>
</ul>
<h4 id="3-回溯机制">3. 回溯机制</h4>
<ul>
<li>使用标记字符（如 <code>#</code>）来避免在同一次 DFS 中重复访问相同位置</li>
<li>在 DFS 返回时恢复原始字符，确保不同路径可以重复使用相同位置</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="字典树节点设计">字典树节点设计</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodes [<span class="number">26</span>]*Trie1  <span class="comment">// 26个字母的子节点</span></span><br><span class="line">    word  <span class="type">string</span>      <span class="comment">// 存储完整单词（仅在单词结尾节点）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DFS-搜索流程">DFS 搜索流程</h3>
<ol>
<li><strong>边界检查</strong>：检查坐标是否越界或位置是否已访问</li>
<li><strong>字典树匹配</strong>：根据当前字符在字典树中查找对应子节点</li>
<li><strong>剪枝优化</strong>：如果字典树中没有对应子节点，直接返回</li>
<li><strong>结果记录</strong>：如果当前节点包含完整单词，记录到结果中</li>
<li><strong>标记访问</strong>：将当前位置标记为已访问（使用特殊字符）</li>
<li><strong>递归搜索</strong>：向四个方向继续 DFS</li>
<li><strong>恢复状态</strong>：回溯时恢复原始字符</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodes [<span class="number">26</span>]*Trie1</span><br><span class="line">    word  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(word <span class="type">string</span>, root *Trie1)</span></span> &#123;</span><br><span class="line">    node := root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch := word[i] - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.nodes[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            node.nodes[ch] = &amp;Trie1&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nodes[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.word = word  <span class="comment">// 在单词结尾存储完整单词</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dirs = []<span class="keyword">struct</span>&#123; x, y <span class="type">int</span> &#125;&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWords</span><span class="params">(board [][]<span class="type">byte</span>, words []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 构建字典树</span></span><br><span class="line">    root := &amp;Trie1&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        Insert(word, root)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n, m := <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    seen := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;&#125;  <span class="comment">// 去重</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. DFS 搜索函数</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *Trie1, x, y <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *Trie1, x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        ch := board[x][y]</span><br><span class="line">        node = node.nodes[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剪枝：如果字典树中没有对应路径</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到完整单词，记录结果</span></span><br><span class="line">        <span class="keyword">if</span> node.word != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            seen[node.word] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记当前位置为已访问</span></span><br><span class="line">        board[x][y] = <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向四个方向继续搜索</span></span><br><span class="line">        <span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">            nx, ny := x+dir.x, y+dir.y</span><br><span class="line">            <span class="keyword">if</span> nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= n || ny &gt;= m &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> board[nx][ny] == <span class="string">&#x27;#&#x27;</span> &#123;  <span class="comment">// 已访问过</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            dfs(node, nx, ny)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯：恢复原始字符</span></span><br><span class="line">        board[x][y] = ch</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 从每个位置开始搜索</span></span><br><span class="line">    <span class="keyword">for</span> i, row := <span class="keyword">range</span> board &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> row &#123;</span><br><span class="line">            dfs(root, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 转换结果格式</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(seen))</span><br><span class="line">    <span class="keyword">for</span> w := <span class="keyword">range</span> seen &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, w)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>暴力解法</th>
<th>字典树 + DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(k \cdot m \cdot n \cdot 4^L)$</td>
<td>$O(m \cdot n \cdot 4^L)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(L)$</td>
<td>$O(\sum w_i)$</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单</td>
<td>高效剪枝，减少重复搜索</td>
</tr>
<tr>
<td>缺点</td>
<td>重复搜索相同路径</td>
<td>需要额外的字典树空间</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<p>其中：</p>
<ul>
<li>$k$ = 单词数量</li>
<li>$m \times n$ = 网格大小</li>
<li>$L$ = 单词最大长度</li>
<li>$\sum w_i$ = 所有单词的字符总数</li>
</ul>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-m-cdot-n-cdot-4-L">时间复杂度：$O(m \cdot n \cdot 4^L)$</h3>
<p>详细分析：</p>
<ol>
<li><strong>字典树构建</strong>：$O(\sum w_i)$，其中 $\sum w_i$ 是所有单词的字符总数</li>
<li><strong>DFS 搜索</strong>：
<ul>
<li>从每个位置开始：$O(m \cdot n)$</li>
<li>每次 DFS 最多递归 $L$ 层（单词最大长度）</li>
<li>每层有 4 个方向选择：$O(4^L)$</li>
<li>字典树剪枝大大减少了实际搜索空间</li>
</ul>
</li>
</ol>
<p>总时间复杂度：$O(m \cdot n \cdot 4^L + \sum w_i)$，主要部分是 $O(m \cdot n \cdot 4^L)$</p>
<h3 id="空间复杂度：-O-sum-w-i">空间复杂度：$O(\sum w_i)$</h3>
<p>空间使用分析：</p>
<ol>
<li><strong>字典树存储</strong>：$O(\sum w_i)$ - 存储所有单词的字符</li>
<li><strong>DFS 递归栈</strong>：$O(L)$ - 最大递归深度为单词长度</li>
<li><strong>结果存储</strong>：$O(k \cdot L)$ - 最多 $k$ 个单词，每个长度 $L$</li>
</ol>
<h2 id="关键收获">关键收获</h2>
<h3 id="算法技巧">算法技巧</h3>
<ol>
<li><strong>字典树优化</strong>：将多个单词的搜索问题转化为单次遍历问题</li>
<li><strong>剪枝策略</strong>：利用字典树的前缀特性提前终止无效路径</li>
<li><strong>状态恢复</strong>：使用标记字符避免重复访问，回溯时恢复状态</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>忘记回溯</strong>：必须在 DFS 返回时恢复原始字符</li>
<li><strong>重复计数</strong>：使用 <code>map[string]bool</code> 去重，避免同一单词被多次计算</li>
<li><strong>边界处理</strong>：检查数组越界和已访问位置</li>
</ol>
<h3 id="扩展应用">扩展应用</h3>
<ul>
<li><strong>单词游戏</strong>：如 Boggle 游戏的单词搜索</li>
<li><strong>文本匹配</strong>：在大文本中搜索多个模式串</li>
<li><strong>路径规划</strong>：在图中搜索满足特定模式的路径</li>
</ul>
<p>这道题完美展示了<strong>字典树在多模式匹配中的强大作用</strong>，是掌握高级字符串算法的重要题目。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>字典树</tag>
        <tag>回溯算法</tag>
        <tag>难度Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 211 - 添加与搜索单词-数据结构设计（Design Add and Search Words Data Structure）</title>
    <url>/2025/06/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>请你设计一个数据结构，支持添加新单词和查找字符串是否与任何先前添加的字符串匹配。</p>
<p>实现词典类 <code>WordDictionary</code>：</p>
<ul>
<li><code>WordDictionary()</code> 初始化词典对象</li>
<li><code>void addWord(word)</code> 将 <code>word</code> 添加到数据结构中，之后可以对它进行匹配</li>
<li><code>bool search(word)</code> 如果数据结构中存在字符串与 <code>word</code> 匹配，则返回 <code>true</code>；否则，返回 <code>false</code>。<code>word</code> 中可能包含一些 <code>'.'</code>，每个 <code>'.'</code> 都可以表示任何一个字母。</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span><br><span class="line">[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,false,true,true,true]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">WordDictionary wordDictionary = new WordDictionary();</span><br><span class="line">wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">wordDictionary.search(&quot;pad&quot;); // 返回 False</span><br><span class="line">wordDictionary.search(&quot;bad&quot;); // 返回 True</span><br><span class="line">wordDictionary.search(&quot;.ad&quot;); // 返回 True</span><br><span class="line">wordDictionary.search(&quot;b..&quot;); // 返回 True</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>1 &lt;= word.length &lt;= 25</code></li>
<li><code>addWord</code> 中的 <code>word</code> 由小写英文字母组成</li>
<li><code>search</code> 中的 <code>word</code> 由 <code>'.'</code> 或小写英文字母组成</li>
<li>最多调用 <code>10^4</code> 次 <code>addWord</code> 和 <code>search</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题需要实现一个支持通配符搜索的字典数据结构。<strong>核心思路是使用字典树(Trie)存储单词，并用深度优先搜索(DFS)处理通配符匹配</strong>。</p>
<h3 id="关键洞察">关键洞察</h3>
<ol>
<li><strong>字典树适合前缀匹配</strong>：Trie的每个节点表示一个字符，从根到叶子的路径构成完整单词</li>
<li><strong>通配符需要递归处理</strong>：遇到 <code>'.'</code> 时，需要尝试所有可能的字符分支</li>
<li><strong>状态记录很重要</strong>：每个节点需要标记是否为单词结尾</li>
</ol>
<h3 id="算法步骤">算法步骤</h3>
<h4 id="1-数据结构设计">1. 数据结构设计</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TrieNode 结构：</span><br><span class="line">├── children[26]  // 26个小写字母的子节点</span><br><span class="line">└── isEnd        // 标记是否为单词结尾</span><br></pre></td></tr></table></figure>
<h4 id="2-AddWord-操作">2. AddWord 操作</h4>
<ol>
<li>从根节点开始遍历待添加的单词</li>
<li>对每个字符，计算其在children数组中的索引：<code>index = char - 'a'</code></li>
<li>如果对应子节点不存在，创建新节点</li>
<li>移动到子节点，继续处理下一个字符</li>
<li>单词结束时，标记当前节点的 <code>isEnd = true</code></li>
</ol>
<h4 id="3-Search-操作（核心难点）">3. Search 操作（核心难点）</h4>
<p>使用递归DFS处理两种情况：</p>
<p><strong>普通字符</strong>：</p>
<ul>
<li>直接沿着对应的子节点路径继续搜索</li>
</ul>
<p><strong>通配符 ‘.’</strong>：</p>
<ul>
<li>遍历当前节点的所有非空子节点</li>
<li>对每个子节点递归调用搜索函数</li>
<li>只要有一个分支返回true，整个搜索就成功</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="DFS递归函数设计">DFS递归函数设计</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TrieNode, word <span class="type">string</span>, index <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 边界条件检查</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索完成，检查是否为单词结尾</span></span><br><span class="line">    <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(word) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理通配符</span></span><br><span class="line">    <span class="keyword">if</span> word[index] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试所有可能的字符</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> node.children &#123;</span><br><span class="line">            <span class="keyword">if</span> dfs(node.children[i], word, index+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理普通字符</span></span><br><span class="line">    <span class="keyword">return</span> dfs(node.children[word[index]-<span class="string">&#x27;a&#x27;</span>], word, index+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法执行示例">算法执行示例</h3>
<p>以搜索 <code>&quot;.ad&quot;</code> 为例（假设字典中有 “bad”, “dad”, “mad”）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. dfs(root, &quot;.ad&quot;, 0)</span><br><span class="line">   ├── word[0] = &#x27;.&#x27; → 遍历所有子节点</span><br><span class="line">   ├── dfs(node_b, &quot;.ad&quot;, 1) → 搜索 &quot;ad&quot;</span><br><span class="line">   │   └── word[1] = &#x27;a&#x27; → 进入node_a</span><br><span class="line">   │       └── word[2] = &#x27;d&#x27; → 进入node_d</span><br><span class="line">   │           └── index=3, node_d.isEnd=true → 返回true</span><br><span class="line">   └── 找到匹配，返回true</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WordDictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *TrieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    children [<span class="number">26</span>]*TrieNode <span class="comment">// 只针对小写字母 a-z</span></span><br><span class="line">    isEnd    <span class="type">bool</span>          <span class="comment">// 标记单词结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> WordDictionary &#123;</span><br><span class="line">    <span class="keyword">return</span> WordDictionary&#123;</span><br><span class="line">        root: &amp;TrieNode&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span></span> AddWord(word <span class="type">string</span>) &#123;</span><br><span class="line">    node := this.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span> <span class="comment">// 将字符映射到0-25的索引</span></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            node.children[index] = &amp;TrieNode&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span> <span class="comment">// 标记单词结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TrieNode, index <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">    </span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TrieNode, index <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(word) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.isEnd</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> word[index] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试所有可能的字符分支</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> node.children &#123;</span><br><span class="line">                <span class="keyword">if</span> dfs(node.children[i], index+<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 普通字符，直接沿着对应路径搜索</span></span><br><span class="line">        <span class="keyword">return</span> dfs(node.children[word[index]-<span class="string">&#x27;a&#x27;</span>], index+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(this.root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p><strong>AddWord操作</strong>：$O(m)$</p>
<ul>
<li>其中 $m$ 是单词长度</li>
<li>需要遍历单词的每个字符</li>
</ul>
<p><strong>Search操作</strong>：</p>
<ul>
<li><strong>最好情况</strong>：$O(m)$ - 无通配符时</li>
<li><strong>最坏情况</strong>：$O(26^k \cdot m)$ - 其中 $k$ 是通配符数量</li>
<li>通配符会导致指数级的搜索分支</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<p>$O(ALPHABET_SIZE \times N \times M)$</p>
<ul>
<li>$ALPHABET_SIZE = 26$（小写字母数量）</li>
<li>$N$ 是单词总数</li>
<li>$M$ 是平均单词长度</li>
<li>Trie的空间消耗取决于单词的公共前缀</li>
</ul>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>Trie + DFS</th>
<th>哈希表 + 暴力搜索</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>AddWord: O(m)</td>
<td>AddWord: O(1)</td>
</tr>
<tr>
<td></td>
<td>Search: O(26^k×m)</td>
<td>Search: O(N×m)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(26×N×M)</td>
<td>O(N×M)</td>
</tr>
<tr>
<td>通配符支持</td>
<td>★★★★★</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>★★★☆☆</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>前缀查询</td>
<td>★★★★★</td>
<td>★☆☆☆☆</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>Trie适合字符串前缀操作</strong>：对于涉及字符串前缀匹配的问题，Trie通常是最佳选择</li>
<li><strong>递归处理分支逻辑</strong>：通配符问题常需要递归探索多个可能的路径</li>
<li><strong>状态标记的重要性</strong>：<code>isEnd</code> 标记确保只有完整单词才能匹配成功</li>
<li><strong>优化搜索策略</strong>：可以考虑剪枝优化，比如提前终止无效分支</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ul>
<li><strong>忘记检查 <code>isEnd</code></strong>：搜索到单词结尾时必须验证是否为有效单词</li>
<li><strong>边界条件处理</strong>：空节点和索引越界需要正确处理</li>
<li><strong>通配符逻辑错误</strong>：需要遍历所有可能的子节点，而不是第一个找到的</li>
</ul>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">LeetCode 208: 实现 Trie (前缀树)</a></li>
<li><a href="https://leetcode.cn/problems/word-search/">LeetCode 79: 单词搜索</a></li>
<li><a href="https://leetcode.cn/problems/word-search-ii/">LeetCode 212: 单词搜索 II</a></li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Medium</tag>
        <tag>DFS</tag>
        <tag>Trie</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 127 - 单词接龙（Word Ladder）</title>
    <url>/2025/06/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的<strong>转换序列</strong>是一个按下述规格组成的序列：</p>
<ol>
<li>序列中第一个单词是 <code>beginWord</code></li>
<li>序列中最后一个单词是 <code>endWord</code></li>
<li>每次转换只能改变一个字母</li>
<li>转换过程中的中间单词必须是字典 <code>wordList</code> 中的单词</li>
</ol>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code>，找到从 <code>beginWord</code> 到 <code>endWord</code> 的<strong>最短转换序列</strong>中的<strong>单词数目</strong>。如果不存在这样的转换序列，返回 0。</p>
<h3 id="示例-1">示例 1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2">示例 2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>
<li><code>endWord.length == beginWord.length</code></li>
<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>
<li><code>wordList[i].length == beginWord.length</code></li>
<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>
<li><code>beginWord != endWord</code></li>
<li><code>wordList</code> 中的所有字符串<strong>互不相同</strong></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题本质上是一个<strong>图的最短路径问题</strong>。我们需要将单词转换问题建模为图，然后使用 BFS 找到最短路径。</p>
<h3 id="核心洞察">核心洞察</h3>
<p><strong>关键思路</strong>：将每个单词看作图中的节点，如果两个单词只相差一个字符，就在它们之间建立一条边。然后使用 BFS 从 <code>beginWord</code> 开始搜索到 <code>endWord</code> 的最短路径。</p>
<h3 id="虚拟节点技巧">虚拟节点技巧</h3>
<p>直接比较每对单词是否只相差一个字符的时间复杂度很高。我们使用一个巧妙的<strong>虚拟节点</strong>技巧：</p>
<ol>
<li>对于每个单词的每个位置，将该位置的字符替换为 <code>*</code>，创建一个虚拟节点</li>
<li>例如：<code>&quot;hit&quot;</code> 可以生成 <code>&quot;*it&quot;</code>、<code>&quot;h*t&quot;</code>、<code>&quot;hi*&quot;</code> 三个虚拟节点</li>
<li>所有能生成相同虚拟节点的单词之间都只相差一个字符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单词图示例：</span><br><span class="line">hit -&gt; *it &lt;- hot</span><br><span class="line">hit -&gt; h*t &lt;- hut  </span><br><span class="line">hit -&gt; hi* &lt;- his</span><br><span class="line"></span><br><span class="line">这样 hit 和 hot 通过虚拟节点 *it 连接起来</span><br></pre></td></tr></table></figure>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li>
<p><strong>建图阶段</strong>：</p>
<ul>
<li>为每个单词创建虚拟节点</li>
<li>建立单词节点与虚拟节点之间的双向边</li>
</ul>
</li>
<li>
<p><strong>BFS 搜索阶段</strong>：</p>
<ul>
<li>从 <code>beginWord</code> 开始 BFS</li>
<li>当找到 <code>endWord</code> 时返回路径长度</li>
<li>由于存在虚拟节点，实际路径长度需要除以 2 再加 1</li>
</ul>
</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="建图过程">建图过程</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加单词到图中，返回单词的ID</span></span><br><span class="line">addWord := <span class="function"><span class="keyword">func</span><span class="params">(word <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    id, has := wordId[word]</span><br><span class="line">    <span class="keyword">if</span> !has &#123;</span><br><span class="line">        id = <span class="built_in">len</span>(wordId)</span><br><span class="line">        wordId[word] = id</span><br><span class="line">        graph = <span class="built_in">append</span>(graph, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为单词创建虚拟节点并建立连接</span></span><br><span class="line">addEdge := <span class="function"><span class="keyword">func</span><span class="params">(word <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    id1 := addWord(word)</span><br><span class="line">    s := []<span class="type">byte</span>(word)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, b := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[i] = <span class="string">&#x27;*&#x27;</span>                    <span class="comment">// 创建虚拟节点</span></span><br><span class="line">        id2 := addWord(<span class="type">string</span>(s))     <span class="comment">// 添加虚拟节点</span></span><br><span class="line">        graph[id1] = <span class="built_in">append</span>(graph[id1], id2)  <span class="comment">// 建立双向边</span></span><br><span class="line">        graph[id2] = <span class="built_in">append</span>(graph[id2], id1)</span><br><span class="line">        s[i] = b                      <span class="comment">// 恢复原字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS-搜索过程">BFS 搜索过程</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化距离数组</span></span><br><span class="line"><span class="keyword">const</span> inf <span class="type">int</span> = math.MaxInt32</span><br><span class="line">dist := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(wordId))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dist &#123;</span><br><span class="line">    dist[i] = inf</span><br><span class="line">&#125;</span><br><span class="line">dist[beginId] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 队列</span></span><br><span class="line">queue := []<span class="type">int</span>&#123;beginId&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    v := queue[<span class="number">0</span>]</span><br><span class="line">    queue = queue[<span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> v == endId &#123;</span><br><span class="line">        <span class="keyword">return</span> dist[endId]/<span class="number">2</span> + <span class="number">1</span>  <span class="comment">// 除以2是因为有虚拟节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, w := <span class="keyword">range</span> graph[v] &#123;</span><br><span class="line">        <span class="keyword">if</span> dist[w] == inf &#123;</span><br><span class="line">            dist[w] = dist[v] + <span class="number">1</span></span><br><span class="line">            queue = <span class="built_in">append</span>(queue, w)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ladderLength</span><span class="params">(beginWord <span class="type">string</span>, endWord <span class="type">string</span>, wordList []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    wordId := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加单词到图中</span></span><br><span class="line">    addWord := <span class="function"><span class="keyword">func</span><span class="params">(word <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        id, has := wordId[word]</span><br><span class="line">        <span class="keyword">if</span> !has &#123;</span><br><span class="line">            id = <span class="built_in">len</span>(wordId)</span><br><span class="line">            wordId[word] = id</span><br><span class="line">            graph = <span class="built_in">append</span>(graph, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为单词创建虚拟节点并建立连接</span></span><br><span class="line">    addEdge := <span class="function"><span class="keyword">func</span><span class="params">(word <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        id1 := addWord(word)</span><br><span class="line">        s := []<span class="type">byte</span>(word)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, b := <span class="keyword">range</span> s &#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">            id2 := addWord(<span class="type">string</span>(s))</span><br><span class="line">            graph[id1] = <span class="built_in">append</span>(graph[id1], id2)</span><br><span class="line">            graph[id2] = <span class="built_in">append</span>(graph[id2], id1)</span><br><span class="line">            s[i] = b</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建图：处理字典中的所有单词</span></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordList &#123;</span><br><span class="line">        addEdge(word)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加起始单词</span></span><br><span class="line">    beginId := addEdge(beginWord)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查目标单词是否存在</span></span><br><span class="line">    endId, has := wordId[endWord]</span><br><span class="line">    <span class="keyword">if</span> !has &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BFS 搜索最短路径</span></span><br><span class="line">    <span class="keyword">const</span> inf <span class="type">int</span> = math.MaxInt32</span><br><span class="line">    dist := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(wordId))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dist &#123;</span><br><span class="line">        dist[i] = inf</span><br><span class="line">    &#125;</span><br><span class="line">    dist[beginId] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    queue := []<span class="type">int</span>&#123;beginId&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        v := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> v == endId &#123;</span><br><span class="line">            <span class="keyword">return</span> dist[endId]/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _, w := <span class="keyword">range</span> graph[v] &#123;</span><br><span class="line">            <span class="keyword">if</span> dist[w] == inf &#123;</span><br><span class="line">                dist[w] = dist[v] + <span class="number">1</span></span><br><span class="line">                queue = <span class="built_in">append</span>(queue, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法执行示例">算法执行示例</h2>
<p>以 <code>beginWord = &quot;hit&quot;</code>, <code>endWord = &quot;cog&quot;</code>, <code>wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code> 为例：</p>
<h3 id="建图阶段">建图阶段</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单词节点：hit(0), hot(1), dot(2), dog(3), lot(4), log(5), cog(6)</span><br><span class="line">虚拟节点：*it(7), h*t(8), hi*(9), *ot(10), ho*(11), ...</span><br><span class="line"></span><br><span class="line">连接关系：</span><br><span class="line">hit(0) &lt;-&gt; *it(7) &lt;-&gt; hot(1)</span><br><span class="line">hit(0) &lt;-&gt; h*t(8) &lt;-&gt; hot(1)  </span><br><span class="line">hot(1) &lt;-&gt; *ot(10) &lt;-&gt; dot(2), lot(4)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="BFS-搜索过程-2">BFS 搜索过程</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始：queue = [0(hit)], dist[0] = 0</span><br><span class="line"></span><br><span class="line">第1轮：访问 hit(0)</span><br><span class="line">- 访问虚拟节点 *it(7), h*t(8), hi*(9)</span><br><span class="line">- dist[7] = dist[8] = dist[9] = 1</span><br><span class="line">- queue = [7, 8, 9]</span><br><span class="line"></span><br><span class="line">第2轮：访问虚拟节点</span><br><span class="line">- 通过 *it(7) 访问到 hot(1), dist[1] = 2</span><br><span class="line">- queue = [8, 9, 1]</span><br><span class="line"></span><br><span class="line">...继续直到找到 cog(6)</span><br><span class="line"></span><br><span class="line">最终：dist[6] = 8，返回 8/2 + 1 = 5</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-M-2-times-N">时间复杂度：$O(M^2 \times N)$</h3>
<ul>
<li>$M$ 是单词长度，$N$ 是单词列表长度</li>
<li>建图阶段：每个单词创建 $M$ 个虚拟节点，总共 $O(M \times N)$ 个节点</li>
<li>BFS 阶段：最坏情况下访问所有节点和边，边数为 $O(M \times N)$</li>
<li>字符串操作：每次字符串复制需要 $O(M)$ 时间</li>
</ul>
<h3 id="空间复杂度：-O-M-2-times-N">空间复杂度：$O(M^2 \times N)$</h3>
<ul>
<li>图存储：$O(M \times N)$ 个节点，每个节点最多连接 $O(M)$ 条边</li>
<li>队列和距离数组：$O(M \times N)$</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<h3 id="重要算法概念">重要算法概念</h3>
<ol>
<li><strong>图建模</strong>：将问题转换为图的最短路径问题</li>
<li><strong>虚拟节点技巧</strong>：避免直接比较所有单词对，提高建图效率</li>
<li><strong>BFS 特性</strong>：保证找到最短路径</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>忘记检查目标单词</strong>：如果 <code>endWord</code> 不在字典中直接返回 0</li>
<li><strong>路径长度计算错误</strong>：由于有虚拟节点，需要 <code>dist/2 + 1</code></li>
<li><strong>双向边建立</strong>：虚拟节点与单词节点之间需要建立双向连接</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li>LeetCode 126: 单词接龙 II（返回所有最短路径）</li>
<li>LeetCode 433: 最小基因变化（相似的BFS问题）</li>
<li>其他图的最短路径问题</li>
</ul>
<p>这道题展示了如何将字符串转换问题巧妙地转化为图论问题，并使用虚拟节点优化建图过程，是 BFS 算法的经典应用。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>广度优先搜索</tag>
        <tag>Medium</tag>
        <tag>图</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 433 - 最小基因变化 (Minimum Genetic Mutation)</title>
    <url>/2025/06/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-433-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 ‘A’、‘C’、‘G’ 和 ‘T’ 之一。</p>
<p>假设我们需要调查从基因序列 <code>startGene</code> 变为 <code>endGene</code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>
<ul>
<li>例如，<code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot;</code> 就是一次基因变化。</li>
</ul>
<p>另有一个基因库 <code>bank</code> 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 <code>bank</code> 中）</p>
<p>给你两个基因序列 <code>startGene</code> 和 <code>endGene</code> ，以及一个基因库 <code>bank</code> ，请你找出并返回能够使 <code>startGene</code> 变化为 <code>endGene</code> 所需的 <strong>最少变化次数</strong>。如果无法完成此基因变化，返回 -1 。</p>
<p><strong>注意：</strong> 起始基因序列 <code>startGene</code> 默认是有效的，但是它并不一定会出现在基因库中。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：startGene = &quot;AACCGGTT&quot;, endGene = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：startGene = &quot;AACCGGTT&quot;, endGene = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：startGene = &quot;AAAAACCC&quot;, endGene = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>约束条件:</strong></p>
<ul>
<li><code>startGene.length == 8</code></li>
<li><code>endGene.length == 8</code></li>
<li><code>0 &lt;= bank.length &lt;= 10</code></li>
<li><code>bank[i].length == 8</code></li>
<li><code>startGene</code>、<code>endGene</code> 和 <code>bank[i]</code> 仅由字符 <code>['A', 'C', 'G', 'T']</code> 组成</li>
</ul>
<h3 id="解题思路">解题思路</h3>
<p>这个问题要求解&quot;最少变化次数&quot;，这是一个典型的最短路径问题。我们可以将每个基因序列看作一个节点，如果两个基因序列之间可以通过一次变化（即一个字符不同）相互转换，并且目标序列在基因库 <code>bank</code> 中，那么这两个节点之间就存在一条边。问题的目标就是找到从 <code>startGene</code> 到 <code>endGene</code> 的最短路径。</p>
<h4 id="思路一：建图-Dijkstra-算法">思路一：建图 + Dijkstra 算法</h4>
<p>这种方法将问题显式地转换为图的最短路径问题。</p>
<ol>
<li><strong>节点定义</strong>：将 <code>startGene</code> 以及 <code>bank</code> 中所有不重复的基因序列作为图的节点。</li>
<li><strong>边的定义</strong>：如果两个基因序列（节点）之间只有一个字符不同，则在它们之间连接一条权重为 1 的边。</li>
<li><strong>构建邻接矩阵</strong>：我们可以创建一个邻接矩阵 <code>graph</code> 来存储图的结构。<code>graph[i][j] = 1</code> 表示节点 <code>i</code> 和节点 <code>j</code> 之间可以相互转换。</li>
<li><strong>最短路径算法</strong>：在构建好的图上，从 <code>startGene</code> 对应的节点开始，使用 Dijkstra 算法计算到 <code>endGene</code> 对应节点的最短路径。</li>
</ol>
<h5 id="实现细节">实现细节</h5>
<p>Dijkstra 算法是一种经典的解决单源最短路径问题的算法，它适用于边权为非负数的情况。虽然在这里所有边权都为 1，使用它也是完全正确的。</p>
<h5 id="代码实现-Go-Dijkstra">代码实现 (Go - Dijkstra)</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode 433</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMutation</span><span class="params">(startGene <span class="type">string</span>, endGene <span class="type">string</span>, bank []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	cnt := <span class="number">0</span></span><br><span class="line">	DNA2Index := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 startGene 和 bank 中的基因序列加入映射并编号</span></span><br><span class="line">	DNA2Index[startGene] = cnt</span><br><span class="line">	cnt++</span><br><span class="line">	<span class="keyword">for</span> _, dna := <span class="keyword">range</span> bank &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := DNA2Index[dna]; ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		DNA2Index[dna] = cnt</span><br><span class="line">		cnt++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 endGene 不在可达的基因库中，直接返回 -1</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := DNA2Index[endGene]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">	graph := <span class="built_in">make</span>([][]<span class="type">int</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> graph &#123;</span><br><span class="line">		graph[i] = <span class="built_in">make</span>([]<span class="type">int</span>, cnt)</span><br><span class="line">		<span class="keyword">for</span> j := <span class="keyword">range</span> graph[i] &#123;</span><br><span class="line">			<span class="keyword">if</span> i != j &#123;</span><br><span class="line">				graph[i][j] = math.MaxInt32</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据基因差异构建图的边</span></span><br><span class="line">	dnaList := <span class="built_in">make</span>([]<span class="type">string</span>, cnt)</span><br><span class="line">	<span class="keyword">for</span> dna, index := <span class="keyword">range</span> DNA2Index &#123;</span><br><span class="line">		dnaList[index] = dna</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; cnt; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> diff(dnaList[i], dnaList[j]) == <span class="number">1</span> &#123;</span><br><span class="line">				graph[i][j] = <span class="number">1</span></span><br><span class="line">				graph[j][i] = <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	startIndex := DNA2Index[startGene]</span><br><span class="line">	endIndex := DNA2Index[endGene]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Dijkstra 算法求解</span></span><br><span class="line">	dist, has := dijkstra(graph, startIndex, endIndex)</span><br><span class="line">	<span class="keyword">if</span> !has &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dijkstra 算法实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dijkstra</span><span class="params">(matrix [][]<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(matrix)</span><br><span class="line">	dist := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dist &#123;</span><br><span class="line">		dist[i] = math.MaxInt32</span><br><span class="line">	&#125;</span><br><span class="line">	dist[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		u := <span class="number">-1</span></span><br><span class="line">		minDist := math.MaxInt32</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> !visited[j] &amp;&amp; dist[j] &lt; minDist &#123;</span><br><span class="line">				minDist = dist[j]</span><br><span class="line">				u = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> u == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		visited[u] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> v := <span class="number">0</span>; v &lt; n; v++ &#123;</span><br><span class="line">			<span class="keyword">if</span> !visited[v] &amp;&amp; matrix[u][v] != math.MaxInt32 &amp;&amp; dist[u]+matrix[u][v] &lt; dist[v] &#123;</span><br><span class="line">				dist[v] = dist[u] + matrix[u][v]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dist[end] == math.MaxInt32 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist[end], <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个基因序列的差异字符数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diff</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	diffNum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> a[i] != b[i] &#123;</span><br><span class="line">			diffNum++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> diffNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二：广度优先搜索-BFS">思路二：广度优先搜索 (BFS)</h4>
<p>对于边权全部为 1 的图，广度优先搜索（BFS）是求解最短路径问题的更直接、更高效的选择。BFS 按层级遍历图，第一次到达目标节点时所经过的层数（步数）就是最短路径的长度。</p>
<ol>
<li><strong>数据结构</strong>：
<ul>
<li>一个队列 <code>queue</code> 用于存储待访问的基因序列。</li>
<li>一个哈希集合 <code>visited</code> (或 <code>map</code>) 用于记录已经访问过的序列，防止重复搜索和陷入循环。</li>
<li>一个哈希集合 <code>bankSet</code> 用于快速查询一个基因序列是否在基因库 <code>bank</code> 中。</li>
</ul>
</li>
<li><strong>算法流程</strong>：
<ul>
<li>将 <code>startGene</code> 和初始步数 0 加入队列。</li>
<li>将 <code>startGene</code> 加入 <code>visited</code> 集合。</li>
<li>当队列不为空时，取出队头元素（当前基因序列 <code>currentGene</code> 和步数 <code>steps</code>）。</li>
<li>如果 <code>currentGene</code> 等于 <code>endGene</code>，则 <code>steps</code> 就是最短路径，返回 <code>steps</code>。</li>
<li>否则，生成 <code>currentGene</code> 的所有可能的一次变化。对于每个新的基因序列 <code>nextGene</code>：
<ul>
<li>如果 <code>nextGene</code> 存在于 <code>bankSet</code> 中且未被访问过，则将其加入队列和 <code>visited</code> 集合，步数加 1。</li>
</ul>
</li>
<li>如果队列为空仍未找到 <code>endGene</code>，说明无法转换，返回 -1。</li>
</ul>
</li>
</ol>
<h5 id="代码实现-Go-BFS">代码实现 (Go - BFS)</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMutationBfs</span><span class="params">(startGene <span class="type">string</span>, endGene <span class="type">string</span>, bank []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	bankSet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> bank &#123;</span><br><span class="line">		bankSet[s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := bankSet[endGene]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> pair <span class="keyword">struct</span> &#123;</span><br><span class="line">		gene  <span class="type">string</span></span><br><span class="line">		steps <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q := list.New()</span><br><span class="line">	q.PushBack(pair&#123;startGene, <span class="number">0</span>&#125;)</span><br><span class="line">	visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	visited[startGene] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	chars := []<span class="type">byte</span>&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> q.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		element := q.Front()</span><br><span class="line">		p := element.Value.(pair)</span><br><span class="line">		q.Remove(element)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> p.gene == endGene &#123;</span><br><span class="line">			<span class="keyword">return</span> p.steps</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		geneChars := []<span class="type">byte</span>(p.gene)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(geneChars); i++ &#123;</span><br><span class="line">			oldChar := geneChars[i]</span><br><span class="line">			<span class="keyword">for</span> _, c := <span class="keyword">range</span> chars &#123;</span><br><span class="line">				<span class="keyword">if</span> oldChar == c &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				geneChars[i] = c</span><br><span class="line">				nextGene := <span class="type">string</span>(geneChars)</span><br><span class="line">				<span class="keyword">if</span> _, inBank := bankSet[nextGene]; inBank &#123;</span><br><span class="line">					<span class="keyword">if</span> _, isVisited := visited[nextGene]; !isVisited &#123;</span><br><span class="line">						visited[nextGene] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">						q.PushBack(pair&#123;nextGene, p.steps + <span class="number">1</span>&#125;)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			geneChars[i] = oldChar <span class="comment">// 恢复，以便进行下一个位置的变化</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法比较">方法比较</h3>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一 (Dijkstra)</th>
<th>方法二 (BFS)</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(N² + L*N²) or O(N²logN)</td>
<td>O(C<em>L</em>N)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(N²)</td>
<td>O(L*N)</td>
</tr>
<tr>
<td>核心思想</td>
<td>通用的单源最短路径算法</td>
<td>针对无权图的最短路径优化</td>
</tr>
<tr>
<td>优点</td>
<td>思路通用，可处理带权图</td>
<td>实现更简洁，效率更高</td>
</tr>
<tr>
<td>缺点</td>
<td>对于无权图来说过于复杂</td>
<td>仅适用于无权图</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>N</strong>: <code>bank</code> 的长度。</li>
<li><strong>L</strong>: 基因序列的长度 (这里是 8)。</li>
<li><strong>C</strong>: 基因字符集的大小 (这里是 4)。</li>
<li>Dijkstra 的复杂度取决于其具体实现（邻接矩阵为 O(N²)，优先队列为 O(E log V)，在此图中 E 可能达到 O(N²))。</li>
<li>BFS 的复杂度中，<code>C*L</code> 代表从一个节点可以扩展出的邻居数量，N 是节点总数。</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<h4 id="Dijkstra">Dijkstra</h4>
<ul>
<li><strong>时间复杂度</strong>: <code>O(N^2)</code>，其中 <code>N</code> 是图中节点的总数 (<code>len(bank) + 1</code>)。构建邻接矩阵需要 <code>O(N^2 * L)</code> 的时间（L=8），Dijkstra 算法在使用邻接矩阵和线性扫描找最小距离节点时的时间复杂度是 <code>O(N^2)</code>。</li>
<li><strong>空间复杂度</strong>: <code>O(N^2)</code>，主要用于存储邻接矩阵。</li>
</ul>
<h4 id="BFS">BFS</h4>
<ul>
<li><strong>时间复杂度</strong>: <code>O(C * L * N)</code>。<code>N</code> 是 <code>bank</code> 的长度，<code>L</code> 是基因序列长度 (8)，<code>C</code> 是字符集大小 (4)。对于队列中的每个元素，我们都需要遍历其所有可能的 <code>C*L</code> 种变化，并检查其是否在 <code>bank</code> 中。由于 <code>bank</code> 的大小 <code>N</code> 很小，这种方法非常高效。</li>
<li><strong>空间复杂度</strong>: <code>O(L * N)</code>，用于存储 <code>bankSet</code>、<code>visited</code> 集合和队列。</li>
</ul>
<h3 id="关键收获">关键收获</h3>
<ul>
<li><strong>问题建模</strong>: 识别出 “最少次数”、“最短转换” 这类问题可以建模为图的最短路径问题是解决关键。</li>
<li><strong>算法选择</strong>: 在无权图（所有边的权重都为 1 或相同）中，BFS 是求解最短路径的首选算法。它的实现简单且时间复杂度优于通用的 Dijkstra 算法。</li>
<li><strong>隐式图 vs 显式图</strong>: Dijkstra 的解法是先 <strong>显式</strong> 地把图的完整结构（邻接矩阵）构建出来，然后再运行算法。而 BFS 的解法是在搜索过程中 <strong>隐式</strong> 地探索图的节点和边，无需预先构建整个图，从而节省了空间和预处理时间。对于节点连接规则明确但图可能很大的情况，隐式图搜索是更优的选择。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>广度优先搜索</tag>
        <tag>Medium</tag>
        <tag>图</tag>
        <tag>BFS</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 909 - 蛇梯棋（Snakes and Ladders）❌错题集</title>
    <url>/2025/06/23/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code>，其中 <code>n</code> 和 <code>board[i][j]</code> 都在范围 <code>[1, n]</code> 内。</p>
<p>蛇梯棋的棋盘上标有从 <code>1</code> 到 <code>n²</code> 的数字，按从左到右，从下到上的 <strong>蛇形</strong> 方式编号。</p>
<p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p>
<p>每一回合，玩家都要从当前方格开始出发，按以下规则前进：</p>
<ul>
<li>选择目标方格来决定下一步的移动，目标方格的编号是 <code>[curr + 1, curr + 6]</code> 的范围内任意整数 <code>curr</code> 是玩家当前所在的方格编号。</li>
<li>该选择模拟了掷 <strong>六面骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li>
<li>如果目标方格有蛇或梯子，玩家必须按蛇梯的指示前进。蛇梯的目的地不会有蛇或梯子。</li>
<li>注意，玩家在每回合的移动过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也不能继续移动。</li>
</ul>
<p>返回达到编号为 <code>n²</code> 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">首先，从方格 1 [第 5 行，第 0 列] 开始。 </span><br><span class="line">决定移动到方格 2，并必须爬过梯子移动到方格 15。</span><br><span class="line">然后决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。</span><br><span class="line">接下来决定移动到方格 14，且必须爬过梯子移动到方格 35。 </span><br><span class="line">最后决定移动到方格 36 [第 0 行，第 5 列]，游戏结束。 </span><br><span class="line">可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4。</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/23/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-909-%E8%9B%87%E6%A2%AF%E6%A3%8B-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/1750689003149.png" alt="1750689003149"></p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[-1,-1],[-1,3]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h2 id="❌-错误分析过程">❌ 错误分析过程</h2>
<h3 id="遇到的主要问题">遇到的主要问题</h3>
<h4 id="1-内存限制超出-Memory-Limit-Exceeded">1. <strong>内存限制超出 (Memory Limit Exceeded)</strong></h4>
<p><strong>错误现象</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Memory Limit Exceeded</span><br><span class="line">5/217 cases passed (N/A)</span><br><span class="line">Testcase: [[-1,4,-1],[6,2,6],[-1,3,-1]]</span><br><span class="line">Expected Answer: 2</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>: 这个错误是由于存在<strong>循环蛇梯</strong>导致的无限递归调用。在测试案例中：</p>
<ul>
<li>位置 2 指向位置 6</li>
<li>位置 6 指向位置 2</li>
</ul>
<p>形成了循环，<code>numToNode</code> 函数会无限递归调用自己，导致栈溢出。</p>
<h4 id="2-坐标转换逻辑复杂">2. <strong>坐标转换逻辑复杂</strong></h4>
<p>蛇梯棋的编号规则相当复杂：</p>
<ul>
<li>从棋盘底部开始编号（1 在最后一行第一列）</li>
<li>奇数行从左到右，偶数行从右到左</li>
<li>需要正确处理数组索引到棋盘编号的转换</li>
</ul>
<p><strong>多次尝试的坐标转换方案</strong>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方案1: 最初的错误实现</span></span><br><span class="line"><span class="keyword">if</span> row%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    col = n - <span class="number">1</span> - col</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2: 修正后的实现</span></span><br><span class="line"><span class="keyword">if</span> (n<span class="number">-1</span>-row)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">    col = n - <span class="number">1</span> - col</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案3: 最终尝试的实现</span></span><br><span class="line">row := (num - <span class="number">1</span>) / n</span><br><span class="line"><span class="keyword">if</span> row%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">    col = n - <span class="number">1</span> - col</span><br><span class="line">&#125;</span><br><span class="line">row = n - <span class="number">1</span> - row</span><br></pre></td></tr></table></figure>
<h4 id="3-BFS-访问控制问题">3. <strong>BFS 访问控制问题</strong></h4>
<p><strong>问题</strong>: 没有正确处理已访问节点的标记，导致：</p>
<ul>
<li>重复访问同一个位置</li>
<li>算法效率低下</li>
<li>可能的无限循环</li>
</ul>
<h4 id="4-递归vs迭代的选择">4. <strong>递归vs迭代的选择</strong></h4>
<p>最初使用递归的 <code>numToNode</code> 函数来处理蛇梯跳转，但遇到循环蛇梯时会导致栈溢出。</p>
<h2 id="解题思路分析">解题思路分析</h2>
<h3 id="核心算法-BFS-广度优先搜索">核心算法: BFS (广度优先搜索)</h3>
<p>这是一个典型的<strong>最短路径</strong>问题，应该使用 BFS 来解决：</p>
<ol>
<li><strong>状态表示</strong>: 每个状态包含当前位置编号和步数</li>
<li><strong>状态转移</strong>: 从当前位置可以移动到 <code>[curr+1, curr+6]</code> 范围内的任意位置</li>
<li><strong>蛇梯处理</strong>: 如果到达的位置有蛇或梯子，需要跳转到指定位置</li>
<li><strong>终止条件</strong>: 到达编号为 <code>n²</code> 的位置</li>
</ol>
<h3 id="关键难点">关键难点</h3>
<h4 id="1-坐标转换">1. <strong>坐标转换</strong></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">棋盘编号示例 (4x4):</span><br><span class="line">13  14  15  16</span><br><span class="line">12  11  10   9</span><br><span class="line"> 5   6   7   8</span><br><span class="line"> 4   3   2   1</span><br><span class="line"></span><br><span class="line">对应数组索引:</span><br><span class="line">[0,0] [0,1] [0,2] [0,3]</span><br><span class="line">[1,0] [1,1] [1,2] [1,3]</span><br><span class="line">[2,0] [2,1] [2,2] [2,3]</span><br><span class="line">[3,0] [3,1] [3,2] [3,3]</span><br></pre></td></tr></table></figure>
<h4 id="2-蛇梯处理">2. <strong>蛇梯处理</strong></h4>
<ul>
<li>需要在到达新位置后立即检查是否有蛇或梯子</li>
<li>避免无限递归调用</li>
<li>正确处理循环蛇梯的情况</li>
</ul>
<h4 id="3-访问控制">3. <strong>访问控制</strong></h4>
<ul>
<li>使用 <code>visited</code> 数组避免重复访问</li>
<li>注意数组索引范围（编号1到n²）</li>
</ul>
<h2 id="错误代码实现历程">错误代码实现历程</h2>
<h3 id="第一版：最初的错误实现">第一版：最初的错误实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">	X    <span class="type">int</span></span><br><span class="line">	Y    <span class="type">int</span></span><br><span class="line">	step <span class="type">int</span></span><br><span class="line">	Num  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">snakesAndLadders</span><span class="params">(board [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	n := <span class="built_in">len</span>(board)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> numToNode <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> Location</span><br><span class="line"></span><br><span class="line">	numToNode = <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> Location &#123;</span><br><span class="line"></span><br><span class="line">		row := n - <span class="number">1</span> - (num<span class="number">-1</span>)/n</span><br><span class="line">		col := (num - <span class="number">1</span>) % n</span><br><span class="line">		<span class="keyword">if</span> row%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; n%<span class="number">2</span> == <span class="number">0</span> &#123;  <span class="comment">// ❌ 错误的坐标转换逻辑</span></span><br><span class="line">			col = n - <span class="number">1</span> - col</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> board[row][col] &gt;= <span class="number">0</span> &#123;  <span class="comment">// ❌ 应该是 != -1</span></span><br><span class="line">			<span class="keyword">return</span> numToNode(board[row][col])  <span class="comment">// ❌ 递归调用，会导致循环蛇梯时栈溢出</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Location&#123;X: row, Y: col, step: <span class="number">0</span>, Num: num&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	start := numToNode(<span class="number">1</span>)</span><br><span class="line">	fmt.Println(start)  <span class="comment">// 调试输出</span></span><br><span class="line">	end := numToNode(n * n)</span><br><span class="line"></span><br><span class="line">	cnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	queue := []Location&#123;start&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &amp;&amp; cnt &lt;= n*n &#123;</span><br><span class="line">		top := queue[<span class="number">0</span>]</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line">		cnt++</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> top.X == end.X &amp;&amp; top.Y == end.Y &#123;  <span class="comment">// ❌ 用坐标比较而不是编号</span></span><br><span class="line">			<span class="keyword">return</span> top.step</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> board[top.X][top.Y] == <span class="number">-2</span> &#123;  <span class="comment">// ❌ 用修改原数组的方式标记访问</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		board[top.X][top.Y] = <span class="number">-2</span>  <span class="comment">// ❌ 破坏原数组</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> top.Num+i &lt;= n*n &#123;</span><br><span class="line">				next := numToNode(top.Num + i)  <span class="comment">// ❌ 递归调用</span></span><br><span class="line">				next.step = top.step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">				queue = <span class="built_in">append</span>(queue, next)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong>:</p>
<ol>
<li>坐标转换条件 <code>row%2 == 0 &amp;&amp; n%2 == 0</code> 完全错误</li>
<li>使用递归的 <code>numToNode</code> 函数处理蛇梯跳转，遇到循环时会栈溢出</li>
<li>用修改原数组的方式标记访问，不够优雅且容易出错</li>
<li>终止条件用坐标比较，不如直接用编号比较</li>
</ol>
<h3 id="第二版：尝试修复坐标转换和访问控制">第二版：尝试修复坐标转换和访问控制</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">snakesAndLadders</span><span class="params">(board [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	n := <span class="built_in">len</span>(board)</span><br><span class="line">	visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n*n+<span class="number">1</span>) <span class="comment">// ✅ 使用visited数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> numToNode <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> Location</span><br><span class="line"></span><br><span class="line">	numToNode = <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> Location &#123;</span><br><span class="line"></span><br><span class="line">		row := n - <span class="number">1</span> - (num<span class="number">-1</span>)/n</span><br><span class="line">		col := (num - <span class="number">1</span>) % n</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ✅ 修正行翻转逻辑：从底部数起的偶数行需要翻转</span></span><br><span class="line">		<span class="keyword">if</span> (n<span class="number">-1</span>-row)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">			col = n - <span class="number">1</span> - col</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> board[row][col] != <span class="number">-1</span> &#123;  <span class="comment">// ✅ 修正条件</span></span><br><span class="line">			<span class="keyword">return</span> numToNode(board[row][col])  <span class="comment">// ❌ 仍然是递归调用</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Location&#123;X: row, Y: col, step: <span class="number">0</span>, Num: num&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	start := numToNode(<span class="number">1</span>)</span><br><span class="line">	start.step = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	queue := []Location&#123;start&#125;</span><br><span class="line">	visited[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">		top := queue[<span class="number">0</span>]</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ✅ 检查是否到达目标</span></span><br><span class="line">		<span class="keyword">if</span> top.Num == n*n &#123;</span><br><span class="line">			<span class="keyword">return</span> top.step</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++ &#123;</span><br><span class="line">			nextNum := top.Num + i</span><br><span class="line">			<span class="keyword">if</span> nextNum &lt;= n*n &amp;&amp; !visited[nextNum] &#123;</span><br><span class="line">				next := numToNode(nextNum)  <span class="comment">// ❌ 仍然递归</span></span><br><span class="line">				next.step = top.step + <span class="number">1</span></span><br><span class="line">				visited[nextNum] = <span class="literal">true</span></span><br><span class="line">				queue = <span class="built_in">append</span>(queue, next)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong>:</p>
<ul>
<li>✅ 修正了坐标转换逻辑</li>
<li>✅ 使用了proper的visited数组</li>
<li>✅ 修正了终止条件</li>
<li>❌ 仍然使用递归处理蛇梯，循环蛇梯时会导致栈溢出</li>
</ul>
<h3 id="第三版：最终尝试的实现">第三版：最终尝试的实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">snakesAndLadders</span><span class="params">(board [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(board)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> numToNode <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> Location</span><br><span class="line">    </span><br><span class="line">    numToNode = <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> Location &#123;</span><br><span class="line">        row := (num - <span class="number">1</span>) / n  <span class="comment">// ❌ 修改了计算方式，但可能不正确</span></span><br><span class="line">        col := (num - <span class="number">1</span>) % n</span><br><span class="line">        <span class="keyword">if</span> row%<span class="number">2</span> == <span class="number">1</span> &#123;  <span class="comment">// ❌ 翻转逻辑又变了</span></span><br><span class="line">            col = n - <span class="number">1</span> - col</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        row = n - <span class="number">1</span> - row  <span class="comment">// ❌ 后置转换</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Location&#123;X: row, Y: col, step: <span class="number">0</span>, Num: num&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    start := numToNode(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n*n)  <span class="comment">// ❌ 长度应该是 n*n+1</span></span><br><span class="line">    </span><br><span class="line">    queue := []Location&#123;start&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) != <span class="number">0</span> &#123;</span><br><span class="line">        top := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++ &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> top.Num+i &gt; n*n &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            next := numToNode(top.Num + i)</span><br><span class="line">            <span class="keyword">if</span> board[next.X][next.Y] &gt; <span class="number">0</span> &#123;  <span class="comment">// ❌ 应该是 != -1</span></span><br><span class="line">                next = numToNode(board[next.X][next.Y])  <span class="comment">// ❌ 仍然递归</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> next.Num == n*n &#123;</span><br><span class="line">                <span class="keyword">return</span> top.step + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> visited[next.Num] &#123;  <span class="comment">// ❌ next.Num 可能是n*n，会越界</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            visited[next.Num] = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            next.step = top.step + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            queue = <span class="built_in">append</span>(queue, next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong>:</p>
<ol>
<li><strong>visited数组越界</strong>: <code>visited := make([]bool, n*n)</code> 长度为n<em>n，但编号范围是[1,n</em>n]，访问 <code>visited[n*n]</code> 会越界</li>
<li><strong>递归问题未解决</strong>: 仍然使用递归处理蛇梯跳转</li>
<li><strong>坐标转换逻辑</strong>: 多次修改，但仍不确定正确性</li>
</ol>
<h2 id="正确解题思路分析">正确解题思路分析</h2>
<h3 id="1-坐标转换的正确逻辑">1. <strong>坐标转换的正确逻辑</strong></h3>
<p>蛇梯棋的编号规则需要仔细理解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6x6棋盘编号示例：</span><br><span class="line">31  32  33  34  35  36</span><br><span class="line">30  29  28  27  26  25  </span><br><span class="line">19  20  21  22  23  24</span><br><span class="line">18  17  16  15  14  13</span><br><span class="line"> 7   8   9  10  11  12</span><br><span class="line"> 6   5   4   3   2   1</span><br><span class="line"></span><br><span class="line">对应数组索引：</span><br><span class="line">[0,0][0,1][0,2][0,3][0,4][0,5]</span><br><span class="line">[1,0][1,1][1,2][1,3][1,4][1,5]</span><br><span class="line">[2,0][2,1][2,2][2,3][2,4][2,5]</span><br><span class="line">[3,0][3,1][3,2][3,3][3,4][3,5]</span><br><span class="line">[4,0][4,1][4,2][4,3][4,4][4,5]</span><br><span class="line">[5,0][5,1][5,2][5,3][5,4][5,5]</span><br></pre></td></tr></table></figure>
<p><strong>正确的坐标转换公式</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numToPos</span><span class="params">(num, n <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 从底部数的行号（从0开始）</span></span><br><span class="line">    bottomRow := (num - <span class="number">1</span>) / n</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为数组行索引</span></span><br><span class="line">    row := n - <span class="number">1</span> - bottomRow</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 列索引</span></span><br><span class="line">    col := (num - <span class="number">1</span>) % n</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 偶数行（从底部数，索引1,3,5...）需要翻转</span></span><br><span class="line">    <span class="keyword">if</span> bottomRow%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        col = n - <span class="number">1</span> - col</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> row, col</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键理解</strong>：</p>
<ul>
<li><code>bottomRow = (num-1) / n</code> 计算从底部数的行号</li>
<li>从底部数的奇数行（bottomRow=0,2,4…）：从左到右</li>
<li>从底部数的偶数行（bottomRow=1,3,5…）：从右到左</li>
</ul>
<h3 id="2-避免递归的蛇梯处理">2. <strong>避免递归的蛇梯处理</strong></h3>
<p><strong>错误方式</strong>（会导致栈溢出）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numToNode</span><span class="params">(num <span class="type">int</span>)</span></span> Location &#123;</span><br><span class="line">    row, col := numToPos(num, n)</span><br><span class="line">    <span class="keyword">if</span> board[row][col] != <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numToNode(board[row][col])  <span class="comment">// ❌ 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Location&#123;X: row, Y: col, Num: num&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正确方式</strong>（在BFS中直接处理）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在BFS循环中</span></span><br><span class="line">nextNum := curr.Num + i</span><br><span class="line">row, col := numToPos(nextNum, n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理蛇梯跳转</span></span><br><span class="line"><span class="keyword">if</span> board[row][col] != <span class="number">-1</span> &#123;</span><br><span class="line">    nextNum = board[row][col]  <span class="comment">// 直接更新编号，不递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否已访问最终位置</span></span><br><span class="line"><span class="keyword">if</span> !visited[nextNum] &#123;</span><br><span class="line">    visited[nextNum] = <span class="literal">true</span></span><br><span class="line">    newRow, newCol := numToPos(nextNum, n)</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, Location&#123;X: newRow, Y: newCol, Num: nextNum, step: curr.step + <span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-完整的正确实现">3. <strong>完整的正确实现</strong></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</span><br><span class="line">    X    <span class="type">int</span></span><br><span class="line">    Y    <span class="type">int</span></span><br><span class="line">    step <span class="type">int</span></span><br><span class="line">    Num  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">snakesAndLadders</span><span class="params">(board [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(board)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编号到坐标的转换函数</span></span><br><span class="line">    numToPos := <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        bottomRow := (num - <span class="number">1</span>) / n</span><br><span class="line">        row := n - <span class="number">1</span> - bottomRow</span><br><span class="line">        col := (num - <span class="number">1</span>) % n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> bottomRow%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            col = n - <span class="number">1</span> - col</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> row, col</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// visited数组，注意长度是n*n+1，因为编号从1开始</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n*n+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BFS队列，从编号1开始</span></span><br><span class="line">    queue := []Location&#123;&#123;Num: <span class="number">1</span>, step: <span class="number">0</span>&#125;&#125;</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        curr := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否到达终点</span></span><br><span class="line">        <span class="keyword">if</span> curr.Num == n*n &#123;</span><br><span class="line">            <span class="keyword">return</span> curr.step</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模拟掷骰子：1到6点</span></span><br><span class="line">        <span class="keyword">for</span> dice := <span class="number">1</span>; dice &lt;= <span class="number">6</span>; dice++ &#123;</span><br><span class="line">            nextNum := curr.Num + dice</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 超出边界则跳过</span></span><br><span class="line">            <span class="keyword">if</span> nextNum &gt; n*n &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取目标位置坐标</span></span><br><span class="line">            row, col := numToPos(nextNum)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理蛇梯：如果不是-1，则跳转到指定位置</span></span><br><span class="line">            <span class="keyword">if</span> board[row][col] != <span class="number">-1</span> &#123;</span><br><span class="line">                nextNum = board[row][col]</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查最终位置是否已访问</span></span><br><span class="line">            <span class="keyword">if</span> !visited[nextNum] &#123;</span><br><span class="line">                visited[nextNum] = <span class="literal">true</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取最终位置的坐标（用于完整性，实际可能不需要）</span></span><br><span class="line">                finalRow, finalCol := numToPos(nextNum)</span><br><span class="line">                </span><br><span class="line">                queue = <span class="built_in">append</span>(queue, Location&#123;</span><br><span class="line">                    X:    finalRow,</span><br><span class="line">                    Y:    finalCol,</span><br><span class="line">                    Num:  nextNum,</span><br><span class="line">                    step: curr.step + <span class="number">1</span>,</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">// 无法到达终点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-关键技术要点">4. <strong>关键技术要点</strong></h3>
<h4 id="A-坐标转换的数学原理">A. <strong>坐标转换的数学原理</strong></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于编号num（从1开始）：</span></span><br><span class="line">bottomRow := (num - <span class="number">1</span>) / n     <span class="comment">// 从底部数的行号（从0开始）</span></span><br><span class="line">col := (num - <span class="number">1</span>) % n           <span class="comment">// 在该行中的位置（从0开始）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 蛇形路径的处理：</span></span><br><span class="line"><span class="keyword">if</span> bottomRow%<span class="number">2</span> == <span class="number">1</span> &#123;          <span class="comment">// 偶数行（从底部数1,3,5...行）</span></span><br><span class="line">    col = n - <span class="number">1</span> - col          <span class="comment">// 从右到左，需要翻转列索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">row := n - <span class="number">1</span> - bottomRow       <span class="comment">// 转换为数组行索引</span></span><br></pre></td></tr></table></figure>
<h4 id="B-循环蛇梯的处理">B. <strong>循环蛇梯的处理</strong></h4>
<ul>
<li><strong>关键思想</strong>: 在BFS中直接处理跳转，不使用递归</li>
<li><strong>访问标记</strong>: 对最终到达的位置进行标记，避免重复访问</li>
<li><strong>一次跳转</strong>: 题目保证蛇梯的目的地不会再有蛇梯</li>
</ul>
<h4 id="C-BFS的优化要点">C. <strong>BFS的优化要点</strong></h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. visited数组大小正确</span></span><br><span class="line">visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n*n+<span class="number">1</span>)  <span class="comment">// 编号范围[1, n*n]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 边界检查</span></span><br><span class="line"><span class="keyword">if</span> nextNum &gt; n*n &#123;</span><br><span class="line">    <span class="keyword">break</span>  <span class="comment">// 超出棋盘范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 终止条件</span></span><br><span class="line"><span class="keyword">if</span> curr.Num == n*n &#123;  <span class="comment">// 直接比较编号，不需要坐标</span></span><br><span class="line">    <span class="keyword">return</span> curr.step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-复杂度分析">5. <strong>复杂度分析</strong></h3>
<ul>
<li>
<p><strong>时间复杂度</strong>: O(n²)</p>
<ul>
<li>每个位置最多访问一次</li>
<li>总共n²个位置</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>: O(n²)</p>
<ul>
<li>visited数组: O(n²)</li>
<li>BFS队列: 最坏情况O(n²)</li>
</ul>
</li>
</ul>
<h2 id="仍存在的问题">仍存在的问题</h2>
<h3 id="1-visited数组索引越界">1. <strong>visited数组索引越界</strong></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n*n)  <span class="comment">// 长度为 n*n，索引范围 [0, n*n-1]</span></span><br><span class="line"><span class="comment">// 但是编号范围是 [1, n*n]，访问 visited[n*n] 会越界</span></span><br></pre></td></tr></table></figure>
<h3 id="2-递归问题未解决">2. <strong>递归问题未解决</strong></h3>
<p>仍然使用 <code>numToNode</code> 递归函数，遇到循环蛇梯时依然会有问题。</p>
<h3 id="3-坐标转换的正确性">3. <strong>坐标转换的正确性</strong></h3>
<p>多次修改坐标转换逻辑，但仍不确定是否完全正确。</p>
<h2 id="关键收获与反思">关键收获与反思</h2>
<h3 id="算法层面">算法层面</h3>
<ol>
<li><strong>BFS是正确的选择</strong>: 求最短路径问题应该使用BFS</li>
<li><strong>状态设计要清晰</strong>: 明确每个状态包含的信息</li>
<li><strong>边界条件要仔细</strong>: 数组索引、编号范围等细节很重要</li>
</ol>
<h3 id="实现层面">实现层面</h3>
<ol>
<li><strong>坐标转换是核心难点</strong>: 蛇梯棋的编号规则比较复杂</li>
<li><strong>递归vs迭代要权衡</strong>: 对于可能有循环的场景，迭代更安全</li>
<li><strong>访问控制必不可少</strong>: 避免重复访问和无限循环</li>
</ol>
<h3 id="调试技巧">调试技巧</h3>
<ol>
<li><strong>小数据测试</strong>: 用简单的测试案例验证坐标转换逻辑</li>
<li><strong>边界条件检查</strong>: 特别关注数组越界问题</li>
<li><strong>循环检测</strong>: 对于图相关问题要考虑循环的处理</li>
</ol>
<h2 id="错误根因总结">错误根因总结</h2>
<p>通过深入分析，这道题的错误主要集中在以下几个方面：</p>
<h3 id="1-坐标转换理解不够深入">1. <strong>坐标转换理解不够深入</strong></h3>
<ul>
<li><strong>错误</strong>: 多次尝试不同的转换公式，但都没有正确理解蛇形编号的数学规律</li>
<li><strong>正确</strong>: 需要清楚理解 <code>bottomRow = (num-1)/n</code> 和翻转条件 <code>bottomRow%2 == 1</code></li>
</ul>
<h3 id="2-递归vs迭代的选择失误">2. <strong>递归vs迭代的选择失误</strong></h3>
<ul>
<li><strong>错误</strong>: 使用递归处理蛇梯跳转，遇到循环时导致栈溢出</li>
<li><strong>正确</strong>: 在BFS主循环中直接处理跳转，避免函数调用栈问题</li>
</ul>
<h3 id="3-边界条件处理不当">3. <strong>边界条件处理不当</strong></h3>
<ul>
<li><strong>错误</strong>: visited数组长度为n<em>n，但编号范围是[1,n</em>n]，导致越界</li>
<li><strong>正确</strong>: visited数组长度应为n<em>n+1，或者将编号映射到[0,n</em>n-1]范围</li>
</ul>
<h3 id="4-访问控制时机错误">4. <strong>访问控制时机错误</strong></h3>
<ul>
<li><strong>错误</strong>: 在出队时才标记访问，或者标记时机不当</li>
<li><strong>正确</strong>: 在入队时立即标记最终位置为已访问</li>
</ul>
<h2 id="算法学习收获">算法学习收获</h2>
<h3 id="技术层面">技术层面</h3>
<ol>
<li>
<p><strong>坐标转换公式推导</strong>:</p>
<ul>
<li>理解二维编号到一维数组的映射关系</li>
<li>掌握蛇形路径的数学规律</li>
</ul>
</li>
<li>
<p><strong>BFS实现技巧</strong>:</p>
<ul>
<li>合理的visited数组设计</li>
<li>正确的访问标记时机</li>
<li>边界条件的全面检查</li>
</ul>
</li>
<li>
<p><strong>避免递归陷阱</strong>:</p>
<ul>
<li>识别可能存在循环的场景</li>
<li>选择迭代而非递归的处理方式</li>
</ul>
</li>
</ol>
<h3 id="思维层面">思维层面</h3>
<ol>
<li><strong>问题分解能力</strong>: 将复杂问题拆分为坐标转换、蛇梯处理、BFS遍历等子问题</li>
<li><strong>边界意识</strong>: 时刻关注数组索引范围、编号范围等边界条件</li>
<li><strong>调试思维</strong>: 通过具体例子验证算法逻辑的正确性</li>
</ol>
<h3 id="代码质量">代码质量</h3>
<ol>
<li><strong>函数设计</strong>: 将坐标转换抽象为独立函数，提高代码可读性</li>
<li><strong>变量命名</strong>: 使用有意义的变量名（如bottomRow）帮助理解</li>
<li><strong>注释习惯</strong>: 在关键逻辑处添加说明，特别是数学公式部分</li>
</ol>
<h2 id="总结">总结</h2>
<p>LeetCode 909 蛇梯棋是一道综合性很强的题目，涉及：</p>
<ul>
<li><strong>图论</strong>: BFS最短路径</li>
<li><strong>数学</strong>: 坐标转换公式推导</li>
<li><strong>编程技巧</strong>: 避免递归、正确的访问控制</li>
</ul>
<p><strong>核心教训</strong>:</p>
<ol>
<li><strong>理论先行</strong>: 在编码前要完全理解问题的数学模型</li>
<li><strong>细节关键</strong>: 边界条件、数组索引等细节往往决定成败</li>
<li><strong>迭代优于递归</strong>: 对于可能有循环的图问题，优先考虑迭代解法</li>
<li><strong>测试验证</strong>: 用简单例子验证关键逻辑（如坐标转换）的正确性</li>
</ol>
<p><strong>标记为错题的价值</strong>: 通过完整记录错误过程和正确思路，为今后遇到类似的坐标转换、BFS遍历问题提供了宝贵的参考经验。这种深度分析比简单的AC更有学习价值。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
        <category>错题集</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>BFS</tag>
        <tag>图论</tag>
        <tag>坐标转换</tag>
        <tag>错题分析</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 399 - 除法求值：从图论到Floyd算法的优雅转换</title>
    <url>/2025/06/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h2 id="引言：一个看似简单的数学问题">引言：一个看似简单的数学问题</h2>
<p>当我第一次看到LeetCode 399这道题时，心想：&quot;不就是计算一些除法吗？&quot;但仔细一看，发现事情远没有那么简单。</p>
<p>题目给出了一些变量之间的除法关系，比如 <code>a/b = 2.0, b/c = 3.0</code>，然后要求我们计算其他变量对的除法结果，如 <code>a/c = ?</code>。如果变量不存在或者无法通过已知关系推导出结果，就返回 <code>-1.0</code>。</p>
<p>这个问题的有趣之处在于，它表面上是数学计算，实际上是一个<strong>关系传递</strong>的问题。就像现实生活中的汇率换算：如果你知道 <code>1美元 = 7人民币</code> 和 <code>1人民币 = 0.14欧元</code>，那么你自然能推算出 <code>1美元 = 0.98欧元</code>。</p>
<h2 id="第一直觉：这不就是图论问题吗？">第一直觉：这不就是图论问题吗？</h2>
<p>面对这样的关系传递问题，我的第一直觉是：<strong>这可以用图来建模</strong>！</p>
<h3 id="思路的形成过程">思路的形成过程</h3>
<p>让我们一步步分析：</p>
<ol>
<li><strong>变量可以看作节点</strong>：每个变量（如 <code>a</code>, <code>b</code>, <code>c</code>）都是图中的一个节点</li>
<li><strong>除法关系可以看作边</strong>：如果 <code>a/b = 2.0</code>，那么可以建立一条从 <code>a</code> 到 <code>b</code> 的有向边，权重为 <code>2.0</code></li>
<li><strong>查询就是路径搜索</strong>：要计算 <code>a/c</code>，就是要找从节点 <code>a</code> 到节点 <code>c</code> 的路径</li>
</ol>
<p>但这里有个关键问题：<strong>路径上的权重如何计算？</strong></p>
<p>在传统的图论问题中，我们通常计算路径长度（权重相加）。但在除法问题中，关系是<strong>乘性的</strong>：</p>
<ul>
<li>如果 <code>a/b = 2.0</code> 且 <code>b/c = 3.0</code></li>
<li>那么 <code>a/c = (a/b) × (b/c) = 2.0 × 3.0 = 6.0</code></li>
</ul>
<p>这个洞察很重要：<strong>路径权重需要相乘，而不是相加</strong>！</p>
<h3 id="图的构建策略">图的构建策略</h3>
<p>明确了基本思路后，我们需要考虑如何构建图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定：a/b = 2.0, b/c = 3.0</span><br><span class="line"></span><br><span class="line">构建的图：</span><br><span class="line">   a ----2.0---→ b ----3.0---→ c</span><br><span class="line">   ↑             ↑             ↑</span><br><span class="line">   |             |             |</span><br><span class="line"> 0.5            0.33          0.33</span><br><span class="line">   |             |             |</span><br><span class="line">   ↓             ↓             ↓</span><br><span class="line">   a ←---0.5---- b ←---0.33--- c</span><br></pre></td></tr></table></figure>
<p>注意几个要点：</p>
<ol>
<li><strong>双向边</strong>：如果 <code>a/b = 2.0</code>，那么 <code>b/a = 0.5</code></li>
<li><strong>自环</strong>：每个变量除以自己等于 <code>1.0</code></li>
<li><strong>权重传递</strong>：通过中间节点可以计算间接关系</li>
</ol>
<h2 id="解法一：DFS图搜索-直观而有效">解法一：DFS图搜索 - 直观而有效</h2>
<p>基于图论的思路，最直观的解法就是深度优先搜索：</p>
<h3 id="核心算法设计">核心算法设计</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcEquation</span><span class="params">(equations [][]<span class="type">string</span>, values []<span class="type">float64</span>, queries [][]<span class="type">string</span>)</span></span> []<span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 构建图的邻接表</span></span><br><span class="line">    graph := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化图 - 添加双向边和自环</span></span><br><span class="line">    <span class="keyword">for</span> i, equation := <span class="keyword">range</span> equations &#123;</span><br><span class="line">        a, b := equation[<span class="number">0</span>], equation[<span class="number">1</span>]</span><br><span class="line">        value := values[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> graph[a] == <span class="literal">nil</span> &#123;</span><br><span class="line">            graph[a] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> graph[b] == <span class="literal">nil</span> &#123;</span><br><span class="line">            graph[b] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float64</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关键：双向边的建立</span></span><br><span class="line">        graph[a][b] = value      <span class="comment">// a/b = value</span></span><br><span class="line">        graph[b][a] = <span class="number">1.0</span> / value <span class="comment">// b/a = 1/value</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自环处理</span></span><br><span class="line">        graph[a][a] = <span class="number">1.0</span></span><br><span class="line">        graph[b][b] = <span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. DFS搜索函数 - 寻找路径并计算乘积</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(start, end <span class="type">string</span>, visited <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span></span> <span class="type">float64</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, end <span class="type">string</span>, visited <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> graph[start] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接可达</span></span><br><span class="line">        <span class="keyword">if</span> val, exists := graph[start][end]; exists &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记访问，避免环路</span></span><br><span class="line">        visited[start] = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归搜索所有邻居</span></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight := <span class="keyword">range</span> graph[start] &#123;</span><br><span class="line">            <span class="keyword">if</span> !visited[neighbor] &#123;</span><br><span class="line">                result := dfs(neighbor, end, visited)</span><br><span class="line">                <span class="keyword">if</span> result != <span class="number">-1.0</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> weight * result  <span class="comment">// 关键：权重相乘</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        visited[start] = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 处理所有查询</span></span><br><span class="line">    results := <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">for</span> i, query := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        start, end := query[<span class="number">0</span>], query[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> graph[start] == <span class="literal">nil</span> || graph[end] == <span class="literal">nil</span> &#123;</span><br><span class="line">            results[i] = <span class="number">-1.0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> start == end &#123;</span><br><span class="line">            results[i] = <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">        results[i] = dfs(start, end, visited)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法执行过程分析">算法执行过程分析</h3>
<p>让我们通过一个具体例子来看DFS的执行过程：</p>
<p><strong>输入</strong>：<code>equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0]</code><br>
<strong>查询</strong>：<code>a/c</code></p>
<ol>
<li>
<p><strong>图构建阶段</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph[&quot;a&quot;][&quot;b&quot;] = 2.0, graph[&quot;b&quot;][&quot;a&quot;] = 0.5</span><br><span class="line">graph[&quot;b&quot;][&quot;c&quot;] = 3.0, graph[&quot;c&quot;][&quot;b&quot;] = 0.33</span><br><span class="line">graph[&quot;a&quot;][&quot;a&quot;] = 1.0, graph[&quot;b&quot;][&quot;b&quot;] = 1.0, graph[&quot;c&quot;][&quot;c&quot;] = 1.0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>DFS搜索过程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dfs(&quot;a&quot;, &quot;c&quot;, &#123;&#125;)</span><br><span class="line">→ 检查直接边：不存在 a→c</span><br><span class="line">→ 标记 a 为已访问</span><br><span class="line">→ 遍历邻居：找到 b，权重 2.0</span><br><span class="line">  → dfs(&quot;b&quot;, &quot;c&quot;, &#123;&quot;a&quot;: true&#125;)</span><br><span class="line">    → 检查直接边：存在 b→c，权重 3.0</span><br><span class="line">    → 返回 3.0</span><br><span class="line">  → 返回 2.0 × 3.0 = 6.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="DFS解法的优缺点">DFS解法的优缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li>思路直观，容易理解</li>
<li>实现相对简单</li>
<li>适合中小规模数据</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>每次查询都需要重新搜索</li>
<li>时间复杂度较高：$O(M \times (N + E))$</li>
<li>大量查询时效率不高</li>
</ul>
<h2 id="解法二：Floyd-Warshall算法的优雅转换">解法二：Floyd-Warshall算法的优雅转换</h2>
<p>就在我对DFS解法基本满意的时候，突然意识到一个问题：如果查询量很大怎么办？每次都DFS搜索显然不够高效。</p>
<p>这时我想到了经典的<strong>Floyd-Warshall算法</strong>。传统的Floyd算法用于计算所有点对之间的最短路径，核心是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是等等！<strong>我们的除法问题中，路径权重是相乘的，不是相加的</strong>。那么，能不能把加法改成乘法呢？</p>
<h3 id="算法改进的关键洞察">算法改进的关键洞察</h3>
<p>答案是肯定的！关键在于理解除法的传递性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 a/k = x 且 k/b = y</span><br><span class="line">那么 a/b = (a/k) × (k/b) = x × y</span><br></pre></td></tr></table></figure>
<p>这正好对应Floyd算法中通过中间点k的路径计算！</p>
<h3 id="Floyd算法的除法版本">Floyd算法的除法版本</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcEquationFloyd</span><span class="params">(equations [][]<span class="type">string</span>, values []<span class="type">float64</span>, queries [][]<span class="type">string</span>)</span></span> []<span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 建立变量到索引的映射</span></span><br><span class="line">    variables := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, equation := <span class="keyword">range</span> equations &#123;</span><br><span class="line">        <span class="keyword">for</span> _, variable := <span class="keyword">range</span> equation &#123;</span><br><span class="line">            <span class="keyword">if</span> _, exists := variables[variable]; !exists &#123;</span><br><span class="line">                variables[variable] = idx</span><br><span class="line">                idx++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n := <span class="built_in">len</span>(variables)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化距离矩阵</span></span><br><span class="line">    dist := <span class="built_in">make</span>([][]<span class="type">float64</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dist &#123;</span><br><span class="line">        dist[i] = <span class="built_in">make</span>([]<span class="type">float64</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> dist[i] &#123;</span><br><span class="line">            <span class="keyword">if</span> i == j &#123;</span><br><span class="line">                dist[i][j] = <span class="number">1.0</span>    <span class="comment">// 自己/自己 = 1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dist[i][j] = <span class="number">-1.0</span>   <span class="comment">// 初始不可达</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 填充已知的除法关系</span></span><br><span class="line">    <span class="keyword">for</span> i, equation := <span class="keyword">range</span> equations &#123;</span><br><span class="line">        a, b := variables[equation[<span class="number">0</span>]], variables[equation[<span class="number">1</span>]]</span><br><span class="line">        value := values[i]</span><br><span class="line">        </span><br><span class="line">        dist[a][b] = value</span><br><span class="line">        dist[b][a] = <span class="number">1.0</span> / value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. Floyd核心算法 - 关键在于乘法！</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">                <span class="comment">// 传统Floyd: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</span></span><br><span class="line">                <span class="comment">// 除法版本: 如果通过k的路径存在，则计算乘积</span></span><br><span class="line">                <span class="keyword">if</span> dist[i][k] != <span class="number">-1.0</span> &amp;&amp; dist[k][j] != <span class="number">-1.0</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> dist[i][j] == <span class="number">-1.0</span> &#123;</span><br><span class="line">                        dist[i][j] = dist[i][k] * dist[k][j]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 处理查询 - O(1)时间复杂度</span></span><br><span class="line">    results := <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="built_in">len</span>(queries))</span><br><span class="line">    <span class="keyword">for</span> i, query := <span class="keyword">range</span> queries &#123;</span><br><span class="line">        start, end := query[<span class="number">0</span>], query[<span class="number">1</span>]</span><br><span class="line">        startIdx, startExists := variables[start]</span><br><span class="line">        endIdx, endExists := variables[end]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> !startExists || !endExists &#123;</span><br><span class="line">            results[i] = <span class="number">-1.0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            results[i] = dist[startIdx][endIdx]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd算法的执行过程">Floyd算法的执行过程</h3>
<p>让我们看看Floyd算法是如何工作的：</p>
<p><strong>初始状态</strong>（以 <code>a/b=2.0, b/c=3.0</code> 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    a    b    c</span><br><span class="line">a [ 1.0  2.0  -1 ]</span><br><span class="line">b [ 0.5  1.0  3.0]</span><br><span class="line">c [ -1   0.33 1.0]</span><br></pre></td></tr></table></figure>
<p><strong>k=0时</strong>（通过a作为中间点）：</p>
<ul>
<li>检查所有i,j对，看是否能通过a连接</li>
<li>发现没有新的连接</li>
</ul>
<p><strong>k=1时</strong>（通过b作为中间点）：</p>
<ul>
<li>检查 <code>dist[a][c]</code>：<code>dist[a][b] * dist[b][c] = 2.0 * 3.0 = 6.0</code></li>
<li>检查 <code>dist[c][a]</code>：<code>dist[c][b] * dist[b][a] = 0.33 * 0.5 = 0.167</code></li>
</ul>
<p><strong>最终状态</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    a    b    c</span><br><span class="line">a [ 1.0  2.0  6.0 ]</span><br><span class="line">b [ 0.5  1.0  3.0 ]</span><br><span class="line">c [0.167 0.33 1.0 ]</span><br></pre></td></tr></table></figure>
<p>现在，任何查询都可以在O(1)时间内完成！</p>
<h3 id="❌-常见错误分析：条件判断的陷阱">❌ 常见错误分析：条件判断的陷阱</h3>
<p>在实现Floyd-Warshall算法时，有一个常见的错误会导致精度问题和错误结果。让我们看看这个错误的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误的Floyd实现</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; cnt; k++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cnt; j++ &#123;</span><br><span class="line">            <span class="comment">// 问题出现在这里！</span></span><br><span class="line">            <span class="keyword">if</span> matrix[i][k] != <span class="number">0</span> &amp;&amp; matrix[k][j] != <span class="number">0</span> &amp;&amp; matrix[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">                matrix[i][j] = matrix[i][k] * matrix[k][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误的根本原因：不必要的 <code>matrix[i][j] != 0</code> 条件</strong></p>
<p>这个多余的条件导致算法只在已存在路径的情况下才更新，错过了许多建立新路径的机会。</p>
<p><strong>具体的错误场景</strong></p>
<p>以下测试用例暴露了这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">equations = [[&quot;b&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;d&quot;,&quot;c&quot;],...,[&quot;t&quot;,&quot;u&quot;]]  // 20个连续关系</span><br><span class="line">values = [1e-05,1e-05,1e-05,...,1e-05]  // 20个相同的小数值</span><br><span class="line">queries = [[&quot;a&quot;,&quot;u&quot;]]</span><br><span class="line"></span><br><span class="line">预期输出：[1.0]</span><br><span class="line">实际输出：[0.99994]  // 精度丢失</span><br></pre></td></tr></table></figure>
<p><strong>错误分析</strong>：</p>
<ol>
<li>
<p><strong>路径建立失败</strong>：由于 <code>matrix[i][j] != 0</code> 条件，算法错过了通过中间节点建立新路径的机会</p>
</li>
<li>
<p><strong>精度累积误差</strong>：算法可能在不同中间节点间重复计算，导致浮点运算累积误差</p>
</li>
<li>
<p><strong>理论vs实际</strong>：理论上 <code>a/u</code> 应该等于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1×10^5)^20 × (1×10^-5)^20 = 1.0</span><br></pre></td></tr></table></figure>
<p>但错误的条件判断破坏了这个数学关系</p>
</li>
</ol>
<p><strong>正确的实现方式</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确的Floyd实现</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 关键修改：移除多余的条件</span></span><br><span class="line">            <span class="keyword">if</span> dist[i][k] != <span class="number">-1.0</span> &amp;&amp; dist[k][j] != <span class="number">-1.0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> dist[i][j] == <span class="number">-1.0</span> &#123;  <span class="comment">// 只在没有路径时建立新路径</span></span><br><span class="line">                    dist[i][j] = dist[i][k] * dist[k][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么正确的实现可以工作</strong>：</p>
<ol>
<li><strong>积极路径发现</strong>：只要通过k有路径就尝试建立i到j的连接</li>
<li><strong>避免重复更新</strong>：只在没有直接路径时才建立新路径</li>
<li><strong>数值稳定性</strong>：减少了不必要的重复计算，提高了精度</li>
</ol>
<p><strong>学习要点</strong>：</p>
<ul>
<li>Floyd-Warshall算法的本质是<strong>尝试通过中间节点改进路径</strong></li>
<li>不要随意添加&quot;看似合理&quot;的条件判断</li>
<li>在浮点运算中要格外注意累积误差的影响</li>
<li>算法的正确性不仅在于核心思想，更在于实现细节的准确性</li>
</ul>
<h2 id="两种解法的深度对比">两种解法的深度对比</h2>
<h3 id="复杂度分析">复杂度分析</h3>
<table>
<thead>
<tr>
<th>方面</th>
<th>DFS解法</th>
<th>Floyd解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>预处理时间</td>
<td>$O(N + E)$</td>
<td>$O(N^3)$</td>
</tr>
<tr>
<td>单次查询</td>
<td>$O(N + E)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>总时间复杂度</td>
<td>$O(M \times (N + E))$</td>
<td>$O(N^3 + M)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(N + E)$</td>
<td>$O(N^2)$</td>
</tr>
</tbody>
</table>
<h3 id="适用场景分析">适用场景分析</h3>
<p><strong>DFS解法适合</strong>：</p>
<ul>
<li>变量数量较多，但查询较少的情况</li>
<li>图比较稀疏的情况</li>
<li>内存受限的情况</li>
</ul>
<p><strong>Floyd解法适合</strong>：</p>
<ul>
<li>变量数量不多（N ≤ 100），但查询频繁</li>
<li>需要预计算所有可能结果的情况</li>
<li>代码简洁性要求高的场合</li>
</ul>
<h3 id="代码可读性对比">代码可读性对比</h3>
<p>从代码可读性来说，Floyd算法明显更胜一筹：</p>
<ol>
<li><strong>逻辑清晰</strong>：核心就是三重循环，经典算法模板</li>
<li><strong>易于调试</strong>：可以直接观察距离矩阵的变化</li>
<li><strong>数学美感</strong>：加法→乘法的转换体现了算法的适应性</li>
</ol>
<h2 id="深入思考：算法设计的艺术">深入思考：算法设计的艺术</h2>
<p>这道题给我最大的收获不是具体的解法，而是对<strong>算法适应性</strong>的深入理解。</p>
<h3 id="经典算法的新应用">经典算法的新应用</h3>
<p>Floyd-Warshall算法最初是为了解决最短路径问题，核心操作是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">distance = min(current_distance, path1 + path2)</span><br></pre></td></tr></table></figure>
<p>但在除法求值问题中，我们巧妙地将其转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ratio = path1 × path2  (如果路径存在)</span><br></pre></td></tr></table></figure>
<p>这种转换不是简单的替换，而是对算法本质的深刻理解：</p>
<ul>
<li><strong>Floyd算法的本质</strong>：通过中间节点建立连接</li>
<li><strong>关键适应</strong>：将&quot;距离相加&quot;改为&quot;比率相乘&quot;</li>
<li><strong>数学基础</strong>：除法的传递性</li>
</ul>
<h3 id="问题抽象的重要性">问题抽象的重要性</h3>
<p>这道题还展示了<strong>问题抽象</strong>的重要性：</p>
<ol>
<li><strong>表面问题</strong>：计算除法表达式</li>
<li><strong>抽象后的问题</strong>：在有向加权图中计算路径权重乘积</li>
<li><strong>进一步抽象</strong>：传递闭包的计算问题</li>
</ol>
<p>正确的抽象让我们能够运用已有的算法知识，而不是从零开始设计解法。</p>
<h2 id="实际应用场景">实际应用场景</h2>
<p>除了算法题，这种思路在实际开发中也很有用：</p>
<h3 id="货币汇率转换">货币汇率转换</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果知道 USD/CNY = 7.0, CNY/EUR = 0.14</span></span><br><span class="line"><span class="comment">// 就能计算出 USD/EUR = 7.0 × 0.14 = 0.98</span></span><br></pre></td></tr></table></figure>
<h3 id="单位换算系统">单位换算系统</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 长度单位：米→厘米→毫米</span></span><br><span class="line"><span class="comment">// 1米 = 100厘米, 1厘米 = 10毫米</span></span><br><span class="line"><span class="comment">// 因此 1米 = 1000毫米</span></span><br></pre></td></tr></table></figure>
<h3 id="网络拓扑分析">网络拓扑分析</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络节点间的传输延迟比例</span></span><br><span class="line"><span class="comment">// 可以用类似方法计算端到端的性能指标</span></span><br></pre></td></tr></table></figure>
<h2 id="总结：算法思维的提升">总结：算法思维的提升</h2>
<p>通过这道题，我深刻体会到了算法学习的几个层次：</p>
<ol>
<li><strong>基础层</strong>：知道某个算法怎么写</li>
<li><strong>应用层</strong>：知道在什么场景下使用某个算法</li>
<li><strong>创新层</strong>：能够改造经典算法解决新问题</li>
<li><strong>设计层</strong>：能够抽象问题本质，选择最优解法</li>
</ol>
<p>Floyd算法的除法应用完美体现了第三层的能力。它不是简单的算法套用，而是在理解算法本质的基础上，进行创造性的改进。</p>
<p>更重要的是，这种思维方式可以推广到其他问题：</p>
<ul>
<li>当遇到新问题时，首先思考它的本质是什么</li>
<li>是否可以抽象为已知的经典问题</li>
<li>如果不完全匹配，能否通过巧妙的转换来适应</li>
</ul>
<p>这就是算法学习的真正价值：不是记住多少个算法模板，而是培养解决问题的思维方式。而LeetCode 399这道除法求值问题，正是这种思维训练的绝佳案例。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Medium</tag>
        <tag>图论</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title>顽岩资产 Golang后端开发实习生 一面</title>
    <url>/2025/06/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/%E9%A1%BD%E5%B2%A9%E8%B5%84%E4%BA%A7/2025-02-17-%E9%A1%BD%E5%B2%A9%E8%B5%84%E4%BA%A7-Golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E7%94%9F-%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: 顽岩资产（金融科技公司）</li>
<li><strong>职位</strong>: Golang后端开发实习生</li>
<li><strong>面试轮次</strong>: 一面（技术面）</li>
<li><strong>面试形式</strong>: 在线语音面试</li>
<li><strong>面试时长</strong>: 约47分钟</li>
<li><strong>面试官</strong>: 技术面试官（负责机器学习平台开发）</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：自我介绍">问题1：自我介绍</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“先自我介绍一下”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“你好，我是王宇哲，现在是华东师范大学软件工程学院的研究生，主要研究方向是密码学方向。我之前本科期间获得过国家奖学金以及蓝桥杯国赛二等奖这类奖项。然后我现在主要技术栈在于Go语言。Go的话主要做了两个项目。第一个项目是叫抖音商城，它是一个分布式微服务，基于Go加gRPC的微服务架构的一个框架，一个商城系统。然后结合了一些可观测性之类的，还有消息队列redis之类的技术栈。还有一个的话是叫ANX，是我自己学习阶段的时候，自己做了一个叫AI多代理，就是分布式AI多代理架构的一个相当于让AI来进行微服务调用的一个框架。然后我之前实习的话是在业内名企实习的，主要的实习期间工作就是参与CMS系统的开发，以及一些日常维护工作。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>其实可以这样组织会更好：</p>
<p>&quot;您好，我是王宇哲，华东师范大学软件工程学院研究生，专业方向是密码学。在技术方面，我主要专注于Go语言后端开发，有两个比较重要的项目经历：</p>
<p>第一个是抖音商城项目，这是一个基于Go+gRPC的分布式微服务架构，我在其中负责了API网关设计、权限管理、黑名单功能等核心模块，还接入了消息队列、可观测性等技术。</p>
<p>第二个是ANX项目，这是一个创新性的AI多代理分布式架构，通过分层AI设计让AI能够精准调用微服务，我在其中解决了流式AI函数调用拼接等技术难点。</p>
<p>实习方面，我在某公司参与了CMS系统开发，使用PHP技术栈，主要负责官网重构和模板渲染优化。</p>
<p>在学术方面，我的研究方向是可搜索加密，主要关注模糊搜索相关的数据库技术。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答涵盖了基本信息，但可以更有逻辑性</li>
<li>面试官比较关注技术项目，后续主要围绕项目展开</li>
</ul>
<h3 id="问题2：实习项目的技术选型">问题2：实习项目的技术选型</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“实习的时候用的不是Go吧？现在还有系统在用PHP，他们是一个比较古早的系统吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“他也不是很古早，但是当时就是因为他们官网，因为一开始它是纯静态页面的，后面的话就是加我进去，因为他们官网的话维护成本越来越高，因为它随着新闻就越来越多，因为他们公司主要业务也不是在IT上面，所以IT上面没有花很多功夫。然后我就是负责他们官网，当时是让我去写静态页面，然后我就想着既然都要写静态页面，要不把整个系统重构一下，给他直接就是让他们可以后台管理，这样的话不是省了开发的大量的时间吗？然后我们也就让我去组织这个，但是他给我要求就是要尽快完成。所以说为了快的话，我就选择了暂时先用PHP去实现它。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>其实可以这样解释技术选型的考虑：</p>
<p>&quot;确实用的是PHP，主要是基于业务需求和时间成本考虑的。当时公司官网是纯静态页面，随着内容增多维护成本很高，我提出了重构方案，将其改造为可后台管理的CMS系统。</p>
<p>选择PHP主要有几个原因：首先是时间要求紧迫，需要快速交付；其次PHP在Web开发方面生态成熟，特别是模板渲染这块有很多现成的轮子可以用；最后考虑到团队维护成本，PHP相对来说学习成本较低。</p>
<p>不过在具体实现上，我还是做了一些技术优化，比如设计了模板缓存机制，通过哈希值管理静态页面缓存，避免每次请求都重新渲染。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答解释了背景，但技术选型的逻辑可以更清晰</li>
<li>面试官关注技术选型的合理性</li>
</ul>
<h3 id="问题3：抖音商城项目架构设计">问题3：抖音商城项目架构设计</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“介绍一下抖音商城这个项目”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“抖音商城这个项目它是一个包含基本业务的一个商城系统。技术栈设计的话是使用了Go加gRPC，我专门设计了一个类似于API网关的一个东西，就是叫frontend微服务。它只直接与前端进行交互的，相当于它是进行请求转发的，然后以及去调用后台的各种gRPC服务。除此之外，它还负责把前端的token转化直接转化为user ID，以方便后面的gRPC微服务去调用。因为gRPC它基本上一般来说是部署在内网的安全的环境的。所以说不需要每个微服务它都要去解析一下token。因为这样会带来很大的开销。所以说我直接让frontend去解析完以后，丢给后台后面的几个微服务。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>可以这样更系统地介绍架构设计：</p>
<p>&quot;抖音商城是一个完整的电商系统，采用Go+gRPC的微服务架构。整体架构分为几个层次：</p>
<p>首先是API网关层，我设计了一个frontend微服务作为统一入口，负责几个关键功能：一是请求路由和转发，二是token解析和用户身份转换，三是统一的权限控制和黑名单管理。</p>
<p>这样设计的好处是，后端的gRPC微服务可以专注于业务逻辑，不需要重复处理认证授权，提高了开发效率和系统性能。</p>
<p>在权限管理上，我集成了casbin，并且实现了正则匹配功能，这样可以批量管理路由权限，比如/user/*下的所有子路径可以用一个规则统一管理。</p>
<p>黑名单功能采用了Redis+MySQL的设计，短期封禁放Redis，长期封禁存MySQL，这样既保证了查询性能，又控制了内存使用。</p>
<p>目前正在优化的是商品搜索功能，通过监听MySQL的binlog，实时同步数据到Elasticsearch，保证搜索数据的强一致性。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>介绍了核心架构，但可以更突出设计亮点</li>
<li>面试官对binlog监听比较感兴趣，进行了深入追问</li>
</ul>
<h3 id="问题4：MySQL-binlog监听的替代方案">问题4：MySQL binlog监听的替代方案</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“为什么要用到MySQL的binlog？在互联网公司里，可能这个binlog的权限不对研发开放。所以有没有其他的替代形式呢？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“其他替代形式的话就是在代码里面嵌入一些。就比如说你直接去，每次插入的时候都给它放ES也插入一下。或者说用消息队列传递给后台专门维护ES的那个微服务，然后让他去同步一下，这是一个方案。但是这种方案的话，它最大的问题其实就是在于代码嵌入太大了，可能会对开发造成很大的开发层面上来说会有很多的工作量。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题问得很好，确实在实际工作中binlog权限是个问题。替代方案有几种：</p>
<p>第一种是代码层面的双写，就是在业务代码中同时写MySQL和ES。优点是实现简单，缺点是代码侵入性强，而且存在一致性问题。</p>
<p>第二种是通过消息队列解耦，业务代码写完MySQL后发送消息，由专门的消费者负责同步ES。这样降低了代码侵入性，但增加了系统复杂度。</p>
<p>第三种是使用数据库的触发器或者存储过程，在数据变更时自动发送同步信号。</p>
<p>第四种是采用CDC（Change Data Capture）工具，比如Debezium，它可以监听数据库变更并推送到消息队列。</p>
<p>在生产环境中，我觉得消息队列方案是比较好的平衡，既保证了代码的清洁，又有较好的可靠性。至于选择哪种方案，主要看公司的技术栈和权限管理策略。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答了替代方案，但没有深入分析各种方案的优缺点</li>
<li>面试官的问题很实际，体现了工程经验</li>
</ul>
<h3 id="问题5：AI多代理项目的架构设计">问题5：AI多代理项目的架构设计</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“AIGC的那个项目，你里面写的主要都是跟gRPC和微服务架构有关的，介绍一下总体思路”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“他这个整体的目的就是用户输入一个指令，然后通过AI他会去解析这个指令，然后去调用相关的微服务。但是当时设计架构之初的时候，考虑到其实每一个AI的上下文是有限的。所以说他可能没有办法，如果他要管理的那个函数列表太多的话，他可能精准度就会相应的下来。所以说就调用的精准度会下来。所以说我就想到用一个分层的一种架构来实现。就比如说他有个主AI，主AI他不知道每个微服务中它具体有哪些函数，但是他知道有哪些微服务。然后他去判断用户的这个请求要交给哪些微服务去执行。然后他会把这个请求转发给对应的微服务，每个对应的微服务前面它都会有一个自己的AI，这个AI他只管理这个微服务中所有的函数列表。这样的话他就可以根据主AI的要求以及用户的要求去决定去调用哪个函数，然后去填充哪些参数，最后把整个结果返回回来。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个项目的核心创新点在于分层AI架构设计，我来详细说明一下：</p>
<p>首先，问题背景是AI的上下文窗口有限，如果让一个AI管理所有微服务的函数列表，会导致调用精准度下降。</p>
<p>我的解决方案是设计了两层AI架构：</p>
<p>第一层是主AI（路由层），它只知道系统中有哪些微服务以及每个微服务的职责，负责根据用户请求进行分发。</p>
<p>第二层是专门的服务AI（执行层），每个微服务前置一个专门的AI，只管理该微服务的函数列表，负责具体的函数调用和参数填充。</p>
<p>技术实现上，我通过解析gRPC的proto文件，自动生成各层AI的函数清单。这样既保证了信息的准确性，又实现了自动化管理。</p>
<p>最大的技术难点是流式AI的函数调用拼接。因为AI是流式返回的，需要在合适的时机触发函数调用，并且正确拼接多个函数调用结果。</p>
<p>这种设计的优势是提高了调用精准度，缺点是增加了系统复杂度和响应时延。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>说明了设计思路，但技术实现细节可以更具体</li>
<li>面试官对流式处理的技术难点比较感兴趣</li>
</ul>
<h3 id="问题6：系统设计开放题-数据版本管理">问题6：系统设计开放题 - 数据版本管理</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“如果说我的数据集就是很大，那你现在要设计这个东西，你会怎么想的？就比如说我现在设计的这个模型仓库，一个模型可能几十兆几百兆，但是一个数据集可能是几十G或者几T的规模。他每次会有一些新增，但我有的时候还是要用上个版本的，你怎么去做管理呢？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我的想法就是能不能从索引上去思考这个问题。就比如说我们不做文件的管理，我们去做索引的管理。版本化的话，我们第一个版本它会有一个索引文件，第二个版本它会有另一个索引文件。然后我们要每次去加载数据集的时候，我们走这个索引，而不是去直接找所有的文件。然后文件的话全都堆在那一块就行了。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这是一个很好的大数据版本管理问题。我认为可以从几个角度来设计：</p>
<p>首先，索引化管理的思路是对的。我们可以设计一个类似Git的版本管理机制：</p>
<ol>
<li>
<p><strong>文件去重</strong>：使用内容哈希（如SHA256）作为文件唯一标识，相同内容的文件只存储一份。</p>
</li>
<li>
<p><strong>增量存储</strong>：每个版本只存储相对于父版本的变更，包括新增、删除、修改的文件列表。</p>
</li>
<li>
<p><strong>索引结构</strong>：每个版本维护一个索引文件，记录该版本包含的所有文件及其哈希值。索引文件本身也可以采用分层结构，支持快速查找。</p>
</li>
<li>
<p><strong>存储优化</strong>：</p>
<ul>
<li>热数据放SSD，冷数据放普通磁盘</li>
<li>对于大文件，可以考虑分块存储</li>
<li>使用压缩技术减少存储空间</li>
</ul>
</li>
<li>
<p><strong>版本树管理</strong>：支持分支和合并，就像Git那样。</p>
</li>
</ol>
<p>具体实现上，可以用一个元数据数据库（如MySQL）管理版本关系和文件索引，用对象存储（如MinIO）管理实际文件内容。</p>
<p>这样既保证了存储效率，又支持灵活的版本管理。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答了基本思路，但实现细节不够深入</li>
<li>这是一个很好的开放性系统设计题，考察架构思维</li>
</ul>
<h3 id="问题7：研究方向相关">问题7：研究方向相关</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你是学密码学的，没有去做一些跟密码学有关的项目或者实习吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“密码学相关的项目没有。因为密码学的话其实好像没有很多对口的专对口的岗位，除了区块链。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>确实密码学相关的岗位相对较少，但我的研究方向是可搜索加密，主要关注模糊搜索方面。虽然没有直接的密码学项目，但我觉得这个研究背景对后端开发还是有帮助的：</p>
<p>第一，密码学的严谨性训练了我的逻辑思维能力，这在系统设计和算法优化上很有用。</p>
<p>第二，可搜索加密涉及大量的数据库和索引技术，这与后端开发中的数据存储和检索优化是相通的。</p>
<p>第三，我平时会阅读很多数据库相关的论文，对前沿技术保持敏感度。</p>
<p>目前我还是希望专注于后端开发方向，因为我更享受解决工程问题的过程，而且Go语言的简洁性很符合我的编程风格。</p>
<p>当然，如果将来有机会，我也很愿意将密码学知识应用到数据安全、隐私保护等相关领域。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答过于简单，没有体现研究背景的价值</li>
<li>可以将学术背景与工程实践联系起来</li>
</ul>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中，主要考察项目经验和架构思维</li>
<li><strong>面试官风格</strong>: 专业友善，会根据回答深入追问技术细节</li>
<li><strong>题目类型</strong>: 项目讲解(60%) + 系统设计(30%) + 背景了解(10%)</li>
<li><strong>准备建议</strong>: 重点准备项目架构和技术选型的逻辑，要能说清楚为什么这样设计</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官介绍了公司业务方向，询问了个人规划</li>
<li><strong>后续流程</strong>: 面试官表示会考虑，后续HR会联系</li>
<li><strong>个人感受</strong>: 整体交流比较顺畅，面试官对AI项目比较感兴趣</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ul>
<li>项目介绍比较完整，覆盖了技术栈和业务场景</li>
<li>对系统设计有自己的思考</li>
<li>回答问题比较诚实，不懂的地方不胡编乱造</li>
</ul>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ul>
<li>技术细节表达不够准确，有些地方逻辑不够清晰</li>
<li>对开放性问题的思考深度不够</li>
<li>学术背景与工程实践的结合可以更好</li>
</ul>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>项目经验要深入</strong>：不仅要说做了什么，还要说为什么这样做，遇到了什么问题，如何解决的</li>
<li><strong>系统设计要练习</strong>：多做一些开放性的架构设计题，培养全局思维</li>
<li><strong>技术表达要准确</strong>：专业术语要用准确，技术方案要有逻辑</li>
<li><strong>背景经历要串联</strong>：将学术背景、项目经验、个人规划串成一条主线</li>
</ol>
<h3 id="知识点复习">知识点复习</h3>
<ul>
<li>Go语言GMP模型和并发机制</li>
<li>微服务架构设计原则</li>
<li>分布式系统数据一致性方案</li>
<li>MySQL binlog原理和CDC技术</li>
<li>系统设计中的数据存储和版本管理</li>
<li>AI工程化和流式处理技术</li>
</ul>
<p>总的来说，这是一次很好的技术面试体验，面试官专业水平很高，问题有深度也很实际。对于准备后端开发岗位的同学，建议多关注系统设计和工程实践，不仅要会写代码，还要能设计系统。</p>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>一面</tag>
        <tag>顽岩资产</tag>
        <tag>Golang后端开发</tag>
        <tag>实习生</tag>
      </tags>
  </entry>
  <entry>
    <title>蔚来 Golang后端开发 一面</title>
    <url>/2025/06/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/%E8%94%9A%E6%9D%A5/2025-02-11-%E8%94%9A%E6%9D%A5-Golang%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: 蔚来汽车（新能源汽车独角兽）</li>
<li><strong>职位</strong>: Golang后端开发工程师</li>
<li><strong>面试轮次</strong>: 一面（技术面）</li>
<li><strong>面试形式</strong>: 线上视频面试</li>
<li><strong>面试时长</strong>: 约60分钟（包含15-20分钟代码题）</li>
<li><strong>面试官</strong>: 技术leader，主要负责车辆测试系统开发</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：自我介绍和项目经历">问题1：自我介绍和项目经历</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你先做个自我介绍，然后介绍一下你的项目经历。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;好的，首先我叫王宇哲，来自华东师范大学，现在是在软件工程学院的软件工程专业就读，目前是研一。研一的话我们导师没有说不同意出来实习，也没有说同意，但是我因为论文基本上已经完成得差不多了，所以也跟导师商量好了，科研上的任务基本上没有太多了，所以现在就来找实习了。</p>
<p>然后我主要的技术栈是Go语言，以前也做过Java、PHP相关的项目。现在主要技术栈的话，最近做的是抖音商城，它是一个参加字节跳动青训营的项目。这个项目用gin加gRPC，然后融合了一些可观测性之类的组件进去，服务注册服务发现，基本上能想到的跟微服务相关的常见的东西基本上都融入进去了。</p>
<p>另一个项目的话叫ani q，是我自己学习之余做的一个项目，是去年暑假的时候还没开学的时候做的。它是一个基于字节跳动那个框架搭建出来的微服务架构的多代理AI系统。以前本科的话拿过国家奖学金，也参加过蓝桥杯拿过国一，计算机设计大赛拿过国三，还有大学生数学竞赛拿过一等奖，差不多就这些。&quot;</p>
</blockquote>
<p><strong>面试官后续提问</strong>：</p>
<blockquote>
<p>“你那个AI是做了一个什么样的具体的方向？AI那个的话能详细讲一下吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;AI那个的话它主要就是除了微服务，除了一些简单基本的微服务以外，我们主要当时设想是这样一个AI能够去就比如说它会有一个架构，它是首先一个主AI是用来分析用户需求的。然后它会类似于一个树形的结构，它会分配给下级的AI去执行一些执行那个微服务的，执行执行决定要转发给哪个微服务。</p>
<p>就比如说它可能有订单微服务，就比如说一些常见的商城系统，它可能有订单微服务，用户微服务，然后它跟AI提出一个请求，它会然后主AI它会去判断应该是交给哪个微服务去操作的。然后交给那它不会直接交给那个微服务，会交给一个下游AI，那个下游AI的话它是知道那个微服务的所有的接口的。然后第二级AI的话，它可以去决定去调用哪一个函数。这样的话它就可以以一种树形的结构去调度的话，它可以它因为现在AI上下文的长度不是很高。因为上下文一旦多了以后，它这个准确度就会下来。如果用这种架构的话，它即使是即使它支持上下文有限，它也可以达到一个很好的效果。因为有点像分治的思想在里面。&quot;</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“第一个项目应该没有很复杂的业务，在里面你是自己练练手的一个项目，对吧？主要就是一些商城的一些常用的一些模型的一些CRUD为主对吧？消息队列是用来做什么？能详细说说吗？比如说你是处理什么样的业务需要放到消息队列里面。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;不只是CRUD，它主要是因为要保证一些可观测性之类的，所以说它融合挺多。比如说消息队列也融合进去了。消息队列主要是为了能够保证高并发场景下的那些负载，就是服务对高并发场景下，它服务器负载就是单个节点的负载不会太大。</p>
<p>比如说订单，比如说创建订单，你都不是立即处理，都是异步处理的。这个放到消息队列，这样的话就是服务器压力不会太大。我们用的RocketMQ。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>自我介绍这块我觉得可以更有条理一些。可以这样组织：</p>
<p>&quot;大家好，我是xxx，目前在华东师范大学软件工程专业读研一。技术方面，我主要专注于Go语言后端开发，有约1年的实践经验。</p>
<p>项目经历方面，我主要完成了两个比较有代表性的项目：</p>
<p>第一个是字节跳动青训营的抖音商城项目，这是一个完整的微服务架构项目。技术栈使用gin+gRPC，集成了服务注册发现、消息队列RocketMQ、链路追踪Prometheus等组件，主要解决高并发场景下的订单处理问题。</p>
<p>第二个是我个人开发的ani q多代理AI系统，基于字节跳动的Hertz和Kitex框架，设计了分层的AI调度架构，通过解析Proto文件实现泛化调用，是一个比较有创新性的尝试。</p>
<p>学术方面，我获得过国家奖学金，在算法竞赛和数学竞赛中也有不错的成绩。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时介绍有点啰嗦，逻辑不够清晰</li>
<li>应该突出核心技术能力和项目亮点</li>
<li>可以提前准备1-2分钟的精炼版本</li>
</ul>
<h3 id="问题2：Go语言defer机制">问题2：Go语言defer机制</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你说一下Go语言里面那个defer有什么用？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“defer的话它主要就是它会在一个函数执行前去，这个函数结束之前去执行这个defer里面的那个对一些方法。然后它的话是使用了一个这样的结构，就是它先进先出。也就是说比如说你defer它可能定义的是顺序是1、2、3，但它最后执行的话，执行defer里面的函数，它会用3、2、1的顺序去执行。它这个一般是用在比如说我开启了一个数据库，然后我们要在函数结束的时候要给它销毁掉，执行这样一些方法。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>关于defer机制，我觉得可以这样回答会更准确：</p>
<p>&quot;defer是Go语言的一个关键字，主要用于延迟执行函数调用，直到包含它的函数返回时才执行。</p>
<p>defer有几个重要特性：第一，它是先进后出的执行顺序，也就是LIFO（Last In First Out），后定义的defer会先执行；第二，defer的参数会在defer语句执行时就确定值，而不是在实际调用时；第三，即使函数发生panic，defer语句也会执行。</p>
<p>实际应用中，defer主要用于资源清理，比如关闭文件句柄、释放数据库连接、解锁mutex等。这样可以确保资源在函数退出时一定会被正确释放，避免资源泄露。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close() <span class="comment">// 确保文件一定会关闭</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理文件逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时说成了&quot;先进先出&quot;，应该是&quot;后进先出&quot;（LIFO）</li>
<li>表达有些磕磕绊绊，逻辑不够清晰</li>
<li>没有提到panic时也会执行defer这个重要特性</li>
<li>应该给出具体的代码示例</li>
</ul>
<h3 id="问题3：Go语言垃圾回收机制">问题3：Go语言垃圾回收机制</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“说一下Go语言的垃圾回收机制是什么样子？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“这个垃圾回收机制的话我没有太了解，但是我记得它好像是有一个叫三色标记法，好像是Go语言以后的。我记得它是会用一个黑色节点去标记，标记了黑色节点以后，它就是标记为这些资源不会再被使用了，就是等待被回收的。然后它不会一次性回收，它会好像是每隔一段时间它会回收一部分。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Go语言的垃圾回收确实是基于三色标记法，我来详细说一下：</p>
<p>&quot;Go语言使用的是并发三色标记清除算法。具体来说：</p>
<p>三色标记法把所有对象分为三种颜色：</p>
<ul>
<li>白色：未被访问的对象，回收候选</li>
<li>灰色：已被访问但其引用还未被扫描的对象</li>
<li>黑色：已被访问且其引用也已被扫描的对象</li>
</ul>
<p>回收过程是这样的：首先从根对象开始，标记为灰色；然后扫描灰色对象的所有引用，将引用对象标记为灰色，自己变为黑色；重复这个过程直到没有灰色对象；最后清理所有白色对象。</p>
<p>Go的优化点在于：第一，使用写屏障技术保证并发安全；第二，采用混合写屏障减少STW（Stop The World）时间；第三，通过调优参数GOGC控制回收频率，平衡吞吐量和延迟。</p>
<p>现在Go 1.5+版本的GC延迟已经控制在毫秒级别，对于大部分应用来说性能表现都很好。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时只记得三色标记法的概念，没有深入理解</li>
<li>应该学习完整的GC流程和优化策略</li>
<li>可以补充一些性能调优的实践经验</li>
</ul>
<h3 id="问题4：Go协程间通信方式">问题4：Go协程间通信方式</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“Go语言里面goroutine之间有哪些可以通信的方式？举2到3个。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;一般来说的话，第一种就是它用那种信号量机制，比如说sync这个库里面它会提供mutex，用这种方式去执行一个类似于同步之类的操作，这也是一种通信方式。</p>
<p>最主要的还是channel这种，它相当于有点像是一个消息通道。然后左边有一个消费者，右边一个…就是左边一个provider，右边一个consumer，然后就是用这个信号，用这个channel的话，它就可以实现一些同步的操作，还可以传递数据。</p>
<p>还有一个叫WaitGroup，我记得它会就是它就比如说你在开启三个协程的时候，每个协程开启之前，你都给它WaitGroup去加1。然后最后的话就是在协程开启完以后，我们去在主函数里面最后去等待等待这些wait WaitGroup被释放，然后就可以同时等待三个协程结束。这样的话就可以同时等待三个程序结束以后，再继续执行下面的操作。</p>
<p>还有一种是共享内存，共享内存它就是直接可以读取。比如说主函数里面的定义了一个变量，然后协程里面它就可以读取主函数这个变量。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Go协程间通信主要有这几种方式：</p>
<p>&quot;第一种是Channel，这是Go语言推荐的通信方式，符合’不要通过共享内存来通信，而要通过通信来共享内存’的理念。Channel可以是无缓冲的（同步）或有缓冲的（异步），能够安全地在协程间传递数据。</p>
<p>第二种是共享内存配合同步原语，比如使用sync.Mutex、sync.RWMutex来保护共享变量的访问。这种方式性能较好，但需要小心处理竞态条件。</p>
<p>第三种是其他同步原语，比如sync.WaitGroup用于等待一组协程完成，sync.Once用于确保函数只执行一次，sync.Cond用于条件等待等。</p>
<p>实际开发中，优先推荐使用Channel，因为它在编译时就能帮我们检查很多并发安全问题。只有在性能要求特别高的场景下，才考虑使用共享内存的方式。</p>
<p>需要注意的是WaitGroup严格来说不是通信方式，而是同步机制，用于协调协程的执行顺序。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时把WaitGroup也算作通信方式，概念有点混淆</li>
<li>应该明确区分通信和同步的概念</li>
<li>可以补充一些具体的使用场景和最佳实践</li>
</ul>
<h3 id="问题5：MySQL-B-树索引结构">问题5：MySQL B+树索引结构</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“MySQL你用的比较多对吧？说一下MySQL的InnoDB引擎的B+树索引，它是什么样一种数据结构？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;B+树的话它一般来说它只在叶子节点去存储真实数据。然后它的非叶子节点的话，它会存储索引的，它会存储一些索引。然后的话它一般来说用这种方法的话，第一它是相当于是B树的改进版本。因为B树的话它每个节点它都会存储一定的数据和索引。但用这种方式的话，它可能树的高度会变会增加得特别快。</p>
<p>然后其次就是它每次IO的话它可能会读取它IO的次数可能会变多。因为它读取每次读取一个节点，它都要进行一次IO，但是用B+树的话，它就是索引都聚集在一块了。然后它读取的IO次数就会减少。然后它IO次数减少了以后，它整体的性能就会，整体的查询速度就会变快。然后B+树它最后一层的话，它还有一个就是它会把每个叶子节点用一个指针给它连起来，这样可以实现一个范围的查找。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>关于B+树索引，我觉得回答得还可以，可以再补充一些细节：</p>
<p>&quot;InnoDB使用B+树作为索引结构有几个关键特点：</p>
<p>首先，B+树是B树的改进版本。B树的每个节点都存储键值和数据，而B+树只有叶子节点存储数据，非叶子节点只存储键值用于导航。</p>
<p>这样设计的优势是：第一，非叶子节点可以存储更多的键值，减少了树的高度，从而减少磁盘IO次数；第二，所有数据都在叶子节点，叶子节点之间通过双向链表连接，非常适合范围查询和排序操作；第三，查询路径稳定，任何查询都需要从根节点走到叶子节点，性能可预期。</p>
<p>在InnoDB中，主键索引的叶子节点存储的是完整的行数据，叫做聚簇索引；而辅助索引的叶子节点存储的是主键值，需要回表查询获取完整数据。</p>
<p>一般来说，InnoDB的B+树高度在2-4层，每层能存储的数据量是指数级增长的，所以即使千万级数据也能保持很好的查询性能。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本概念回答正确，但可以更深入</li>
<li>应该补充聚簇索引和非聚簇索引的区别</li>
<li>可以举一些具体的数据量和性能的例子</li>
</ul>
<h3 id="问题6：Redis分布式锁">问题6：Redis分布式锁</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“Redis有用过吗？说一下Redis如果作为分布式锁，它是什么样一个特性可以拿来作为分布式锁？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“Redis分布式锁大概了解过。我记得它是一个，我记得它是一个单命令，什么样那个命令什么样命令是lock吗？setnx，不是，因为我觉得还是没用过。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Redis分布式锁主要利用的是Redis的原子性操作特性：</p>
<p>&quot;Redis可以实现分布式锁主要是因为几个特性：</p>
<p>第一，Redis是单线程模型，命令执行是原子性的，不会出现并发问题。</p>
<p>第二，可以使用SETNX（SET if Not eXists）命令，它只有在key不存在时才会设置成功，这正好符合锁的语义 - 同一时间只有一个客户端能获取到锁。</p>
<p>第三，可以通过EXPIRE设置过期时间，避免死锁问题。</p>
<p>具体实现时，通常使用SET命令的组合参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 30000</span><br></pre></td></tr></table></figure>
<p>这样可以原子性地设置key和过期时间。</p>
<p>释放锁时需要使用Lua脚本来保证原子性：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当然，Redis分布式锁也有一些局限性，比如在主从架构下可能出现锁丢失的问题，这时候可以考虑使用Redlock算法或者其他分布式锁方案。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时确实没有实际使用经验，回答很简单</li>
<li>应该至少了解基本的实现原理</li>
<li>可以补充学习一些实际的使用场景</li>
</ul>
<h3 id="问题7：队列和栈的区别及应用场景">问题7：队列和栈的区别及应用场景</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“说一下队列和栈有什么区别，他们分别可以在业务上举个例子，在什么样的场景下去使用。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;队列的话一般是用在这种先进先出的情况。就比如说我刚刚说的那个消息队列，它有一种也是一种队列的数据结构。它这样的话就可以保证先生成的订单被，就是先生成的订单会先处理。</p>
<p>然后栈的话是这样一种先进后出的一种数据结构。然后它一般来说的话就是比如说我们在实行一个递归的操作的时候，它的那个函数其实就是一个用栈的实现来，用这样的方式来实现的。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>队列和栈的区别及应用，我觉得当时回答得还可以，可以再丰富一些：</p>
<p>&quot;队列（Queue）是先进先出（FIFO）的数据结构，栈（Stack）是后进先出（LIFO）的数据结构。</p>
<p>队列的典型应用场景：</p>
<ul>
<li>消息队列：如你提到的订单处理，保证请求按顺序处理</li>
<li>广度优先搜索（BFS）：层次遍历树或图</li>
<li>任务调度：操作系统的进程调度，打印机任务队列</li>
<li>缓冲区：生产者消费者模型中的数据缓冲</li>
</ul>
<p>栈的典型应用场景：</p>
<ul>
<li>函数调用栈：存储函数调用的上下文信息</li>
<li>深度优先搜索（DFS）：递归遍历的模拟</li>
<li>表达式求值：中缀表达式转后缀表达式</li>
<li>浏览器历史记录：后访问的页面先返回</li>
<li>撤销操作：编辑器的Ctrl+Z功能</li>
</ul>
<p>在实际开发中，比如做一个计算器应用，解析数学表达式时就需要用栈来处理括号匹配和运算符优先级。而做一个任务系统时，通常用队列来保证任务的公平调度。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本概念回答正确</li>
<li>应用场景可以更丰富一些</li>
<li>可以结合具体的技术实现来说明</li>
</ul>
<h3 id="问题8：深度优先遍历和广度优先遍历">问题8：深度优先遍历和广度优先遍历</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“说一下深度优先遍历和广度优先遍历分别是什么样的一种遍历方式。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;深度优先遍历的话，我直接在树这个结构，就不在图里面去讲了。比如说在树这个结构下的话，深度优先遍历的话，它会从根节点开始一级级遍历。它每次只会选择一个分支去进行遍历，然后最后碰到了叶子节点以后再返回，不一定是叶子节点，就是碰到了比如说它是先向左遍历，那它碰到没有左节点以后，它会继续向右遍历。然后相当于它就先往深处遍历，然后慢慢再回溯，然后再往深处遍历，是这样一个操作过程。</p>
<p>而广度优先遍历的话它是一层一层的遍历，它就是有种那种比较发散的那种感觉。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>关于DFS和BFS，我觉得可以这样解释会更清楚：</p>
<p>&quot;深度优先遍历（DFS）和广度优先遍历（BFS）是两种不同的图/树遍历策略：</p>
<p>深度优先遍历的特点：</p>
<ul>
<li>尽可能深地访问节点，直到无法继续为止，然后回溯</li>
<li>使用栈（递归或显式栈）来实现</li>
<li>空间复杂度相对较低，为O(h)，h是树的高度</li>
<li>适用场景：找路径、检测环、拓扑排序等</li>
</ul>
<p>广度优先遍历的特点：</p>
<ul>
<li>逐层访问节点，先访问距离根节点近的节点</li>
<li>使用队列来实现</li>
<li>空间复杂度为O(w)，w是树的最大宽度</li>
<li>适用场景：找最短路径、层次遍历、连通性检测</li>
</ul>
<p>举个具体例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>DFS顺序：1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 3<br>
BFS顺序：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
<p>在实际应用中，比如在社交网络中找朋友关系，如果要找最近的共同好友，用BFS比较合适；如果要遍历整个关系网络，DFS可能更节省内存。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本思想解释正确</li>
<li>可以补充实现方式和复杂度分析</li>
<li>应该结合具体例子来说明</li>
</ul>
<h3 id="问题9：代码题环节">问题9：代码题环节</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“现在做个代码考核，时间大概15到20分钟。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>[在代码环节遇到了协程相关的问题，最后没有完全解决]<br>
“这个我实在是想不起来了…这个协程不怎么用。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>代码题部分确实是我的薄弱环节，主要暴露了以下问题：</p>
<p>&quot;虽然我了解Go语言的基本语法和概念，但在实际编程实现上还需要更多练习。特别是协程相关的代码，平时虽然知道理论，但手写代码的经验不足。</p>
<p>这提醒我需要：</p>
<ol>
<li>多做一些Go语言的编程练习，特别是并发相关的</li>
<li>熟悉常见的代码模式和最佳实践</li>
<li>准备一些经典的代码题，比如协程池、生产者消费者等</li>
<li>平时开发中应该更多地使用Go的并发特性</li>
</ol>
<p>建议其他同学在准备面试时，不仅要掌握理论知识，还要有足够的编码实践，这样在面试中才能更好地展现自己的技术能力。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>理论知识掌握尚可，但编程实践不足</li>
<li>需要加强代码题的训练</li>
<li>应该准备一些常见的Go并发编程模式</li>
</ul>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中，主要考察基础知识和理解深度</li>
<li><strong>面试官风格</strong>: 专业友善，会根据回答情况进行深入追问</li>
<li><strong>题目类型</strong>: 主要考察Go语言基础、数据库原理、数据结构算法，还有编程实践能力</li>
<li><strong>准备建议</strong>: 需要系统复习Go语言特性，加强编程实践，准备常见的技术问题</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官没有给出明确反馈，整体氛围比较友好</li>
<li><strong>后续流程</strong>: 等待HR通知，但最终没有进入下一轮</li>
<li><strong>个人感受</strong>: 基础知识回答还可以，但代码实现能力有待提高</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ul>
<li>项目介绍比较清晰，技术栈匹配度较高</li>
<li>基础概念掌握相对扎实</li>
<li>面试过程中比较诚实，不会的地方坦诚承认</li>
</ul>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ul>
<li>部分概念理解不够深入，如垃圾回收机制</li>
<li>编程实践能力需要加强，特别是并发编程</li>
<li>应该准备更多的具体代码示例</li>
</ul>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>系统学习Go语言</strong>：不仅要知道是什么，还要知道为什么，以及如何应用</li>
<li><strong>加强编程练习</strong>：多做一些Go语言的实际项目和代码题</li>
<li><strong>深入理解原理</strong>：对于数据库、缓存等基础设施要有更深入的理解</li>
<li><strong>准备项目细节</strong>：能够深入讲解项目中的技术决策和实现细节</li>
<li><strong>关注业务场景</strong>：了解目标公司的业务，准备相关的技术问题</li>
</ol>
<h3 id="知识点复习">知识点复习</h3>
<ul>
<li>Go语言GMP模型和调度机制</li>
<li>Go语言内存管理和垃圾回收</li>
<li>Go并发编程最佳实践</li>
<li>MySQL索引原理和优化</li>
<li>Redis数据结构和应用场景</li>
<li>常见数据结构和算法的实现</li>
<li>微服务架构设计模式</li>
</ul>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>一面</tag>
        <tag>后端开发</tag>
        <tag>蔚来</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>B站 测试开发工程师 一面</title>
    <url>/2025/06/22/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/B%E7%AB%99/2025-02-08-B%E7%AB%99-%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: B站（哔哩哔哩）</li>
<li><strong>职位</strong>: 测试开发工程师（日常实习）</li>
<li><strong>面试轮次</strong>: 一面（技术面）</li>
<li><strong>面试形式</strong>: 线上视频面试</li>
<li><strong>面试时长</strong>: 约65分钟</li>
<li><strong>面试官</strong>: 技术面试官</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：自我介绍">问题1：自我介绍</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“首先欢迎你参加本次面试，先请你做一个自我介绍。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“你好，我是王宇哲，然后是一个研一的学生，现在就读于华东师范大学软件工程专业，研究方向是密码学方向。我现在主要的技术栈在Go语言这一块，但是也接触过一些测试相关的知识。我做过一些项目，比如说抖音商城，这是一个基于Go语言、gRPC，然后各种微服务组件组合起来构成的一个微服务框架的项目。然后还有一个是AI Nexus，是我自己做的一个小项目，是一个使用AI的分布式系统，多代理系统，差不多就这些。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>自我介绍要更加结构化一些，建议这样组织：</p>
<p>&quot;您好，我是XXX，目前是华东师范大学软件工程专业的研一学生，研究方向是密码学。在技术栈方面，我主要专注于Go语言后端开发，同时也有测试相关的实践经验。</p>
<p>在项目经验方面，我参与了字节跳动青训营的抖音商城项目，这是一个基于Go语言的微服务架构项目，使用了gRPC、服务发现、消息队列等技术。另外我还独立开发了AI Native项目，这是一个多代理AI系统。</p>
<p>除了项目经验，我还有实际的实习经历，负责过CMS系统开发和CI/CD流水线搭建等工作。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答比较随意，结构性不强</li>
<li>对项目的描述不够清晰</li>
<li>应该突出与测试开发相关的经验</li>
</ul>
<h3 id="问题2：为什么选择Go语言">问题2：为什么选择Go语言</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“为什么选择做Go语言呢？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“因为Go语言的话我觉得它第一它比较简洁，就是从我个人开发角度来说，我觉得它比较简洁。然后我自己做的时候也比较方便，能部署到我自己的服务器上面去会比较方便。因为它编译好运行以后可以直接部署上去。但Java的话，我服务器它可能会因为还要运行一个虚拟机，所以说它可能会有点慢。所以说从我个人开发角度来说，我倾向于使用Go。其次是Go的语法的话，我觉得是比较简单易懂的，因为它有点像是面向过程的那种语言，Java的话它可能看起来代码量会大一点，当然它不是真的大，基本上就是因为我个人感觉Go语言，对我自己的使用而言会更舒服一些。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>选择Go语言主要有几个原因：</p>
<p>首先是部署简单，Go是编译型语言，可以直接编译成二进制文件，部署时不需要额外的运行环境，这对个人项目和小团队特别友好。</p>
<p>其次是语法简洁清晰，Go的设计理念就是简单优雅，学习曲线相对平缓，代码可读性很好。</p>
<p>另外Go在并发编程方面有天然优势，goroutine和channel的设计让并发编程变得简单安全。</p>
<p>最后是性能表现，Go的执行效率比较高，内存占用也相对较小，特别适合云原生和微服务场景。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答了基本想法，但表达不够专业</li>
<li>可以更多从技术特性角度分析</li>
</ul>
<h3 id="问题3：实习经历介绍">问题3：实习经历介绍</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“我看你之前还有一个实习经历是吧？这个是你们说一下你这个实习经历的主要工作有哪些？”</p>
</blockquote>
<p><strong>我的回答</strong>：<br>
描述了在实习期间主要做PHP官网系统重构、数据库迁移（SQLite到MySQL）、CI/CD流水线搭建等工作。</p>
<p><strong>标准/建议回答</strong>：</p>
<p>我的实习主要负责三个方面的工作：</p>
<p>第一是官网系统重构，使用PHP技术栈重新设计了模板渲染引擎，通过正则表达式实现变量提取和替换。</p>
<p>第二是数据库迁移，将原有的SQLite数据库迁移到MySQL，处理了数据类型兼容性问题，编写Python脚本完成了600多条新闻数据的迁移。</p>
<p>第三是搭建CI/CD流水线，使用阿里云效平台实现了自动化部署，建立了测试环境和生产环境的分离，将部署周期从两周缩短到3-4天。</p>
<p>这些工作让我了解了完整的项目开发流程，特别是质量保障和自动化部署的重要性。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>项目经验比较完整</li>
<li>体现了一定的工程化思维</li>
<li>与测试开发岗位有一定关联性</li>
</ul>
<h3 id="问题4：抖音商城项目详解">问题4：抖音商城项目详解</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“我看你去去从近期在做的一个项目是抖音商城这个项目。对，你能大概说一下这个项目的功能有哪些吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：<br>
详细介绍了抖音商城项目的微服务架构，包括用户模块、授权模块、前端模块、订单模块、购物车模块、商品模块、结算和支付模块等。</p>
<p><strong>标准/建议回答</strong>：</p>
<p>抖音商城是一个基于微服务架构的电商系统，我主要负责以下几个核心模块：</p>
<ol>
<li>用户认证授权：实现JWT令牌分发、权限校验和黑名单机制</li>
<li>前端网关：负责请求路由和权限验证，使用正则表达式进行路径匹配</li>
<li>订单系统：包括下单流程、库存校验、支付集成和订单超时处理</li>
<li>商品搜索：使用Elasticsearch实现商品的模糊搜索</li>
<li>消息队列：使用RocketMQ实现订单处理的削峰填谷</li>
</ol>
<p>在技术架构上，我们使用了服务注册中心（Nacos）、分布式链路追踪、日志收集等可观测性组件，确保系统的稳定性和可维护性。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>项目经验丰富，技术栈完整</li>
<li>对微服务架构有实际理解</li>
<li>体现了一定的架构设计能力</li>
</ul>
<h3 id="问题5：消息队列原理">问题5：消息队列原理</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你能说一下这个消息队列的底层原理是什么样子的吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“消息队列底层的话应该是是我没有了解太多，但是我感觉他应该就是一个队列。因为他我部署的时候，我发现他有一个叫name server，还有一个叫他应该是一个主从结构的。然后他消息的话应该是他就是一个队列然后。它底层应该就是一个队列，直观上看上去就是一个队列。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>RocketMQ的底层原理可以从几个层面来说：</p>
<p>首先是架构组成，主要包括Name Server（服务发现）、Broker（消息存储）、Producer（生产者）和Consumer（消费者）。</p>
<p>存储机制上，RocketMQ使用CommitLog进行顺序写入，通过ConsumerQueue建立索引，这样既保证了写入性能，又支持高效的消息检索。</p>
<p>在高可用方面，Broker支持主从复制，Name Server采用无状态设计，避免了单点故障。</p>
<p>消息的可靠性通过同步/异步刷盘、主从同步等机制来保证。</p>
<p>在消费模式上，支持推拉两种模式，可以实现负载均衡和广播消费。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对消息队列的理解比较浅层</li>
<li>需要深入学习中间件的底层原理</li>
<li>实际使用经验有，但理论基础需要加强</li>
</ul>
<h3 id="问题6：数据库基础">问题6：数据库基础</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“说一下基本的增删改的关键字，周善改查，增删改查四个。”</p>
</blockquote>
<p><strong>我的回答</strong>：<br>
介绍了SELECT、INSERT INTO、UPDATE、DELETE的基本语法。</p>
<p><strong>标准/建议回答</strong>：</p>
<p>MySQL的基本CRUD操作：</p>
<p>查询（SELECT）：<code>SELECT 字段 FROM 表名 WHERE 条件 GROUP BY 字段 HAVING 条件 ORDER BY 字段</code></p>
<p>插入（INSERT）：</p>
<ul>
<li><code>INSERT INTO 表名 VALUES (值列表)</code></li>
<li><code>INSERT INTO 表名 (字段列表) VALUES (值列表)</code></li>
</ul>
<p>更新（UPDATE）：<code>UPDATE 表名 SET 字段=值 WHERE 条件</code></p>
<p>删除（DELETE）：<code>DELETE FROM 表名 WHERE 条件</code></p>
<p>需要注意的是WHERE条件的使用，避免误删误改数据。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基础语法掌握正确</li>
<li>表达比较清晰</li>
</ul>
<h3 id="问题7：索引的作用">问题7：索引的作用</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“说一下索引的作用。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“索引的话它主要是为了让这个字段能够提高查询的效率。它是对字段进行加索引的，然后索引的话就是你走这个字段索引完以后，它会再回过头去走主键的那个索引。然后这样的话就是能大大提高搜索效率。因为底层的B+树结构的话，它是支持就可以把查询的速度从O(n)降到O(log n)，所以说可以大大提高查询的效率。但是索引有时候也会失效，就是可能会造成一些最终还是会变成全表扫描。然后我们系统优化，就是MySQL优化的话，也要去避免这些可能会造成全表扫描的情况。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>索引的作用主要是提高查询效率，具体原理是这样的：</p>
<p>首先，索引使用B+树数据结构，可以将查询时间复杂度从O(n)降低到O(log n)。</p>
<p>其次，索引的查询过程分为两步：先通过索引定位到主键，再通过主键回表获取完整数据，这叫做回表操作。</p>
<p>但是索引也有成本，包括：</p>
<ol>
<li>占用额外存储空间</li>
<li>影响写入性能（每次写入都要维护索引）</li>
<li>可能失效的情况（如函数操作、类型转换、最左匹配原则等）</li>
</ol>
<p>所以索引设计要考虑查询模式，避免过多无用索引。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本概念理解正确</li>
<li>对B+树和回表有认识</li>
<li>但表达不够准确，术语使用有误</li>
</ul>
<h3 id="问题8：TCP和UDP的区别">问题8：TCP和UDP的区别</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“能说一下TCP和UDP的区别吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：<br>
介绍了TCP面向连接、可靠性、三次握手四次挥手，UDP面向报文、不可靠但速度快等特点。</p>
<p><strong>标准/建议回答</strong>：</p>
<p>TCP和UDP的主要区别：</p>
<p><strong>连接性</strong>：TCP是面向连接的，需要建立连接后才能传输；UDP是无连接的，直接发送数据。</p>
<p><strong>可靠性</strong>：TCP通过序列号、确认应答、重传机制保证可靠传输；UDP不保证可靠性。</p>
<p><strong>效率</strong>：TCP头部较大（20字节），有各种控制机制；UDP头部简单（8字节），传输效率高。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>TCP适用于对可靠性要求高的场景，如HTTP、HTTPS、文件传输</li>
<li>UDP适用于对实时性要求高的场景，如视频直播、在线游戏、DNS查询</li>
</ul>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本概念掌握正确</li>
<li>能够结合应用场景分析</li>
<li>回答比较完整</li>
</ul>
<h3 id="问题9：HTTP和HTTPS的区别">问题9：HTTP和HTTPS的区别</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“说一下HTTP和HTTPS的区别。”</p>
</blockquote>
<p><strong>我的回答</strong>：<br>
介绍了端口号区别（80 vs 443）、HTTPS的加密机制、证书验证过程等。</p>
<p><strong>标准/建议回答</strong>：</p>
<p>HTTP和HTTPS的主要区别：</p>
<p><strong>安全性</strong>：HTTP是明文传输，容易被窃听；HTTPS在HTTP基础上加了SSL/TLS加密层。</p>
<p><strong>端口</strong>：HTTP默认使用80端口，HTTPS使用443端口。</p>
<p><strong>认证机制</strong>：HTTPS使用数字证书验证服务器身份，防止中间人攻击。</p>
<p><strong>加密过程</strong>：</p>
<ol>
<li>客户端请求HTTPS连接</li>
<li>服务器返回数字证书（包含公钥）</li>
<li>客户端验证证书有效性</li>
<li>使用公钥加密随机生成的会话密钥</li>
<li>后续通信使用会话密钥进行对称加密</li>
</ol>
<p><strong>性能影响</strong>：HTTPS由于加密解密过程，性能略低于HTTP，但现在硬件性能足够，影响微乎其微。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对加密原理有基本理解</li>
<li>能够说出具体的握手过程</li>
<li>回答相对完整</li>
</ul>
<h3 id="问题10：HTTP请求类型">问题10：HTTP请求类型</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“HTTP的请求有哪些类型？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“主要有GET、POST这两个最常用。然后还有OPTIONS，它是请求方法的。然后PUT、DELETE好像也是比较新一些的类型，好像很少看到。然后还有一个TRACE它好像是用来链路跟踪的类型。还有一个我不太确定了，好像是一个关于HEAD的类型。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>HTTP的主要请求方法：</p>
<p><strong>GET</strong>：获取资源，幂等且安全<br>
<strong>POST</strong>：创建资源，非幂等<br>
<strong>PUT</strong>：更新整个资源，幂等<br>
<strong>DELETE</strong>：删除资源，幂等<br>
<strong>PATCH</strong>：部分更新资源<br>
<strong>HEAD</strong>：获取资源头信息，不返回消息体<br>
<strong>OPTIONS</strong>：获取服务器支持的HTTP方法<br>
<strong>TRACE</strong>：用于诊断，回显服务器收到的请求</p>
<p>其中GET、POST是最常用的，PUT、DELETE在RESTful API中使用较多。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本方法都知道</li>
<li>但对每个方法的具体作用不够清晰</li>
<li>表达有些不准确</li>
</ul>
<h3 id="问题11：HTTP状态码">问题11：HTTP状态码</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“HTTP的响应状态码，说一些你比较熟悉的。”</p>
</blockquote>
<p><strong>我的回答</strong>：<br>
介绍了200、301/302、404、403、401、502、503等常见状态码。</p>
<p><strong>标准/建议回答</strong>：</p>
<p>常见HTTP状态码：</p>
<p><strong>2xx成功</strong>：</p>
<ul>
<li>200 OK：请求成功</li>
<li>201 Created：资源创建成功</li>
<li>204 No Content：请求成功但无返回内容</li>
</ul>
<p><strong>3xx重定向</strong>：</p>
<ul>
<li>301 Moved Permanently：永久重定向</li>
<li>302 Found：临时重定向</li>
<li>304 Not Modified：资源未修改，使用缓存</li>
</ul>
<p><strong>4xx客户端错误</strong>：</p>
<ul>
<li>400 Bad Request：请求语法错误</li>
<li>401 Unauthorized：未认证</li>
<li>403 Forbidden：无权限</li>
<li>404 Not Found：资源不存在</li>
</ul>
<p><strong>5xx服务器错误</strong>：</p>
<ul>
<li>500 Internal Server Error：服务器内部错误</li>
<li>502 Bad Gateway：网关错误</li>
<li>503 Service Unavailable：服务不可用</li>
</ul>
<p><strong>总结反思</strong>：</p>
<ul>
<li>常见状态码基本掌握</li>
<li>能够分类说明</li>
<li>个别状态码理解有偏差</li>
</ul>
<h3 id="问题12：编程题-第一个只出现一次的字符">问题12：编程题 - 第一个只出现一次的字符</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“好，行，那我们来做一个编程的题目。好这个题目二，第一个只出现一次的字符OK。”</p>
</blockquote>
<p><strong>我的回答</strong>：<br>
实现了使用map统计字符出现次数，然后遍历字符串找到第一个出现次数为1的字符的解法。</p>
<p><strong>标准/建议回答</strong>：</p>
<p>这道题有两种主要解法：</p>
<p><strong>方法一：哈希表</strong>（我使用的方法）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 统计每个字符出现次数</span></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        count[char]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找第一个出现次数为1的字符</span></span><br><span class="line">    <span class="keyword">for</span> i, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> count[char] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：两次遍历优化</strong><br>
可以用数组代替map，因为字符范围有限，空间复杂度更优。</p>
<p>时间复杂度：O(n)，空间复杂度：O(1)（字符集大小固定）</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>解法正确，思路清晰</li>
<li>代码实现没有问题</li>
<li>编程基础扎实</li>
</ul>
<h3 id="问题13：职业规划">问题13：职业规划</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“就是你自己的整体的职业规划大概是什么样子？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我整体职业规划的话，其实我主要是想要接触一些更多的技术，就是先提升自己的技术能力，然后就是争取未来能走上一些更好的开发岗，测试开测试开发也在内。目前来说的话，主要是想要更多学习的技术，然后学习一些规范更规范的流程。因为我原本实习的公司，他的那个开发它不是它的核心职能部门。所以说我们我们的工作它没有其实是没有一个很规范的一些流程的。所以说我想知道真正的一个开发的规范流程应该是什么样子的，这是我目前想要做的事。然后接下来才是主要就是这些，就是目前来说是这些。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>我的职业规划分为几个阶段：</p>
<p><strong>短期目标（1-2年）</strong>：<br>
通过实习机会深入了解大厂的开发流程和质量保障体系，学习规范的工程化实践，提升技术栈的深度和广度。</p>
<p><strong>中期目标（3-5年）</strong>：<br>
成为一名优秀的测试开发工程师，能够独立设计和实施自动化测试体系，具备系统架构和性能优化的能力。</p>
<p><strong>长期目标</strong>：<br>
向技术专家或技术管理方向发展，能够在技术决策和团队建设方面发挥更大作用。</p>
<p>选择测试开发是因为这个岗位既能发挥我的开发能力，又能让我深入了解质量保障体系，对技术的全面性要求更高。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>表达了学习意愿</li>
<li>对规范流程的渴望很真诚</li>
<li>但规划不够具体和深入</li>
</ul>
<h3 id="问题14：对测试开发岗位的理解">问题14：对测试开发岗位的理解</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“那你对测试开发岗位是有什么样的理，就是预期是什么样的，或者是说初步的了解是什么样的。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“测试开发岗位的话他其实就是感觉有点像是。有点像是一个一堵防火墙，它可以能保证最终那个软件上线是能能要尽量确保软件上线是正常的。因为实际上我们开发的时候，就是在开发的过程中，我们可能会因为注重业务的实现，导致忽略了很多忽略很多一些边界条件什么的。就导致最后上线的话，它可能会出现一些bug。然后测试的作用就是在中间给他做一个完整性的测试，然后就是尽可能的杜绝这些出现的问题。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>我对测试开发岗位的理解：</p>
<p><strong>核心职责</strong>：测试开发不只是一道防火墙，更是质量保障体系的建设者。主要包括：</p>
<ol>
<li>设计和实现自动化测试框架</li>
<li>建设CI/CD流水线中的质量卡点</li>
<li>进行性能测试和稳定性测试</li>
<li>开发测试工具和平台</li>
</ol>
<p><strong>技能要求</strong>：</p>
<ul>
<li>扎实的编程能力（自动化测试开发）</li>
<li>深入的业务理解（设计有效的测试策略）</li>
<li>系统性思维（整体质量保障设计）</li>
<li>工具开发能力（提升测试效率）</li>
</ul>
<p><strong>价值体现</strong>：通过技术手段提升研发效率，降低线上故障率，保障用户体验。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对岗位有基本认知</li>
<li>理解了质量保障的重要性</li>
<li>但对具体工作内容了解不够深入</li>
</ul>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中偏难</li>
<li><strong>面试官风格</strong>: 专业友善，会逐步深入追问</li>
<li><strong>题目类型</strong>: 项目经验+基础知识+编程题，全面考察</li>
<li><strong>准备建议</strong>: 需要对项目经验进行深度总结，基础知识要扎实</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官没有明确表态</li>
<li><strong>后续流程</strong>: 等待HR通知</li>
<li><strong>个人感受</strong>: 整体发挥一般，项目经验较好，基础知识有待加强</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ul>
<li>项目经验比较丰富，能够详细介绍技术细节</li>
<li>编程题解答正确，代码实现没有问题</li>
<li>对实习工作有深入思考</li>
</ul>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ul>
<li>语言表达需要更加专业和准确</li>
<li>基础知识掌握不够深入，特别是中间件原理</li>
<li>对目标岗位的理解还需要加深</li>
</ul>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>项目经验</strong>：准备STAR法则描述项目，突出技术难点和解决方案</li>
<li><strong>基础知识</strong>：深入学习Go语言特性、数据库原理、网络协议等</li>
<li><strong>测试开发</strong>：了解自动化测试框架、CI/CD、性能测试等相关知识</li>
<li><strong>表达能力</strong>：多练习技术表达，使用准确的专业术语</li>
</ol>
<h3 id="知识点复习">知识点复习</h3>
<ul>
<li>Go语言并发编程（GMP模型、channel等）</li>
<li>微服务架构设计和中间件原理</li>
<li>数据库索引优化和SQL调优</li>
<li>HTTP/HTTPS协议详解</li>
<li>自动化测试和质量保障体系</li>
</ul>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>B站</tag>
        <tag>测试开发</tag>
        <tag>一面</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯IEG 运营开发工程师 一面</title>
    <url>/2025/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/%E8%85%BE%E8%AE%AF/2025-03-24-%E8%85%BE%E8%AE%AFIEG-%E8%BF%90%E8%90%A5%E5%BC%80%E5%8F%91-%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: 腾讯IEG（互动娱乐事业群）</li>
<li><strong>职位</strong>: 运营开发工程师（偏全栈）</li>
<li><strong>面试轮次</strong>: 一面（技术面）</li>
<li><strong>面试形式</strong>: 线上视频面试</li>
<li><strong>面试时长</strong>: 约90分钟</li>
<li><strong>面试官</strong>: 开发(似乎是全栈开发工程师)</li>
<li><strong>面试日期</strong>: 2025年06月21日</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：自我介绍">问题1：自我介绍</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“咱们老规矩先自我介绍一下呗”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;面试官你好。我是王宇哲，目前是华东师范大学软件工程密码学方向在读研究生。我研究的方向主要是可搜索加密，然后比较偏数据检索这方面的。然后本科期间的话，我学习成绩比较优异，三年均为专业排名第一，获得过国家奖学金。也通过自己的编程能力获得过一些比如说蓝桥杯国奖，计算机设计大赛三等奖这些奖项。我自己的话是对分布式系统以及微服务架构这些微服务架构设计这些方面特别感兴趣。然后在过去的项目中，我主要是使用Go技术栈去构建一些分布式应用。</p>
<p>去年12月到今年2月期间，我参加抖音的青训营，然后组织团队完成了一个基于微服务架构的抖音商城系统。然后我在这里面是负责系统的总体架构设计，以及使用GitHub Actions去实现自动部署微服务上云这些操作。然后我也设计了微服务之间通信的机制，以及结合了OpenTelemetry去融合一些可观测性。也使用了Nacos实现服务注册，以及服务发现，以及动态配置热更新。除此之外我还设计了一些黑名单分级存储策略之类的来优化一些系统性能。然后同时使用Canal加消息队列来进行三个数据库的数据同步。</p>
<p>然后去年7月份的话，我也在学习Go期间，我是开发了一个AIGC NEXUS应用。它是一个分布式的用AI来进行微服务调用的一个框架。基本上就是我的自我介绍。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>自我介绍可以更加结构化一些，建议按照以下逻辑：</p>
<p>&quot;面试官你好，我是XXX。首先说一下教育背景，我现在是华东师范大学软件工程专业的研二学生，研究方向是密码学。</p>
<p>在技术能力方面，我主要专注于分布式系统和微服务架构的开发。最近的项目经验包括：去年12月到今年2月参加了抖音青训营，组织团队完成了一个基于微服务架构的电商系统，我负责系统架构设计、CI/CD流程搭建以及服务间通信机制的设计。</p>
<p>在学术成绩方面，本科三年专业排名第一，获得过国家奖学金。同时也有一些实践经验，比如参加计算机设计大赛获得三等奖等。</p>
<p>我对这个岗位很感兴趣，因为我了解到这个职位涉及到前后端开发，正好符合我希望在工作前几年进行技术广度学习的规划。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>回答比较全面，涵盖了教育背景、项目经验、技术能力</li>
<li>体现了对全栈开发的兴趣和学习规划</li>
<li>可以更简洁一些，重点突出与岗位相关的经验</li>
</ul>
<h3 id="问题2：学习成绩情况与实习经历">问题2：学习成绩情况与实习经历</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你有提到本科阶段成绩比较好，那研究生阶段的成绩怎么样？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“研究生因为是研一，但是我绩点的话应该是3.8，应该也能排前面。然后因为我是考研考上来的，我考研的成绩的话是排专业第二，70个人里面。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“我先问一句，就是你现在是在实习中是吧？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我不在实习中，但是…看你的简历，你是已经结束了一段之前的项目是外部开发的实习。对对对。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“我看你现在应聘的岗位是后台开发方向，我想问一下你对未来的期望。我因为我这边的岗位是偏全栈的，他不单纯是后台开发，后端为主，但是会涉及到一些前端，小程序端的工作量。你这种岗位你未来会考虑吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我会考虑的。因为首先我自己是就是我本科期间，其实我做的东西都很杂，也是偏全栈这些东西就是我什么都会做一点，然后我基本上都会自己去开发一些应用，去类似于做一些小demo之类的，所以说基本上我都会涉及一些，然后我也比较关注的是知识的广度。然后目前的话就是近就是从我研究生研一开始，然后到未来工作的三年内，我都会我都计划是去进行广度的学习，而不是去深度的学习。这在工作的三年中，我可能会进行深度的学习。这段时间的话，我是主要是在广度的涉猎一些技术，了解各种各样的技术栈。所以说我感觉这个职位当时我看到这个职位描述的时候，我觉得我自己是比较希望能进来的。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;研究生阶段我也保持了比较好的学习状态。目前研一的绩点是3.8，在专业中排名靠前。考研时我的成绩在70人中排第二，说明基础还是比较扎实的。</p>
<p>不过研究生阶段我更注重实践能力的提升，所以在保证学业的基础上，我会更多地参与一些项目开发和技术学习，这样能更好地将理论知识转化为实际能力。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>数据具体，有说服力</li>
<li>体现了从理论向实践转化的思路</li>
<li>展现了学习能力和自我规划意识</li>
</ul>
<h3 id="问题3：抖音商城项目背景">问题3：抖音商城项目背景</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你刚才也提到过那个抖音商城的项目是一个什么背景，抖音的什么比赛项目吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“对他是一个青训营的项目，他就是组织一群人一起去，他会给我们一些教学视频，然后让我们自己去学完视频以后，自己去根据这个团队，按照他的需求文档来做一个系统出来。大概花了，初期的话是一个月就已经把基本的功能都给做完了。然后中间是春节，春节就是中间很长时间没有做。然后后面的话就是在春节期间也考虑一些其他的技术栈，比如说后来那个Canal什么的，都是后来考虑到的，然后去给它融合进去了，总共加起来的话是两个月。我们的话具体开发的话四个人，但是其实主要工作量还是我大概70%的工作量。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;是的，这是字节跳动青训营的一个实战项目。青训营是字节跳动面向大学生的技术成长计划，他们会提供系统的技术培训视频和实战项目。</p>
<p>整个流程是这样的：首先我们需要学习他们提供的微服务开发相关视频课程，然后根据他们给出的需求文档，自主组队完成一个完整的电商系统。</p>
<p>我选择担任队长，主要是因为我对微服务架构比较感兴趣，而且希望能在项目中承担更多的技术决策和架构设计工作。这个项目让我对分布式系统有了更深入的理解，也积累了团队协作的经验。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>说明了项目的权威性和含金量</li>
<li>体现了主动学习和领导能力</li>
<li>展现了对技术的热情</li>
</ul>
<h3 id="问题4：内存占用排查与分布式事务">问题4：内存占用排查与分布式事务</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“先问一个内存问题，假如说现在有遇到一个问题，你这个服务上线了，但是有一天遇到服务器告警，内存不足，你去排查问题，你会用什么方法去去排查？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;这个正好是我之前实习的时候遇到了一个问题。就是当时实习的话因为我们当时那个公司的系统版本比较低。然后后来不知道怎么的，就是好像去年十月份开始有一个漏洞，就有一个蠕虫病毒，然后悄无声息进入我们那个服务器里面去了。然后他就一直在挖矿，然后导致我们那个MySQL就一直在启动，然后过三天宕机了，再启动又过三天又宕机了。</p>
<p>然后我们先去用那个命令行去看top，就是用top去看进程的那些什么内存占用情况，CPU占用情况，发现都不太行。然后后来的话我们就下了一个第三方的那个工具，然后第三方的那个命令行管理工具，然后我们去运行，然后发现他那个我们一运行就会发现他前他就是最就是会有一个应用，会有一个进程，它占用特别多内存，还有那个CPU资源。然后我们就用那个which命令去去判断top指令它在哪个目录。然后我们发现top被那个蠕虫病毒给修改掉了。&quot;</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“那换一个问题，如果不是被攻击的，就只是单纯的你的服务内存占用比较高，怎么解决？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;首先一般来说服务占内存占用比较高的话，它有几个问题。我自己开发那个抖音商城的时候也遇到过相关的问题。就比如说我用Nacos的时候，他那个服务器动不动就OPS过高，然后整个服务器就停止了。后来排查原因发现是Nacos他那个日志级别的问题。因为给他设置了info日志，导致他日志特别多。然后不停的读写磁盘，导致它那个内存过高了。于是我们就把这个日志级别给改成那个error级别。</p>
<p>除此之外还有MySQL，MySQL经常会出现内存过高的情况，占用内存量过高的情况。那它一般来说就是它的一些缓冲池之类的，就是参数设置过高，我们会给它设置低一点。虽然说它查找速度性能会变低，但是它不至于让整个系统的内存在负载太高。&quot;</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“那现在就有一个比较现实的问题，就是你上去就top去看一下，发现有某个服务的进程，它耗的内存就是比较高，越来越多。那你怎么去排查垃圾回收的问题？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“垃圾回收的问题的话，这个我感觉是要从代码层面去考虑。可能就是在做单元测试的时候，去给每个进程去帮他们GC一下，然后去判断一下这个内存最后会占用多少，然后去一个个去找到对应哪个内存可能占用一直过高的那个。但是排查内存泄露的工具我没有用过。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“如果用分布式事务解决库存问题，具体是怎么操作的呢？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“这个我不太了解，应该是如果说他出现了问题，他应该还要专门写一个恢复的函数。我估计是这样，因为我不太了解这个分布式事务，它应该是要专门写一个恢复库存的一个函数。然后就是分布式事务它会有个中心，应该会通知他去回滚，应该是这样的。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;分布式事务解决库存问题主要有几种方案：</p>
<p>第一种是2PC（两阶段提交）模式，有个事务协调器来管理。第一阶段先向各个服务发送准备请求，比如订单服务预创建订单，库存服务预扣减库存。第二阶段如果都准备成功就提交，否则就回滚。</p>
<p>第二种是TCC模式，就是Try-Confirm-Cancel。Try阶段先尝试执行，比如冻结库存；Confirm阶段确认提交；如果出现问题就Cancel回滚，释放冻结的库存。</p>
<p>第三种是SAGA模式，将一个分布式事务拆分为多个本地事务，每个事务都有对应的补偿操作。如果后面的事务失败，就逐步执行补偿操作来回滚。</p>
<p>实际项目中我们更多会选择最终一致性方案，比如使用消息队列来异步处理，配合重试和补偿机制来保证数据最终一致。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>当时回答过于简单，缺乏具体的技术方案</li>
<li>应该准备常见的分布式事务解决方案</li>
<li>需要加强分布式系统理论知识</li>
</ul>
<h3 id="问题5：MySQL索引设计">问题5：MySQL索引设计</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“假如说有一张用户的数据表，字段有用户名、昵称、性别、年龄、注册时间，对这个表做索引的设计，你会做哪几加索引？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;我首先肯定要考虑的考虑把用户名设或者ID设置为主键，这样的话查询起来比较快。因为用户名查找的肯定是最多的。然后其次的话昵称我一般是不会建索引的。因为像比如说我们现在QQ我们那个QQ里面很多人都他都会有很多稀奇古怪的符号。如果说我们建索引的话，他其实很少有人会对它进行精确的查询。所以说我们不会对他建索引，让他每次查询都全表扫描。</p>
<p>然后这个性别的话一般查的也比较少，性别年龄一般查的也比较少。注册时间的话我觉得内部他可能会统计一些用户信息，他可能会用，所以说可能要建个索引，而且他比较比较能比较良好的支持一些范围查询之类的。所以说这个可能要建一个索引，可能根据内部需求。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;对于这个用户表的索引设计，我会这样考虑：</p>
<p>首先肯定是主键索引，如果有user_id就用user_id，这是聚簇索引，查询效率最高。</p>
<p>然后我会根据业务场景来设计其他索引：</p>
<ol>
<li>
<p>用户名（username）：这个肯定要建唯一索引，因为登录时会频繁按用户名查询，而且用户名不能重复。</p>
</li>
<li>
<p>注册时间（register_time）：这个建议建普通索引，因为运营经常需要按时间范围统计用户，比如查询某个时间段的新增用户。</p>
</li>
<li>
<p>性别、年龄：单独建索引意义不大，因为区分度太低。但如果经常需要按年龄段和性别组合查询，可以考虑建联合索引 (age, gender)。</p>
</li>
<li>
<p>昵称：一般不建索引，因为昵称查询不多，而且昵称可能包含特殊字符，索引效果不好。</p>
</li>
</ol>
<p>总的原则是：高频查询的字段、区分度高的字段优先建索引，但也要考虑索引维护成本。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本思路正确，但分析不够深入</li>
<li>应该更多从业务场景角度考虑</li>
<li>需要掌握索引设计的基本原则</li>
</ul>
<h3 id="问题6：联合索引使用规则">问题6：联合索引使用规则</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“如果有ABC3列的话，AB、AC、BC、CB、CA哪几个能用到索引？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“AB应该是会用到的，因为它满足最左原则，其实我们联合索引可以把它看成几个字段给它拼起来，就从左向右拼起来，所以说AB肯定可以。AC可以查一部分，就是查的性能可能没有那么好吧，感觉会先查A。具体的字段忘了，具体字段忘了，它好像会显示用到哪些什么range之类的一些索引，但是具体的用的比较少，所以说我已经记不太清楚了。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;这是联合索引的最左前缀原则问题。如果建立了ABC的联合索引，那么：</p>
<p>能完全使用索引的组合：</p>
<ul>
<li>A：可以使用，因为A是最左边的</li>
<li>AB：可以使用，符合最左前缀原则</li>
<li>ABC：可以使用，完全匹配</li>
</ul>
<p>能部分使用索引的组合：</p>
<ul>
<li>AC：只能使用A列的索引，C列用不到，因为缺少中间的B</li>
<li>BC：完全用不到索引，因为没有最左边的A</li>
</ul>
<p>完全用不到索引的组合：</p>
<ul>
<li>CB、CA：都用不到，因为没有从最左边开始</li>
</ul>
<p>这是因为联合索引在B+树中是按照建立顺序进行排序的，必须从最左边开始才能有效利用索引的有序性。实际应用中，我们通常把查询频率最高、区分度最大的字段放在最左边。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对最左前缀原则理解不够准确</li>
<li>需要深入理解联合索引的存储结构</li>
<li>应该能准确判断各种组合的索引使用情况</li>
</ul>
<h3 id="问题7：海量数据处理">问题7：海量数据处理</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“统计海量IP数据中出现次数最多的前十个IP。数据量会比较大，假设是一个IP地址的文件，然后文件中有100亿个IP，文件大小大约是100G。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;最简单的方式的话，应该是想到用一个map来存。但是100个G的文件，它没有办法直接加到内存中。首先它是100个G的文件，它不可能一次性读入内存。首先我们肯定是这个命令行的话，它肯定是要用一些指针去记录上一次读入内存的文件的地址。我记得C++里面，它应该是有一个指针的，就是文件的游标。</p>
<p>然后我们首先第一次初步统计前，就是初步我们分批次读取。比如说第一次读个一个G然后读完一个G以后，我们先用一些常规的算法去把它前10个IP统计出来。但分批次读的话，它会丢失前面那一个分块的信息。比如说可能统计出来前十个分块，前十个分块次数出现次数最多的是IP1，然后他出现了十次。但是其实出现次数第二高的它是出现了九次。但是后面这个IP1它再也没有被出现过。但IP2的话它一直又经常性的出现。但是IP2没有被计算进去，那就没有办法达到我们的需求。</p>
<p>可能得用归并排序吧。但哈希的话它会占用很多内存。但是这个海量IP，它不应该是乱序的吗？有重复的有重复的。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;这是一个典型的海量数据处理问题，100G的文件无法直接加载到内存，需要用分治的思想：</p>
<p>第一步：数据分片</p>
<ul>
<li>将100G文件按IP进行哈希分片，比如分成1万个小文件</li>
<li>每个IP做hash(IP) % 10000，相同IP一定会分到同一个文件中</li>
<li>这样每个小文件大约10M，可以放入内存处理</li>
</ul>
<p>第二步：单文件处理</p>
<ul>
<li>对每个小文件，用HashMap统计IP出现次数</li>
<li>找出每个文件中出现次数最多的前10个IP</li>
</ul>
<p>第三步：全局合并</p>
<ul>
<li>将所有小文件的top10结果合并（最多10万个IP）</li>
<li>再次统计，找出全局的top10</li>
</ul>
<p>时间复杂度：O(n)，空间复杂度：O(k)，其中k是单个分片的大小。</p>
<p>这种方法的核心思想是’分而治之’，确保相同IP在同一个分片中，这样就可以准确统计每个IP的总出现次数。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>刚开始思路不够清晰，被100G的数据量吓到了</li>
<li>经过面试官提示后理解了哈希分片的思路</li>
<li>需要加强大数据处理的算法思维</li>
</ul>
<h3 id="问题8：抽奖算法实现">问题8：抽奖算法实现</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“实现一个抽奖程序，有一个概率表：一等奖0.1，二等奖0.1，三等奖0.2，四等奖0.4，概率和是1。要求实现这个抽奖的算法，并且执行1万次抽奖，然后计算每个奖项的总和。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>[现场编程实现了基于随机数和概率累加的抽奖算法]</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;这个抽奖算法我用概率区间的方式来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lottery</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 概率表：[0.1, 0.1, 0.2, 0.4, 0.2]</span></span><br><span class="line">    probabilities := []<span class="type">float64</span>&#123;<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.2</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成0-1之间的随机数</span></span><br><span class="line">    rand := rand.Float64()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 累加概率，找到对应区间</span></span><br><span class="line">    cumulative := <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, prob := <span class="keyword">range</span> probabilities &#123;</span><br><span class="line">        cumulative += prob</span><br><span class="line">        <span class="keyword">if</span> rand &lt;= cumulative &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>  <span class="comment">// 返回奖项编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(probabilities) <span class="comment">// 兜底</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的时间复杂度是O(n)，其中n是奖项数量。如果奖项很多，可以用二分查找优化到O(log n)。</p>
<p>执行1万次的结果应该接近理论期望：一等奖约1000次，二等奖约1000次，三等奖约2000次，四等奖约4000次，五等奖约2000次。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>现场编程基本实现正确</li>
<li>考虑了算法的时间复杂度</li>
<li>可以进一步优化，比如预处理累积概率数组</li>
</ul>
<h3 id="问题9：Redis与gRPC">问题9：Redis与gRPC</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“Redis的持久化有什么方法？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“持久化的话它有两种，一种叫AOF，一种叫RDB。然后AOF的话，它相当于是记录到一个日志文件里面。它因为它AOF它全名叫append only file，它实际上是把每次请求，每次操作都给它加到一个日志文件里面去。RDB的话它相当于是一个镜像，它会把整个数据库全量给它保存下来，但它不会保存每次操作记录。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你项目里面有用到过gRPC对吧？说说gRPC和restful API的区别。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“对，gRPC的话首先它restful API的话他用的是HTTP协议，gRPC好像是RPC协议，还是他自己研发的一套协议，不太记得。但它肯定是RPC。首先RPC它是去掉了HTTP里面的一些东西的，所以说它的性能会更高一点，它更适合去做内网的通信什么的。所以说我们一般来说就是微服务之间调用都使用RPC协议。除非有的时候就比如说有别的公司想让你来调用他的微服务，但是他的RPC肯定不可能向你开放。那这个时候还是要使用restful API去调用他微服务，主要是考虑这个。就是内网和外网的区别。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你技术选型你是怎么怎么做的？就决定用这一套。以前做过类似的项目吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“以前就下面那一个叫AIGC的，它也是一个微服务项目。但是我一开始接触微服务的时候就是接触gRPC的，所以说我都是这么选的。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“抖音商城的技术栈和前面那个AIGC的项目技术栈里面有什么差异吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“抖音商城的技术栈的话它是比较丰富一点，但是AIGC的话它更多。因为现在AI它想要用户去响应的友好一点，他肯定是要用流式API去调用的。然后流式API在微服务中它可能就会有一些问题。然后就在AIGC微服务调用的时候，AIGC这个项目微服务调用的时候，它会使用server streaming去调用。就是他用流式去调用。主要是这一点区别，然后以及他他需要一个泛化调用，就是AIGC native它还有一个技术体现在泛化调用。”</p>
</blockquote>
<h3 id="问题10：MySQL数据引擎与库存问题">问题10：MySQL数据引擎与库存问题</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“mysql常用的数据引擎有哪些？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“首先是InnoDB，然后还有一个叫MyISAM，然后还有一个是好像是直接存到内存里面的一个引擎，具体名字我不太记得。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“Memory那个memory这个场景比较特殊，一般持久化的InnoDB和MyISAM它的特性有什么区别？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“InnoDB的话它主要是支持ACID特性。然后MyISAM的话它是不支持事务的，然后他好像也没有很强的一些锁之类能力。他应该主要面向于查询这个场景的一个引擎。像InnoDB的话的功能就比较完善，增删改查它都比较有比较好的性能。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“抖音商城里面不可避免的会有商品库存问题，这个库存问题你怎么解决的？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“首先我可以说一下，其实我们当时没有做库存这个东西，但是我有思路。库存的话它有好几种方式。一种就是在分布式系统里面，它有个叫分布式事务这个东西用分布式事务去给它扣减库存。然后还有一种方式是用Redis Lua脚本去扣减。这个的话是我的队员去实现，然后我看到他去这么实现，然后稍微看了一下。但是他最后因为我们当时分工的时候，就是他不知道没有库存这个东西，然后他实现了库存这个东西。然后的话我还有一些就是用Redis进行加锁。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“获取锁和释放锁分别是什么操作？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“这个有一点不太记得了，因为都是在函数里面去调用lock unlock方法。就前端是Hertz，叫前端是用的Gin。”</p>
</blockquote>
<h3 id="问题11：Web安全漏洞与个人背景">问题11：Web安全漏洞与个人背景</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“常见的外部开发里面的安全漏洞，这个有了解吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;常见的web开发安全漏洞，第一个SQL注入，这个漏洞的话基本上被现在因为用ORM框架用的比较多，所以基本上已经被基本上解决了。但是不排除一些公司他还在沿用那种字符串拼接的方式去对数据库进行操作。他我记得以前用PHP的时候，它有360的一个安全库，它可以做一个浅层的过滤，用一个正则表达式去做过滤。就是它会有各种各样的不安全的那些字符组合就用那种方式可以过滤。</p>
<p>然后XSS漏洞的话，XSS的漏洞主要就是其实他防范的就是防范主要是脚本。所以说现在的话我了解到最新的方式就是在HTTP请求的header头里面，它有一个header，你可以去给它开启。然后它就可以防范这个XSS的注入。它就可以即使你有XSS代码，但是它也会不允许你跳转到一些你不允许的网站里面去，这样就能一定程度上防范这个漏洞了。&quot;</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“比较早是多早？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我初三的时候就接触，当时在接触PHP。对，自己做网站。因为当时的时候也是为了攒钱，买一些自己想要的东西。就是当时很火的一些授权之类的。就是你做一个好的产品，然后你可以授权卖给别人。那是很早，大概13、14年。PHP估计两三年。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你的实习的时间是四月份开始，时长是多久？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“能一年吗？一年，因为我论文我基本上写的差不多了，我其实更想在公司里面学到更多的东西。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你玩游戏吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“玩过。基本上就平常偶尔玩一玩王者荣耀。因为平常的话主要还是在写代码，然后学累了我会玩一玩王者荣耀。星耀段位。我上过王者，很早之前。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>&quot;Web开发中常见的安全漏洞主要有：</p>
<ol>
<li>
<p>SQL注入：通过在输入中注入恶意SQL代码来操作数据库</p>
<ul>
<li>防范：使用预编译语句、参数化查询</li>
<li>对特殊字符进行转义</li>
</ul>
</li>
<li>
<p>XSS（跨站脚本攻击）：在页面中注入恶意脚本</p>
<ul>
<li>防范：对用户输入进行HTML转义</li>
<li>设置CSP（内容安全策略）头</li>
<li>使用HttpOnly cookie</li>
</ul>
</li>
<li>
<p>CSRF（跨站请求伪造）：利用用户登录状态进行恶意操作</p>
<ul>
<li>防范：使用CSRF token</li>
<li>验证Referer头</li>
<li>设置SameSite cookie属性</li>
</ul>
</li>
<li>
<p>文件上传漏洞：上传恶意文件执行代码</p>
<ul>
<li>防范：限制文件类型和大小</li>
<li>文件内容检查</li>
<li>存储在非执行目录</li>
</ul>
</li>
<li>
<p>权限控制漏洞：未正确验证用户权限</p>
<ul>
<li>防范：严格的权限校验</li>
<li>最小权限原则</li>
</ul>
</li>
</ol>
<p>在实际开发中，我们通常使用安全框架来防范这些漏洞，比如Spring Security、OWASP的安全组件等。&quot;</p>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“如果如果这是一个已经上线的业务，你去看一个slow query就有个慢查询的日志。你怎么分析这个表的索引有没有被用到。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我记得好像有一个叫explain命令。具体的字段忘了，具体字段忘了，它好像会显示用到哪些什么range之类的一些索引，但是具体的用的比较少，所以说我已经记不太清楚了。”</p>
</blockquote>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“现在这个场景稍微变一下，如果是以QQ号就是别的账号体系生成的账号为例，我们要设计抖音商城的一个用户访问数据。比如说我们要记录用户浏览商品的所有的日志，接到数据库，然后后面可能供数据挖掘去做商品推荐使用，这个流量会比较大，每天500万的浏览量。这个数据存储你怎么设计？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“这种一般是用数仓来存储的。首先我们所以引擎的话可能要改一下，改成那个MyISAM。因为它只有增和查这两个主要操作，所以说我们并不需要对它去改和删。所以说的话首先引擎这方面要变掉，然后其次的话表的设计。表的设计的话最好还是设计成一个表。就是用户相关信息，以及商品对应的关系，它都设计成一个表中，不要尽量不要进行多表关联，多表关联的话可能会比较消耗一些内存。考虑它的数据量级。怎么存？他这种数据量级的话，一般是要分库分表。根据浏览时间进行分表。比如说我们以一年为一个维度，我们可能会把它拆成12个月，然后每个月它有一个自己的表，或者说每一天他有一个单独的表。这样的话查询起来压力应该没有那么大了，就是存储起来压力应该就没有那么大了。”</p>
</blockquote>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本概念了解，但深度不够</li>
<li>需要更系统地学习Web安全知识</li>
<li>应该结合实际项目经验来回答</li>
<li>对大数据量处理有一定思路，但缺乏更深入的分库分表方案</li>
</ul>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中偏难</li>
<li><strong>面试官风格</strong>: 专业、耐心，会适当引导</li>
<li><strong>题目类型</strong>: 偏重实际应用，考察项目经验、系统设计、编程基础</li>
<li><strong>准备建议</strong>: 需要有实际的项目经验，对分布式系统、数据库优化要有深入理解</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官对项目经验比较认可，指出了一些技术深度不足的地方</li>
<li><strong>后续流程</strong>: 等待HR通知后续面试安排</li>
<li><strong>个人感受</strong>: 整体表现中等，项目经验是亮点，但技术深度还需加强</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ol>
<li><strong>项目经验丰富</strong>: 抖音青训营项目体现了完整的开发经验</li>
<li><strong>学习能力强</strong>: 体现了持续学习和技术广度探索的意愿</li>
<li><strong>沟通表达</strong>: 能够清晰表达技术思路，逻辑性较好</li>
</ol>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ol>
<li><strong>技术深度</strong>: 对分布式事务、数据库优化等深层技术理解不够</li>
<li><strong>系统设计</strong>: 海量数据处理等算法思维需要加强</li>
<li><strong>安全知识</strong>: Web安全漏洞的防范措施掌握不够全面</li>
</ol>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>深入学习分布式系统</strong>: 重点掌握分布式事务、一致性算法、服务治理</li>
<li><strong>数据库优化</strong>: 深入理解MySQL索引原理、查询优化、分库分表</li>
<li><strong>系统设计能力</strong>: 多练习大数据量处理、高并发系统设计</li>
<li><strong>安全知识</strong>: 系统学习OWASP Top 10，了解常见安全防护措施</li>
<li><strong>算法基础</strong>: 加强海量数据处理、分治算法等基础算法能力</li>
</ol>
<h3 id="知识点复习清单">知识点复习清单</h3>
<ul>
<li>[ ] 分布式事务（2PC、TCC、SAGA）</li>
<li>[ ] MySQL索引优化和联合索引原理</li>
<li>[ ] Redis持久化机制和分布式锁</li>
<li>[ ] 微服务架构设计模式</li>
<li>[ ] Web安全漏洞防护</li>
<li>[ ] 海量数据处理算法</li>
<li>[ ] 系统性能优化策略</li>
</ul>
<h3 id="对IEG运营开发岗位的理解">对IEG运营开发岗位的理解</h3>
<p><strong>面试官介绍</strong>：</p>
<blockquote>
<p>&quot;我们部门比较大，部门整应该说我们部门负责的是腾讯互娱，互娱也就是我们那个互动娱乐运营。你别说他现在叫IEG，腾讯的工作室群划分，这个你知道对吧？腾讯云对微信，大概分这么几个BG。IEG就是可以统称腾讯互娱，所有的游戏相关的都在这个事业群。然后我们部门的话是在IEG之下做游戏核心玩法以外的一些周边的系统工具运营活动等等。相关的项目可能都在我们这儿。那游戏工作室的话就很好理解，他们做游戏本身，游戏玩法就是客户端。</p>
<p>然后除了你能玩到的那个游戏本身的东西，还会有一些做运营的相关的方向。比如说王者荣耀，你如果玩过就应该知道它里面经常会看到一些活动。比如说那个皮肤返场、投票、领奖，就你参与投票或者是投稿一些比赛赛事等等，这种活动都会有一些奖励。这种活动类的大多数是我们做的。王者的运营开发就在我们团队，对，运营开发就在我们团队。我们这负责是准确的说是天美的所有的游戏运营开发都在我们这。</p>
<p>项目的话比较杂，除了除了核心玩法以外，它的那些工具系统。比如说我们有可能会做一些运营活动，以运营活动为主，大头是这个。还有一部分是像比如说策划用的一些工具，系统都有可能是我们来做。</p>
<p>项目最多的是运营活动类的。运营活动类王者里面你能看到很多，他里面现在是用这种叫游戏内的一种仿原生的开发技术。王者本身它是unity开发客户端，用U引擎的。但我们可以往里面去往游戏里面去嵌H5的。就这种web的活动页面也可以用那个原生的仿原生的一种。我们自己我们部门自己做了一种引擎去做那个支持热更的这种原生活动，对比王者项目组自己做的话，这种就更新，还有开发效率方面会更高。然后他试验成本会相对低一些，因为他们自己做的话，用unity去做发版本这种会比较麻烦。这是我们叫我们自己叫他那个潘多拉的框架，这个是端内的原生项目。</p>
<p>然后还有一些是外部开发的项目，有一些是小程序的项目，大概是这样。但小程序我们倒不用自己做纯页面部分，一般的H5和小程序的页面的切图和重构会有专人来做。我们会负责去做后端的功能，以及把这个页面和功能整合起来。就写一部分JS，大概是这样。&quot;</p>
</blockquote>
<p>面试官详细介绍了岗位职责：主要负责腾讯游戏（特别是天美工作室群）的运营活动开发，包括：</p>
<ul>
<li>游戏内活动页面开发（H5、小程序、原生）</li>
<li>运营工具系统开发</li>
<li>后端服务和数据处理</li>
<li>技术栈偏全栈，需要一定的前端能力</li>
<li>使用自研的潘多拉框架支持热更新</li>
</ul>
<p>这个岗位很适合希望在技术广度上发展的同学，能接触到游戏行业的业务场景，技术挑战也比较丰富。特别是对于亿级用户量的游戏活动，在高并发和数据处理方面都有很高的技术要求。</p>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>一面</tag>
        <tag>腾讯</tag>
        <tag>运营开发</tag>
        <tag>IEG</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯IEG 运营开发工程师 二面</title>
    <url>/2025/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/%E8%85%BE%E8%AE%AF/2025-03-26-%E8%85%BE%E8%AE%AFIEG-%E8%BF%90%E8%90%A5%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: 腾讯IEG（互动娱乐事业群）</li>
<li><strong>职位</strong>: 运营开发工程师（日常实习）</li>
<li><strong>面试轮次</strong>: 二面（技术面）</li>
<li><strong>面试形式</strong>: 线上视频面试（腾讯会议）</li>
<li><strong>面试时长</strong>: 约50分钟</li>
<li><strong>面试官</strong>: 技术leader，比较友善专业</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：水杯量水（逻辑思维题）">问题1：水杯量水（逻辑思维题）</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你手上有两个水杯，都是没有刻度的，一个三升，还有一个是五升。你还有大量的水，怎么用最快的方式量出四升的水？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“首先先往这个三毫升的水里面装满，三毫升的杯子里面装满水，然后再倒到这个五毫升的水里面，然后再把这个就是现在5毫升的杯子里面有三毫升的水了。然后再再把这个三毫升的装满。装满以后再把这个3毫升的杯子里面水倒满，倒到5毫升的杯子里面倒满。然后5毫升的杯子满了，那3毫升的杯子里面就只剩一毫升的水了。然后再把5毫升的杯子里面水全都倒掉，然后再把这个三毫升杯子里面的那个一毫升的水给倒到5毫升的杯子里面，最后再把这个3毫升的杯子装满，然后装满然后再倒到5毫升的杯子里面，这样就可以实现了。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题回答得还不错。具体步骤是：</p>
<ol>
<li>先把3升杯子装满，倒入5升杯子（5升杯子里有3升水）</li>
<li>再把3升杯子装满，继续倒入5升杯子直到满（3升杯子里剩1升水）</li>
<li>把5升杯子的水全部倒掉，把3升杯子里的1升水倒入5升杯子</li>
<li>再把3升杯子装满，倒入5升杯子（1+3=4升）</li>
</ol>
<p>这样就得到了4升水。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>思路正确，步骤也对</li>
<li>表达稍微有些啰嗦，可以更简洁些</li>
</ul>
<h3 id="问题2：博弈论问题（苹果抢夺游戏）">问题2：博弈论问题（苹果抢夺游戏）</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“在一个课桌上有100个苹果。我和你轮流拿，每人每次拿的苹果数量是1到5。你来设计一个策略，保证第100个苹果，也就是最后一个苹果一定是你能拿到的。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我要确保我拿完以后，最后剩下的苹果数模六是等于一的…比如说我有N个苹果，然后我第一次拿四个，然后之后对方无论拿多少个，无论拿多少个，比如说对方拿七个，那我都一定拿6减7个。这样就一定能保证我会最后获胜。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个是经典的博弈论问题。正确的策略是：</p>
<p>首先分析获胜条件：要想拿到最后一个苹果，就要保证轮到对方拿的时候，剩余苹果数是6的倍数。</p>
<p>因为每次最多拿5个，最少拿1个，所以如果剩6个苹果轮到对方，无论他拿几个（1-5个），我都能通过拿对应数量的苹果（5-1个）来保证拿到最后一个。</p>
<p>具体策略：</p>
<ol>
<li>100 ÷ 6 = 16…4，所以第一次我拿4个，剩96个</li>
<li>之后无论对方拿几个（1-5个），我都拿对应的数让两人这轮总共拿6个</li>
<li>这样每轮结束后，剩余苹果数都是6的倍数</li>
<li>最终轮到对方时剩6个，我必胜</li>
</ol>
<p><strong>总结反思</strong>：</p>
<ul>
<li>思路方向对了，但一开始说成了&quot;模5等于1&quot;</li>
<li>经过面试官提示逐步找到了正确答案</li>
<li>这类题目需要从终局往前推理</li>
</ul>
<h3 id="问题3：编程题（最长连续递增子序列）">问题3：编程题（最长连续递增子序列）</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“写个算法求出字符串的最长连续递增子序列，要把这个子序列输出出来，字符串是A到Z的小写字母。”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我印象中是用DP，然后如果说发现他这一个右边那个元素，就是小于前面的一个元素了，那就是需要回溯一下，然后继续重新进行那个DP。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>其实这题用DP可能把问题复杂化了，有更简单的思路：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestIncreasingSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maxLength := <span class="number">1</span></span><br><span class="line">    maxStart := <span class="number">0</span></span><br><span class="line">    currentLength := <span class="number">1</span></span><br><span class="line">    currentStart := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] &gt; s[i<span class="number">-1</span>] &#123; <span class="comment">// 连续递增</span></span><br><span class="line">            currentLength++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 重新开始</span></span><br><span class="line">            <span class="keyword">if</span> currentLength &gt; maxLength &#123;</span><br><span class="line">                maxLength = currentLength</span><br><span class="line">                maxStart = currentStart</span><br><span class="line">            &#125;</span><br><span class="line">            currentLength = <span class="number">1</span></span><br><span class="line">            currentStart = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查最后一段</span></span><br><span class="line">    <span class="keyword">if</span> currentLength &gt; maxLength &#123;</span><br><span class="line">        maxLength = currentLength</span><br><span class="line">        maxStart = currentStart</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s[maxStart : maxStart+maxLength]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 测试用例</span></span><br><span class="line">    test := <span class="string">&quot;abcxyzdeghi&quot;</span></span><br><span class="line">    result := longestIncreasingSubstring(test)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;输入: %s\n&quot;</span>, test)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;最长连续递增子序列: %s\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路就是：设置一个最大长度记录器，遍历字符串，如果下一个字符比前一个大就继续，否则重新开始计数，并更新最大值。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>方向想复杂了，其实是比较基础的算法题</li>
<li>现场没有写出代码，说明基础算法需要加强</li>
<li>应该多练习这类字符串处理题目</li>
</ul>
<h3 id="问题4：项目经验（抖音商城系统）">问题4：项目经验（抖音商城系统）</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“您这边有做过比较有价值的一个项目，能够两分钟给我介绍一下背景，还有你在里面做的一些事情？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“比较有技术含量的应该是这个抖音商城。这个项目最大的挑战是Casbin权限管理框架的缓存一致性问题。我定义了两个Casbin对象，但是这两个对象并没有真的去同步他们的缓存数据。最后解决的方法就是把整个项目中Casbin只允许初始化一次，使用单例模式解决了这个问题。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>项目介绍可以更结构化一些：</p>
<ol>
<li>
<p><strong>项目背景</strong>：这是抖音青训营的团队项目，基于微服务架构开发的电商系统，我主要负责整体架构设计和技术选型。</p>
</li>
<li>
<p><strong>技术架构</strong>：使用Go语言+微服务架构，集成了服务发现、配置中心、消息队列、分布式缓存等组件，还实现了CICD自动化部署。</p>
</li>
<li>
<p><strong>技术难点</strong>：主要是Casbin权限管理的缓存一致性问题。Casbin在内存中维护策略缓存，当我创建多个Casbin实例时，出现了缓存不同步的问题。最终通过单例模式确保全局只有一个Casbin实例，解决了缓存一致性问题。</p>
</li>
<li>
<p><strong>其他亮点</strong>：还实现了Redis+MySQL的分级存储、Canal+MQ的数据同步、基于Redis Lua脚本的分布式锁等。</p>
</li>
</ol>
<p><strong>总结反思</strong>：</p>
<ul>
<li>项目经验还算丰富，但表达可以更有条理</li>
<li>对技术细节的理解还不够深入</li>
</ul>
<h3 id="问题5：高并发场景（库存超卖问题）">问题5：高并发场景（库存超卖问题）</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“在高并发情况下，比如说库存是100，但是高并发大家一起过来买，有可能会出现超卖的情况。这种问题你当时在设计的时候怎么解决？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我们使用了Redis的Lua脚本，然后去给库存去进行加锁…使用了Redis里面的SET NX命令进行加锁，因为Redis本身是单线程的，所以一旦对库存进行加锁以后，别的请求其实是会被拒绝的。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>超卖问题确实是高并发场景下的经典问题，解决方案有几种：</p>
<ol>
<li>
<p><strong>Redis原子操作</strong>：使用Redis的DECR命令，因为Redis是单线程的，可以保证原子性。先检查库存是否充足，再减库存。</p>
</li>
<li>
<p><strong>Lua脚本</strong>：把检查库存和减库存的逻辑写在一个Lua脚本里，Redis会原子性地执行整个脚本：</p>
</li>
</ol>
<p>Lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;stock&#x27;</span>) &gt;= <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;decrby&#x27;</span>, <span class="string">&#x27;stock&#x27;</span>, ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Go语言调用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decreaseStock</span><span class="params">(rdb *redis.Client, quantity <span class="type">int</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    luaScript := <span class="string">`</span></span><br><span class="line"><span class="string">        if redis.call(&#x27;get&#x27;, KEYS[1]) &gt;= tonumber(ARGV[1]) then</span></span><br><span class="line"><span class="string">            return redis.call(&#x27;decrby&#x27;, KEYS[1], ARGV[1])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return -1</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    </span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    result, err := rdb.Eval(ctx, luaScript, []<span class="type">string</span>&#123;<span class="string">&quot;stock&quot;</span>&#125;, quantity).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result.(<span class="type">int64</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr: <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试减少库存</span></span><br><span class="line">    remaining, err := decreaseStock(rdb, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;减库存失败: %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> remaining == <span class="number">-1</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;库存不足&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;减库存成功，剩余库存: %d\n&quot;</span>, remaining)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p><strong>数据库层面</strong>：使用乐观锁（版本号）或悲观锁（SELECT FOR UPDATE）。</p>
</li>
<li>
<p><strong>分布式锁</strong>：使用Redis实现分布式锁，但性能会有损失。</p>
</li>
</ol>
<p>其中Redis + Lua脚本是比较好的方案，既保证了原子性，性能也不错。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>知道用Redis和Lua脚本的思路是对的</li>
<li>但对具体实现细节不够清楚</li>
<li>需要深入理解Redis原子操作的原理</li>
</ul>
<h3 id="问题6：监控告警系统">问题6：监控告警系统</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你们做了一些监控和告警的功能，监控哪些指标？监控日志是监控的什么指标？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“我们是直接接入了OpenTelemetry，监控QPS指标，但QPS我们没有做告警。还有监控日志，日志监控只是为了去排查问题…我们告警主要是黑名单这一块，使用Redis进行QPS限制，如果一个用户一秒内请求超过十次，就会调用黑名单功能禁用这个用户。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>监控告警系统通常包括以下几个方面：</p>
<ol>
<li>
<p><strong>应用层监控</strong>：</p>
<ul>
<li>QPS/TPS：每秒请求数/事务数</li>
<li>响应时间：平均响应时间、P99响应时间</li>
<li>错误率：4xx、5xx错误比例</li>
<li>接口可用性</li>
</ul>
</li>
<li>
<p><strong>系统层监控</strong>：</p>
<ul>
<li>CPU使用率、内存使用率</li>
<li>磁盘IO、网络IO</li>
<li>数据库连接数</li>
</ul>
</li>
<li>
<p><strong>业务层监控</strong>：</p>
<ul>
<li>用户访问量、转化率</li>
<li>业务操作成功率</li>
<li>资金安全相关指标</li>
</ul>
</li>
<li>
<p><strong>日志监控</strong>：</p>
<ul>
<li>错误日志数量和频率</li>
<li>关键业务操作日志</li>
<li>安全相关日志（登录失败、异常访问等）</li>
</ul>
</li>
</ol>
<p>告警策略应该基于阈值设置，比如错误率超过5%、响应时间超过1秒等。</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对监控的理解比较浅层，主要停留在工具使用层面</li>
<li>缺乏对监控体系的系统性理解</li>
<li>应该学习更多监控告警的最佳实践</li>
</ul>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中，主要考察基础能力和项目经验</li>
<li><strong>面试官风格</strong>: 比较友善，会给提示引导思考</li>
<li><strong>题目类型</strong>: 逻辑思维+编程+项目经验，比较全面</li>
<li><strong>准备建议</strong>: 需要加强基础算法和深入理解项目技术细节</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官表示技术项目还是很扎实的</li>
<li><strong>后续流程</strong>: 表示还在招聘中，需要等对比结果</li>
<li><strong>个人感受</strong>: 整体发挥一般，算法题没答出来比较遗憾</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ul>
<li>项目经验比较丰富，技术栈涉及面广</li>
<li>逻辑思维题思路清晰，能在提示下找到答案</li>
<li>对微服务、分布式有一定理解</li>
</ul>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ul>
<li>基础算法能力需要加强，编程题完全没写出来</li>
<li>对项目中技术细节的理解不够深入</li>
<li>表达可以更有条理，回答更简洁</li>
</ul>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>算法刷题</strong>：LeetCode中等难度题目要熟练掌握</li>
<li><strong>项目深挖</strong>：对简历中的项目要能深入到源码层面</li>
<li><strong>基础巩固</strong>：Redis、MySQL、微服务等核心技术要深入理解</li>
<li><strong>系统设计</strong>：多了解高并发、分布式系统的经典问题和解决方案</li>
</ol>
<h3 id="知识点复习">知识点复习</h3>
<ul>
<li>水杯量水等经典逻辑题</li>
<li>博弈论基础问题</li>
<li>字符串处理算法（滑动窗口、双指针）</li>
<li>Redis原子操作和Lua脚本</li>
<li>分布式系统中的缓存一致性问题</li>
<li>监控告警系统设计</li>
<li>高并发场景下的常见问题（超卖、缓存击穿等）</li>
</ul>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>腾讯</tag>
        <tag>运营开发</tag>
        <tag>二面</tag>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云CSIG 后端开发实习 一面</title>
    <url>/2025/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/%E8%85%BE%E8%AE%AF/2025-06-11-%E8%85%BE%E8%AE%AF%E4%BA%91-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0-%E4%B8%80%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: 腾讯云CSIG（机器学习平台部门）</li>
<li><strong>职位</strong>: 后端开发实习生</li>
<li><strong>面试轮次</strong>: 一面（技术面）</li>
<li><strong>面试形式</strong>: 腾讯会议面试（不需要开视频）</li>
<li><strong>面试时长</strong>: 约20分钟</li>
<li><strong>面试官</strong>: 技术人员，负责AI/大模型训练平台相关开发</li>
<li><strong>面试时间</strong>: 2025年06月11日 下午07点58分</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：自我介绍">问题1：自我介绍</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“要不你先给我先介绍一下你这边的项目经理”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“面试官你好，我是王宇哲，然后是华东师范大学软件工程硕士，研究方向是加密信息检索。然后本科三年专业第一，获得过国家奖学金和蓝桥国赛二等奖。简历上的项目主要是通过go编写的分布式应用。第一个项目的话是独立实现的分布式缓存项目，它的单点性能能超过5000QPS，然后采用了一致性哈希算法实现了数据切片。然后通过ETCD做服务发现，用gRPC去做通信，并实现了防缓存击穿的single fly机制。第二个项目的话是微服务架构的抖音商城系统，然后负责整体架构设计以及70%以上的代码开发任务。使用github action自动部署上云。集成open telemetry去实现了可观测性，然后通过分布式锁去解决了超卖问题。然后用canal加消息队列实现了mysql、redis、elasticsearch这三个数据库的同步。第三个项目的话是AI网关项目。然后思路上实现有点像现在比较火的MCP。然后它能够根据用户输入提示词去规划任务，然后通过RPC去调用对应的微服务的对应接口。然后我设计了多代理分层的方式去调度，减少了上下文窗口带来的遗忘问题。然后提高了任务的准确度，并通过泛化调用来实现AI层与实际函数层的解耦。然后最近的话也为开源项目mineru（一个30k star的开源项目）贡献了自己编写的MCP的代码。平常的话我对各种AI工具熟练使用，比如cursor之类的。然后对于现代前沿的AI技术和理念也有所了解，也熟练使用各种AI去组合出一套开发流程来快速开发。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>自我介绍部分回答很完整，涵盖了教育背景、项目经验和技术特长。建议可以更加简洁一些，突出重点：</p>
<p>“您好，我是王宇哲，华东师范大学软件工程硕士，主要专注于Go语言后端开发。我有三个比较有代表性的项目：首先是分布式缓存系统，单点QPS超过5000，使用了一致性哈希和ETCD服务发现；然后是微服务电商系统，负责架构设计和大部分开发工作，集成了可观测性和分布式锁；最后是AI网关项目，类似MCP模式，能够根据提示词智能调度微服务。最近也为mineru开源项目贡献了MCP代码。我比较熟悉AI工具辅助开发，对现代后端技术栈有深入理解。”</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>项目介绍比较详细，展现了技术广度</li>
<li>面试官对mineru项目感兴趣，进行了追问</li>
<li>自我介绍略长，可以更加精炼</li>
</ul>
<h3 id="问题2：编程题-合并两个有序数组">问题2：编程题 - 合并两个有序数组</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“写一个简单的，合并两个有序数组”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>当时在在线编辑器中实现了合并两个有序数组的算法，面试官确认不需要开辟新空间，要求原地合并到第一个数组中。</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这是一个经典的双指针问题。由于要求原地合并，可以这样思考：</p>
<p>&quot;这个题目的关键是要原地合并，不能开辟新空间。我的思路是从后往前填充，这样不会覆盖还没处理的元素。</p>
<p>具体实现是用三个指针：i指向nums1的有效元素末尾，j指向nums2的末尾，k指向nums1的真实末尾。然后比较nums1[i]和nums2[j]，把较大的放到nums1[k]位置，然后相应指针前移。</p>
<p>这样时间复杂度是O(m+n)，空间复杂度是O(1)，满足原地合并的要求。&quot;</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="type">int</span>, m <span class="type">int</span>, nums2 []<span class="type">int</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    i, j, k := m<span class="number">-1</span>, n<span class="number">-1</span>, m+n<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt; nums2[j] &#123;</span><br><span class="line">            nums1[k] = nums1[i]</span><br><span class="line">            i--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        k--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结反思</strong>：</p>
<ul>
<li>编程过程中出现了一些小错误，需要调试</li>
<li>面试官耐心等待并给予了提示</li>
<li>应该先想清楚思路再开始编写</li>
</ul>
<h3 id="问题3：Go语言垃圾回收机制">问题3：Go语言垃圾回收机制</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你知道Go现在它的那个垃圾回收机制是什么样子的？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“他现在的话最新的我没有去了解，但是的话再往前一点，我不知道最新有没有去更新。但再往前一点的话，是更新到了三色标记法加那个读写屏障。然后三色标记法的话，我的理解就是…他应该是18和19版本以后就是更新的这个三色标记法加读写屏障。然后他这个读写屏障的话相当于之前的话他会去从主函数开始，以及堆顶开始，一个个去遍历所有便利标记那些可以被访问到的那些对象，然后再把未标记的全都删掉。以前是这样的，但是会发现这样的话会有一个叫stop the world，就是它会需要把整个程序暂停，然后去进行这样的垃圾回收。这样的话是很影响性能的。于是他就想出了一个三色标记法，然后这样就可以和那个程序去并行的，在程序运行过程中并行的去进行垃圾回收。这样就感受不到那种卡顿了。它相当于好像是先用一个颜色，我是不太记得了。但是的话先是所有对象是白色，然后它会他好像是白色，然后他会把所有的主函数中直接能获取到的对象，就堆顶能直接混淆的对象标记为黑色。然后在每一通过这个黑色的对象再往下遍历，然后遍历完便利后的对象应该会被标记为。标记为灰色，然后标记为灰色对象。我想一想…”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Go的垃圾回收确实是基于三色标记法，我来系统地说一下：</p>
<p>&quot;Go目前使用的是三色标记清除算法配合写屏障。三色指的是白色、灰色、黑色三种状态：</p>
<p>白色对象：未被标记的对象，垃圾回收结束后会被清理<br>
灰色对象：已被标记但其引用的对象还未完全扫描的对象<br>
黑色对象：已被标记且其引用的对象都已扫描完成的对象</p>
<p>具体流程是这样的：首先从GC Root开始，把直接可达的对象标记为灰色。然后不断地取出灰色对象，把它标记为黑色，同时把它引用的白色对象标记为灰色。当没有灰色对象时，所有白色对象就是垃圾，可以清理了。</p>
<p>写屏障的作用是在并发标记过程中，如果程序修改了指针引用，会触发屏障函数，确保新的引用关系被正确处理，避免错误回收。</p>
<p>这样就实现了并发垃圾回收，大大减少了STW时间，提高了程序性能。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对概念有基本了解，但表达不够清晰</li>
<li>细节记忆模糊，应该更系统地复习</li>
<li>面试官看出了我的不确定，及时转换了话题</li>
</ul>
<h3 id="问题4：Go语言Map实现">问题4：Go语言Map实现</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“比如说你那个Go的map，它是怎么实现的？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“map它底层是用一个哈希表去实现的。然后怎么说呢？就它一开始的长度为零，然后它会每次往里面添加元素的时候，它会如果说超出了它的容量，它会去扩增。然后每次乘2，然后到好像1024的时候，他就后面不是乘2了。后1024以后就每次会增加1024个元素的存储空间，好像是这样。”</p>
</blockquote>
<p><strong>面试官追问</strong>：</p>
<blockquote>
<p>“那你了解他现在那些碰撞算法是怎么实现的吗？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“碰撞算法如果它碰撞了之后，它会…Go中的我没有去了解，但是我大概知道几种碰撞，一种就是哈希表碰撞解决办法一般第一种叫好像什么开放寻址法之类的。他有些会就是往后就往后一个个去找。然后还有一些的话，他就是会先往右一格，就是这一个如果说发生碰撞的话，那它就会到这个索引加一的位置再找。然后如果说再找再被占用的话，到加1，然后再到加2这样去查找。然后还有一种的话就是一直往后找，就index一直加1加1加1。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Go的map实现确实比较复杂，我来详细说明一下：</p>
<p>&quot;Go的map底层是哈希表，具体实现上使用的是拉链法解决冲突。它的数据结构包含buckets数组，每个bucket可以存储8个key-value对。</p>
<p>当发生哈希冲突时，Go不是用开放寻址法，而是用拉链法。如果一个bucket满了，会创建overflow bucket链接到后面。这样相同哈希值的元素会形成一个链表结构。</p>
<p>关于扩容机制，Go map有两种扩容方式：</p>
<ol>
<li>翻倍扩容：当负载因子超过6.5时触发，bucket数量翻倍</li>
<li>等量扩容：当overflow bucket过多时触发，重新整理数据但不增加bucket数量</li>
</ol>
<p>扩容是渐进式的，不是一次性完成，而是在每次访问时逐步迁移，这样避免了长时间阻塞。</p>
<p>还有一个重要特性是map遍历是随机的，这是Go故意设计的，为了防止开发者依赖遍历顺序。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对基本原理有了解，但细节不够准确</li>
<li>混淆了Go实际使用的碰撞解决方案</li>
<li>应该区分不同语言的哈希表实现差异</li>
</ul>
<h3 id="问题5：Go语言反射机制">问题5：Go语言反射机制</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“那个Go它那个反射它是怎么去实现的？比如说Go那个struct里面，它不是有可以定义一些那个type，对吧？比如说你marshal的时候，你知道那个type怎么实现的？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“不太了解Go的底层，我没有太研究过，主要是编程应用。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>这个问题考察的是Go反射的底层实现，确实比较深入：</p>
<p>&quot;Go的反射是基于interface{}的底层实现来实现的。每个interface{}实际上包含两个指针：一个指向类型信息（type），一个指向具体数据（data）。</p>
<p>Go的类型系统中，每个类型都有一个runtime.Type结构，包含了类型的元数据信息，比如类型名称、方法列表、字段信息等。</p>
<p>当我们使用reflect.TypeOf()时，实际上是获取了interface{}中的类型信息部分。reflect.ValueOf()则是获取了数据部分，并提供了一系列方法来操作这个值。</p>
<p>对于struct的tag，比如json标签，这些信息是存储在类型的元数据中的。编译器会把这些tag信息编译到二进制文件中，运行时通过反射可以读取到这些信息。</p>
<p>marshal/unmarshal的过程就是：先通过反射获取类型信息和tag信息，然后根据tag规则进行序列化和反序列化。</p>
<p>这就是为什么反射会有性能开销，因为需要在运行时查找和解析这些元数据信息。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>承认不了解比直接乱答要好</li>
<li>这是一个比较深入的问题，需要对Go运行时有深入理解</li>
<li>可以平时多关注一些底层实现的文章</li>
</ul>
<h3 id="问题6：缓存过期机制">问题6：缓存过期机制</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你你你那个缓存是吧？缓存它过期是怎么实现的？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“缓存过期的话，我是模仿那个redis里面的。然后我看那个缓存过期的时候，我并不会直接将它删除，而是等下一次再访问这个缓存的时候。就每次访问缓存之前，我会去判断一下。不访问的话，他后台会有一个协程去监听，然后就是会定期去清理，就是全局去查找，然后去清理过期的那些缓存。但是这种方式其实也是有优化的，但我还没有做优化，因为全局清理的话会比较耗时间。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>缓存过期机制的实现思路是对的，可以更详细地说明一下：</p>
<p>&quot;我实现的缓存过期机制主要采用了两种策略，参考了Redis的设计：</p>
<p>第一种是惰性删除：当客户端访问某个key时，先检查是否过期，如果过期就删除并返回空值。这种方式的优点是不会浪费CPU资源，缺点是如果某些key一直不被访问，就会一直占用内存。</p>
<p>第二种是定期删除：启动一个后台协程，定期扫描所有key，删除过期的key。为了避免一次性扫描所有key导致性能问题，我采用了分批处理的方式。</p>
<p>更好的优化方案可以考虑：</p>
<ol>
<li>随机采样：每次只检查一部分key，而不是全量扫描</li>
<li>时间轮算法：按过期时间对key进行分组，减少检查频率</li>
<li>LRU淘汰：当内存不足时，主动淘汰最久未使用的key</li>
</ol>
<p>这样既能保证过期key及时清理，又不会对系统性能造成太大影响。&quot;</p>
<p><strong>总结反思</strong>：</p>
<ul>
<li>基本思路正确，参考了Redis的实现</li>
<li>意识到了性能优化的问题</li>
<li>可以进一步了解更多优化策略</li>
</ul>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中，主要考察Go语言基础和系统设计思维</li>
<li><strong>面试官风格</strong>: 比较友善，会给予提示和引导</li>
<li><strong>题目类型</strong>: 基础概念 + 编程实现 + 项目经验</li>
<li><strong>准备建议</strong>: 重点复习Go语言特性、数据结构实现和分布式系统概念</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官询问了实习时间安排，表示可以接受</li>
<li><strong>后续流程</strong>: 面试官表示会安排后续通知</li>
<li><strong>个人感受</strong>: 整体表现中等，有些基础概念需要加强</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ul>
<li>自我介绍比较全面，项目经验丰富</li>
<li>编程题最终实现正确，思路清晰</li>
<li>对于不了解的问题诚实回答，没有强行回答</li>
</ul>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ul>
<li>Go语言基础概念掌握不够深入，特别是底层实现</li>
<li>表达时有些卡顿，逻辑性有待提高</li>
<li>对于垃圾回收等核心概念应该更加准确</li>
</ul>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>Go语言基础</strong>: 深入学习GMP模型、垃圾回收、map实现等核心概念</li>
<li><strong>系统设计</strong>: 加强对分布式系统、缓存策略的理解</li>
<li><strong>算法实现</strong>: 多练习双指针、数组操作等基础算法</li>
<li><strong>表达能力</strong>: 提前准备技术概念的标准表述，避免口语化过重</li>
</ol>
<h3 id="重要知识点复习">重要知识点复习</h3>
<ul>
<li>Go语言三色标记垃圾回收算法</li>
<li>Go map的底层实现和扩容机制</li>
<li>Go反射的实现原理</li>
<li>缓存过期策略设计</li>
<li>分布式系统常见问题和解决方案</li>
</ul>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>一面</tag>
        <tag>后端开发</tag>
        <tag>实习</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 133 - 克隆图（Clone Graph）</title>
    <url>/2025/06/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你无向<strong>连通</strong>图中一个节点的引用，请你返回该图的<strong>深拷贝</strong>（克隆）。</p>
<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例格式">测试用例格式</h3>
<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>
<p><strong>邻接列表</strong>是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>
<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将<strong>给定节点的拷贝</strong>作为对克隆图的引用返回。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和节点 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和节点 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和节点 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和节点 3 。</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/1750518091470.png" alt="1750518091470"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：adjList = [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-133-%E5%85%8B%E9%9A%86%E5%9B%BE/1750518114187.png" alt="1750518114187"></p>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：adjList = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>节点数不超过 100</li>
<li><code>1 &lt;= Node.val &lt;= 100</code></li>
<li>每个节点值 <code>Node.val</code> 都是唯一的</li>
<li>无向图</li>
<li>图是连通的，你可以从给定节点访问到所有节点</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这是一个<strong>图的深拷贝</strong>问题，核心挑战在于处理图中的<strong>环形引用</strong>。如果直接递归复制，会陷入无限循环。</p>
<h3 id="核心思路">核心思路</h3>
<p><strong>使用深度优先搜索（DFS）+ 哈希表</strong>来解决：</p>
<ol>
<li><strong>哈希表记录映射关系</strong>：用 <code>visited</code> 哈希表记录原节点到克隆节点的映射关系</li>
<li><strong>避免重复访问</strong>：如果节点已经被访问过，直接返回对应的克隆节点</li>
<li><strong>递归构建邻居关系</strong>：对每个邻居节点递归调用克隆函数</li>
</ol>
<h3 id="关键洞察">关键洞察</h3>
<p><strong>访问标记的时机至关重要</strong>：必须在开始处理邻居之前就建立原节点到克隆节点的映射关系，而不是在处理完邻居之后。这样可以避免在处理环形引用时出现无限递归。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li><strong>边界处理</strong>：如果输入节点为空，直接返回 <code>nil</code></li>
<li><strong>检查是否已访问</strong>：如果当前节点已经在 <code>visited</code> 中，说明已经克隆过，直接返回克隆节点</li>
<li><strong>创建克隆节点</strong>：创建一个新节点，值与原节点相同，邻居列表为空</li>
<li><strong>⭐ 关键步骤</strong>：立即将原节点和克隆节点的映射关系存入 <code>visited</code></li>
<li><strong>递归处理邻居</strong>：遍历原节点的所有邻居，递归调用克隆函数，将返回的克隆邻居添加到当前克隆节点的邻居列表中</li>
<li><strong>返回克隆节点</strong></li>
</ol>
<h3 id="为什么要先建立映射关系？">为什么要先建立映射关系？</h3>
<p>考虑这样的图结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ---- 2</span><br><span class="line">|      |</span><br><span class="line">|      |</span><br><span class="line">4 ---- 3</span><br></pre></td></tr></table></figure>
<p>如果我们在处理完邻居后才建立映射：</p>
<ol>
<li>克隆节点 1，开始处理其邻居节点 2 和 4</li>
<li>递归克隆节点 2，开始处理其邻居节点 1 和 3</li>
<li>递归克隆节点 1（又回到了节点 1！）</li>
<li>因为节点 1 还没有在 <code>visited</code> 中建立映射，会重新开始克隆过程</li>
<li><strong>无限递归</strong>！</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<h3 id="正确实现">正确实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cloneGraph</span><span class="params">(node *Node)</span></span> *Node &#123;</span><br><span class="line">    visited := <span class="keyword">map</span>[*Node]*Node&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(cur *Node)</span></span> *Node</span><br><span class="line">    </span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(cur *Node)</span></span> *Node &#123;</span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经访问过，直接返回克隆节点</span></span><br><span class="line">        <span class="keyword">if</span> clonedNode, ok := visited[cur]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> clonedNode</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建克隆节点</span></span><br><span class="line">        clonedNode := &amp;Node&#123;cur.Val, []*Node&#123;&#125;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⭐ 关键：立即建立映射关系！</span></span><br><span class="line">        visited[cur] = clonedNode</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归处理所有邻居</span></span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> cur.Neighbors &#123;</span><br><span class="line">            clonedNode.Neighbors = <span class="built_in">append</span>(clonedNode.Neighbors, dfs(neighbor))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> clonedNode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误实现分析">错误实现分析</h3>
<p>❌ <strong>错误的代码</strong>（将 <code>visited[cur] = clonedNode</code> 放在最后）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cloneGraph</span><span class="params">(node *Node)</span></span> *Node &#123;</span><br><span class="line">    visited := <span class="keyword">map</span>[*Node]*Node&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(cur *Node)</span></span> *Node</span><br><span class="line">    </span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(cur *Node)</span></span> *Node &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> clonedNode, ok := visited[cur]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> clonedNode</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        clonedNode := &amp;Node&#123;cur.Val, []*Node&#123;&#125;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归处理所有邻居</span></span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> cur.Neighbors &#123;</span><br><span class="line">            clonedNode.Neighbors = <span class="built_in">append</span>(clonedNode.Neighbors, dfs(neighbor))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ❌ 错误：太晚建立映射关系！</span></span><br><span class="line">        visited[cur] = clonedNode</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> clonedNode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因详细分析">错误原因详细分析</h3>
<h4 id="问题根源">问题根源</h4>
<p><strong>时机错误</strong>：在处理邻居的递归调用过程中，当前节点还没有被标记为&quot;已访问&quot;，导致在环形引用的情况下会重复进入同一个节点。</p>
<h4 id="具体执行过程">具体执行过程</h4>
<p>以图 <code>1-2-1</code> 为例（节点 1 和节点 2 互相连接）：</p>
<ol>
<li>
<p><strong>第一次调用 <code>dfs(node1)</code></strong>：</p>
<ul>
<li><code>visited</code> 为空，创建 <code>clonedNode1</code></li>
<li>开始处理 <code>node1</code> 的邻居 <code>node2</code></li>
<li>调用 <code>dfs(node2)</code></li>
</ul>
</li>
<li>
<p><strong>第二次调用 <code>dfs(node2)</code></strong>：</p>
<ul>
<li><code>visited</code> 仍为空（<code>node1</code> 还没被添加），创建 <code>clonedNode2</code></li>
<li>开始处理 <code>node2</code> 的邻居 <code>node1</code></li>
<li>调用 <code>dfs(node1)</code> ← <strong>又回到了节点 1！</strong></li>
</ul>
</li>
<li>
<p><strong>第三次调用 <code>dfs(node1)</code></strong>：</p>
<ul>
<li><code>visited</code> 仍为空，再次创建新的 <code>clonedNode1</code></li>
<li>开始处理邻居…</li>
<li><strong>无限递归开始！</strong></li>
</ul>
</li>
</ol>
<h4 id="Runtime-Error-的具体表现">Runtime Error 的具体表现</h4>
<ul>
<li><strong>Stack Overflow</strong>：递归栈深度超出限制</li>
<li><strong>超时错误</strong>：程序陷入无限循环</li>
<li><strong>内存溢出</strong>：不断创建新的节点对象</li>
</ul>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>时间复杂度</strong>：$O(N + M)$</p>
<ul>
<li>$N$ 是节点数量，$M$ 是边的数量</li>
<li>每个节点访问一次：$O(N)$</li>
<li>每条边访问一次：$O(M)$</li>
</ul>
<p><strong>空间复杂度</strong>：$O(N)$</p>
<ul>
<li><code>visited</code> 哈希表存储：$O(N)$</li>
<li>递归调用栈深度：$O(N)$（最坏情况下是链状图）</li>
<li>克隆图的存储空间：$O(N + M)$（不计入结果空间）</li>
</ul>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>正确实现</th>
<th>错误实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>映射建立时机</td>
<td>创建节点后立即建立</td>
<td>处理完邻居后建立</td>
</tr>
<tr>
<td>环形引用处理</td>
<td>✅ 正确处理</td>
<td>❌ 无限递归</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>$O(N + M)$</td>
<td>无法完成（超时/栈溢出）</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(N)$</td>
<td>无法完成（内存溢出）</td>
</tr>
<tr>
<td>运行结果</td>
<td>✅ 通过所有测试用例</td>
<td>❌ Runtime Error</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<h3 id="重要概念">重要概念</h3>
<ol>
<li><strong>图的深拷贝</strong>：不仅要复制节点值，还要正确复制节点间的连接关系</li>
<li><strong>环形引用检测</strong>：使用哈希表记录访问状态，避免重复访问</li>
<li><strong>访问标记时机</strong>：在开始处理当前节点时就要标记，而不是处理完成后</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>❌ 访问标记时机错误</strong>：在递归处理邻居之后才标记访问状态</li>
<li><strong>❌ 忘记处理空图</strong>：没有检查输入节点是否为 <code>nil</code></li>
<li><strong>❌ 邻居列表初始化错误</strong>：没有正确初始化克隆节点的邻居列表</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><strong>LeetCode 138 - 复制带随机指针的链表</strong>：类似的深拷贝问题</li>
<li><strong>LeetCode 207 - 课程表</strong>：图的环检测问题</li>
<li><strong>LeetCode 200 - 岛屿数量</strong>：图的 DFS 遍历</li>
</ul>
<h3 id="实际应用">实际应用</h3>
<ul>
<li><strong>对象深拷贝</strong>：在需要完全独立的对象副本时</li>
<li><strong>图数据库</strong>：复制图结构用于备份或分析</li>
<li><strong>社交网络</strong>：复制用户关系网络的子图</li>
</ul>
<p>这道题的核心教训是：<strong>在处理有环数据结构时，访问标记的时机至关重要</strong>。必须在开始处理当前元素时就进行标记，而不是等处理完成后再标记。这是避免无限递归的关键！</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Medium</tag>
        <tag>图</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云CSIG 后端开发工程师 二面</title>
    <url>/2025/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E5%8E%82/%E8%85%BE%E8%AE%AF/2025-06-18-%E8%85%BE%E8%AE%AF%E4%BA%91CSIG-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试基本信息">面试基本信息</h2>
<ul>
<li><strong>公司</strong>: 腾讯云 AI产品中心</li>
<li><strong>职位</strong>: 后端开发工程师</li>
<li><strong>面试轮次</strong>: 二面（技术面）</li>
<li><strong>面试形式</strong>: 线上视频面试（可选择是否开摄像头）</li>
<li><strong>面试时长</strong>: 约70分钟</li>
<li><strong>面试官</strong>: 技术团队负责人，主要负责AI平台机器学习平台相关产品</li>
</ul>
<h2 id="团队介绍">团队介绍</h2>
<p>面试官介绍了团队情况：</p>
<ul>
<li>隶属于腾讯云AI产品中心</li>
<li>主要做AI平台和机器学习平台相关产品</li>
<li>具体工作偏向底层支撑，优化GPU、CPU算力的使用效率</li>
<li>让平台更高效地使用计算资源</li>
</ul>
<h2 id="面试问题与回答">面试问题与回答</h2>
<h3 id="问题1：项目介绍-Go-Cache分布式缓存系统">问题1：项目介绍 - Go Cache分布式缓存系统</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“简单介绍一下你的基础情况和项目，我看你简历上有个Go Cache项目，说一下这个项目的背景”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“Go Cache是一个分布式缓存系统，挂载在服务端和数据库中间。可以设置各种数据源，通过缓存机制减少数据库访问，提高QPS。项目中使用了single flight机制解决缓存击穿问题，将多个相同请求合并成一个，减少网络IO次数。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>项目介绍可以更系统一些。首先说明项目的定位和解决的问题：Go Cache是一个分布式缓存中间件，主要解决高并发场景下数据库压力过大的问题。</p>
<p>然后介绍架构设计：采用主从架构，主节点负责接收客户端请求和协调，从节点负责数据存储和数据源访问。支持数据分片，类似Redis集群。</p>
<p>最后说明核心优化：实现了single flight机制解决缓存击穿，当多个相同请求同时到达时，只有一个真正发起数据获取，其他请求等待并共享结果。</p>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>single flight的时间窗口和失败处理</li>
<li>主从节点的具体职责划分</li>
<li>分布式体现在哪里</li>
</ul>
<p><strong>总结反思</strong>：</p>
<ul>
<li>对项目的核心机制理解清楚</li>
<li>但对故障处理场景考虑不足</li>
<li>应该准备更详细的架构图和异常处理方案</li>
</ul>
<h3 id="问题2：项目介绍-抖音商城系统">问题2：项目介绍 - 抖音商城系统</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“再介绍一下你的抖音商城项目，这个项目是什么背景？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“这是参加字节跳动青训营的项目，是完整的商城系统。实现了服务发现、服务注册、配置中心、分布式缓存、分布式锁等。使用Canal监听MySQL binlog实现数据同步，保证MySQL、Redis、ElasticSearch之间的弱一致性。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>可以从系统设计角度更好地介绍这个项目。首先说明这是一个微服务架构的电商系统，实现了完整的商城核心功能。</p>
<p>技术架构方面：</p>
<ol>
<li>微服务治理：服务发现、注册、配置中心</li>
<li>数据层：MySQL主库 + Redis缓存 + ElasticSearch搜索</li>
<li>可观测性：集成OpenTelemetry</li>
<li>数据一致性：Canal + 消息队列实现最终一致性</li>
</ol>
<p>核心亮点是数据同步方案：通过Canal监听MySQL binlog，将数据变更发送到消息队列，消费者更新Redis和ES，实现了业务代码解耦和数据最终一致性。</p>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>为什么选择ElasticSearch而不是MySQL做搜索</li>
<li>数据一致性要求和Canal的作用</li>
</ul>
<h3 id="问题3：MySQL性能优化">问题3：MySQL性能优化</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“如果MySQL查询很慢，有什么办法定位和优化？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“首先用explain语句查看是否使用了索引，检查key字段。然后看查询语句是否有导致优化器选择全表扫描的问题，比如使用了OR。可能需要建索引，但在数据量大的时候建索引会比较耗时。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>MySQL查询优化可以从几个层面来分析：</p>
<ol>
<li>
<p><strong>SQL层面</strong>：使用EXPLAIN分析执行计划，重点看type、key、rows、filtered字段。检查是否走索引，是否有filesort、temporary等</p>
</li>
<li>
<p><strong>索引层面</strong>：分析慢查询日志，检查where条件、order by、group by字段是否有适当索引。考虑联合索引的最左匹配原则</p>
</li>
<li>
<p><strong>系统层面</strong>：查看MySQL服务器状态，包括连接数、锁等待、IO状况等</p>
</li>
<li>
<p><strong>具体优化手段</strong>：</p>
<ul>
<li>重写SQL，避免函数、OR、前缀模糊查询</li>
<li>添加覆盖索引减少回表</li>
<li>分库分表处理大数据量</li>
<li>读写分离分担压力</li>
</ul>
</li>
</ol>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>如何设计索引，考虑哪些因素</li>
<li>联合索引的使用场景</li>
</ul>
<h3 id="问题4：分布式锁实现">问题4：分布式锁实现</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“如果用MySQL实现分布式锁，应该怎么做？用Redis呢？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>&quot;MySQL实现分布式锁我觉得不太适合，因为速度比较慢。但要实现的话也可以，我想到有两种方式。第一种是用事务，让所有请求都执行同一个insert语句。因为insert会对整个表加锁，或者说对ID的间隙进行加锁，这时其他请求就会被阻塞。然后在事务执行过程中可以添加业务代码，最后业务代码执行完再提交事务，这样就实现了锁。第二种是避免用insert，可以使用select xxx for update这种方式实现加锁。</p>
<p>Redis的话用SET NX命令，因为Redis单线程保证原子性。需要注意删除锁时的安全性，用lua脚本保证原子性。&quot;</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p><strong>MySQL分布式锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方案1：基于唯一索引</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> lock_table (lock_key, owner, expire_time) <span class="keyword">VALUES</span> (<span class="string">&#x27;resource_id&#x27;</span>, <span class="string">&#x27;unique_id&#x27;</span>, NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">SECOND</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方案2：基于行锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> lock_table <span class="keyword">WHERE</span> lock_key <span class="operator">=</span> <span class="string">&#x27;resource_id&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>优点是强一致性，缺点是性能较低，适合对一致性要求极高的场景。</p>
<p><strong>Redis分布式锁</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加锁</span></span><br><span class="line">SET lock_key unique_value PX 30000 NX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解锁（lua脚本保证原子性）</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[1]) == ARGV[1] <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>优点是性能高，缺点是可能存在锁丢失的极端情况。</p>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>lua脚本的问题和替代方案</li>
<li>Redis大key问题和解决方案</li>
</ul>
<h3 id="问题5：Redis内存评估和缓存策略">问题5：Redis内存评估和缓存策略</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“如何评估Redis缓存需要多少内存？比如1万个key，每个value 1KB，需要多少内存？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“1万个key，每个1KB，大概需要几十兆内存。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Redis内存评估需要考虑多个方面：</p>
<ol>
<li><strong>数据本身</strong>：1万 × 1KB = 10MB</li>
<li><strong>key的存储</strong>：假设key平均20字节，1万 × 20B = 200KB</li>
<li><strong>Redis数据结构开销</strong>：每个key-value对大约有40-50字节的元数据开销</li>
<li><strong>内存碎片</strong>：通常占用额外10-20%空间</li>
<li><strong>持久化开销</strong>：RDB/AOF可能需要额外内存</li>
</ol>
<p>所以实际需要大约：10MB + 0.2MB + 0.5MB + 2MB = 13-15MB左右。</p>
<p>对于热点数据管理：</p>
<ul>
<li>可以通过统计访问频率识别热点</li>
<li>使用LRU、LFU等淘汰策略</li>
<li>定期刷新热点数据，避免业务高峰期回源</li>
</ul>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>热点数据变化时的处理策略</li>
</ul>
<h3 id="问题6：Redis单线程模型">问题6：Redis单线程模型</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“Redis说是单线程，它是怎么支持高并发的？在多核系统上怎么利用多核优势？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“Redis的单线程是指命令执行是单线程，实际上是多线程的。单线程避免了上下文切换开销，而且操作的是内存速度很快。多核系统可以开多个Redis实例在不同端口。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p>Redis的单线程指的是<strong>命令处理</strong>是单线程的，但整个系统是多线程的：</p>
<ol>
<li><strong>主线程</strong>：处理客户端请求，执行命令</li>
<li><strong>后台线程</strong>：处理持久化、内存回收、集群数据同步等</li>
</ol>
<p>单线程的优势：</p>
<ul>
<li>避免线程切换开销</li>
<li>避免锁竞争</li>
<li>简化内存模型</li>
<li>基于内存操作，CPU不是瓶颈</li>
</ul>
<p>高并发支持：</p>
<ul>
<li>基于IO多路复用（epoll/kqueue）</li>
<li>非阻塞IO，单线程处理多个连接</li>
<li>内存操作速度极快</li>
</ul>
<p>多核利用：</p>
<ul>
<li>单实例主要受内存和网络IO限制</li>
<li>可以部署多实例利用多核</li>
<li>Redis 6.0引入多线程处理网络IO</li>
</ul>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>主要性能瓶颈在哪里</li>
<li>Redis内部请求处理流程</li>
</ul>
<h3 id="问题7：网络协议和HTTPS">问题7：网络协议和HTTPS</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“你了解HTTP/2吗？HTTPS的机制是什么？如果要拦截HTTPS请求应该怎么做？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“HTTP/2好像是在长连接方面做了优化。HTTPS是在HTTP基础上加了密钥交换和加密。拦截需要有客户端信任的CA证书。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p><strong>HTTPS机制</strong>：</p>
<ol>
<li><strong>证书验证</strong>：客户端验证服务器证书合法性</li>
<li><strong>密钥协商</strong>：通过RSA或ECDHE等算法协商对称密钥</li>
<li><strong>数据加密</strong>：使用协商的对称密钥加密传输数据</li>
</ol>
<p><strong>HTTPS中间人拦截</strong>：<br>
需要作为中间代理：</p>
<ol>
<li>客户端信任代理的根证书</li>
<li>代理为目标域名动态生成证书</li>
<li>与客户端建立HTTPS连接（使用代理证书）</li>
<li>与服务器建立HTTPS连接（验证真实证书）</li>
<li>解密客户端数据，处理后转发给服务器</li>
</ol>
<p>这种方案常用于企业网关、安全审计等场景。</p>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>网络包传输的完整流程</li>
<li>从应用层到物理层的处理过程</li>
</ul>
<h3 id="问题8：Go语言协程和调度">问题8：Go语言协程和调度</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“Go语言的协程和线程有什么区别？协程什么时候会让出CPU？”</p>
</blockquote>
<p><strong>我的回答</strong>：</p>
<blockquote>
<p>“协程比线程轻量，不需要和内核态交互。进程是资源分配单位，线程是调度单位，协程在线程之上。协程超过10毫秒会被强制调度，或者阻塞时主动让出。”</p>
</blockquote>
<p><strong>标准/建议回答</strong>：</p>
<p><strong>协程与线程的区别</strong>：</p>
<ol>
<li>
<p><strong>创建开销</strong>：</p>
<ul>
<li>线程：需要内核态操作，栈空间默认8MB</li>
<li>协程：用户态创建，初始栈2KB，动态增长</li>
</ul>
</li>
<li>
<p><strong>调度方式</strong>：</p>
<ul>
<li>线程：抢占式调度，内核控制</li>
<li>协程：协作式调度，用户态控制</li>
</ul>
</li>
<li>
<p><strong>上下文切换</strong>：</p>
<ul>
<li>线程：涉及内核态切换，保存完整寄存器状态</li>
<li>协程：只需保存少量寄存器，开销很小</li>
</ul>
</li>
</ol>
<p><strong>协程让出CPU的时机</strong>：</p>
<ol>
<li><strong>主动让出</strong>：调用runtime.Gosched()、channel操作阻塞、mutex获取失败</li>
<li><strong>被动抢占</strong>：运行时间过长（10ms），系统调用返回时检查</li>
<li><strong>系统调用</strong>：进入系统调用时，M会与P分离</li>
</ol>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>线程切换的具体开销</li>
<li>for循环会不会一直占用CPU</li>
</ul>
<h3 id="问题9：编程题-并发安全的Map">问题9：编程题 - 并发安全的Map</h3>
<p><strong>面试官问题</strong>：</p>
<blockquote>
<p>“用Go语言实现一个并发安全的map，包含put、get、delete方法”</p>
</blockquote>
<p><strong>我的实现</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu   sync.RWMutex</span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SafeMap)</span></span> Put(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">    m.data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SafeMap)</span></span> Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">    m.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.RUnlock()</span><br><span class="line">    value, ok := m.data[key]</span><br><span class="line">    <span class="keyword">return</span> value, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SafeMap)</span></span> Delete(key <span class="type">string</span>) &#123;</span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">    <span class="built_in">delete</span>(m.data, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>面试官追问</strong>：</p>
<ul>
<li>为什么使用读写锁？</li>
<li>还能怎么优化？</li>
</ul>
<p><strong>标准/建议回答</strong>：</p>
<p>读写锁的优势：在读多写少的场景下，多个goroutine可以同时获取读锁，提高并发性能。</p>
<p>进一步优化方案：</p>
<ol>
<li><strong>分段锁</strong>：将map分成多个segment，每个segment独立加锁，减少锁竞争</li>
<li><strong>无锁实现</strong>：使用atomic包和CAS操作</li>
<li><strong>使用sync.Map</strong>：Go标准库提供的并发安全map</li>
</ol>
<p>分段锁实现思路：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SegmentedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    segments []segment</span><br><span class="line">    mask     <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> segment <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu   sync.RWMutex</span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试整体感受">面试整体感受</h2>
<ul>
<li><strong>难度评价</strong>: 适中，主要考查基础扎实程度和项目经验</li>
<li><strong>面试官风格</strong>: 专业友善，会深入追问细节</li>
<li><strong>题目类型</strong>: 项目经验、基础知识、编程能力并重</li>
<li><strong>准备建议</strong>: 重点准备项目细节、常见中间件原理、Go语言特性</li>
</ul>
<h2 id="面试结果">面试结果</h2>
<ul>
<li><strong>当场反馈</strong>: 面试官没有给出明确反馈</li>
<li><strong>后续流程</strong>: 需要等待HR通知后续安排</li>
<li><strong>个人感受</strong>: 部分问题回答不够深入，特别是网络协议和系统底层部分</li>
</ul>
<h2 id="经验总结">经验总结</h2>
<h3 id="做得好的地方">做得好的地方</h3>
<ul>
<li>项目介绍比较清晰，single flight等核心技术点表达准确</li>
<li>Redis、MySQL基础知识掌握较好</li>
<li>编程题实现思路正确</li>
</ul>
<h3 id="需要改进的地方">需要改进的地方</h3>
<ul>
<li>对故障场景和边界情况考虑不足</li>
<li>网络协议底层原理掌握不够深入</li>
<li>系统设计的全局思维需要加强</li>
</ul>
<h3 id="准备建议">准备建议</h3>
<ol>
<li><strong>项目经验</strong>：准备详细的架构图，考虑各种异常场景的处理</li>
<li><strong>基础知识</strong>：深入理解常用中间件的底层原理和源码</li>
<li><strong>系统设计</strong>：多练习分布式系统设计，考虑性能、一致性、可用性权衡</li>
<li><strong>编程能力</strong>：熟练掌握常见数据结构和算法的并发安全实现</li>
</ol>
<h3 id="知识点复习">知识点复习</h3>
<ul>
<li>分布式缓存设计原理</li>
<li>MySQL索引优化和查询分析</li>
<li>Redis内存管理和持久化机制</li>
<li>HTTPS/TLS协议详解</li>
<li>Go语言GMP调度模型</li>
<li>分布式锁的实现和对比</li>
<li>网络协议栈和数据包传输流程</li>
</ul>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>腾讯</tag>
        <tag>二面</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 530 - 二叉搜索树的最小绝对差（Minimum Absolute Difference in BST）</title>
    <url>/2025/06/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个二叉搜索树的根节点 <code>root</code>，返回 <strong>树中任意两不同节点值之间的最小差值</strong>。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>树中节点的数目范围是 <code>[2, 10^4]</code></li>
<li><code>0 &lt;= Node.val &lt;= 10^5</code></li>
</ul>
<p><strong>注意：</strong> 本题与 783 题相同。</p>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心思路是利用 <strong>二叉搜索树中序遍历的有序性</strong>。</p>
<h3 id="关键洞察">关键洞察</h3>
<p><strong>二叉搜索树的中序遍历结果是一个有序序列</strong>。这意味着如果我们按照中序遍历访问节点，相邻访问的两个节点在数值上也是相邻的，因此最小差值一定出现在相邻的两个节点之间。</p>
<h3 id="算法思路">算法思路</h3>
<p>我们不需要将中序遍历的结果存储到数组中，而是可以在遍历的过程中：</p>
<ol>
<li>使用一个 <code>prev</code> 指针记录前一个访问的节点</li>
<li>使用一个 <code>cur</code> 指针记录当前访问的节点</li>
<li>在每次访问当前节点时，计算与前一个节点的差值</li>
<li>维护一个全局最小值</li>
</ol>
<h3 id="实现步骤">实现步骤</h3>
<ol>
<li><strong>初始化</strong>：设置最小值为最大整数，前驱节点为空</li>
<li><strong>中序遍历</strong>：左 → 根 → 右的顺序访问</li>
<li><strong>处理当前节点</strong>：
<ul>
<li>如果前驱节点不为空，计算差值并更新最小值</li>
<li>将当前节点设为前驱节点</li>
</ul>
</li>
<li><strong>继续遍历右子树</strong></li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="中序遍历的实现">中序遍历的实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(node.Left)   <span class="comment">// 遍历左子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    cur = node</span><br><span class="line">    <span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">        minVal = min(minVal, <span class="type">int</span>(math.Abs(<span class="type">float64</span>(prev.Val)-<span class="type">float64</span>(cur.Val))))</span><br><span class="line">    &#125;</span><br><span class="line">    prev = cur</span><br><span class="line">    </span><br><span class="line">    dfs(node.Right)  <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么使用中序遍历？">为什么使用中序遍历？</h3>
<p>对于二叉搜索树 <code>[4,2,6,1,3]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>中序遍历序列：<code>1 → 2 → 3 → 4 → 6</code></p>
<p>这是一个有序序列，最小差值只可能出现在相邻元素之间：</p>
<ul>
<li>|2-1| = 1</li>
<li>|3-2| = 1</li>
<li>|4-3| = 1</li>
<li>|6-4| = 2</li>
</ul>
<p>所以最小差值是 1。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minVal := math.MaxInt32</span><br><span class="line">    <span class="keyword">var</span> prev, cur *TreeNode</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(node.Left)   <span class="comment">// 遍历左子树</span></span><br><span class="line">        </span><br><span class="line">        cur = node</span><br><span class="line">        <span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">            minVal = min(minVal, <span class="type">int</span>(math.Abs(<span class="type">float64</span>(prev.Val)-<span class="type">float64</span>(cur.Val))))</span><br><span class="line">        &#125;</span><br><span class="line">        prev = cur</span><br><span class="line">        </span><br><span class="line">        dfs(node.Right)  <span class="comment">// 遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> minVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以 <code>[4,2,6,1,3]</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访问顺序：1 → 2 → 3 → 4 → 6</span><br><span class="line"></span><br><span class="line">1. 访问节点1：prev=nil, cur=1, prev=1</span><br><span class="line">2. 访问节点2：prev=1, cur=2, 计算|2-1|=1, minVal=1, prev=2</span><br><span class="line">3. 访问节点3：prev=2, cur=3, 计算|3-2|=1, minVal=1, prev=3  </span><br><span class="line">4. 访问节点4：prev=3, cur=4, 计算|4-3|=1, minVal=1, prev=4</span><br><span class="line">5. 访问节点6：prev=4, cur=6, 计算|6-4|=2, minVal=1, prev=6</span><br><span class="line"></span><br><span class="line">最终结果：1</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>时间复杂度：</strong> $O(n)$</p>
<ul>
<li>需要访问每个节点一次，其中 n 是树中节点的数量</li>
</ul>
<p><strong>空间复杂度：</strong> $O(h)$</p>
<ul>
<li>递归调用的栈深度等于树的高度 h</li>
<li>最坏情况下（退化为链表）：$O(n)$</li>
<li>最好情况下（平衡树）：$O(\log n)$</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>BST 性质的应用</strong>：二叉搜索树的中序遍历产生有序序列，这是解决此类问题的关键</li>
<li><strong>空间优化</strong>：不需要额外数组存储遍历结果，一次遍历即可完成</li>
<li><strong>算法模式</strong>：这种&quot;在遍历过程中维护前驱节点&quot;的模式在很多树问题中都很有用</li>
<li><strong>相关问题</strong>：
<ul>
<li>LeetCode 783: 二叉搜索树节点最小距离（完全相同）</li>
<li>LeetCode 98: 验证二叉搜索树</li>
<li>LeetCode 230: 二叉搜索树中第K小的元素</li>
</ul>
</li>
</ol>
<h2 id="常见陷阱">常见陷阱</h2>
<ol>
<li><strong>忘记初始化</strong>：<code>prev</code> 必须初始化为 <code>nil</code></li>
<li><strong>类型转换</strong>：Go 中需要将 <code>int</code> 转换为 <code>float64</code> 才能使用 <code>math.Abs</code></li>
<li><strong>遍历顺序</strong>：必须是中序遍历，其他遍历方式无法保证有序性</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Easy</tag>
        <tag>二叉搜索树</tag>
        <tag>中序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Go语言并发调度器GMP模型</title>
    <url>/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/</url>
    <content><![CDATA[<h1>深入理解Go语言并发调度器GMP模型</h1>
<h2 id="📖-概述">📖 概述</h2>
<p>Go语言的并发能力是其最大的特色之一，而这一切都归功于其强大的调度器系统。本文将深入剖析Go语言的GMP调度器模型，从历史演进到核心原理，再到实际调度场景，帮助你全面理解Go语言并发编程的底层机制。</p>
<h2 id="🎯-学习目标">🎯 学习目标</h2>
<p>阅读本文后，你将能够：</p>
<ul>
<li>理解Go调度器的发展历程和设计思想</li>
<li>掌握GMP模型的核心概念和工作原理</li>
<li>了解Goroutine的调度场景和生命周期</li>
<li>具备回答相关面试问题的能力</li>
</ul>
<h2 id="🏗️-第一章：Go调度器的历史演进">🏗️ 第一章：Go调度器的历史演进</h2>
<h3 id="1-1-单进程时代的困境">1.1 单进程时代的困境</h3>
<p>在计算机发展早期，操作系统只能运行一个程序，直到程序运行完毕才能执行下一个程序。这种<strong>串行执行</strong>的方式带来了两个主要问题：</p>
<ol>
<li><strong>执行效率低</strong>：只能一个任务一个任务地处理</li>
<li><strong>CPU资源浪费</strong>：当进程因IO等操作阻塞时，CPU处于空闲状态</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750165896833.png" alt="单进程时代"></p>
<h3 id="1-2-多进程-多线程的改进与新问题">1.2 多进程/多线程的改进与新问题</h3>
<p>为了解决单进程的问题，操作系统引入了<strong>多进程</strong>和<strong>多线程</strong>机制：</p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750165911410.png" alt="多进程多线程"></p>
<p><strong>优势</strong>：</p>
<ul>
<li>当一个进程阻塞时，CPU可以切换到其他进程继续执行</li>
<li>宏观上实现了并发执行</li>
</ul>
<p><strong>新的问题</strong>：</p>
<ul>
<li><strong>资源消耗大</strong>：每个进程占用4GB虚拟内存，线程也需要约4MB内存</li>
<li><strong>切换成本高</strong>：进程/线程的创建、切换、销毁都需要大量时间</li>
<li><strong>调度开销大</strong>：CPU很大一部分时间用于进程调度</li>
</ul>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750165922867.png" alt="进程线程调度"></p>
<h3 id="1-3-协程：轻量级的解决方案">1.3 协程：轻量级的解决方案</h3>
<h4 id="用户态线程-vs-内核态线程">用户态线程 vs 内核态线程</h4>
<p>工程师们发现可以将线程分为两类：</p>
<ul>
<li><strong>内核态线程</strong>：由操作系统内核管理，CPU直接调度</li>
<li><strong>用户态线程（协程）</strong>：由用户程序管理，必须绑定到内核态线程上运行</li>
</ul>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750165936977.png" alt="用户态与内核态线程"></p>
<h4 id="三种协程-线程映射模型">三种协程-线程映射模型</h4>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750165957203.png" alt="协程线程映射"></p>
<h5 id="N-1-模型">N:1 模型</h5>
<ul>
<li><strong>特点</strong>：N个协程绑定1个线程</li>
<li><strong>优点</strong>：协程切换在用户态完成，切换成本极低</li>
<li><strong>缺点</strong>：
<ul>
<li>无法利用多核优势</li>
<li>一个协程阻塞会导致所有协程阻塞</li>
</ul>
</li>
</ul>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166007486.png" alt="N:1模型"></p>
<h5 id="1-1-模型">1:1 模型</h5>
<ul>
<li><strong>特点</strong>：1个协程绑定1个线程</li>
<li><strong>优点</strong>：实现简单，不存在N:1模型的缺点</li>
<li><strong>缺点</strong>：协程创建、删除、切换的代价与线程相同，成本较高</li>
</ul>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166026834.png" alt="1:1模型"></p>
<h5 id="M-N-模型">M:N 模型</h5>
<ul>
<li><strong>特点</strong>：M个协程绑定N个线程</li>
<li><strong>优点</strong>：结合了N:1和1:1模型的优势</li>
<li><strong>缺点</strong>：实现复杂度最高</li>
</ul>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166037159.png" alt="M:N模型"></p>
<blockquote>
<p>💡 <strong>关键区别</strong>：协程是<strong>协作式调度</strong>（需要主动让出CPU），线程是<strong>抢占式调度</strong>（由CPU强制切换）</p>
</blockquote>
<h3 id="1-4-Go语言的Goroutine">1.4 Go语言的Goroutine</h3>
<p>Go语言采用了M:N模型，并称其轻量级线程为<strong>Goroutine</strong>：</p>
<p><strong>Goroutine特点</strong>：</p>
<ul>
<li><strong>内存占用小</strong>：初始栈只有几KB</li>
<li><strong>动态扩展</strong>：runtime会根据需要自动扩展栈空间</li>
<li><strong>调度灵活</strong>：由Go runtime而非OS调度</li>
<li><strong>并发能力强</strong>：支持数万甚至数十万个Goroutine</li>
</ul>
<h3 id="1-5-旧调度器的问题">1.5 旧调度器的问题</h3>
<p>Go最初的调度器存在严重的性能问题：</p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166093219.png" alt="旧调度器架构"></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166100261.png" alt="旧调度器实现"></p>
<p><strong>主要问题</strong>：</p>
<ol>
<li><strong>锁竞争激烈</strong>：所有M都需要访问全局G队列，需要加锁保护</li>
<li><strong>局部性差</strong>：新创建的G被分配给其他M执行，缺乏局部性</li>
<li><strong>系统调用开销大</strong>：频繁的线程阻塞和唤醒增加系统开销</li>
</ol>
<h2 id="🔧-第二章：GMP模型的设计与实现">🔧 第二章：GMP模型的设计与实现</h2>
<h3 id="2-1-GMP模型核心概念">2.1 GMP模型核心概念</h3>
<p>为了解决旧调度器的问题，Go在2012年重新设计了调度器，引入了<strong>P</strong>（<strong>Processor</strong>）的概念：</p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166111531.png" alt="GMP模型"></p>
<h4 id="核心组件定义">核心组件定义</h4>
<p><strong>G (Goroutine)</strong>：</p>
<ul>
<li>代表一个Goroutine</li>
<li>包含函数指针、栈信息、状态等</li>
<li>是调度的基本单位</li>
</ul>
<p><strong>M (Machine)</strong>：</p>
<ul>
<li>代表一个操作系统线程</li>
<li>负责执行Goroutine</li>
<li>必须绑定P才能运行G</li>
</ul>
<p><strong>P (Processor)</strong>：</p>
<ul>
<li>逻辑处理器，包含运行Goroutine所需的资源</li>
<li>维护本地Goroutine队列</li>
<li>数量由GOMAXPROCS决定</li>
</ul>
<h4 id="GMP模型架构">GMP模型架构</h4>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166119273.png" alt="GMP架构详解"></p>
<p><strong>主要组件</strong>：</p>
<ol>
<li><strong>全局队列</strong>：存放等待运行的G</li>
<li><strong>P的本地队列</strong>：存放等待运行的G，容量限制为256个</li>
<li><strong>P列表</strong>：所有P在程序启动时创建，数量为GOMAXPROCS</li>
<li><strong>M</strong>：工作线程，需要获取P才能运行G</li>
</ol>
<h3 id="2-2-P和M的数量关系">2.2 P和M的数量关系</h3>
<h4 id="P的数量">P的数量</h4>
<ul>
<li>由环境变量<code>GOMAXPROCS</code>或<code>runtime.GOMAXPROCS()</code>决定</li>
<li>通常设置为CPU核心数</li>
<li>在程序执行过程中保持不变</li>
</ul>
<h4 id="M的数量">M的数量</h4>
<ul>
<li><strong>默认上限</strong>：10000个（通常达不到）</li>
<li><strong>动态创建</strong>：当现有M都阻塞时，会创建新的M</li>
<li><strong>可配置</strong>：通过<code>runtime/debug.SetMaxThreads()</code>设置</li>
</ul>
<blockquote>
<p>📌 <strong>重要提示</strong>：M的数量不固定，会根据运行时需要动态调整</p>
</blockquote>
<h4 id="P和M的创建时机">P和M的创建时机</h4>
<p><strong>P的创建</strong>：在确定最大数量后，运行时系统创建对应数量的P</p>
<p><strong>M的创建</strong>：当没有足够的M来关联P并运行G时，会创建新的M</p>
<h3 id="2-3-调度器的设计策略">2.3 调度器的设计策略</h3>
<h4 id="复用线程">复用线程</h4>
<ol>
<li>
<p><strong>Work Stealing（工作窃取）</strong>：</p>
<ul>
<li>当本线程的P队列为空时，从其他P偷取G</li>
<li>避免了线程的创建和销毁开销</li>
</ul>
</li>
<li>
<p><strong>Hand Off（移交）</strong>：</p>
<ul>
<li>当线程因系统调用阻塞时，将P移交给其他空闲线程</li>
<li>保证P中的其他G能继续执行</li>
</ul>
</li>
</ol>
<h4 id="利用并行">利用并行</h4>
<ul>
<li>通过<code>GOMAXPROCS</code>控制并行度</li>
<li>最多有<code>GOMAXPROCS</code>个线程同时在不同CPU核心上运行</li>
</ul>
<h4 id="抢占式调度">抢占式调度</h4>
<ul>
<li>Goroutine最多连续运行10ms</li>
<li>防止某个Goroutine长时间占用CPU，导致其他Goroutine饿死</li>
<li>这是Goroutine与传统协程的重要区别</li>
</ul>
<h4 id="调度器查找G的优先级顺序">调度器查找G的优先级顺序</h4>
<p>当M需要执行新的Goroutine时，按以下顺序查找：</p>
<ol>
<li><strong>P的本地队列</strong>：最高优先级，无锁访问，性能最佳</li>
<li><strong>全局队列</strong>：中等优先级，每61次调度检查一次，需要加锁</li>
<li><strong>网络轮询器(netpoll)</strong>：检查是否有网络I/O就绪的G</li>
<li><strong>Work Stealing</strong>：最后手段，从其他P的本地队列偷取G</li>
</ol>
<p>这个设计保证了：</p>
<ul>
<li>🚀 <strong>性能优先</strong>：本地队列无锁访问</li>
<li>⚖️ <strong>公平调度</strong>：定期检查全局队列防止饥饿</li>
<li>💪 <strong>负载均衡</strong>：work stealing机制分散负载</li>
<li>🔄 <strong>资源利用</strong>：netpoll提高I/O密集型程序效率</li>
</ul>
<h2 id="🔄-第三章：Goroutine调度流程详解">🔄 第三章：Goroutine调度流程详解</h2>
<h3 id="3-1-创建Goroutine的流程">3.1 创建Goroutine的流程</h3>
<p>当我们使用<code>go func()</code>创建Goroutine时，发生了什么？</p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166136097.png" alt="创建Goroutine流程"></p>
<p><strong>详细步骤</strong>：</p>
<ol>
<li>通过<code>go func()</code>创建新的Goroutine（G2）</li>
<li>新G优先加入当前P的本地队列</li>
<li>如果本地队列已满，执行负载均衡，将部分G移至全局队列</li>
<li>M从P的本地队列获取G执行</li>
<li>如果本地队列为空，先从全局队列获取G</li>
<li>如果全局队列也为空，再尝试从其他P窃取G</li>
</ol>
<p><strong>关键特性</strong>：</p>
<ul>
<li><strong>循环调度</strong>：M调度G执行是一个循环过程</li>
<li><strong>系统调用处理</strong>：当G进行系统调用时，M会被摘除，创建新M服务P</li>
<li><strong>P的复用</strong>：系统调用结束后，G尝试获取空闲P继续执行</li>
</ul>
<h3 id="3-2-调度器的生命周期">3.2 调度器的生命周期</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166152945.png" alt="调度器生命周期"></p>
<h4 id="特殊的M0和G0">特殊的M0和G0</h4>
<p><strong>M0</strong>：</p>
<ul>
<li>程序启动后的主线程</li>
<li>负责执行初始化操作</li>
<li>启动第一个Goroutine后与普通M无异</li>
</ul>
<p><strong>G0</strong>：</p>
<ul>
<li>每个M都有一个G0</li>
<li>专门负责调度工作</li>
<li>不执行用户代码，只处理调度逻辑</li>
</ul>
<h4 id="调度器启动流程">调度器启动流程</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的执行流程：</p>
<ol>
<li>创建M0和G0，建立关联</li>
<li>初始化调度器：创建P列表、设置GOMAXPROCS等</li>
<li>为<code>runtime.main</code>创建main goroutine</li>
<li>启动M0，开始调度循环</li>
<li>执行用户的<code>main.main</code>函数</li>
<li>程序结束，清理资源</li>
</ol>
<h2 id="📊-第四章：可视化GMP调度">📊 第四章：可视化GMP调度</h2>
<h3 id="4-1-使用go-tool-trace">4.1 使用go tool trace</h3>
<p>创建trace示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动trace</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要逻辑</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用方法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行程序生成trace文件</span></span><br><span class="line">go run trace.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析trace文件</span></span><br><span class="line">go tool trace trace.out</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166198901.png" alt="Trace分析界面"></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166205460.png" alt="Trace详细视图"></p>
<p><strong>信息解读</strong>：</p>
<ul>
<li><strong>G信息</strong>：可以看到Goroutine的运行状态和切换过程</li>
<li><strong>M信息</strong>：显示线程的创建和使用情况</li>
<li><strong>P信息</strong>：展示处理器的工作负载分布</li>
</ul>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166212597.png" alt="G信息详情"><br>
<img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166219787.png" alt="M信息详情"><br>
<img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166245678.png" alt="P信息详情"><br>
<img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166252879.png" alt="动态M创建"><br>
<img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166258618.png" alt="M2详情"></p>
<h3 id="4-2-使用GODEBUG调试">4.2 使用GODEBUG调试</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GODEBUG=schedtrace=1000 ./program</span><br></pre></td></tr></table></figure>
<p><strong>输出解释</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>gomaxprocs=2</code>：P的数量</li>
<li><code>idleprocs=0</code>：空闲P的数量</li>
<li><code>threads=4</code>：M的总数量</li>
<li><code>spinningthreads=1</code>：自旋M的数量</li>
<li><code>runqueue=0</code>：全局队列中G的数量</li>
<li><code>[0 0]</code>：各个P本地队列中G的数量</li>
</ul>
<h2 id="🎬-第五章：典型调度场景分析">🎬 第五章：典型调度场景分析</h2>
<h3 id="场景1：创建新Goroutine">场景1：创建新Goroutine</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166280168.png" alt="场景1"></p>
<p><strong>描述</strong>：P拥有G1，M1获取P后运行G1，G1创建G2<br>
<strong>结果</strong>：G2优先加入P1的本地队列（局部性原理）</p>
<h3 id="场景2：Goroutine执行完毕">场景2：Goroutine执行完毕</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166294675.png" alt="场景2"></p>
<p><strong>描述</strong>：G1执行完毕，M1复用执行G2<br>
<strong>关键函数</strong>：</p>
<ul>
<li><code>goexit</code>：Goroutine退出</li>
<li><code>schedule</code>：调度新的Goroutine</li>
<li><code>execute</code>：执行Goroutine</li>
</ul>
<h3 id="场景3：本地队列未满">场景3：本地队列未满</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166302874.png" alt="场景3"></p>
<p><strong>描述</strong>：假设P的本地队列容量为3，G2创建G3、G4、G5<br>
<strong>结果</strong>：新创建的G都加入P1的本地队列</p>
<h3 id="场景4：本地队列已满，执行负载均衡">场景4：本地队列已满，执行负载均衡</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166310526.png" alt="场景4"></p>
<p><strong>描述</strong>：G2创建G7时，P1本地队列已满<br>
<strong>负载均衡策略</strong>：</p>
<ul>
<li>将本地队列前一半的G移至全局队列</li>
<li>新创建的G也移至全局队列</li>
<li>维护队列的动态平衡</li>
</ul>
<h3 id="场景5：继续创建Goroutine">场景5：继续创建Goroutine</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166319379.png" alt="场景5"></p>
<p><strong>描述</strong>：G2创建G8，此时P1本地队列未满<br>
<strong>结果</strong>：G8直接加入P1本地队列</p>
<h3 id="场景6：唤醒空闲的M-P组合">场景6：唤醒空闲的M-P组合</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166332661.png" alt="场景6"></p>
<p><strong>关键机制</strong>：创建G时会尝试唤醒空闲的M-P组合<br>
<strong>自旋线程</strong>：没有G执行但保持运行状态，持续寻找可执行的G</p>
<h3 id="场景7：从全局队列获取G">场景7：从全局队列获取G</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166340433.png" alt="场景7"></p>
<p><strong>负载均衡公式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = min(len(GQ)/GOMAXPROCS + 1, len(GQ)/2)</span><br></pre></td></tr></table></figure>
<p><strong>设计原则</strong>：</p>
<ul>
<li>至少获取1个G</li>
<li>不要一次性获取太多G，给其他P留机会</li>
<li>实现全局队列到本地队列的负载均衡</li>
</ul>
<h3 id="场景8：Work-Stealing（工作窃取）">场景8：Work Stealing（工作窃取）</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166348141.png" alt="场景8"></p>
<p><strong>触发条件</strong>：本地队列为空且从全局队列也无法获取G时<br>
<strong>窃取策略</strong>：从其他P的本地队列尾部窃取一半的G<br>
<strong>优势</strong>：避免线程空闲，提高CPU利用率</p>
<h3 id="场景9：多个M处于自旋状态">场景9：多个M处于自旋状态</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166359369.png" alt="场景9"></p>
<p><strong>自旋线程的意义</strong>：</p>
<ul>
<li><strong>优点</strong>：有新G时能立即执行，降低延迟</li>
<li><strong>缺点</strong>：消耗CPU资源</li>
<li><strong>限制</strong>：最多允许GOMAXPROCS个自旋线程</li>
</ul>
<h3 id="场景10：系统调用阻塞">场景10：系统调用阻塞</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166366685.png" alt="场景10"></p>
<p><strong>阻塞系统调用处理</strong>：</p>
<ol>
<li>M2与P2立即解绑</li>
<li>P2寻找空闲的M（如M5）重新绑定</li>
<li>保证P2中的其他G能继续执行</li>
<li>实现了Hand Off机制</li>
</ol>
<h3 id="场景11：非阻塞系统调用">场景11：非阻塞系统调用</h3>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/GMP/GMP/1750166376430.png" alt="场景11"></p>
<p><strong>非阻塞系统调用处理</strong>：</p>
<ol>
<li>M2记住P2，然后与P2解绑</li>
<li>系统调用结束后，M2尝试重新获取P2</li>
<li>如果P2被占用，尝试获取其他空闲P</li>
<li>如果没有空闲P，G进入全局队列，M进入休眠</li>
</ol>
<h2 id="📝-面试重点总结">📝 面试重点总结</h2>
<h3 id="核心概念">核心概念</h3>
<ul>
<li><strong>G</strong>：Goroutine，轻量级线程</li>
<li><strong>M</strong>：Machine，操作系统线程</li>
<li><strong>P</strong>：Processor，逻辑处理器，包含运行G所需的资源</li>
</ul>
<h3 id="关键机制">关键机制</h3>
<ol>
<li><strong>Work Stealing</strong>：从其他P窃取G</li>
<li><strong>Hand Off</strong>：系统调用时P的移交</li>
<li><strong>负载均衡</strong>：本地队列与全局队列间的G分配</li>
<li><strong>抢占式调度</strong>：防止Goroutine长时间占用CPU</li>
</ol>
<h3 id="性能优化">性能优化</h3>
<ul>
<li><strong>局部性</strong>：新G优先放入当前P的本地队列</li>
<li><strong>批量操作</strong>：从全局队列批量获取G</li>
<li><strong>动态扩容</strong>：根据需要动态创建M</li>
</ul>
<h3 id="面试高频问题">面试高频问题</h3>
<p><strong>Q1：解释GMP模型的核心组件</strong><br>
<strong>A1</strong>：</p>
<ul>
<li>G代表Goroutine，是Go语言的轻量级线程</li>
<li>M代表Machine，是操作系统线程</li>
<li>P代表Processor，是逻辑处理器，包含运行Goroutine所需的资源</li>
</ul>
<p><strong>Q2：为什么需要P这个组件？</strong><br>
<strong>A2</strong>：</p>
<ul>
<li>解决旧调度器的全局锁竞争问题</li>
<li>提供本地队列，减少锁竞争</li>
<li>实现Work Stealing机制</li>
<li>支持更好的局部性</li>
</ul>
<p><strong>Q3：什么是Work Stealing？</strong><br>
<strong>A3</strong>：<br>
当一个P的本地队列为空，且从全局队列也无法获取G时，对应的M会从其他P的本地队列尾部窃取一半的G来执行，这样避免了M的空闲，提高了CPU利用率。</p>
<p><strong>Q4：Go调度器查找可运行Goroutine的顺序是什么？</strong><br>
<strong>A4</strong>：</p>
<ol>
<li>首先检查P的本地队列（无锁，最快）</li>
<li>每61次调度检查一次全局队列（避免全局队列饥饿）</li>
<li>检查网络轮询器(netpoll)是否有I/O就绪的G</li>
<li>最后进行work stealing，从其他P偷取G</li>
</ol>
<p>这个顺序既保证了性能（优先本地队列），又确保了公平性（定期检查全局队列）。</p>
<p><strong>Q5：Goroutine如何实现抢占？</strong><br>
<strong>A5</strong>：<br>
Go调度器通过在函数调用时检查抢占标志来实现协作式抢占，同时设置最大连续运行时间为10ms，防止某个Goroutine长时间占用CPU。</p>
<h2 id="🎯-总结">🎯 总结</h2>
<p>Go语言的GMP调度器是一个精心设计的并发系统：</p>
<ol>
<li><strong>历史演进</strong>：从单进程到多线程，再到协程，最终发展为GMP模型</li>
<li><strong>核心思想</strong>：通过M:N映射实现轻量级并发，用P作为资源容器减少锁竞争</li>
<li><strong>关键机制</strong>：Work Stealing、Hand Off、负载均衡等保证高效调度</li>
<li><strong>性能优化</strong>：局部性、批量操作、动态扩容等提升整体性能</li>
</ol>
<p><strong>Go调度器的本质是把大量的Goroutine高效地分配到少量的线程上执行，充分利用多核并行能力，实现强大的并发性能。</strong></p>
<p>理解GMP模型不仅有助于写出高性能的Go代码，更能帮助我们深入理解并发编程的本质。</p>
<hr>
<p><em>参考资料：</em></p>
<ul>
<li><a href="https://golang.org/doc/">Go语言官方文档</a></li>
<li><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw">Go调度器设计文档</a></li>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
</ul>
<blockquote>
<p>💡 <strong>学习建议</strong>：建议结合实际代码和trace工具来加深理解，多写多练才能真正掌握Go并发编程的精髓。</p>
</blockquote>
]]></content>
      <categories>
        <category>八股文</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>八股文</tag>
        <tag>并发编程</tag>
        <tag>GMP模型</tag>
        <tag>Goroutine</tag>
        <tag>调度器</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 222 - 完全二叉树的节点个数（Count Complete Tree Nodes）</title>
    <url>/2025/06/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一棵<strong>完全二叉树</strong>的根节点 <code>root</code>，求出该树的节点个数。</p>
<p><strong>完全二叉树</strong>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最底层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1 ~ 2^(h-1) 个节点。</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h3 id="示例-3：">示例 3：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h3 id="约束条件：">约束条件：</h3>
<ul>
<li>树中节点的数目范围是 <code>[0, 5 * 10^4]</code></li>
<li><code>0 &lt;= Node.val &lt;= 5 * 10^4</code></li>
<li>题目数据保证输入的树是<strong>完全二叉树</strong></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的关键在于利用<strong>完全二叉树的性质</strong>来优化计算。</p>
<p>如果直接遍历整个树来计算节点个数，时间复杂度会是 O(n)。但是，完全二叉树有一个重要性质：<strong>对于完全二叉树的任意子树，如果其左子树的高度等于右子树的高度，那么这个子树是一个满二叉树</strong>。</p>
<h3 id="核心思想">核心思想</h3>
<ol>
<li><strong>满二叉树的节点个数</strong>：对于高度为 h 的满二叉树，节点个数为 $2^h - 1$</li>
<li><strong>高度计算</strong>：通过计算左子树的高度（一直往左走）和右子树的高度（一直往右走）</li>
<li><strong>递归判断</strong>：
<ul>
<li>如果左子树高度 = 右子树高度 → 满二叉树 → 使用公式计算</li>
<li>如果左子树高度 ≠ 右子树高度 → 递归计算左右子树 + 根节点</li>
</ul>
</li>
</ol>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li><strong>边界条件</strong>：如果节点为空，返回 0</li>
<li><strong>计算高度</strong>：
<ul>
<li>从当前节点开始，一直向左走，计算左子树高度 <code>hl</code></li>
<li>从当前节点开始，一直向右走，计算右子树高度 <code>hr</code></li>
</ul>
</li>
<li><strong>判断是否为满二叉树</strong>：
<ul>
<li>如果 <code>hl == hr</code>，说明是满二叉树，返回 $2^{hl} - 1$</li>
<li>如果 <code>hl != hr</code>，递归计算：<code>countNodes(left) + 1 + countNodes(right)</code></li>
</ul>
</li>
</ol>
<h3 id="为什么这样做是正确的？">为什么这样做是正确的？</h3>
<p>对于完全二叉树，如果左子树高度等于右子树高度，说明左子树是满的，右子树也是满的（除了可能最后一层）。但由于我们计算的是从根到最深叶子的路径长度，如果左右路径长度相等，说明整个子树都是满的。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算左子树高度</span></span><br><span class="line">        hl := <span class="number">0</span></span><br><span class="line">        cur := node</span><br><span class="line">        <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur = cur.Left</span><br><span class="line">            hl++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算右子树高度</span></span><br><span class="line">        hr := <span class="number">0</span></span><br><span class="line">        cur = node</span><br><span class="line">        <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur = cur.Right</span><br><span class="line">            hr++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果高度相等，说明是满二叉树</span></span><br><span class="line">        <span class="keyword">if</span> hl == hr &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;hl - <span class="number">1</span>  <span class="comment">// 等价于 2^hl - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 否则递归计算左右子树</span></span><br><span class="line">        <span class="keyword">return</span> dfs(node.Left) + <span class="number">1</span> + dfs(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键实现细节">关键实现细节</h3>
<ol>
<li><strong>高度计算</strong>：从当前节点开始计算，所以根节点的高度为 1</li>
<li><strong>位运算优化</strong>：<code>1&lt;&lt;hl - 1</code> 等价于 $2^{hl} - 1$，利用位运算提高效率</li>
<li><strong>递归结构</strong>：使用内部函数 <code>dfs</code> 来实现递归逻辑</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-log-2-n">时间复杂度：$O(\log^2 n)$</h3>
<p><strong>推导过程</strong>：</p>
<ul>
<li>每次递归调用时，我们需要计算左右子树的高度，这需要 $O(\log n)$ 时间</li>
<li>在最坏情况下，我们需要递归 $O(\log n)$ 次（树的高度）</li>
<li>因此总时间复杂度为 $O(\log n \times \log n) = O(\log^2 n)$</li>
</ul>
<p><strong>为什么不是 O(n)？</strong></p>
<ul>
<li>关键在于我们不是每个节点都访问</li>
<li>每次递归时，要么直接计算出满二叉树的节点数，要么只递归到一个子树</li>
<li>这大大减少了需要访问的节点数量</li>
</ul>
<h3 id="空间复杂度：-O-log-n">空间复杂度：$O(\log n)$</h3>
<ul>
<li>递归调用栈的深度最多为树的高度</li>
<li>完全二叉树的高度为 $O(\log n)$</li>
</ul>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>暴力遍历</th>
<th>本题解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n)$</td>
<td>$O(\log^2 n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(\log n)$</td>
<td>$O(\log n)$</td>
</tr>
<tr>
<td>优点</td>
<td>思路简单直接</td>
<td>充分利用完全二叉树性质</td>
</tr>
<tr>
<td>缺点</td>
<td>没有利用题目条件</td>
<td>实现相对复杂</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>利用数据结构特性</strong>：完全二叉树的特殊性质是解决这个问题的关键</li>
<li><strong>满二叉树判断</strong>：通过比较左右子树高度来判断是否为满二叉树</li>
<li><strong>递归优化</strong>：不是所有子树都需要递归，大大提高了效率</li>
<li><strong>位运算应用</strong>：使用 <code>1&lt;&lt;h</code> 代替 <code>pow(2,h)</code> 提高计算效率</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>高度计算错误</strong>：注意从当前节点开始计算高度，根节点高度为 1</li>
<li><strong>公式记忆错误</strong>：满二叉树节点数是 $2^h - 1$，不是 $2^h$</li>
<li><strong>递归终止条件</strong>：要正确处理空节点的情况</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li>LeetCode 104: 二叉树的最大深度</li>
<li>LeetCode 111: 二叉树的最小深度</li>
<li>LeetCode 958: 二叉树的完全性检验</li>
</ul>
<p>这道题很好地展示了如何利用数据结构的特殊性质来优化算法，是一道经典的树形结构优化问题。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股：Go语言垃圾回收 - 三色标记算法详解</title>
    <url>/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>GC是面试里的老八股文了，提起GC，很多人心里会发怵，但好好准备一番后，弄清其中的来龙去脉，在面试的过程中，往往能够舌灿莲花。今天特地梳理了一下GC的相关知识点，相信在各位道友看完后，也可以对面试官提出的GC问题，灰常自信的娓娓道来…</p>
<h2 id="背景知识">背景知识</h2>
<h3 id="什么是GC？">什么是GC？</h3>
<p><strong>垃圾回收（Garbage Collection，缩写为GC）</strong>，是一种自动内存管理机制。</p>
<p>即我们在程序中定义一个变量后，会在内存中开辟相应空间进行存储。当不需要此变量后，需要手动销毁此对象，并释放内存。而这种对不再使用的内存资源进行自动回收的功能即为垃圾回收。</p>
<h3 id="GC相关术语">GC相关术语</h3>
<p>在对GC开始讲解之前，有很多关于GC的行话，先普及一下，不然后文读起来会稍微有点懵。</p>
<ul>
<li>
<p><strong>赋值器（Mutator）</strong>：说白了就是你写的程序代码，在程序的执行过程中，可能会改变对象的引用关系，或者创建新的引用。</p>
</li>
<li>
<p><strong>回收器（Collector）</strong>：垃圾回收器的责任就是去干掉那些程序中不再被引用的对象。</p>
</li>
<li>
<p><strong>STW（Stop The World）</strong>：GC期间某个阶段会停止所有的赋值器，中断你的程序逻辑，以确定引用关系。</p>
<blockquote>
<p><strong>为什么需要STW？</strong> 举个生动的例子：想象一个幼儿园老师要统计孩子们的手牵手情况。如果孩子们在统计过程中还在跑来跑去，改变牵手关系，那统计结果就不准确了。所以老师需要先让所有孩子&quot;定格&quot;（STW），然后进行统计。在GC中也是如此，如果程序在标记过程中还在改变对象引用关系，就可能导致应该存活的对象被误删除。</p>
</blockquote>
</li>
<li>
<p><strong>Root对象</strong>：根对象是指赋值器不需要通过其他对象就可以直接访问到的对象，通过Root对象，可以追踪到其他存活的对象。常见的root对象有：</p>
<ul>
<li><strong>全局变量</strong>：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li>
<li><strong>执行栈</strong>：每个goroutine（包括main函数）都拥有自己的执行栈，这些执行栈上包含栈上的变量及堆内存指针。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>易混淆点解释</strong>：很多人分不清栈内存和堆内存的对象。简单记住：</p>
<ul>
<li><strong>栈内存</strong>：函数内的局部变量，作用域有限，函数结束就释放</li>
<li><strong>堆内存</strong>：通过new、make等分配的内存，需要GC来回收</li>
</ul>
</blockquote>
<h2 id="Go的GC发展演变史">Go的GC发展演变史</h2>
<h3 id="v1-3-标记清除法">v1.3 - 标记清除法</h3>
<p>标记清除法主要包含两个步骤：</p>
<ol>
<li><strong>标记</strong></li>
<li><strong>清除</strong></li>
</ol>
<h4 id="算法流程示例">算法流程示例</h4>
<p><strong>第一步：开启STW，停止程序的运行</strong></p>
<p>图中是本次GC涉及到的root节点和相关对象：</p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089761940.png" alt="1750089761940"></p>
<p><strong>第二步：从根节点出发，标记所有可达对象</strong></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089768379.png" alt="1750089768379"></p>
<p><strong>第三步：停止STW，回收所有未被标记的对象</strong></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089782651.png" alt="1750089782651"></p>
<h4 id="标记清除法的弊端">标记清除法的弊端</h4>
<p>标记清除法的最大弊端就是在整个GC期间需要STW，将整个程序暂停。因为如果不进行STW的话，会出现已经被标记的对象A，引用了新的未被标记的对象B，但由于对象A已经标记过了，不会再重新扫描A对B的可达性，从而将B对象当做垃圾回收掉。</p>
<p>说实话这种全程STW的GC算法真的是如过街老鼠，人见人打…好家伙，让我程序停下来，专门去做垃圾回收这件事，在追求高性能的今天，很难有人可以接受这种性能损耗。</p>
<p>所以Golang团队这个时期就开始专注于如何能提升GC的性能，这里希望各位道友能明白Golang团队对GC算法优化的方向是什么，或者目标是什么，那就是<strong>让GC和用户程序可以互不干扰，并发进行</strong>。所以才有了后面的三色标记法。</p>
<h3 id="v1-5-三色标记法">v1.5 - 三色标记法</h3>
<h4 id="算法流程">算法流程</h4>
<p><strong>第一步：初始时，所有对象被标记为白色</strong></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089792781.png" alt="1750089792781"></p>
<p><strong>第二步：GC开始，遍历rootset，将直接可达的对象标记为灰色</strong></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089800640.png" alt="1750089800640"></p>
<p><strong>第三步：遍历灰色对象，将直接可达的对象标记为灰色，并将自身标记为黑色</strong></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089807926.png" alt="1750089807926"></p>
<p><strong>第四步：重复第三步，直到灰色对象为空，也就是标记完所有对象</strong></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089813826.png" alt="1750089813826"></p>
<p><strong>第五步：停止STW，回收所有白色对象</strong></p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089819494.png" alt="1750089819494"></p>
<blockquote>
<p><strong>三色含义详解</strong>：</p>
<ul>
<li><strong>白色</strong>：未被访问的对象，可能是垃圾，最终会被回收</li>
<li><strong>灰色</strong>：已被访问但其引用的对象还没有全部访问完，相当于&quot;待处理队列&quot;</li>
<li><strong>黑色</strong>：已访问且其引用的对象也全部访问完毕，确定存活的对象</li>
</ul>
</blockquote>
<h4 id="三色标记法的问题">三色标记法的问题</h4>
<p>对于上述的三色标记法来讲，仍然需要依赖STW的。因为如果不暂停程序，程序的逻辑改变对象引用关系，这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景：</p>
<p><strong>问题场景演示：</strong></p>
<ol>
<li>对象2标记为灰色，对象2引用了对象3：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089840658.png" alt="1750089840658"></p>
<ol start="2">
<li>黑色对象6创建了一个指针，指向了对象3：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089857909.png" alt="1750089857909"></p>
<ol start="3">
<li>对象2删除了对象3的引用：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089870176.png" alt="1750089870176"></p>
<ol start="4">
<li>由于对象6不会再进行扫描，3对象一直会是白色标记，最后会被当做垃圾回收掉：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750089876109.png" alt="1750089876109"></p>
<blockquote>
<p><strong>这个问题为什么会发生？</strong><br>
因为对象6已经是黑色，按照算法规则，黑色对象不会再被扫描。当对象6新增对对象3的引用，而对象2又删除了对对象3的引用时，对象3就&quot;失联&quot;了——没有任何灰色对象能发现它，但它实际上还被黑色对象6引用着，应该存活。</p>
</blockquote>
<p>好，那我们接着说，Golang是如何解决这个STW问题的呢？</p>
<h4 id="对象丢失的条件分析">对象丢失的条件分析</h4>
<p>其实总结来看，在三色标记法的过程中对象丢失，需要同时满足下面两个条件：</p>
<ul>
<li><strong>条件一</strong>：白色对象被黑色对象引用</li>
<li><strong>条件二</strong>：灰色对象与白色对象之间的可达关系遭到破坏</li>
</ul>
<p>看来只要把上面两个条件破坏掉一个，就可以保证对象不丢失，所以我们的golang团队就提出了两种破坏条件的方式：<strong>强三色不变式</strong>和<strong>弱三色不变式</strong>。</p>
<blockquote>
<p><strong>为什么需要同时满足两个条件？</strong></p>
<ul>
<li>如果只满足条件一，但灰色对象还能到达白色对象，那么在后续扫描中还能发现这个白色对象</li>
<li>如果只满足条件二，但白色对象没有被黑色对象引用，那么这个白色对象本来就应该被回收</li>
<li>只有两个条件同时满足，才会出现&quot;应该存活但被误删&quot;的情况</li>
</ul>
</blockquote>
<h2 id="两种不变式">两种不变式</h2>
<h3 id="强三色不变式">强三色不变式</h3>
<p><strong>规则</strong>：不允许黑色对象引用白色对象</p>
<p><strong>破坏条件</strong>：破坏了条件一 - 白色对象被黑色对象引用</p>
<p><strong>解释</strong>：如果一个黑色对象不直接引用白色对象，那么就不会出现白色对象扫描不到，从而被当做垃圾回收掉的尴尬：</p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090062290.png" alt="1750090062290"></p>
<blockquote>
<p><strong>通俗理解</strong>：就像班级里，“已完成作业的同学”（黑色）不能直接帮助&quot;未开始作业的同学&quot;（白色），必须通过&quot;正在做作业的同学&quot;（灰色）来传递帮助。</p>
</blockquote>
<h3 id="弱三色不变式">弱三色不变式</h3>
<p><strong>规则</strong>：黑色对象可以引用白色对象，但是白色对象的上游必须存在灰色对象</p>
<p><strong>破坏条件</strong>：破坏了条件二 - 灰色对象与白色对象之间的可达关系遭到破坏</p>
<p><strong>解释</strong>：如果一个白色对象的上游有灰色对象，则这个白色对象一定可以扫描到，从而不被回收：</p>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090072223.png" alt="1750090072223"></p>
<blockquote>
<p><strong>通俗理解</strong>：允许&quot;已完成作业的同学&quot;（黑色）直接帮助&quot;未开始作业的同学&quot;（白色），但必须保证有&quot;正在做作业的同学&quot;（灰色）也能联系到这个&quot;未开始作业的同学&quot;，这样就有双重保障。</p>
</blockquote>
<h2 id="屏障机制">屏障机制</h2>
<p>Golang团队遵循上述两种不变式提到的原则，分别提出了两种实现机制：<strong>插入写屏障</strong>和<strong>删除写屏障</strong>。</p>
<blockquote>
<p><strong>什么是写屏障？</strong><br>
写屏障可以理解为在程序修改指针时自动执行的一小段代码，它会拦截这些修改操作，并执行一些额外的标记工作。就像门卫一样，监控所有的&quot;引用关系变更&quot;。</p>
</blockquote>
<h3 id="插入写屏障">插入写屏障</h3>
<p><strong>规则</strong>：当一个对象引用另外一个对象时，将另外一个对象标记为灰色。</p>
<p><strong>满足</strong>：强三色不变式。不会存在黑色对象引用白色对象</p>
<p><strong>重要提示</strong>：插入屏障仅会在堆内存中生效，不对栈内存空间生效，这是因为go在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万goroutine的栈都进行屏障保护自然会有性能问题。</p>
<blockquote>
<p><strong>为什么栈不用屏障？</strong></p>
<ol>
<li><strong>性能考虑</strong>：栈操作极其频繁，每个函数调用都涉及栈操作</li>
<li><strong>并发数量</strong>：Go程序可能有数十万个goroutine，每个都有自己的栈</li>
<li><strong>开销太大</strong>：如果每个栈操作都要写屏障，性能损失巨大</li>
</ol>
</blockquote>
<h4 id="插入写屏障机制示例">插入写屏障机制示例</h4>
<p>下面我们看看插入写屏障机制，在插入写屏障机制下是如何保护对象不丢失的：</p>
<ol>
<li>对象2标记为灰色，对象2引用了对象3：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090080410.png" alt="1750090080410"></p>
<ol start="2">
<li>黑色对象6创建了一个指针，指向了对象3，由于插入写屏障，对象3变成灰色：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090087363.png" alt="1750090087363"></p>
<ol start="3">
<li>对象2删除了对象3的引用：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090093919.png" alt="1750090093919"></p>
<p>可以发现，对象3在插入写屏障机制下，得到了保护，但是由于栈上的对象没有插入写机制，在扫描完成后，仍然可能存在栈上的白色对象被黑色对象引用，所以在最后需要对栈上的空间进行STW，防止对象误删除。如下所示：</p>
<ol start="4">
<li>为黑色对象1新引用对象9，由于对象1在栈区，不会触发插入写屏障机制：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090101055.png" alt="1750090101055"></p>
<ol start="5">
<li>对栈空间进行STW保护：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090111424.png" alt="1750090111424"></p>
<ol start="6">
<li>对栈空间重新进行扫描，将对象9标记为了黑色，最后垃圾回收白色标记的对象5和8，符合预期：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090117475.png" alt="1750090117475"></p>
<h4 id="插入写屏障的弊端">插入写屏障的弊端</h4>
<p>对于插入写屏障来讲，插入写屏障最大的弊端就是，在一次正常的三色标记流程结束后，需要对栈上重新进行一次STW，然后再rescan一次。</p>
<blockquote>
<p><strong>插入写屏障的问题</strong>：虽然大部分时间可以并发标记，但最后还是需要STW来处理栈，这依然会造成程序暂停。</p>
</blockquote>
<h3 id="删除写屏障">删除写屏障</h3>
<p><strong>规则</strong>：在删除引用时，如果被删除引用的对象自身为灰色或者白色，那么被标记为灰色。</p>
<p><strong>满足</strong>：弱三色不变式。灰色对象到白色对象的路径不会断</p>
<p><strong>解释</strong>：白色对象始终会被灰色对象保护</p>
<h4 id="删除写屏障机制示例">删除写屏障机制示例</h4>
<p>下面我们看看在删除写屏障机制下是如何保护对象不丢失的：</p>
<ol>
<li>对象2标记为灰色，对象2引用了对象3：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090125329.png" alt="1750090125329"></p>
<ol start="2">
<li>黑色对象6引用了对象3：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090132051.png" alt="1750090132051"></p>
<ol start="3">
<li>灰色对象2去掉了对象3的引用，触发删除写屏障，将对象3标记为灰色：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090138630.png" alt="1750090138630"></p>
<ol start="4">
<li>遍历完所有可达对象后，回收了白色对象5和8，符合预期：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090145711.png" alt="1750090145711"></p>
<h4 id="删除写屏障的弊端">删除写屏障的弊端</h4>
<p>但是引入删除写屏障，有一个弊端，就是一个对象的引用被删除后，即使没有其他存活的对象引用它，它仍然会活到下一轮。如此一来，会产生很多的冗余扫描成本，且降低了回收精度。</p>
<p><strong>举例说明：</strong></p>
<p>如下图：</p>
<ol>
<li>对象1为黑色，对象2为灰色，对象3…n为白色，1引用2，2引用3，…，n-1引用n</li>
<li>对象2删除了对象3的引用</li>
<li>触发删除屏障机制，对象3标灰</li>
<li>冗余扫描对象3到对象n，且GC完成后均被保留下来，降低了回收精度</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090152351.png" alt="1750090152351"></p>
<blockquote>
<p><strong>删除写屏障的问题</strong>：它过于&quot;保守&quot;，宁愿多留一些垃圾到下次GC，也不愿意误删有用对象。这导致内存回收不够及时。</p>
</blockquote>
<h3 id="小结">小结</h3>
<p>从上面示例来看，插入写屏障机制和删除写屏障机制中任一机制均可保护对象不丢失。在V1.5的版本中采用的是插入写机制实现。</p>
<p><strong>对比插入写屏障和删除写屏障</strong>：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入写屏障</td>
<td>回收精度高，能及时回收垃圾</td>
<td>最后需要STW重扫栈</td>
<td>写入操作较多的场景</td>
</tr>
<tr>
<td>删除写屏障</td>
<td>不需要重扫栈，减少STW时间</td>
<td>回收精度低，产生浮动垃圾</td>
<td>删除操作较多的场景</td>
</tr>
</tbody>
</table>
<h2 id="v1-8-混合写屏障机制">v1.8 - 混合写屏障机制</h2>
<p>讲到这里，如果是你，你会怎么做呢？当然是取其精华，去其糟粕啦…没错，Golang团队，正是结合了这两点，在v1.8版本下引入了<strong>混合写屏障机制</strong>。</p>
<h3 id="混合屏障机制的核心定义">混合屏障机制的核心定义</h3>
<ol>
<li>
<p><strong>GC刚开始的时候，会将栈上的可达对象全部标记为黑色。</strong></p>
</li>
<li>
<p><strong>GC期间，任何在栈上新创建的对象，均为黑色。</strong></p>
<blockquote>
<p><strong>为什么这样做？</strong><br>
因为栈操作太频繁，与其在每次栈操作时都用写屏障（性能损失大），不如在GC开始时一次性把栈上的对象都标记为黑色。这样既避免了频繁的写屏障，也确保栈上对象不会被误删。</p>
</blockquote>
</li>
<li>
<p><strong>堆上被删除的对象标记为灰色</strong></p>
</li>
<li>
<p><strong>堆上新添加的对象标记为灰色</strong></p>
</li>
</ol>
<h3 id="混合写屏障机制的示例">混合写屏障机制的示例</h3>
<p>下面我们看看混合写屏障机制的示例：</p>
<ol>
<li>初始时，所有对象被标记为白色：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090165652.png" alt="1750090165652"></p>
<ol start="2">
<li>GC开始时，先将栈上所有可达对象标记为黑色：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090172566.png" alt="1750090172566"></p>
<ol start="3">
<li>开始三色标记，将6标记为灰色，同时栈上对象3引用对象9，触发混合写屏障机制，将对象9标记为黑色：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090178723.png" alt="1750090178723"></p>
<ol start="4">
<li>对象6新引用对象10，对象6在堆上，触发混合屏障机制，将10对象标记为灰色：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090184552.png" alt="1750090184552"></p>
<ol start="5">
<li>对象1引用了对象7，由于对象1在栈上，不会触发混合屏障机制，仅仅是挂载：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090190532.png" alt="1750090190532"></p>
<ol start="6">
<li>对象6删除了对对象7的引用，对象6在堆上，触发混合写屏障机制，将对象7标记为灰色：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090196232.png" alt="1750090196232"></p>
<p><strong>重要说明</strong>：有同学可能会问，万一栈上的对象1引用了堆上的一个新分配的白色对象8，由于不触发混合写屏障机制，那对象8一直是白色的，最后不就被垃圾回收走了么？</p>
<blockquote>
<p><strong>这个担心是多余的！</strong></p>
<p>这个情况是不会发生的，原因如下：</p>
<ol>
<li><strong>对象创建时机</strong>：如果对象8是在GC开始后新分配的，它不会是白色，而是会被标记为黑色（这是混合写屏障的规则）</li>
<li><strong>引用可达性</strong>：一个对象之所以能被引用，前提是它必须是可达的。在图中的8号对象显然是不可达的白色对象（GC开始前就存在且无引用）</li>
<li><strong>栈扫描时机</strong>：栈上的可达对象在GC开始时就全部标记为黑色了，包括它们当时能到达的所有对象</li>
</ol>
</blockquote>
<p>那为什么1号对象可以引用7号对象呢？这是因为1号对象在引用7号对象的时候，对象7是在对象6的下游，本身是可达的，所以这种引用关系的改变是合理的。</p>
<ol start="7">
<li>将所有可达对象标记完成后，GC结束，最后把对象5和对象8白色对象回收：</li>
</ol>
<p><img src="/2025/06/17/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95/1750090203090.png" alt="1750090203090"></p>
<h3 id="混合写屏障的优势">混合写屏障的优势</h3>
<ol>
<li><strong>消除了重扫栈的STW</strong>：不需要在最后暂停程序重新扫描栈</li>
<li><strong>兼顾性能和精度</strong>：既避免了频繁的栈写屏障，又保持了较高的回收精度</li>
<li><strong>实现简单</strong>：逻辑清晰，易于理解和维护</li>
</ol>
<blockquote>
<p><strong>混合写屏障的精妙之处</strong>：</p>
<ul>
<li>用&quot;一次性标黑栈对象&quot;替代&quot;频繁的栈写屏障&quot;</li>
<li>在堆上同时使用插入和删除写屏障的优点</li>
<li>达到了性能和精度的完美平衡</li>
</ul>
</blockquote>
<h2 id="总结">总结</h2>
<p>Go语言垃圾回收机制的演进历程：</p>
<ol>
<li>
<p><strong>Golang v1.3之前</strong>：采用传统的标记-清除法，需要STW，暂停整个程序的运行。</p>
<ul>
<li>优点：简单直接，逻辑清晰</li>
<li>缺点：STW时间长，严重影响程序性能</li>
</ul>
</li>
<li>
<p><strong>v1.5版本</strong>：引入了三色标记法和插入写屏障机制，其中插入写屏障机制只在堆内存中生效。但在标记过程中，最后需要对栈进行STW。</p>
<ul>
<li>优点：大部分时间可以并发标记，性能有所提升</li>
<li>缺点：最后仍需STW重扫栈，存在性能瓶颈</li>
</ul>
</li>
<li>
<p><strong>v1.8版本</strong>：结合删除写屏障机制，推出了混合屏障机制，屏障限制只在堆内存中生效。避免了最后节点对栈进行STW的问题，提升了GC效率。</p>
<ul>
<li>优点：几乎消除了STW，达到了并发标记的目标</li>
<li>缺点：实现复杂度稍高，但这个代价是值得的</li>
</ul>
</li>
</ol>
<h2 id="深度理解要点">深度理解要点</h2>
<h3 id="易混淆概念澄清">易混淆概念澄清</h3>
<ol>
<li><strong>三色的本质</strong>：三色不是对象的固有属性，而是GC过程中的临时标记状态</li>
<li><strong>写屏障的作用时机</strong>：只有在修改指针引用关系时才会触发，普通的值修改不会触发</li>
<li><strong>栈与堆的处理差异</strong>：栈处理简单粗暴（全标黑），堆处理精细复杂（写屏障）</li>
<li><strong>STW的必要性</strong>：不是所有GC都能完全避免STW，关键是尽可能减少STW时间</li>
</ol>
<h3 id="性能优化思路">性能优化思路</h3>
<p>Go GC的优化思路体现了工程上的智慧：</p>
<ol>
<li><strong>权衡取舍</strong>：在吞吐量、延迟、内存使用之间寻找平衡</li>
<li><strong>分治策略</strong>：栈和堆采用不同的处理策略</li>
<li><strong>渐进优化</strong>：从v1.3到v1.8的逐步改进，每次解决一个主要问题</li>
<li><strong>实用主义</strong>：不追求理论上的完美，而是追求工程上的可行</li>
</ol>
<h2 id="常见面试问题">常见面试问题</h2>
<h3 id="Q1：Go语言中三色标记法的基本原理是什么？">Q1：Go语言中三色标记法的基本原理是什么？</h3>
<p><strong>答</strong>：三色标记法将所有对象分为三种颜色：</p>
<ul>
<li><strong>白色</strong>：未被访问的对象，最后会被回收</li>
<li><strong>灰色</strong>：已访问但其引用的对象还未全部访问，相当于待处理队列</li>
<li><strong>黑色</strong>：已访问且其引用的对象也全部访问完毕，确定存活的对象</li>
</ul>
<p>标记过程从根对象开始，逐步将可达对象从白色标记为灰色，再从灰色标记为黑色，最终回收所有白色对象。这个过程可以与程序并发执行，提高了GC效率。</p>
<h3 id="Q2：为什么需要写屏障机制？">Q2：为什么需要写屏障机制？</h3>
<p><strong>答</strong>：在并发标记过程中，程序可能会修改对象间的引用关系，这可能导致应该存活的对象被误回收。具体来说，当同时满足以下两个条件时，对象会丢失：</p>
<ol>
<li>白色对象被黑色对象引用</li>
<li>灰色对象与白色对象之间的可达关系被破坏</li>
</ol>
<p>写屏障机制可以拦截这些引用关系的改变，通过破坏上述条件之一来确保对象不会丢失。</p>
<h3 id="Q3：插入写屏障和删除写屏障的区别是什么？">Q3：插入写屏障和删除写屏障的区别是什么？</h3>
<p><strong>答</strong>：</p>
<ul>
<li>
<p><strong>插入写屏障</strong>：在创建新引用时触发，将被引用对象标记为灰色，满足强三色不变式（不允许黑色对象引用白色对象）</p>
<ul>
<li>优点：回收精度高</li>
<li>缺点：最后需要STW重扫栈</li>
</ul>
</li>
<li>
<p><strong>删除写屏障</strong>：在删除引用时触发，将被删除引用的对象标记为灰色，满足弱三色不变式（白色对象的上游必须存在灰色对象）</p>
<ul>
<li>优点：不需要重扫栈</li>
<li>缺点：回收精度低，产生浮动垃圾</li>
</ul>
</li>
</ul>
<h3 id="Q4：Go-1-8的混合写屏障解决了什么问题？">Q4：Go 1.8的混合写屏障解决了什么问题？</h3>
<p><strong>答</strong>：混合写屏障结合了插入写屏障和删除写屏障的优点，主要解决了以下问题：</p>
<ol>
<li><strong>消除STW</strong>：通过在GC开始时将栈上对象全部标记为黑色，避免了最后重扫栈的STW</li>
<li><strong>性能优化</strong>：避免了在高频的栈操作上使用写屏障，大大降低了性能开销</li>
<li><strong>提高精度</strong>：在堆上同时使用插入和删除写屏障的机制，保持了较高的回收精度</li>
</ol>
<p>其核心思想是：栈用简单粗暴的方式处理（全标黑），堆用精细的写屏障处理，达到性能和精度的平衡。</p>
<h3 id="Q5：为什么栈不使用写屏障？">Q5：为什么栈不使用写屏障？</h3>
<p><strong>答</strong>：栈不使用写屏障的原因：</p>
<ol>
<li><strong>性能考虑</strong>：栈操作极其频繁，每个函数调用、局部变量操作都涉及栈，如果都加写屏障，性能损失巨大</li>
<li><strong>数量问题</strong>：Go程序可能有数十万个goroutine，每个都有自己的栈，写屏障的开销会被放大</li>
<li><strong>替代方案</strong>：混合写屏障采用在GC开始时一次性标记栈上所有对象为黑色的方式，避免了频繁的写屏障</li>
</ol>
<h3 id="Q6：什么情况下会触发GC？">Q6：什么情况下会触发GC？</h3>
<p><strong>答</strong>：Go语言中GC的触发条件主要有：</p>
<ol>
<li>
<p><strong>自动触发</strong>：</p>
<ul>
<li>内存分配达到一定阈值（由GOGC环境变量控制，默认100%）</li>
<li>距离上次GC时间超过2分钟</li>
</ul>
</li>
<li>
<p><strong>手动触发</strong>：</p>
<ul>
<li>调用<code>runtime.GC()</code>函数</li>
<li>调用<code>runtime.GCPercent()</code>设置触发阈值</li>
</ul>
</li>
<li>
<p><strong>系统压力</strong>：</p>
<ul>
<li>系统内存不足时可能会更频繁地触发GC</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p><strong>学习建议</strong>：</p>
<ol>
<li><strong>画图理解</strong>：GC机制最好通过画图来理解对象引用关系的变化</li>
<li><strong>实验验证</strong>：可以通过编写测试程序和使用<code>go tool trace</code>来观察GC行为</li>
<li><strong>关注演进</strong>：理解每个版本的改进点，有助于深入理解设计思路</li>
<li><strong>结合实践</strong>：在实际项目中注意GC的性能影响，学会调优</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
        <tag>三色标记法</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: Go Map 基础概念与用法</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1>Go Map 基础概念与用法</h1>
<h2 id="概述">概述</h2>
<p>map 又称字典，是一种常用的数据结构，核心特征包含下述三点：</p>
<p>（1）存储基于 key-value 对映射的模式；</p>
<p>（2）基于 key 维度实现存储数据的去重；</p>
<p>（3）读、写、删操作控制，时间复杂度 O(1)。</p>
<h2 id="初始化">初始化</h2>
<h3 id="几种初始化方法">几种初始化方法</h3>
<p>golang 中，对 map 的初始化分为以下几种方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>通过 make 关键字进行初始化，同时指定 map 预分配的容量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>通过 make 关键字进行初始化，不显式声明容量，因此默认容量为 0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap3 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化操作连带赋值，一气呵成。</p>
<h3 id="key-的类型要求">key 的类型要求</h3>
<p>map 中，key 的数据类型必须为可比较的类型，chan、map、func 不可比较。</p>
<p><strong>可作为 key 的类型：</strong></p>
<ul>
<li>基本类型：bool, 数值类型, string</li>
<li>指针类型</li>
<li>数组类型（元素可比较）</li>
<li>结构体类型（所有字段可比较）</li>
</ul>
<p><strong>不可作为 key 的类型：</strong></p>
<ul>
<li>slice（切片）</li>
<li>map（映射）</li>
<li>function（函数）</li>
</ul>
<h2 id="读操作">读操作</h2>
<p>读 map 分为下面两种方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v1 := myMap[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>第一种方式是直接读，倘若 key 存在，则获取到对应的 val，倘若 key 不存在或者 map 未初始化，会返回 val 类型的零值作为兜底。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v2, ok := myMap[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>第二种方式是读的同时添加一个 bool 类型的 flag 标识是否读取成功。倘若 ok == false，说明读取失败，key 不存在，或者 map 未初始化。</p>
<p>此处同一种语法能够实现不同返回值类型的适配，是由于代码在汇编时，会根据返回参数类型的区别，映射到不同的实现方法。</p>
<h3 id="判断-key-是否存在">判断 key 是否存在</h3>
<p><strong>正确方式：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := m[key]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="comment">// key存在，value是对应的值</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;key存在，值为:&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// key不存在，value是零值</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;key不存在&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="keyword">if</span> value, ok := m[key]; ok &#123;</span><br><span class="line">    <span class="comment">// key存在的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 不能仅通过值判断 key 是否存在，因为值可能就是零值。</p>
<h2 id="写操作">写操作</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">myMap[<span class="number">5</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>写操作的语法如上。须注意的一点是，倘若 map 未初始化，直接执行写操作会导致 panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;assignment to entry in nil map&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="删除操作">删除操作</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(myMap, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示。</p>
<h2 id="遍历操作">遍历操作</h2>
<p>遍历分为下面两种方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 k,v 依次承接 map 中的 key-value 对；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> myMap &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 k 依次承接 map 中的 key，不关注 val 的取值。</p>
<h3 id="遍历顺序">遍历顺序</h3>
<p>需要注意的是，在执行 map 遍历操作时，获取的 key-value 对并没有一个固定的顺序，因此前后两次遍历顺序可能存在差异。</p>
<p><strong>Go map 遍历无序的原因：</strong></p>
<ol>
<li><strong>哈希表特性</strong>：数据存储位置由哈希值决定，不保证顺序</li>
<li><strong>故意随机化</strong>：Go 1.0 后故意引入随机化，防止程序依赖遍历顺序</li>
<li><strong>扩容影响</strong>：扩容过程中数据重新分布，进一步打乱顺序</li>
</ol>
<p><strong>如需有序遍历：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先收集key并排序</span></span><br><span class="line">keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">	keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按排序后的key遍历</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">	fmt.Println(k, m[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发安全性">并发安全性</h2>
<p>map 不是并发安全的数据结构，倘若存在并发读写行为，会抛出 fatal error。</p>
<p>具体规则是：</p>
<p>（1）并发读没有问题；</p>
<p>（2）并发读写中的&quot;写&quot;是广义上的，包含写入、更新、删除等操作；</p>
<p>（3）读的时候发现其他 goroutine 在并发写，抛出 fatal error；</p>
<p>（4）写的时候发现其他 goroutine 在并发写，抛出 fatal error。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>需要关注，此处并发读写会引发 fatal error，是一种比 panic 更严重的错误，无法使用 recover 操作捕获。</p>
<h3 id="解决方案">解决方案</h3>
<p><strong>使用互斥锁：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line">mu.RLock()</span><br><span class="line">value := m[key]</span><br><span class="line">mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line">mu.Lock()</span><br><span class="line">m[key] = value</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
<p><strong>使用 sync.Map：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储</span></span><br><span class="line">m.Store(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">value, ok := m.Load(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">m.Delete(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 返回false会停止遍历</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="map-的零值">map 的零值</h2>
<ul>
<li><strong>零值</strong>：Go map 的零值是 <code>nil</code></li>
<li><strong>读操作</strong>：可以从 nil map 读取，返回零值和 false</li>
<li><strong>写操作</strong>：不能向 nil map 写入，会 panic：<code>assignment to entry in nil map</code></li>
</ul>
<p><strong>正确初始化方式：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：使用make</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：字面量初始化</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;key&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：指定容量</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>Go 语言的 map 是一个功能强大且高效的数据结构，但在使用时需要注意：</p>
<ol>
<li><strong>类型限制</strong>：key 必须是可比较类型</li>
<li><strong>并发安全</strong>：map 不是并发安全的，需要额外的同步机制</li>
<li><strong>零值处理</strong>：nil map 只能读不能写</li>
<li><strong>遍历顺序</strong>：遍历顺序是随机的，不要依赖顺序</li>
<li><strong>性能特征</strong>：读写删除操作的时间复杂度为 O(1)</li>
</ol>
<p>理解这些基础概念和用法是深入学习 Go map 底层实现的重要基础。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Go语言</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: Go Map 扩容机制深度解析</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1>Go Map 扩容机制深度解析</h1>
<h2 id="扩容机制概述">扩容机制概述</h2>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1750126901506.png" alt="1750126901506"></p>
<p>Go map 的扩容机制是其高性能的关键保障。通过动态调整桶数组大小，map 能够在元素数量增长时始终保持 O(1) 的平均访问时间复杂度。</p>
<h2 id="扩容类型详解">扩容类型详解</h2>
<p>map 的扩容类型分为两类：增量扩容和等量扩容。</p>
<h3 id="增量扩容（翻倍扩容）">增量扩容（翻倍扩容）</h3>
<p><strong>表现</strong>：扩容后，桶数组的长度增长为原长度的 2 倍</p>
<p><strong>目的</strong>：降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度</p>
<p><strong>触发条件</strong>：当负载因子超过 6.5 时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">负载因子 = 元素总数 / 桶数组长度 &gt; 6.5</span><br></pre></td></tr></table></figure>
<h3 id="等量扩容（整理扩容）">等量扩容（整理扩容）</h3>
<p><strong>表现</strong>：扩容后，桶数组的长度和之前保持一致；但是溢出桶的数量会下降</p>
<p><strong>目的</strong>：提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</p>
<p><strong>触发条件</strong>：当溢出桶数量过多时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">溢出桶数量 &gt;= 2^B （B 最大取 15）</span><br></pre></td></tr></table></figure>
<h2 id="扩容触发条件">扩容触发条件</h2>
<h3 id="触发时机">触发时机</h3>
<p>只有 map 的写流程可能开启扩容模式。写 map 新插入 key-value 对之前，会发起扩容条件判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩容状态判断">扩容状态判断</h3>
<p>根据 hmap 的 oldbuckets 是否为空，可以判断 map 此前是否已开启扩容模式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> growing() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增量扩容条件">增量扩容条件</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	loadFactorNum = <span class="number">13</span></span><br><span class="line">	loadFactorDen = <span class="number">2</span></span><br><span class="line">	bucketCnt     = <span class="number">8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件：</p>
<ul>
<li>map 中 key-value 对的数量超过 8 个</li>
<li>负载因子大于 6.5（13/2 = 6.5）</li>
</ul>
<h3 id="等量扩容条件">等量扩容条件</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">		B = <span class="number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>条件：溢出桶的数量大于等于 2^B 个（B 大于 15 时取 15）</p>
<h2 id="扩容开启流程-hashGrow">扩容开启流程 - hashGrow</h2>
<h3 id="hashGrow-核心实现">hashGrow 核心实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">	oldbuckets := h.buckets</span><br><span class="line">	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">		flags |= oldIterator</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// commit the grow (atomic wrt gc)</span></span><br><span class="line">	h.B += bigger</span><br><span class="line">	h.flags = flags</span><br><span class="line">	h.oldbuckets = oldbuckets</span><br><span class="line">	h.buckets = newbuckets</span><br><span class="line">	h.nevacuate = <span class="number">0</span></span><br><span class="line">	h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">		h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.nextOverflow = nextOverflow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开启流程详解">开启流程详解</h3>
<h4 id="1-扩容类型判断">1. 扩容类型判断</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">	bigger = <span class="number">0</span></span><br><span class="line">	h.flags |= sameSizeGrow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>增量扩容：<code>bigger = 1</code>，新桶数组长度翻倍</li>
<li>等量扩容：<code>bigger = 0</code>，并设置等量扩容标志位</li>
</ul>
<h4 id="2-新桶数组创建">2. 新桶数组创建</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">oldbuckets := h.buckets</span><br><span class="line">newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>保存老桶数组引用</li>
<li>创建新桶数组，长度为 2^(B+bigger)</li>
<li>同时创建新的溢出桶</li>
</ul>
<h4 id="3-状态更新">3. 状态更新</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.B += bigger</span><br><span class="line">h.flags = flags</span><br><span class="line">h.oldbuckets = oldbuckets</span><br><span class="line">h.buckets = newbuckets</span><br><span class="line">h.nevacuate = <span class="number">0</span></span><br><span class="line">h.noverflow = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更新桶数组长度指数</li>
<li>设置新老桶数组指针</li>
<li>重置迁移进度和溢出桶计数</li>
</ul>
<h4 id="4-溢出桶处理">4. 溢出桶处理</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">	h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">	h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将原本的溢出桶赋给 oldoverflow，为新桶数组分配新的溢出桶。</p>
<h2 id="数据迁移规则">数据迁移规则</h2>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1750126910858.png" alt="1750126910858"></p>
<h3 id="等量扩容迁移">等量扩容迁移</h3>
<p>在等量扩容中：</p>
<ul>
<li>新桶数组长度与原桶数组相同</li>
<li>key-value 对在新桶数组和老桶数组中的索引号保持一致</li>
<li>主要目的是重新整理数据，减少溢出桶</li>
</ul>
<h3 id="增量扩容迁移">增量扩容迁移</h3>
<p>在增量扩容中：</p>
<ul>
<li>新桶数组长度为原桶数组的 2 倍</li>
<li>把新桶数组分为两个区域：
<ul>
<li><strong>X 区域</strong>：对应老桶数组的区域（索引 0 到 2^(B-1)-1）</li>
<li><strong>Y 区域</strong>：新扩展的区域（索引 2^(B-1) 到 2^B-1）</li>
</ul>
</li>
</ul>
<h3 id="迁移位置计算">迁移位置计算</h3>
<p>一个 key 属于哪个桶，取决于其 hash 值对桶数组长度取模的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bucket = hash &amp; (<span class="number">2</span>^B - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>在增量扩容中，key 的新位置只有两种可能：</p>
<ul>
<li>原位置 i（X 区域）</li>
<li>原位置 + 老桶数组长度（Y 区域）</li>
</ul>
<p>判断依据是 hash 值的第 B 位：</p>
<ul>
<li>第 B 位为 0：迁移到 X 区域</li>
<li>第 B 位为 1：迁移到 Y 区域</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hash&amp;(<span class="number">1</span>&lt;&lt;(B<span class="number">-1</span>)) == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// 迁移到 X 区域，位置不变</span></span><br><span class="line">	newBucket = oldBucket</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 迁移到 Y 区域</span></span><br><span class="line">	newBucket = oldBucket + oldBucketCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="渐进式扩容机制">渐进式扩容机制</h2>
<h3 id="渐进式扩容策略">渐进式扩容策略</h3>
<p>map 采用渐进式扩容方式，避免一次性全量迁移导致的性能抖动：</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/1750126921148.png" alt="1750126921148"></p>
<p>当每次触发写、删操作时，会为处于扩容流程中的 map 完成两组桶的数据迁移：</p>
<ol>
<li>当前写、删操作所命中的桶</li>
<li>当前未迁移的桶中，索引最小的那个桶</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 迁移当前操作命中的桶</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 迁移一个额外的桶推进扩容进度</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="渐进式扩容优势">渐进式扩容优势</h3>
<ol>
<li><strong>分摊开销</strong>：将扩容开销分摊到多次操作中</li>
<li><strong>避免阻塞</strong>：单次操作不会因扩容而长时间阻塞</li>
<li><strong>内存友好</strong>：新老数组并存时间较短，减少内存压力</li>
<li><strong>用户无感知</strong>：对用户来说扩容过程透明</li>
</ol>
<h2 id="数据迁移实现-evacuate">数据迁移实现 - evacuate</h2>
<h3 id="evacuate-核心逻辑">evacuate 核心逻辑</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	newbit := h.noldbuckets()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">		<span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">		x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">		x.e = add(x.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">			y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">			y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">			e := add(k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.keysize)), add(e, <span class="type">uintptr</span>(t.elemsize)) &#123;</span><br><span class="line">				top := b.tophash[i]</span><br><span class="line">				<span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">					b.tophash[i] = evacuatedEmpty</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">					throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				k2 := k</span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">					k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">				<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">					hash := t.hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">					<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">						useY = <span class="number">1</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				b.tophash[i] = evacuatedX + useY</span><br><span class="line">				dst := &amp;xy[useY]</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">					dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">					dst.i = <span class="number">0</span></span><br><span class="line">					dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">					dst.e = add(dst.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">				&#125;</span><br><span class="line">				dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 复制 key</span></span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.k) = k2</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.key, dst.k, k)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 复制 value</span></span><br><span class="line">				<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.elem, dst.e, e)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				dst.i++</span><br><span class="line">				dst.k = add(dst.k, <span class="type">uintptr</span>(t.keysize))</span><br><span class="line">				dst.e = add(dst.e, <span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 清理老桶内存</span></span><br><span class="line">		<span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">			bMem := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize))</span><br><span class="line">			ptr := add(bMem, dataOffset)</span><br><span class="line">			n := <span class="type">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">			memclrHasPointers(ptr, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">		advanceEvacuationMark(h, t, newbit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迁移过程详解">迁移过程详解</h3>
<h4 id="1-目标桶准备">1. 目标桶准备</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">x := &amp;xy[<span class="number">0</span>]  <span class="comment">// X 区域目标桶</span></span><br><span class="line">y := &amp;xy[<span class="number">1</span>]  <span class="comment">// Y 区域目标桶（仅增量扩容使用）</span></span><br></pre></td></tr></table></figure>
<h4 id="2-迁移位置计算">2. 迁移位置计算</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">	hash := t.hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">	<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">		useY = <span class="number">1</span>  <span class="comment">// 迁移到 Y 区域</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-数据复制">3. 数据复制</h4>
<p>根据 key 和 value 是否为指针类型，选择合适的复制方式：</p>
<ul>
<li>指针类型：直接复制指针</li>
<li>值类型：使用 <code>typedmemmove</code> 复制数据</li>
</ul>
<h4 id="4-状态标记">4. 状态标记</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b.tophash[i] = evacuatedX + useY</span><br></pre></td></tr></table></figure>
<p>迁移完成后，在老桶中标记该位置已迁移：</p>
<ul>
<li><code>evacuatedX</code>：已迁移到 X 区域</li>
<li><code>evacuatedY</code>：已迁移到 Y 区域</li>
</ul>
<h3 id="迁移进度管理">迁移进度管理</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	h.nevacuate++</span><br><span class="line">	stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">	<span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">		stop = newbit</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">		h.nevacuate++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">		<span class="comment">// 所有桶都已迁移完成</span></span><br><span class="line">		h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.flags &amp;^= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容期间的操作处理">扩容期间的操作处理</h2>
<h3 id="读操作处理">读操作处理</h3>
<p>读操作需要同时检查新老桶数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">		m &gt;&gt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">		b = oldb  <span class="comment">// 从老桶读取</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写操作处理">写操作处理</h3>
<p>写操作会协助扩容进程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">	growWork(t, h, bucket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次写操作都会迁移两个桶，推进扩容进度。</p>
<h3 id="删除操作处理">删除操作处理</h3>
<p>删除操作同样会协助扩容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">	growWork(t, h, bucket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析与优化">性能分析与优化</h2>
<h3 id="扩容开销分析">扩容开销分析</h3>
<ol>
<li><strong>内存开销</strong>：扩容期间需要同时维护新老两个桶数组</li>
<li><strong>时间开销</strong>：每次写操作额外迁移两个桶</li>
<li><strong>GC 压力</strong>：迁移过程中可能产生额外的垃圾回收压力</li>
</ol>
<h3 id="负载因子选择">负载因子选择</h3>
<p>Go 选择 6.5 作为负载因子的原因：</p>
<ul>
<li><strong>查找效率</strong>：保证大部分查找在常数时间内完成</li>
<li><strong>内存利用率</strong>：避免内存浪费</li>
<li><strong>扩容频率</strong>：平衡扩容开销和性能</li>
</ul>
<h3 id="渐进式扩容优化">渐进式扩容优化</h3>
<ol>
<li><strong>批量迁移</strong>：一次迁移整个桶链表</li>
<li><strong>内存清理</strong>：及时清理老桶内存</li>
<li><strong>状态跟踪</strong>：精确跟踪迁移进度</li>
</ol>
<h2 id="面试重点问题">面试重点问题</h2>
<h3 id="Q1-Go-map-什么时候会扩容？">Q1: Go map 什么时候会扩容？</h3>
<p><strong>A:</strong> Go map 有两种扩容触发条件：</p>
<p><strong>增量扩容（容量翻倍）：</strong></p>
<ul>
<li>触发条件：负载因子 &gt; 6.5（count/2^B &gt; 6.5）</li>
<li>扩容后：桶数组长度变为原来的 2 倍</li>
</ul>
<p><strong>等量扩容（容量不变）：</strong></p>
<ul>
<li>触发条件：溢出桶数量 &gt;= 2^B</li>
<li>目的：整理数据，减少溢出桶数量</li>
</ul>
<h3 id="Q2-Go-map-扩容为什么是渐进式的？">Q2: Go map 扩容为什么是渐进式的？</h3>
<p><strong>A:</strong> 渐进式扩容的优势：</p>
<ol>
<li><strong>避免阻塞</strong>：一次性迁移所有数据会导致长时间阻塞</li>
<li><strong>分摊开销</strong>：将迁移开销分摊到多次操作中</li>
<li><strong>用户无感知</strong>：用户操作不会感受到扩容的影响</li>
<li><strong>内存友好</strong>：减少内存峰值使用</li>
</ol>
<h3 id="Q3-扩容期间如何保证数据一致性？">Q3: 扩容期间如何保证数据一致性？</h3>
<p><strong>A:</strong> 数据一致性保证机制：</p>
<ol>
<li><strong>双数组查找</strong>：读操作同时检查新老桶数组</li>
<li><strong>协助迁移</strong>：写操作协助推进迁移进度</li>
<li><strong>状态标记</strong>：通过 tophash 标记记录迁移状态</li>
<li><strong>原子操作</strong>：关键状态更新使用原子操作</li>
</ol>
<h3 id="Q4-为什么负载因子选择-6-5？">Q4: 为什么负载因子选择 6.5？</h3>
<p><strong>A:</strong> 6.5 负载因子的选择平衡了多个因素：</p>
<ol>
<li><strong>性能考虑</strong>：保证大部分查找在 O(1) 时间内完成</li>
<li><strong>内存效率</strong>：避免过多的内存浪费</li>
<li><strong>扩容频率</strong>：控制扩容操作的频率</li>
<li><strong>实验结果</strong>：经过大量实验验证的最优值</li>
</ol>
<p>理解 Go map 的扩容机制对于优化程序性能和避免性能陷阱非常重要。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Go语言</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
        <tag>扩容机制</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: Go Map 构造与初始化流程</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1>Go Map 构造与初始化流程</h1>
<h2 id="构造流程概述">构造流程概述</h2>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/1750126785867.png" alt="1750126785867"></p>
<p>创建 map 时，实际上会调用 runtime/map.go 文件中的 makemap 方法。本文将深入分析 map 的构造和初始化过程。</p>
<h2 id="makemap-核心实现">makemap 核心实现</h2>
<h3 id="主干源码分析">主干源码分析</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="详细步骤解析">详细步骤解析</h3>
<h4 id="1-内存溢出检查">1. 内存溢出检查</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">	hint = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）hint 为 map 拟分配的容量；在分配前，会提前对拟分配的内存大小进行判断，倘若超限，会将 hint 置为零；</p>
<p>这一步骤防止因为过大的 hint 值导致内存溢出或超出系统限制。</p>
<h4 id="2-hmap-结构体初始化">2. hmap 结构体初始化</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">	h = <span class="built_in">new</span>(hmap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 new 方法初始化 hmap 结构体，这是 map 的核心数据结构。</p>
<h4 id="3-哈希种子生成">3. 哈希种子生成</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.hash0 = fastrand()</span><br></pre></td></tr></table></figure>
<p>调用 fastrand，构造 hash 因子：hmap.hash0。这个随机种子用于哈希计算，增强安全性和散列效果。</p>
<h4 id="4-桶数组容量计算">4. 桶数组容量计算</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">	B++</span><br><span class="line">&#125;</span><br><span class="line">h.B = B</span><br></pre></td></tr></table></figure>
<p>大致上基于 log2(B) &gt;= hint 的思路（具体见 overLoadFactor 方法的介绍），计算桶数组的容量指数 B。</p>
<h4 id="5-桶数组和溢出桶初始化">5. 桶数组和溢出桶初始化</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">	h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">		h.extra.nextOverflow = nextOverflow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）调用 makeBucketArray 方法，初始化桶数组 hmap.buckets；</p>
<p>（6）倘若 map 容量较大，会提前申请一批溢出桶 hmap.extra。</p>
<h2 id="overLoadFactor-负载因子判断">overLoadFactor 负载因子判断</h2>
<p>通过 overLoadFactor 方法，对 map 预分配容量和桶数组长度指数进行判断，决定是否仍需要增长 B 的数值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadFactorNum = <span class="number">13</span></span><br><span class="line"><span class="keyword">const</span> loadFactorDen = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> bucketCnt = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="type">uint8</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">uintptr</span>(<span class="number">1</span>) &lt;&lt; (b &amp; (goarch.PtrSize*<span class="number">8</span> - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="负载因子规则">负载因子规则</h3>
<p>（1）倘若 map 预分配容量小于等于 8，B 取 0，桶的个数为 1；</p>
<p>（2）保证 map 预分配容量小于等于桶数组长度 * 6.5。</p>
<h3 id="容量与桶数组关系表">容量与桶数组关系表</h3>
<table>
<thead>
<tr>
<th>kv 对数量</th>
<th>桶数组长度指数 B</th>
<th>桶数组长度 2^B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 ~ 8</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>9 ~ 13</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>14 ~ 26</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>27 ~ 52</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>2^(B-1) * 6.5+1 ~ 2^B*6.5</td>
<td>B</td>
<td>2^B</td>
</tr>
</tbody>
</table>
<h2 id="makeBucketArray-桶数组分配">makeBucketArray 桶数组分配</h2>
<p>makeBucketArray 方法会进行桶数组的初始化，并根据桶的数量决定是否需要提前作溢出桶的初始化。</p>
<h3 id="核心实现">核心实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">	base := bucketShift(b)</span><br><span class="line">	nbuckets := base</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buckets = newarray(t.bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">	<span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">		nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="详细步骤">详细步骤</h3>
<h4 id="1-计算桶数量">1. 计算桶数量</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">base := bucketShift(b)</span><br><span class="line">nbuckets := base</span><br><span class="line"><span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">	nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeBucketArray 会为 map 的桶数组申请内存，在桶数组的指数 b &gt;= 4 时（桶数组的容量 &gt;= 16），会需要提前创建溢出桶。</p>
<ul>
<li><code>base</code>：记录桶数组的长度，不包含溢出桶</li>
<li><code>nbuckets</code>：记录累加上溢出桶后，桶数组的总长度</li>
</ul>
<h4 id="2-内存分配">2. 内存分配</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">buckets = newarray(t.bucket, <span class="type">int</span>(nbuckets))</span><br></pre></td></tr></table></figure>
<p>调用 newarray 方法为桶数组申请内存空间，连带着需要初始化的溢出桶。</p>
<h4 id="3-溢出桶链接">3. 溢出桶链接</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">	nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若 base != nbuckets，说明需要创建溢出桶，会基于地址偏移的方式，通过 nextOverflow 指向首个溢出桶的地址。</p>
<p>倘若需要创建溢出桶，会将最后一个溢出桶的 overflow 指针指向 buckets 数组，以此来标识申请的溢出桶已经用完。</p>
<h3 id="setoverflow-方法">setoverflow 方法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> setoverflow(t *maptype, ovf *bmap) &#123;</span><br><span class="line">	*(**bmap)(add(unsafe.Pointer(b), <span class="type">uintptr</span>(t.bucketsize)-goarch.PtrSize)) = ovf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法通过内存地址偏移，将溢出桶指针设置到桶结构的末尾位置。</p>
<h2 id="溢出桶预分配策略">溢出桶预分配策略</h2>
<h3 id="预分配条件">预分配条件</h3>
<p>当桶数组长度指数 B &gt;= 4 时（即桶数组长度 &gt;= 16），系统会预分配溢出桶：</p>
<ul>
<li><strong>预分配数量</strong>：2^(B-4) 个溢出桶</li>
<li><strong>存储位置</strong>：连续分配在正常桶数组之后</li>
<li><strong>管理方式</strong>：通过 mapextra 结构管理</li>
</ul>
<h3 id="预分配优势">预分配优势</h3>
<ol>
<li><strong>减少内存分配</strong>：避免运行时频繁分配溢出桶</li>
<li><strong>提高性能</strong>：预分配减少了内存分配的开销</li>
<li><strong>内存连续性</strong>：预分配的溢出桶内存地址连续，提高缓存友好性</li>
</ol>
<h2 id="初始化流程总结">初始化流程总结</h2>
<ol>
<li><strong>参数验证</strong>：检查 hint 值是否会导致内存溢出</li>
<li><strong>结构体创建</strong>：初始化 hmap 核心结构</li>
<li><strong>随机种子</strong>：生成哈希计算用的随机因子</li>
<li><strong>容量计算</strong>：根据负载因子确定桶数组大小</li>
<li><strong>内存分配</strong>：分配桶数组和预分配溢出桶</li>
<li><strong>指针设置</strong>：建立各种指针关系，完成初始化</li>
</ol>
<h2 id="性能优化考虑">性能优化考虑</h2>
<h3 id="内存分配优化">内存分配优化</h3>
<ol>
<li><strong>批量分配</strong>：桶数组和溢出桶一次性分配，减少内存碎片</li>
<li><strong>内存对齐</strong>：确保数据结构按照 CPU 字长对齐</li>
<li><strong>预分配策略</strong>：根据容量大小决定是否预分配溢出桶</li>
</ol>
<h3 id="负载因子优化">负载因子优化</h3>
<ol>
<li><strong>6.5 负载因子</strong>：平衡内存使用和查找性能</li>
<li><strong>动态调整</strong>：根据实际使用情况动态扩容</li>
<li><strong>避免退化</strong>：防止哈希表退化为链表</li>
</ol>
<h2 id="面试要点">面试要点</h2>
<h3 id="常见问题">常见问题</h3>
<p><strong>Q1: make(map[int]int, 100) 和 make(map[int]int) 有什么区别？</strong></p>
<p>A: 主要区别在于：</p>
<ul>
<li><code>make(map[int]int, 100)</code>：会根据容量 hint 预分配合适大小的桶数组</li>
<li><code>make(map[int]int)</code>：初始桶数组大小为 0，随着元素增加动态扩容</li>
<li>预分配可以减少后续的扩容操作，提高性能</li>
</ul>
<p><strong>Q2: Go map 初始化时为什么使用随机哈希种子？</strong></p>
<p>A: 使用随机哈希种子的目的：</p>
<ul>
<li><strong>安全性</strong>：防止哈希碰撞攻击</li>
<li><strong>散列性</strong>：提高哈希值的随机分布</li>
<li><strong>避免退化</strong>：防止特定数据导致性能退化</li>
</ul>
<p><strong>Q3: 溢出桶什么时候会被预分配？</strong></p>
<p>A: 预分配条件：</p>
<ul>
<li>桶数组长度指数 B &gt;= 4（即至少 16 个桶）</li>
<li>预分配数量为 2^(B-4) 个溢出桶</li>
<li>目的是减少运行时的内存分配开销</li>
</ul>
<p>理解这些初始化细节有助于更好地使用和优化 Go 语言中的 map 数据结构。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Go语言</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
        <tag>初始化</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: Go Map 核心原理与数据结构</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1>Go Map 核心原理与数据结构</h1>
<h2 id="核心原理概述">核心原理概述</h2>
<p>map 又称为 hash map，在算法上基于 hash 实现 key 的映射和寻址；在数据结构上基于桶数组实现 key-value 对的存储。</p>
<p>以一组 key-value 对写入 map 的流程为例进行简述：</p>
<p>（1）通过哈希方法取得 key 的 hash 值；</p>
<p>（2）hash 值对桶数组长度取模，确定其所属的桶；</p>
<p>（3）在桶中插入 key-value 对。</p>
<p>hash 的性质，保证了相同的 key 必然产生相同的 hash 值，因此能映射到相同的桶中，通过桶内遍历的方式锁定对应的 key-value 对。</p>
<p>因此，只要在宏观流程上，控制每个桶中 key-value 对的数量，就能保证 map 的几项操作都限制为常数级别的时间复杂度。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126799085.png" alt="1750126799085"></p>
<h2 id="Hash-原理">Hash 原理</h2>
<p>hash 译作散列，是一种将任意长度的输入压缩到某一固定长度的输出摘要的过程，由于这种转换属于压缩映射，输入空间远大于输出空间，因此不同输入可能会映射成相同的输出结果。此外，hash 在压缩过程中会存在部分信息的遗失，因此这种映射关系具有不可逆的特质。</p>
<h3 id="Hash-的核心特性">Hash 的核心特性</h3>
<p>（1）<strong>hash 的可重入性</strong>：相同的 key，必然产生相同的 hash 值；</p>
<p>（2）<strong>hash 的离散性</strong>：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化；</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126805900.png" alt="1750126805900"></p>
<p>（3）<strong>hash 的单向性</strong>：企图通过 hash 值反向映射回 key 是无迹可寻的。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126812775.png" alt="1750126812775"></p>
<p>（4）<strong>hash 冲突</strong>：由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126819675.png" alt="1750126819675"></p>
<h2 id="桶数组结构">桶数组结构</h2>
<p>map 中，会通过长度为 2 的整数次幂的桶数组进行 key-value 对的存储：</p>
<p>（1）每个桶固定可以存放 8 个 key-value 对；</p>
<p>（2）倘若超过 8 个 key-value 对打到桶数组的同一个索引当中，此时会通过创建桶链表的方式来化解这一问题。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126827377.png" alt="1750126827377"></p>
<h3 id="桶数组的设计优势">桶数组的设计优势</h3>
<ol>
<li><strong>2 的幂次长度</strong>：便于使用位运算进行取模操作，提高性能</li>
<li><strong>固定桶容量</strong>：每个桶存储 8 个元素，在内存局部性和查找效率间取得平衡</li>
<li><strong>溢出桶机制</strong>：通过链表解决哈希冲突，保证数据完整性</li>
</ol>
<h2 id="拉链法解决-Hash-冲突">拉链法解决 Hash 冲突</h2>
<p>首先，由于 hash 冲突的存在，不同 key 可能存在相同的 hash 值；</p>
<p>再者，hash 值会对桶数组长度取模，因此不同 hash 值可能被打到同一个桶中。</p>
<p>综上，不同的 key-value 可能被映射到 map 的同一个桶当中。</p>
<p>此时最经典的解决手段分为两种：拉链法和开放寻址法。</p>
<h3 id="拉链法">拉链法</h3>
<p>拉链法中，将命中同一个桶的元素通过链表的形式进行链接，因此很便于动态扩展。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126833996.png" alt="1750126833996"></p>
<h3 id="开放寻址法">开放寻址法</h3>
<p>开放寻址法中，在插入新条目时，会基于一定的探测策略持续寻找，直到找到一个可用于存放数据的空位为止。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126854650.png" alt="1750126854650"></p>
<h3 id="两种方法的优劣对比">两种方法的优劣对比</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>拉链法</td>
<td>简单常用；无需预先为元素分配内存</td>
<td>需要额外指针空间；内存不连续</td>
</tr>
<tr>
<td>开放寻址法</td>
<td>无需额外的指针用于链接元素；内存地址完全连续，可以基于局部性原理，充分利用 CPU 高速缓存</td>
<td>需要预分配内存；删除操作复杂</td>
</tr>
</tbody>
</table>
<h3 id="Go-Map-的混合策略">Go Map 的混合策略</h3>
<p>在 map 解决 hash/分桶冲突问题时，实际上结合了拉链法和开放寻址法两种思路。以 map 的插入写流程为例，进行思路阐述：</p>
<p>（1）桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联；</p>
<p>（2）每个桶固定可以存放 8 个 key-value 对；</p>
<p>（3）当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入；</p>
<p>（4）倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步；</p>
<p>（5）倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126861545.png" alt="1750126861545"></p>
<h2 id="扩容优化性能">扩容优化性能</h2>
<p>倘若 map 的桶数组长度固定不变，那么随着 key-value 对数量的增长，当一个桶下挂载的 key-value 达到一定的量级，此时操作的时间复杂度会趋于线性，无法满足诉求。</p>
<p>因此在实现上，map 桶数组的长度会随着 key-value 对数量的变化而实时调整，以保证每个桶内的 key-value 对数量始终控制在常量级别，满足各项操作为 O(1) 时间复杂度的要求。</p>
<h3 id="扩容机制核心点">扩容机制核心点</h3>
<p>（1）扩容分为增量扩容和等量扩容；</p>
<p>（2）当桶内 key-value 总数/桶数组长度 &gt; 6.5 时发生增量扩容，桶数组长度增长为原值的两倍；</p>
<p>（3）当桶内溢出桶数量大于等于 2^B 时（B 为桶数组长度的指数，B 最大取 15），发生等量扩容，桶的长度保持为原值；</p>
<p>（4）采用渐进扩容的方式，当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126868130.png" alt="1750126868130"></p>
<h2 id="核心数据结构">核心数据结构</h2>
<h3 id="hmap-结构">hmap 结构</h3>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126875064.png" alt="1750126875064"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count      <span class="type">int</span>             <span class="comment">// map 中的 key-value 总数</span></span><br><span class="line">	flags      <span class="type">uint8</span>           <span class="comment">// map 状态标识，可以标识出 map 是否被 goroutine 并发读写</span></span><br><span class="line">	B          <span class="type">uint8</span>           <span class="comment">// 桶数组长度的指数，桶数组长度为 2^B</span></span><br><span class="line">	noverflow  <span class="type">uint16</span>          <span class="comment">// map 中溢出桶的数量</span></span><br><span class="line">	hash0      <span class="type">uint32</span>          <span class="comment">// hash 随机因子，生成 key 的 hash 值时会使用到</span></span><br><span class="line">	buckets    unsafe.Pointer  <span class="comment">// 桶数组</span></span><br><span class="line">	oldbuckets unsafe.Pointer  <span class="comment">// 扩容过程中老的桶数组</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>         <span class="comment">// 扩容时的进度标识，index 小于 nevacuate 的桶都已经由老桶转移到新桶中</span></span><br><span class="line">	extra      *mapextra       <span class="comment">// 预申请的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mapextra-结构">mapextra 结构</h3>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126881251.png" alt="1750126881251"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	overflow     *[]*bmap  <span class="comment">// 供桶数组 buckets 使用的溢出桶</span></span><br><span class="line">	oldoverflow  *[]*bmap  <span class="comment">// 扩容流程中，供老桶数组 oldBuckets 使用的溢出桶</span></span><br><span class="line">	nextOverflow *bmap     <span class="comment">// 下一个可用的溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 map 初始化时，倘若容量过大，会提前申请好一批溢出桶，以供后续使用，这部分溢出桶存放在 hmap.mapextra 当中。</p>
<h3 id="bmap-结构">bmap 结构</h3>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1750126889050.png" alt="1750126889050"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bucketCnt = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span>  <span class="comment">// 每个key的高8位hash值</span></span><br><span class="line">	<span class="comment">// keys and values are not explicitly defined here but are part of the memory layout</span></span><br><span class="line">	<span class="comment">// overflow is also part of the memory layout, typically after keys and values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>bmap 特点：</strong></p>
<p>（1）bmap 就是 map 中的桶，可以存储 8 组 key-value 对的数据，以及一个指向下一个溢出桶的指针；</p>
<p>（2）每组 key-value 对数据包含 key 高 8 位 hash 值 tophash，key 和 val 三部分；</p>
<p>（3）在代码层面只展示了 tophash 部分，但由于 tophash、key 和 val 的数据长度固定，因此可以通过内存地址偏移的方式寻找到后续的 key 数组、val 数组以及溢出桶指针；</p>
<p><strong>完整的 bmap 概念结构：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Conceptual representation of a bmap with explicit fields</span></span><br><span class="line"><span class="keyword">type</span> bmap_conceptual <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash  [bucketCnt]<span class="type">uint8</span>    <span class="comment">// 高8位hash值数组</span></span><br><span class="line">	keys     [bucketCnt]KeyType  <span class="comment">// key数组</span></span><br><span class="line">	values   [bucketCnt]ValType  <span class="comment">// value数组</span></span><br><span class="line">	overflow <span class="type">uintptr</span>             <span class="comment">// 指向下一个溢出桶的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存布局优化">内存布局优化</h2>
<p>Go Map 的内存布局经过精心设计：</p>
<ol>
<li><strong>tophash 数组在前</strong>：便于快速比较，避免访问完整的 key</li>
<li><strong>key 和 value 分离存储</strong>：提高内存访问效率</li>
<li><strong>溢出桶指针在末尾</strong>：只有在需要时才访问</li>
</ol>
<p>这种设计充分考虑了 CPU 缓存友好性和内存访问模式，是 Go Map 高性能的重要保障。</p>
<h2 id="小结">小结</h2>
<p>Go Map 的核心原理体现了现代哈希表设计的精髓：</p>
<ol>
<li><strong>高效的哈希算法</strong>：保证良好的散列性和低冲突率</li>
<li><strong>优化的数据结构</strong>：hmap、bmap、mapextra 三级结构协同工作</li>
<li><strong>混合冲突解决策略</strong>：结合开放寻址法和拉链法的优势</li>
<li><strong>动态扩容机制</strong>：保持负载因子在合理范围内</li>
<li><strong>内存布局优化</strong>：充分利用 CPU 缓存提高性能</li>
</ol>
<p>理解这些核心原理对于深入掌握 Go Map 的实现细节和性能特征至关重要。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数据结构</tag>
        <tag>Go语言</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: Go Map 遍历机制解析</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1>Go Map 遍历机制解析</h1>
<h2 id="遍历机制概述">遍历机制概述</h2>
<p>Go 语言中 map 的遍历是通过 range 关键字实现的，其底层实现涉及复杂的迭代器机制。与其他语言不同，Go map 的遍历顺序是<strong>随机的</strong>，这是有意设计的特性。</p>
<h2 id="迭代器数据结构">迭代器数据结构</h2>
<h3 id="hiter-结构体">hiter 结构体</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">	key         unsafe.Pointer  <span class="comment">// 指向遍历得到 key 的指针</span></span><br><span class="line">	elem        unsafe.Pointer  <span class="comment">// 指向遍历得到 value 的指针</span></span><br><span class="line">	t           *maptype        <span class="comment">// map 类型，包含了 key、value 类型大小等信息</span></span><br><span class="line">	h           *hmap           <span class="comment">// map 的指针</span></span><br><span class="line">	buckets     unsafe.Pointer  <span class="comment">// map 的桶数组</span></span><br><span class="line">	bptr        *bmap           <span class="comment">// 当前遍历到的桶</span></span><br><span class="line">	overflow    *[]*bmap        <span class="comment">// 新老桶数组对应的溢出桶</span></span><br><span class="line">	oldoverflow *[]*bmap        <span class="comment">// 老桶数组的溢出桶</span></span><br><span class="line">	startBucket <span class="type">uintptr</span>         <span class="comment">// 遍历起始位置的桶索引</span></span><br><span class="line">	offset      <span class="type">uint8</span>           <span class="comment">// 遍历起始位置的 key-value 对索引号</span></span><br><span class="line">	wrapped     <span class="type">bool</span>            <span class="comment">// 遍历是否穿越桶数组尾端回到头部了</span></span><br><span class="line">	B           <span class="type">uint8</span>           <span class="comment">// 桶数组的长度指数</span></span><br><span class="line">	i           <span class="type">uint8</span>           <span class="comment">// 当前遍历到的 key-value 对在桶中的索引</span></span><br><span class="line">	bucket      <span class="type">uintptr</span>         <span class="comment">// 当前遍历到的桶</span></span><br><span class="line">	checkBucket <span class="type">uintptr</span>         <span class="comment">// 因为扩容流程的存在，需要额外检查的桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hiter 是遍历 map 时用于存放临时数据的迭代器，它记录了遍历过程中的所有状态信息。</p>
<h3 id="字段详解">字段详解</h3>
<ul>
<li><strong>key/elem</strong>：指向当前遍历到的 key-value 对</li>
<li><strong>t/h</strong>：map 的类型信息和实例指针</li>
<li><strong>buckets</strong>：当前使用的桶数组</li>
<li><strong>bptr</strong>：当前正在遍历的桶</li>
<li><strong>startBucket/offset</strong>：随机化的起始位置</li>
<li><strong>wrapped</strong>：是否已经绕了一圈</li>
<li><strong>bucket/i</strong>：当前遍历位置</li>
<li><strong>checkBucket</strong>：扩容时需要检查的桶</li>
</ul>
<h2 id="初始化流程-mapiterinit">初始化流程 - mapiterinit</h2>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/1750126758693.png" alt="1750126758693"></p>
<p>map 遍历流程开始时，首先会走进 runtime/map.go 的 mapiterinit() 方法，此时会创建 map 迭代器 hiter，并且通过取随机数的方式，决定遍历的起始桶号以及起始 key-value 对索引号。</p>
<h3 id="mapiterinit-源码实现">mapiterinit 源码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">	it.t = t</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	it.h = h</span><br><span class="line">	it.B = h.B</span><br><span class="line">	it.buckets = h.buckets</span><br><span class="line">	<span class="keyword">if</span> t.bucket.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">		h.createOverflow()</span><br><span class="line">		it.overflow = h.extra.overflow</span><br><span class="line">		it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 决定起始位置 - 关键的随机化逻辑</span></span><br><span class="line">	<span class="keyword">var</span> r <span class="type">uintptr</span></span><br><span class="line">	r = <span class="type">uintptr</span>(fastrand())  <span class="comment">// 获取随机数</span></span><br><span class="line"></span><br><span class="line">	it.startBucket = r &amp; bucketMask(h.B)           <span class="comment">// 确定起始桶</span></span><br><span class="line">	it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))  <span class="comment">// 确定桶内起始偏移</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化迭代器状态</span></span><br><span class="line">	it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记存在迭代器</span></span><br><span class="line">	<span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">		atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mapiternext(it)  <span class="comment">// 开始遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机化起始位置">随机化起始位置</h3>
<p>Go map 遍历的随机性主要体现在起始位置的随机化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r <span class="type">uintptr</span></span><br><span class="line">r = <span class="type">uintptr</span>(fastrand())</span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)           <span class="comment">// 随机起始桶</span></span><br><span class="line">it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))  <span class="comment">// 桶内随机起始位置</span></span><br></pre></td></tr></table></figure>
<p>这种设计确保了：</p>
<ol>
<li><strong>起始桶随机</strong>：从随机的桶开始遍历</li>
<li><strong>桶内起始位置随机</strong>：即使在同一个桶内，起始位置也是随机的</li>
<li><strong>不可预测性</strong>：两次遍历的顺序几乎不可能相同</li>
</ol>
<h2 id="遍历执行流程-mapiternext">遍历执行流程 - mapiternext</h2>
<h3 id="mapiternext-核心实现">mapiternext 核心实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">	h := it.h</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	t := it.t</span><br><span class="line">	bucket := it.bucket</span><br><span class="line">	b := it.bptr</span><br><span class="line">	i := it.i</span><br><span class="line">	checkBucket := it.checkBucket</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">	<span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 检查是否完成一轮遍历</span></span><br><span class="line">		<span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">			it.key = <span class="literal">nil</span></span><br><span class="line">			it.elem = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理扩容期间的遍历</span></span><br><span class="line">		<span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">			oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">			b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">			<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">				checkBucket = bucket</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">				checkBucket = noCheck</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">			checkBucket = noCheck</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bucket++</span><br><span class="line">		<span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">			bucket = <span class="number">0</span></span><br><span class="line">			it.wrapped = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历桶内的 key-value 对</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">		offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)  <span class="comment">// 应用随机偏移</span></span><br><span class="line">		<span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">			k = *((*unsafe.Pointer)(k))</span><br><span class="line">		&#125;</span><br><span class="line">		e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 扩容期间的特殊检查</span></span><br><span class="line">		<span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">			hash := t.hasher(k, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">			<span class="keyword">if</span> (hash&gt;&gt;it.h.B)&amp;<span class="number">1</span> != (checkBucket&gt;&gt;it.h.B)&amp;<span class="number">1</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理已迁移的数据</span></span><br><span class="line">		<span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">			!(t.reflexivekey() || t.key.equal(k, k)) &#123;</span><br><span class="line">			it.key = k</span><br><span class="line">			<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">				e = *((*unsafe.Pointer)(e))</span><br><span class="line">			&#125;</span><br><span class="line">			it.elem = e</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 查找新表中的当前值</span></span><br><span class="line">			rk, re := mapaccessK(t, h, k)</span><br><span class="line">			<span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span>  <span class="comment">// key 已被删除</span></span><br><span class="line">			&#125;</span><br><span class="line">			it.key = rk</span><br><span class="line">			it.elem = re</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新迭代器状态</span></span><br><span class="line">		it.bucket = bucket</span><br><span class="line">		<span class="keyword">if</span> it.bptr != b &#123;</span><br><span class="line">			it.bptr = b</span><br><span class="line">		&#125;</span><br><span class="line">		it.i = i + <span class="number">1</span></span><br><span class="line">		it.checkBucket = checkBucket</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 移动到下一个溢出桶</span></span><br><span class="line">	b = b.overflow(t)</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历流程关键点">遍历流程关键点</h3>
<h4 id="1-并发安全检查">1. 并发安全检查</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">	fatal(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历时发现其他 goroutine 在并发写，直接抛出 fatal error。</p>
<h4 id="2-桶内随机偏移">2. 桶内随机偏移</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>即使在同一个桶内，也会应用随机偏移，进一步增强随机性。</p>
<h4 id="3-扩容期间的处理">3. 扩容期间的处理</h4>
<p>在扩容期间遍历需要特别处理：</p>
<ul>
<li>检查数据是在老桶还是新桶</li>
<li>对于未迁移的数据，从老桶读取</li>
<li>对于已迁移的数据，从新桶读取</li>
</ul>
<h4 id="4-数据一致性保证">4. 数据一致性保证</h4>
<p>对于正在迁移的数据，通过以下机制保证一致性：</p>
<ul>
<li>检查 tophash 状态标记</li>
<li>对于已迁移的数据，重新从新表查找</li>
<li>确保返回最新的数据</li>
</ul>
<h2 id="随机化的实现机制">随机化的实现机制</h2>
<h3 id="为什么要随机化">为什么要随机化</h3>
<p>Go 有意设计了随机化的遍历顺序，原因包括：</p>
<ol>
<li><strong>避免依赖</strong>：防止程序依赖特定的遍历顺序</li>
<li><strong>性能考虑</strong>：哈希表本身就不保证顺序</li>
<li><strong>安全性</strong>：防止某些攻击手段利用固定的遍历顺序</li>
<li><strong>向前兼容</strong>：保证未来优化不会破坏现有程序</li>
</ol>
<h3 id="随机化的多个层次">随机化的多个层次</h3>
<ol>
<li><strong>起始桶随机</strong>：<code>startBucket = r &amp; bucketMask(h.B)</code></li>
<li><strong>桶内偏移随机</strong>：<code>offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1))</code></li>
<li><strong>每次偏移应用</strong>：<code>offi = (i + it.offset) &amp; (bucketCnt - 1)</code></li>
</ol>
<h3 id="随机性分析">随机性分析</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：遍历顺序的随机性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demonstrateRandomness</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>, <span class="number">4</span>: <span class="number">4</span>, <span class="number">5</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;第一次遍历:&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d:%d &quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;\n第二次遍历:&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d:%d &quot;</span>, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出顺序很可能不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩容期间的遍历处理">扩容期间的遍历处理</h2>
<h3 id="双数组遍历策略">双数组遍历策略</h3>
<p>在扩容期间，map 同时维护新老两个桶数组，遍历需要特殊处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">	<span class="comment">// 在老桶中查找</span></span><br><span class="line">	oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">	b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">		<span class="comment">// 数据还在老桶中</span></span><br><span class="line">		checkBucket = bucket</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 数据已迁移到新桶</span></span><br><span class="line">		b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		checkBucket = noCheck</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据一致性保证">数据一致性保证</h3>
<ol>
<li><strong>状态检查</strong>：通过 evacuated 函数检查桶是否已迁移</li>
<li><strong>双重查找</strong>：对于已迁移的数据，重新查找确保一致性</li>
<li><strong>版本控制</strong>：通过 checkBucket 机制处理版本差异</li>
</ol>
<h2 id="性能优化考虑">性能优化考虑</h2>
<h3 id="迭代器状态管理">迭代器状态管理</h3>
<ol>
<li><strong>最小状态</strong>：迭代器只保存必要的状态信息</li>
<li><strong>懒加载</strong>：只在需要时才计算下一个位置</li>
<li><strong>内存友好</strong>：避免大量的临时对象分配</li>
</ol>
<h3 id="缓存友好的遍历">缓存友好的遍历</h3>
<ol>
<li><strong>连续访问</strong>：尽可能连续访问内存</li>
<li><strong>预取优化</strong>：利用 CPU 缓存预取机制</li>
<li><strong>局部性原理</strong>：先遍历完一个桶再移动到下一个桶</li>
</ol>
<h2 id="面试重点问题">面试重点问题</h2>
<h3 id="Q1-Go-map-遍历为什么是无序的？">Q1: Go map 遍历为什么是无序的？</h3>
<p><strong>A:</strong> Go map 遍历无序的原因：</p>
<ol>
<li><strong>设计初衷</strong>：故意设计为无序，防止程序依赖遍历顺序</li>
<li><strong>哈希特性</strong>：哈希表本身不保证数据顺序</li>
<li><strong>随机化实现</strong>：
<ul>
<li>随机起始桶：<code>startBucket = r &amp; bucketMask(h.B)</code></li>
<li>随机桶内偏移：<code>offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1))</code></li>
</ul>
</li>
<li><strong>扩容影响</strong>：扩容过程中数据重新分布</li>
</ol>
<h3 id="Q2-如何实现-map-的有序遍历？">Q2: 如何实现 map 的有序遍历？</h3>
<p><strong>A:</strong> 实现有序遍历的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：收集key后排序</span></span><br><span class="line">keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">	keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">	fmt.Println(k, m[k])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用有序容器</span></span><br><span class="line"><span class="comment">// 可以考虑使用 sync.Map 或第三方有序map库</span></span><br></pre></td></tr></table></figure>
<h3 id="Q3-遍历过程中修改-map-会发生什么？">Q3: 遍历过程中修改 map 会发生什么？</h3>
<p><strong>A:</strong> 遍历过程中修改 map 的影响：</p>
<ol>
<li><strong>写操作冲突</strong>：会触发 <code>fatal(&quot;concurrent map iteration and map write&quot;)</code></li>
<li><strong>读操作安全</strong>：同时多个遍历是安全的</li>
<li><strong>避免方法</strong>：
<ul>
<li>先收集要修改的 key，遍历结束后再修改</li>
<li>使用 channel 或其他同步机制</li>
<li>创建新的 map 来保存修改结果</li>
</ul>
</li>
</ol>
<h3 id="Q4-扩容期间遍历如何保证数据一致性？">Q4: 扩容期间遍历如何保证数据一致性？</h3>
<p><strong>A:</strong> 扩容期间的一致性保证机制：</p>
<ol>
<li><strong>双数组查找</strong>：同时检查新老桶数组</li>
<li><strong>迁移状态检查</strong>：通过 tophash 标记判断数据位置</li>
<li><strong>重新查找机制</strong>：对已迁移数据重新查找确保最新值</li>
<li><strong>渐进式迁移</strong>：不会阻塞遍历操作</li>
</ol>
<h2 id="最佳实践建议">最佳实践建议</h2>
<h3 id="1-不要依赖遍历顺序">1. 不要依赖遍历顺序</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：依赖遍历顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processMapInOrder</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		<span class="comment">// 假设某种特定顺序进行处理</span></span><br><span class="line">		<span class="keyword">if</span> isFirstKey(k) &#123; <span class="comment">// 这种假设是错误的</span></span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：显式排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processMapInOrder</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		<span class="comment">// 处理 m[k]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-避免遍历时修改">2. 避免遍历时修改</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：遍历时修改</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> shouldDelete(v) &#123;</span><br><span class="line">		<span class="built_in">delete</span>(m, k)  <span class="comment">// 会panic</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：先收集后处理</span></span><br><span class="line">toDelete := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> shouldDelete(v) &#123;</span><br><span class="line">		toDelete = <span class="built_in">append</span>(toDelete, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> toDelete &#123;</span><br><span class="line">	<span class="built_in">delete</span>(m, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>Go map 的遍历机制体现了精心的设计：</p>
<ol>
<li><strong>随机化策略</strong>：多层次的随机化保证遍历顺序不可预测</li>
<li><strong>扩容兼容</strong>：在扩容期间仍能正确遍历所有数据</li>
<li><strong>性能优化</strong>：充分考虑缓存友好性和内存访问模式</li>
<li><strong>并发安全</strong>：通过检测机制避免并发读写问题</li>
</ol>
<p>理解这些遍历机制有助于更好地使用 Go map，避免常见的陷阱和错误。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>数据结构</tag>
        <tag>Go语言</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: Go Map 读写删除流程详解</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E8%AF%BB%E5%86%99%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1>Go Map 读写删除流程详解</h1>
<h2 id="读流程详解">读流程详解</h2>
<h3 id="读流程概述">读流程概述</h3>
<p>map 读流程主要分为以下几步：</p>
<p>（1）根据 key 取 hash 值；</p>
<p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p>
<p>（3）沿着桶链表依次遍历各个桶内的 key-value 对；</p>
<p>（4）命中相同的 key，则返回 value；倘若 key 不存在，则返回零值。</p>
<p>map 读操作最终会走进 runtime/map.go 的 mapaccess 方法中。</p>
<h3 id="mapaccess-方法源码详解">mapaccess 方法源码详解</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">	m := bucketMask(h.B)</span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line">				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">				<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">					e = *((*unsafe.Pointer)(e))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> e</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读流程详细步骤">读流程详细步骤</h3>
<h4 id="1-边界条件检查">1. 边界条件检查</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若 map 未初始化，或此时存在 key-value 对数量为 0，直接返回零值。</p>
<h4 id="2-并发安全检查">2. 并发安全检查</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">	fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若发现存在其他 goroutine 在写 map，直接抛出并发读写的 fatal error。其中，并发写标记，位于 hmap.flags 的第 3 个 bit 位。</p>
<h4 id="3-哈希计算与桶定位">3. 哈希计算与桶定位</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br></pre></td></tr></table></figure>
<p>通过 maptype.hasher() 方法计算得到 key 的 hash 值，并对桶数组长度取模，取得对应的桶。</p>
<p><code>bucketMask</code> 方法会根据 B 求得桶数组长度 - 1 的值，用于后续的 &amp; 运算，实现取模的效果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketMask</span><span class="params">(b <span class="type">uint8</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> bucketShift(b) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-扩容期间的特殊处理">4. 扩容期间的特殊处理</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">		m &gt;&gt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	<span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">		b = oldb</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在取桶时，会关注当前 map 是否处于扩容的流程，倘若是的话，需要在老的桶数组 oldBuckets 中取桶，通过 evacuated 方法判断桶数据是已迁到新桶还是仍存留在老桶。</p>
<h4 id="5-tophash-优化">5. tophash 优化</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">top := tophash(hash)</span><br></pre></td></tr></table></figure>
<p>取 key hash 值的高 8 位值 top。倘若该值 &lt; 5，会累加 5，以避开 0 ~ 4 的取值，因为这几个值会用于枚举，具有特殊的含义。</p>
<h4 id="6-桶链表遍历">6. 桶链表遍历</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bucketloop:</span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">				<span class="keyword">break</span> bucketloop</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到匹配的tophash，进一步比较完整key</span></span><br><span class="line">		k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">			k = *((*unsafe.Pointer)(k))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line">			e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">				e = *((*unsafe.Pointer)(e))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启两层 for 循环进行遍历流程：</p>
<ul>
<li>外层：基于桶链表，依次遍历首个桶和后续的每个溢出桶</li>
<li>内层：依次遍历一个桶内的 key-value 对</li>
</ul>
<h2 id="写流程详解">写流程详解</h2>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E8%AF%BB%E5%86%99%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/1750126774765.png" alt="1750126774765"></p>
<h3 id="写流程概述">写流程概述</h3>
<p>map 写流程主要分为以下几步：</p>
<p>（1）根据 key 取 hash 值；</p>
<p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p>
<p>（3）倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</p>
<p>（4）沿着桶链表依次遍历各个桶内的 key-value 对；</p>
<p>（5）倘若命中相同的 key，则对 value 进行更新；</p>
<p>（6）倘若 key 不存在，则插入 key-value 对；</p>
<p>（7）倘若发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步。</p>
<h3 id="mapassign-方法核心实现">mapassign 方法核心实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;assignment to entry in nil map&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.buckets = newobject(t.bucket)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> inserti *<span class="type">uint8</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">	<span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line"></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">					inserti = &amp;b.tophash[i]</span><br><span class="line">					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">					elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// key已存在，更新操作</span></span><br><span class="line">			<span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">				typedmemmove(t.key, k, key)</span><br><span class="line">			&#125;</span><br><span class="line">			elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">		&#125;</span><br><span class="line">		ovf := b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = ovf</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否需要扩容</span></span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配新的插入位置</span></span><br><span class="line">	<span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">		newb := h.newoverflow(t, b)</span><br><span class="line">		inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">		insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">		elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入新的key-value对</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">		kmem := newobject(t.key)</span><br><span class="line">		*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">		insertk = kmem</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">		vmem := newobject(t.elem)</span><br><span class="line">		*(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(t.key, insertk, key)</span><br><span class="line">	*inserti = top</span><br><span class="line">	h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">	<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">		elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写流程关键步骤">写流程关键步骤</h3>
<h4 id="1-写标记设置">1. 写标记设置</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">h.flags ^= hashWriting</span><br></pre></td></tr></table></figure>
<p>通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记。</p>
<h4 id="2-扩容协助">2. 扩容协助</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">	growWork(t, h, bucket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容。</p>
<h4 id="3-空位记录">3. 空位记录</h4>
<p>在遍历桶的过程中，会记录第一个可用的空位：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">	inserti = &amp;b.tophash[i]</span><br><span class="line">	insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">	elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-扩容条件检查">4. 扩容条件检查</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">	hashGrow(t, h)</span><br><span class="line">	<span class="keyword">goto</span> again</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有找到已存在的 key 且需要插入新元素时，检查是否需要扩容。</p>
<h2 id="删除流程详解">删除流程详解</h2>
<h3 id="删除流程概述">删除流程概述</h3>
<p>map 删除 kv 对流程主要分为以下几步：</p>
<p>（1）根据 key 取 hash 值；</p>
<p>（2）根据 hash 值对桶数组取模，确定所在的桶；</p>
<p>（3）倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</p>
<p>（4）沿着桶链表依次遍历各个桶内的 key-value 对；</p>
<p>（5）倘若命中相同的 key，删除对应的 key-value 对；并将当前位置的 tophash 置为 emptyOne，表示为空；</p>
<p>（6）倘若当前位置为末位，或者下一个位置的 tophash 为 emptyRest，则沿当前位置向前遍历，将毗邻的 emptyOne 统一更新为 emptyRest。</p>
<h3 id="mapdelete-方法实现">mapdelete 方法实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	bOrig := b</span><br><span class="line">	top := tophash(hash)</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> search</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			k2 := k</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !t.key.equal(key, k2) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 清理key</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(k, t.key.size)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 清理value</span></span><br><span class="line">			e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(e, t.elem.size)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				memclrNoHeapPointers(e, t.elem.size)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			b.tophash[i] = emptyOne</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 优化空槽标记</span></span><br><span class="line">			<span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 向前合并空槽</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				b.tophash[i] = emptyRest</span><br><span class="line">				<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 找到前一个桶</span></span><br><span class="line">					c := b</span><br><span class="line">					<span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					i = bucketCnt - <span class="number">1</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					i--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		notLast:</span><br><span class="line">			h.count--</span><br><span class="line">			<span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">				h.hash0 = fastrand()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span> search</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除流程关键特性">删除流程关键特性</h3>
<h4 id="1-空槽标记优化">1. 空槽标记优化</h4>
<p>删除操作使用两种空槽标记：</p>
<ul>
<li><code>emptyOne</code>：单个空槽</li>
<li><code>emptyRest</code>：连续空槽的结束标记</li>
</ul>
<h4 id="2-向前合并机制">2. 向前合并机制</h4>
<p>删除元素后，会向前遍历，将连续的 <code>emptyOne</code> 标记合并为 <code>emptyRest</code>，这样可以在查找时提前终止，提高性能。</p>
<h4 id="3-内存清理">3. 内存清理</h4>
<p>根据 key 和 value 的类型特性，选择合适的内存清理方式：</p>
<ul>
<li>指针类型：设置为 nil</li>
<li>包含指针的类型：调用<code>memclrHasPointers</code></li>
<li>不包含指针的类型：调用<code>memclrNoHeapPointers</code></li>
</ul>
<h2 id="性能优化技巧">性能优化技巧</h2>
<h3 id="tophash-快速比较">tophash 快速比较</h3>
<p>使用 hash 值的高 8 位作为快速比较，避免完整 key 比较：</p>
<ol>
<li>首先比较 tophash，不匹配直接跳过</li>
<li>tophash 匹配后才进行完整 key 比较</li>
<li>减少了大部分不必要的 key 比较操作</li>
</ol>
<h3 id="内存布局优化">内存布局优化</h3>
<ol>
<li><strong>数据局部性</strong>：key 和 value 分别连续存储，提高缓存命中率</li>
<li><strong>对齐优化</strong>：数据结构按照字长对齐，提高访问效率</li>
<li><strong>预取优化</strong>：连续的内存布局有利于 CPU 预取</li>
</ol>
<h3 id="渐进式扩容">渐进式扩容</h3>
<ol>
<li><strong>分摊开销</strong>：将扩容开销分摊到多次操作中</li>
<li><strong>避免阻塞</strong>：避免单次操作耗时过长</li>
<li><strong>双数组设计</strong>：新老数组并存，支持渐进迁移</li>
</ol>
<h2 id="面试重点">面试重点</h2>
<h3 id="常见面试题">常见面试题</h3>
<p><strong>Q1: Go map 的读写删除操作时间复杂度是多少？</strong></p>
<p>A:</p>
<ul>
<li><strong>平均情况</strong>：O(1)</li>
<li><strong>最坏情况</strong>：O(n)，当所有 key 都哈希到同一个桶时</li>
<li><strong>实际表现</strong>：由于负载因子控制和扩容机制，实际性能接近 O(1)</li>
</ul>
<p><strong>Q2: Go map 在扩容过程中如何处理读写操作？</strong></p>
<p>A:</p>
<ul>
<li><strong>渐进式扩容</strong>：不会一次性迁移所有数据</li>
<li><strong>双数组查找</strong>：读操作会同时检查新老数组</li>
<li><strong>协助迁移</strong>：写操作会协助迁移对应的桶</li>
<li><strong>无阻塞</strong>：操作不会被扩容阻塞</li>
</ul>
<p><strong>Q3: tophash 的作用是什么？</strong></p>
<p>A:</p>
<ul>
<li><strong>快速过滤</strong>：避免不必要的完整 key 比较</li>
<li><strong>状态标记</strong>：标记空槽、迁移状态等信息</li>
<li><strong>性能优化</strong>：减少内存访问和比较操作</li>
</ul>
<p>理解这些读写删除流程的细节，有助于更好地使用和优化 Go 语言中的 map 操作。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Go语言</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
        <tag>算法实现</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: Go Map 面试题解析</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/Go%E8%AF%AD%E8%A8%80/Map/Go-Map-%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1>Go Map 面试题解析</h1>
<h2 id="基础概念类面试题">基础概念类面试题</h2>
<h3 id="Q1-Go-语言中-map-的底层数据结构是什么？">Q1: Go 语言中 map 的底层数据结构是什么？</h3>
<p><strong>A:</strong> Go 语言中 map 的底层数据结构是<strong>哈希表（hash table）</strong>，具体实现包括：</p>
<ol>
<li><strong>hmap 结构体</strong>：存储 map 的元数据，包括桶数组指针、元素数量、哈希种子等</li>
<li><strong>桶数组（buckets）</strong>：长度为 2 的整数次幂的数组，每个桶可存储 8 个 key-value 对</li>
<li><strong>溢出桶链表</strong>：当桶满时，通过链表连接溢出桶解决哈希冲突</li>
<li><strong>渐进式扩容机制</strong>：支持增量扩容和等量扩容</li>
</ol>
<p><strong>核心结构体：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	count      <span class="type">int</span>             <span class="comment">// 元素总数</span></span><br><span class="line">	flags      <span class="type">uint8</span>           <span class="comment">// 状态标志</span></span><br><span class="line">	B          <span class="type">uint8</span>           <span class="comment">// 桶数组长度指数（长度为2^B）</span></span><br><span class="line">	noverflow  <span class="type">uint16</span>          <span class="comment">// 溢出桶数量</span></span><br><span class="line">	hash0      <span class="type">uint32</span>          <span class="comment">// 哈希种子</span></span><br><span class="line">	buckets    unsafe.Pointer  <span class="comment">// 桶数组指针</span></span><br><span class="line">	oldbuckets unsafe.Pointer  <span class="comment">// 扩容时的老桶数组</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>         <span class="comment">// 扩容迁移进度</span></span><br><span class="line">	extra      *mapextra       <span class="comment">// 溢出桶管理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [<span class="number">8</span>]<span class="type">uint8</span>  <span class="comment">// 存储8个key的高8位hash值</span></span><br><span class="line">	<span class="comment">// 后续是8个key、8个value、1个overflow指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q2-Go-map-如何解决哈希冲突？">Q2: Go map 如何解决哈希冲突？</h3>
<p><strong>A:</strong> Go map 采用<strong>拉链法 + 开放寻址法</strong>的混合方式解决哈希冲突：</p>
<ol>
<li><strong>桶内开放寻址</strong>：每个桶固定存储 8 个 key-value 对，发生冲突时在桶内寻找空位</li>
<li><strong>桶间拉链法</strong>：当桶满时，通过溢出桶指针形成链表结构</li>
<li><strong>渐进式扩容</strong>：当负载因子超过 6.5 时触发扩容，重新分布数据</li>
</ol>
<p><strong>解决冲突的步骤：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 计算hash值</span></span><br><span class="line">hash := hasher(key, seed)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 确定桶位置</span></span><br><span class="line">bucket := hash &amp; (bucketCount - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在桶内查找空位（开放寻址）</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> bucket[i] == empty &#123;</span><br><span class="line">		bucket[i] = key_value</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 桶满时创建溢出桶（拉链法）</span></span><br><span class="line">overflowBucket := newOverflowBucket()</span><br><span class="line">linkToOverflow(bucket, overflowBucket)</span><br></pre></td></tr></table></figure>
<h3 id="Q3-Go-map-的-key-有什么限制？">Q3: Go map 的 key 有什么限制？</h3>
<p><strong>A:</strong> Go map 的 key 必须是<strong>可比较类型</strong>：</p>
<p><strong>可作为 key 的类型：</strong></p>
<ul>
<li>基本类型：bool, 数值类型, string</li>
<li>指针类型</li>
<li>数组类型（元素可比较）</li>
<li>结构体类型（所有字段可比较）</li>
</ul>
<p><strong>不可作为 key 的类型：</strong></p>
<ul>
<li>slice（切片）</li>
<li>map（映射）</li>
<li>function（函数）</li>
</ul>
<p><strong>原因：</strong> 这些类型无法用 <code>==</code> 操作符进行比较，无法计算稳定的哈希值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确的key类型</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[[<span class="number">3</span>]<span class="type">int</span>]<span class="type">string</span>) <span class="comment">// 数组可以作为key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误的key类型</span></span><br><span class="line"><span class="comment">// m4 := make(map[[]int]string)     // slice不能作为key</span></span><br><span class="line"><span class="comment">// m5 := make(map[map[int]int]string) // map不能作为key</span></span><br><span class="line"><span class="comment">// m6 := make(map[func()]string)    // function不能作为key</span></span><br></pre></td></tr></table></figure>
<h2 id="扩容机制类面试题">扩容机制类面试题</h2>
<h3 id="Q4-Go-map-什么时候会扩容？扩容规则是什么？">Q4: Go map 什么时候会扩容？扩容规则是什么？</h3>
<p><strong>A:</strong> Go map 有两种扩容触发条件：</p>
<p><strong>增量扩容（容量翻倍）：</strong></p>
<ul>
<li>触发条件：负载因子 &gt; 6.5（即 count/2^B &gt; 6.5）</li>
<li>扩容后：桶数组长度变为原来的 2 倍</li>
<li>目的：降低桶内元素密度，提高查找效率</li>
</ul>
<p><strong>等量扩容（容量不变）：</strong></p>
<ul>
<li>触发条件：溢出桶数量 &gt;= 2^B（B 最大为 15）</li>
<li>扩容后：桶数组长度不变，但重新整理数据</li>
<li>目的：减少溢出桶数量，提高内存利用率</li>
</ul>
<p><strong>扩容特点：</strong></p>
<ul>
<li>采用渐进式扩容，避免性能抖动</li>
<li>每次写操作时迁移 2 个桶的数据</li>
<li>通过 oldbuckets 和 buckets 双数组实现</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容触发条件检查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needGrow</span><span class="params">(h *hmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 增量扩容条件</span></span><br><span class="line">	<span class="keyword">if</span> overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等量扩容条件</span></span><br><span class="line">	<span class="keyword">if</span> tooManyOverflowBuckets(h.noverflow, h.B) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q5-Go-map-扩容为什么是渐进式的？">Q5: Go map 扩容为什么是渐进式的？</h3>
<p><strong>A:</strong> 渐进式扩容的优势：</p>
<ol>
<li><strong>避免阻塞</strong>：一次性迁移所有数据会导致长时间阻塞，影响程序响应性</li>
<li><strong>分摊开销</strong>：将迁移开销分摊到多次操作中，单次操作延迟可控</li>
<li><strong>内存友好</strong>：避免同时存在两份完整数据，减少内存峰值使用</li>
<li><strong>用户无感知</strong>：对用户来说扩容过程透明</li>
</ol>
<p><strong>实现机制：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次写操作协助迁移</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 迁移当前操作命中的桶</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 迁移一个额外的桶推进扩容进度</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发安全类面试题">并发安全类面试题</h2>
<h3 id="Q6-Go-map-为什么不是并发安全的？如何解决？">Q6: Go map 为什么不是并发安全的？如何解决？</h3>
<p><strong>A:</strong> Go map 不是并发安全的原因和解决方案：</p>
<p><strong>不安全的原因：</strong></p>
<ol>
<li><strong>设计理念</strong>：为了性能考虑，Go map 没有内置锁机制</li>
<li><strong>检测机制</strong>：运行时会检测并发读写，发现时抛出 fatal error</li>
<li><strong>性能优先</strong>：避免为不需要并发的场景增加锁开销</li>
</ol>
<p><strong>并发检测规则：</strong></p>
<ul>
<li>并发读是安全的</li>
<li>读写并发会 panic：<code>concurrent map read and map write</code></li>
<li>写写并发会 panic：<code>concurrent map writes</code></li>
</ul>
<p><strong>解决方案：</strong></p>
<p><strong>方案 1：使用 sync.RWMutex 手动加锁</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.RWMutex</span><br><span class="line">	m  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *SafeMap)</span></span> Set(key <span class="type">string</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	sm.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> sm.mu.Unlock()</span><br><span class="line">	sm.m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *SafeMap)</span></span> Get(key <span class="type">string</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">	sm.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> sm.mu.RUnlock()</span><br><span class="line">	v, ok := sm.m[key]</span><br><span class="line">	<span class="keyword">return</span> v, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方案 2：使用 sync.Map</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储</span></span><br><span class="line">m.Store(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">value, ok := m.Load(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">m.Delete(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	fmt.Println(key, value)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>方案 3：使用 channel 进行串行化访问</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MapService <span class="keyword">struct</span> &#123;</span><br><span class="line">	m    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	ch   <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMapService</span><span class="params">()</span></span> *MapService &#123;</span><br><span class="line">	ms := &amp;MapService&#123;</span><br><span class="line">		m:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">		ch: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> ms.run()</span><br><span class="line">	<span class="keyword">return</span> ms</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MapService)</span></span> run() &#123;</span><br><span class="line">	<span class="keyword">for</span> f := <span class="keyword">range</span> ms.ch &#123;</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MapService)</span></span> Set(key <span class="type">string</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ms.ch &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ms.m[key] = value</span><br><span class="line">		<span class="built_in">close</span>(done)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能优化类面试题">性能优化类面试题</h2>
<h3 id="Q7-Go-map-遍历为什么是无序的？如何实现有序遍历？">Q7: Go map 遍历为什么是无序的？如何实现有序遍历？</h3>
<p><strong>A:</strong> Go map 遍历无序的原因：</p>
<ol>
<li><strong>哈希表特性</strong>：数据存储位置由哈希值决定，不保证顺序</li>
<li><strong>故意随机化</strong>：Go 1.0 后故意引入随机化，防止程序依赖遍历顺序</li>
<li><strong>扩容影响</strong>：扩容过程中数据重新分布，进一步打乱顺序</li>
</ol>
<p><strong>随机化实现：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历初始化时的随机化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">	r := <span class="type">uintptr</span>(fastrand())</span><br><span class="line">	it.startBucket = r &amp; bucketMask(h.B)           <span class="comment">// 随机起始桶</span></span><br><span class="line">	it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))  <span class="comment">// 桶内随机偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现有序遍历：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：收集key后排序</span></span><br><span class="line">keys := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">	keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">	fmt.Println(k, m[k])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：使用有序数据结构</span></span><br><span class="line"><span class="keyword">type</span> OrderedMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	keys []<span class="type">string</span></span><br><span class="line">	m    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(om *OrderedMap)</span></span> Set(key <span class="type">string</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, exists := om.m[key]; !exists &#123;</span><br><span class="line">		om.keys = <span class="built_in">append</span>(om.keys, key)</span><br><span class="line">	&#125;</span><br><span class="line">	om.m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(om *OrderedMap)</span></span> Range(fn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> om.keys &#123;</span><br><span class="line">		fn(key, om.m[key])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q8-如何优化-map-的性能？">Q8: 如何优化 map 的性能？</h3>
<p><strong>A:</strong> map 性能优化策略：</p>
<p><strong>1. 预分配容量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 频繁扩容</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">	m[fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i)] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 预分配容量</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">	m[fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i)] = i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 选择合适的 key 类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 性能较差的key类型</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)        <span class="comment">// 字符串比较开销大</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>)   <span class="comment">// 接口类型需要类型断言</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 高效的key类型</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)          <span class="comment">// 整数比较最快</span></span><br><span class="line">m4 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="type">int</span>)       <span class="comment">// 固定长度类型效率高</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 避免频繁的删除操作</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 频繁删除导致碎片化</span></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> shouldDelete(key) &#123;</span><br><span class="line">		<span class="built_in">delete</span>(m, key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 批量重建</span></span><br><span class="line">newM := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> !shouldDelete(key) &#123;</span><br><span class="line">		newM[key] = value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">m = newM</span><br></pre></td></tr></table></figure>
<p><strong>4. 使用专门的数据结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于特定场景使用专门优化的数据结构</span></span><br><span class="line"><span class="comment">// 如：sync.Map 用于读多写少的并发场景</span></span><br><span class="line"><span class="comment">// 如：第三方的有序map库</span></span><br></pre></td></tr></table></figure>
<h2 id="内存管理类面试题">内存管理类面试题</h2>
<h3 id="Q9-Go-map-的零值是什么？可以直接使用吗？">Q9: Go map 的零值是什么？可以直接使用吗？</h3>
<p><strong>A:</strong></p>
<ul>
<li><strong>零值</strong>：Go map 的零值是 <code>nil</code></li>
<li><strong>读操作</strong>：可以从 nil map 读取，返回零值和 false</li>
<li><strong>写操作</strong>：不能向 nil map 写入，会 panic：<code>assignment to entry in nil map</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>)        <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 可以读取</span></span><br><span class="line">v, ok := m[<span class="string">&quot;key&quot;</span>]           <span class="comment">// v=0, ok=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不能写入</span></span><br><span class="line"><span class="comment">// m[&quot;key&quot;] = 1             // panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确初始化</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span>               <span class="comment">// 正常工作</span></span><br></pre></td></tr></table></figure>
<p><strong>正确初始化方式：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：使用make</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：字面量初始化</span></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;key&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：指定容量</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Q10-如何判断-map-中某个-key-是否存在？">Q10: 如何判断 map 中某个 key 是否存在？</h3>
<p><strong>A:</strong> 使用双返回值语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := m[key]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	<span class="comment">// key存在，value是对应的值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;key存在，值为:&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// key不存在，value是零值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;key不存在&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化写法</span></span><br><span class="line"><span class="keyword">if</span> value, ok := m[key]; ok &#123;</span><br><span class="line">	<span class="comment">// key存在的处理逻辑</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;找到值:&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅检查存在性</span></span><br><span class="line"><span class="keyword">if</span> _, ok := m[key]; ok &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;key存在&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：仅通过值判断存在性</span></span><br><span class="line"><span class="keyword">if</span> m[key] != <span class="number">0</span> &#123;  <span class="comment">// 错误！值可能本身就是0</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：使用ok标志</span></span><br><span class="line"><span class="keyword">if</span> _, ok := m[key]; ok &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高级应用类面试题">高级应用类面试题</h2>
<h3 id="Q11-遍历过程中修改-map-会发生什么？">Q11: 遍历过程中修改 map 会发生什么？</h3>
<p><strong>A:</strong> 遍历过程中修改 map 的影响：</p>
<ol>
<li><strong>写操作冲突</strong>：会触发 <code>fatal(&quot;concurrent map iteration and map write&quot;)</code></li>
<li><strong>读操作安全</strong>：同时多个遍历是安全的</li>
<li><strong>数据不一致</strong>：即使不崩溃，也可能导致数据不一致</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：遍历时修改</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> shouldDelete(v) &#123;</span><br><span class="line">		<span class="built_in">delete</span>(m, k)  <span class="comment">// 会panic</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> shouldUpdate(v) &#123;</span><br><span class="line">		m[k] = newValue  <span class="comment">// 会panic</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：先收集后处理</span></span><br><span class="line">toDelete := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">toUpdate := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	<span class="keyword">if</span> shouldDelete(v) &#123;</span><br><span class="line">		toDelete = <span class="built_in">append</span>(toDelete, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> shouldUpdate(v) &#123;</span><br><span class="line">		toUpdate[k] = newValue</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量处理</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> toDelete &#123;</span><br><span class="line">	<span class="built_in">delete</span>(m, k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> toUpdate &#123;</span><br><span class="line">	m[k] = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q12-Go-map-的内存泄漏问题及解决方案？">Q12: Go map 的内存泄漏问题及解决方案？</h3>
<p><strong>A:</strong> Go map 可能的内存泄漏问题：</p>
<p><strong>问题 1：删除元素后内存不释放</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题：频繁删除后，桶数组不会缩小</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="comment">// 添加大量数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">	m[fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i)] = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除大部分数据</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">999000</span>; i++ &#123;</span><br><span class="line">	<span class="built_in">delete</span>(m, fmt.Sprintf(<span class="string">&quot;key%d&quot;</span>, i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时map仍占用大量内存</span></span><br></pre></td></tr></table></figure>
<p><strong>解决方案：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方案1：重建map</span></span><br><span class="line">oldM := m</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>, <span class="built_in">len</span>(oldM))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> oldM &#123;</span><br><span class="line">	m[k] = v</span><br><span class="line">&#125;</span><br><span class="line">oldM = <span class="literal">nil</span>  <span class="comment">// 帮助GC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案2：定期重建</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m) &lt; <span class="built_in">cap</span>(m)/<span class="number">4</span> &#123;  <span class="comment">// 伪代码，实际无法获取cap</span></span><br><span class="line">	<span class="comment">// 重建map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题 2：value 含有指针时的内存泄漏</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	data []<span class="type">byte</span></span><br><span class="line">	next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Node)</span><br><span class="line"><span class="comment">// 删除时如果不处理指针链，可能导致内存泄漏</span></span><br><span class="line"><span class="built_in">delete</span>(m, key)  <span class="comment">// Node及其链表可能无法被GC</span></span><br></pre></td></tr></table></figure>
<p><strong>解决方案：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除前先断开指针链</span></span><br><span class="line"><span class="keyword">if</span> node, ok := m[key]; ok &#123;</span><br><span class="line">	<span class="comment">// 清理指针引用</span></span><br><span class="line">	<span class="keyword">for</span> current := node; current != <span class="literal">nil</span>; &#123;</span><br><span class="line">		next := current.next</span><br><span class="line">		current.next = <span class="literal">nil</span>  <span class="comment">// 断开引用</span></span><br><span class="line">		current = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">delete</span>(m, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实战应用类面试题">实战应用类面试题</h2>
<h3 id="Q13-实现一个并发安全的-LRU-缓存？">Q13: 实现一个并发安全的 LRU 缓存？</h3>
<p><strong>A:</strong> 基于 map + 双向链表实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity <span class="type">int</span></span><br><span class="line">	cache    <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">	head     *Node</span><br><span class="line">	tail     *Node</span><br><span class="line">	mutex    sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	key   <span class="type">int</span></span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">	prev  *Node</span><br><span class="line">	next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUCache</span><span class="params">(capacity <span class="type">int</span>)</span></span> *LRUCache &#123;</span><br><span class="line">	head := &amp;Node&#123;&#125;</span><br><span class="line">	tail := &amp;Node&#123;&#125;</span><br><span class="line">	head.next = tail</span><br><span class="line">	tail.prev = head</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;LRUCache&#123;</span><br><span class="line">		capacity: capacity,</span><br><span class="line">		cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node),</span><br><span class="line">		head:     head,</span><br><span class="line">		tail:     tail,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	lru.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> lru.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line">		lru.moveToHead(node)</span><br><span class="line">		<span class="keyword">return</span> node.value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Put(key, value <span class="type">int</span>) &#123;</span><br><span class="line">	lru.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> lru.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line">		node.value = value</span><br><span class="line">		lru.moveToHead(node)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node := &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">	lru.cache[key] = node</span><br><span class="line">	lru.addToHead(node)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt; lru.capacity &#123;</span><br><span class="line">		tail := lru.removeTail()</span><br><span class="line">		<span class="built_in">delete</span>(lru.cache, tail.key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *Node) &#123;</span><br><span class="line">	lru.removeNode(node)</span><br><span class="line">	lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeNode(node *Node) &#123;</span><br><span class="line">	node.prev.next = node.next</span><br><span class="line">	node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> addToHead(node *Node) &#123;</span><br><span class="line">	node.prev = lru.head</span><br><span class="line">	node.next = lru.head.next</span><br><span class="line">	lru.head.next.prev = node</span><br><span class="line">	lru.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeTail() *Node &#123;</span><br><span class="line">	last := lru.tail.prev</span><br><span class="line">	lru.removeNode(last)</span><br><span class="line">	<span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Q14-如何实现一个支持过期时间的-map？">Q14: 如何实现一个支持过期时间的 map？</h3>
<p><strong>A:</strong> 带过期时间的并发安全 map：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ExpiringMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	data   <span class="keyword">map</span>[<span class="type">string</span>]*Item</span><br><span class="line">	mutex  sync.RWMutex</span><br><span class="line">	stop   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	value    <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	expireAt time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewExpiringMap</span><span class="params">(cleanupInterval time.Duration)</span></span> *ExpiringMap &#123;</span><br><span class="line">	em := &amp;ExpiringMap&#123;</span><br><span class="line">		data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Item),</span><br><span class="line">		stop: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动清理goroutine</span></span><br><span class="line">	<span class="keyword">go</span> em.cleanup(cleanupInterval)</span><br><span class="line">	<span class="keyword">return</span> em</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *ExpiringMap)</span></span> Set(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;, ttl time.Duration) &#123;</span><br><span class="line">	em.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> em.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	em.data[key] = &amp;Item&#123;</span><br><span class="line">		value:    value,</span><br><span class="line">		expireAt: time.Now().Add(ttl),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *ExpiringMap)</span></span> Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	em.mutex.RLock()</span><br><span class="line">	<span class="keyword">defer</span> em.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">	item, ok := em.data[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> time.Now().After(item.expireAt) &#123;</span><br><span class="line">		<span class="comment">// 过期了，需要删除（延迟删除，避免长时间持有读锁）</span></span><br><span class="line">		<span class="keyword">go</span> em.<span class="built_in">delete</span>(key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> item.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *ExpiringMap)</span></span> <span class="built_in">delete</span>(key <span class="type">string</span>) &#123;</span><br><span class="line">	em.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> em.mutex.Unlock()</span><br><span class="line">	<span class="built_in">delete</span>(em.data, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *ExpiringMap)</span></span> cleanup(interval time.Duration) &#123;</span><br><span class="line">	ticker := time.NewTicker(interval)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">			em.removeExpired()</span><br><span class="line">		<span class="keyword">case</span> &lt;-em.stop:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *ExpiringMap)</span></span> removeExpired() &#123;</span><br><span class="line">	em.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> em.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="keyword">for</span> key, item := <span class="keyword">range</span> em.data &#123;</span><br><span class="line">		<span class="keyword">if</span> now.After(item.expireAt) &#123;</span><br><span class="line">			<span class="built_in">delete</span>(em.data, key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(em *ExpiringMap)</span></span> Close() &#123;</span><br><span class="line">	<span class="built_in">close</span>(em.stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>Go map 的面试题涵盖了从基础概念到高级应用的各个方面：</p>
<ol>
<li><strong>基础原理</strong>：理解哈希表、桶数组、冲突解决等核心概念</li>
<li><strong>扩容机制</strong>：掌握渐进式扩容的原理和优势</li>
<li><strong>并发安全</strong>：了解并发问题及各种解决方案</li>
<li><strong>性能优化</strong>：掌握性能优化的技巧和最佳实践</li>
<li><strong>内存管理</strong>：理解内存泄漏问题及解决方案</li>
<li><strong>实战应用</strong>：能够基于 map 实现复杂的数据结构</li>
</ol>
<p>深入理解这些知识点，不仅有助于通过面试，更重要的是能在实际工作中正确高效地使用 Go map。</p>
]]></content>
      <categories>
        <category>技术八股</category>
        <category>Go语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Go语言</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
        <tag>面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 173 - 二叉搜索树迭代器（Binary Search Tree Iterator）</title>
    <url>/2025/06/16/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>实现一个二叉搜索树迭代器类 <code>BSTIterator</code>，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<ul>
<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>
<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code>；否则返回 <code>false</code>。</li>
<li><code>int next()</code> 将指针向右移动，然后返回指针处的数字。</li>
</ul>
<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, 3, 7, true, 9, true, 15, true, 20, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);</span><br><span class="line">bSTIterator.next();    // 返回 3</span><br><span class="line">bSTIterator.next();    // 返回 7</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 9</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 15</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 20</span><br><span class="line">bSTIterator.hasNext(); // 返回 False</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 10^5]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 10^6</code></li>
<li>最多调用 <code>10^5</code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>
</ul>
<p><strong>进阶：</strong><br>
你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code>，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</p>
<h2 id="解题思路">解题思路</h2>
<p>这道题的关键是理解<strong>二叉搜索树的中序遍历会产生有序序列</strong>这一重要性质。我们需要实现一个迭代器，能够按照中序遍历的顺序依次返回节点值。</p>
<h3 id="核心算法思想">核心算法思想</h3>
<p><strong>关键洞见</strong>：使用栈模拟中序遍历的递归过程，但不需要一次性遍历整棵树，而是<strong>按需遍历</strong>，实现懒加载（Lazy Evaluation）。</p>
<p>中序遍历的访问顺序是：<strong>左子树 → 根节点 → 右子树</strong></p>
<h3 id="算法设计要点">算法设计要点</h3>
<ol>
<li><strong>初始化阶段</strong>：从根节点开始，将所有左子节点依次压入栈中，这样栈顶就是最小值节点</li>
<li><strong>next() 操作</strong>：
<ul>
<li>弹出栈顶元素作为当前访问的节点</li>
<li>如果该节点有右子树，将右子树的所有左子节点压入栈中</li>
</ul>
</li>
<li><strong>hasNext() 操作</strong>：检查栈是否为空即可</li>
</ol>
<h3 id="可视化示例">可视化示例</h3>
<p>以示例树为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  7</span><br><span class="line"> / \</span><br><span class="line">3   15</span><br><span class="line">   /  \</span><br><span class="line">  9   20</span><br></pre></td></tr></table></figure>
<p>初始化后栈的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈顶 → [3, 7]  # 从根节点开始，将所有左子节点压入栈</span><br></pre></td></tr></table></figure>
<p>执行过程：</p>
<ol>
<li><code>next()</code> → 返回 3，3 无右子树</li>
<li><code>next()</code> → 返回 7，7 有右子树 15，将 15 及其左子节点 9 压入栈</li>
<li><code>next()</code> → 返回 9，9 无右子树</li>
<li><code>next()</code> → 返回 15，15 有右子树 20，将 20 压入栈</li>
<li><code>next()</code> → 返回 20，20 无右子树，栈为空</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="关键函数设计">关键函数设计</h3>
<h4 id="pushAllLeft-辅助函数">pushAllLeft 辅助函数</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将节点及其所有左子节点压入栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BSTIterator)</span></span> pushAllLeft(node *TreeNode) &#123;</span><br><span class="line">    <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        this.nodeStack = <span class="built_in">append</span>(this.nodeStack, node)</span><br><span class="line">        node = node.Left</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Constructor-构造函数">Constructor 构造函数</h4>
<ul>
<li>初始化栈</li>
<li>将根节点的所有左子节点压入栈，确保栈顶是最小值</li>
</ul>
<h4 id="Next-函数">Next 函数</h4>
<ul>
<li>弹出栈顶节点作为返回值</li>
<li>如果该节点有右子树，将右子树的所有左子节点压入栈</li>
</ul>
<h4 id="HasNext-函数">HasNext 函数</h4>
<ul>
<li>简单检查栈是否为空</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> BSTIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">    nodeStack []*TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(root *TreeNode)</span></span> BSTIterator &#123;</span><br><span class="line">    iterator := BSTIterator&#123;</span><br><span class="line">        nodeStack: []*TreeNode&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将根节点及其所有左子节点压入栈</span></span><br><span class="line">    iterator.pushAllLeft(root)</span><br><span class="line">    <span class="keyword">return</span> iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：将节点及其所有左子节点压入栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BSTIterator)</span></span> pushAllLeft(node *TreeNode) &#123;</span><br><span class="line">    <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">        this.nodeStack = <span class="built_in">append</span>(this.nodeStack, node)</span><br><span class="line">        node = node.Left</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BSTIterator)</span></span> Next() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 弹出栈顶节点</span></span><br><span class="line">    n := <span class="built_in">len</span>(this.nodeStack)</span><br><span class="line">    top := this.nodeStack[n<span class="number">-1</span>]</span><br><span class="line">    this.nodeStack = this.nodeStack[:n<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该节点有右子树，将右子树的所有左子节点压入栈</span></span><br><span class="line">    <span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        this.pushAllLeft(top.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> top.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BSTIterator)</span></span> HasNext() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.nodeStack) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析">执行过程分析</h3>
<p>以示例树为例，详细跟踪执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态：栈 = [7, 3]  // 从根节点7开始，沿左子树到3</span><br><span class="line"></span><br><span class="line">1. next() → 返回3</span><br><span class="line">   - 弹出3，3无右子树</span><br><span class="line">   - 栈 = [7]</span><br><span class="line"></span><br><span class="line">2. next() → 返回7  </span><br><span class="line">   - 弹出7，7有右子树15</span><br><span class="line">   - 将15及其左子节点9压入栈</span><br><span class="line">   - 栈 = [15, 9]</span><br><span class="line"></span><br><span class="line">3. next() → 返回9</span><br><span class="line">   - 弹出9，9无右子树</span><br><span class="line">   - 栈 = [15]</span><br><span class="line"></span><br><span class="line">4. next() → 返回15</span><br><span class="line">   - 弹出15，15有右子树20</span><br><span class="line">   - 将20压入栈（20无左子节点）</span><br><span class="line">   - 栈 = [20]</span><br><span class="line"></span><br><span class="line">5. next() → 返回20</span><br><span class="line">   - 弹出20，20无右子树</span><br><span class="line">   - 栈 = []</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li><strong>Constructor</strong>：$O(h)$，其中 $h$ 是树的高度，需要将根节点到最左叶子节点的路径上所有节点压入栈</li>
<li><strong>next()</strong>：<strong>均摊</strong> $O(1)$</li>
<li><strong>hasNext()</strong>：$O(1)$</li>
</ul>
<p><strong>next() 均摊时间复杂度分析</strong>：<br>
每个节点最多被压入栈一次，最多被弹出栈一次。对于 $n$ 个节点的树，总共执行 $n$ 次 <code>next()</code> 操作，总的栈操作次数为 $2n$，因此均摊时间复杂度为 $O(1)$。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>$O(h)$，其中 $h$ 是树的高度。在最坏情况下（完全不平衡的树），空间复杂度为 $O(n)$；在最好情况下（完全平衡的树），空间复杂度为 $O(\log n)$。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>栈迭代法（推荐）</th>
<th>数组预处理法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>next(): 均摊O(1)</td>
<td>next(): O(1)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(h)</td>
<td>O(n)</td>
</tr>
<tr>
<td>初始化时间</td>
<td>O(h)</td>
<td>O(n)</td>
</tr>
<tr>
<td>内存使用</td>
<td>优秀</td>
<td>较差</td>
</tr>
<tr>
<td>懒加载</td>
<td>✅ 支持</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>BST中序遍历的重要性质</strong>：中序遍历二叉搜索树得到的序列是有序的</li>
<li><strong>栈模拟递归</strong>：使用栈可以将递归的中序遍历转换为迭代形式</li>
<li><strong>懒加载思想</strong>：不需要一次性处理所有数据，按需处理可以显著优化空间复杂度</li>
<li><strong>均摊分析</strong>：虽然单次 <code>next()</code> 操作可能需要 $O(h)$ 时间，但均摊下来是 $O(1)$</li>
<li><strong>空间优化技巧</strong>：相比于预先存储所有节点值的方法，栈方法将空间复杂度从 $O(n)$ 优化到 $O(h)$</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ul>
<li>忘记在 <code>next()</code> 方法中处理右子树的左子节点压栈</li>
<li>混淆中序遍历的访问顺序（应该是左→根→右）</li>
<li>在构造函数中没有正确初始化栈状态</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>栈</tag>
        <tag>二叉搜索树</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>从键入网址到网页显示，期间发生了什么？</title>
    <url>/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1>2.2 键入网址到网页显示，期间发生了什么？</h1>
<p>想必不少小伙伴面试过程中，会遇到「<strong>当键入网址后，到网页显示，其间发生了什么</strong>」的面试题。</p>
<p>还别说，这问题真挺常问的，前几天坐在我旁边的主管电话面试应聘者的时候，也问了这个问题。</p>
<p>接下来以下图较简单的网络拓扑模型作为例子，探究探究其间发生了什么？</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003257891.png" alt="简单的网络模型"></p>
<h2 id="孤单小弟-——-HTTP">孤单小弟 —— HTTP</h2>
<blockquote>
<p>浏览器做的第一步工作是解析 URL</p>
</blockquote>
<p>首先浏览器做的第一步工作就是要对 <code>URL</code> 进行解析，从而生成发送给 <code>Web</code> 服务器的请求信息。</p>
<p>让我们看看一条长长的 URL 里的各个元素的代表什么，见下图：</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003271489.png" alt="1750003271489"></p>
<p>所以图中的长长的 URL 实际上是请求服务器里的文件资源。</p>
<blockquote>
<p>要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？</p>
</blockquote>
<p>当没有路径名时，就代表访问根目录下事先设置的<strong>默认文件</strong>，也就是 <code>/index.html</code> 或者 <code>/default.html</code> 这些文件，这样就不会发生混乱了。</p>
<blockquote>
<p>生产 HTTP 请求信息</p>
</blockquote>
<p>对 <code>URL</code> 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003280759.png" alt="1750003280759"></p>
<blockquote>
<p>一个孤单 HTTP 数据包表示：&quot;我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知道我呢？谁能载我一程呢？谁能保护我呢？我的目的地在哪呢？&quot;充满各种疑问的它，没有停滞不前，依然踏上了征途！</p>
</blockquote>
<hr>
<h2 id="真实地址查询-——-DNS">真实地址查询 —— DNS</h2>
<p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code>  服务器。</p>
<p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p>
<p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。</p>
<p>所以，有一种服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。</p>
<blockquote>
<p>域名的层级关系</p>
</blockquote>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>
<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>
<p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p>
<p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。</p>
<p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p>
<p>所以域名的层级关系类似一个树状结构：</p>
<ul>
<li>根 DNS 服务器（.）</li>
<li>顶级域 DNS 服务器（.com）</li>
<li>权威 DNS 服务器（<a href="http://server.com">server.com</a>）</li>
</ul>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003303859.png" alt="1750003303859"></p>
<p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p>
<p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p>
<p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p>
<blockquote>
<p>域名解析的工作流程</p>
</blockquote>
<ol>
<li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li>
<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com">www.server.com</a>，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：&quot;老大，能告诉我 <a href="http://www.server.com">www.server.com</a> 的 IP 地址吗？&quot;根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com">www.server.com</a> 这个域名归 .com 区域管理”，我把 .com 顶级域名服务器的地址给你，你去问问它吧。&quot;</li>
<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问&quot;老二，你能告诉我 <a href="http://www.server.com">www.server.com</a>  的 IP 地址吗？&quot;</li>
<li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li>
<li>本地 DNS 于是转向问权威 DNS 服务器：&quot;老三，<a href="http://www.server.com">www.server.com</a> 对应的 IP 是啥呀？&quot;<a href="http://server.com">server.com</a> 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003311381.png" alt="1750003311381"></p>
<p>DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，<strong>只指路不带路</strong>。</p>
<blockquote>
<p>那是不是每次解析域名都要经过那么多的步骤呢？</p>
</blockquote>
<p>当然不是了，还有缓存这个东西的嘛。</p>
<p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p>
<blockquote>
<p>数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢？”</p>
</blockquote>
<hr>
<h2 id="指南好帮手-——-协议栈">指南好帮手 —— 协议栈</h2>
<p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p>
<p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003319314.png" alt="1750003319314"></p>
<p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p>
<p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p>
<p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p>
<ul>
<li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li>
<li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li>
</ul>
<p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p>
<blockquote>
<p>数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找找 TCP 大佬！”</p>
</blockquote>
<hr>
<h2 id="可靠传输-——-TCP">可靠传输 —— TCP</h2>
<p>HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。</p>
<blockquote>
<p>TCP 包头格式</p>
</blockquote>
<p>我们先看看 TCP 报文头部的格式：</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003326579.png" alt="1750003326579"></p>
<p>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p>
<p>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</p>
<p>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。</p>
<p>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p>
<p>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p>
<p>除了做流量控制以外，TCP 还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</p>
<blockquote>
<p>TCP 传输数据之前，要先三次握手建立连接</p>
</blockquote>
<p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p>
<p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003334236.png" alt="1750003334236"></p>
<ul>
<li>
<p>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</p>
</li>
<li>
<p>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</p>
</li>
<li>
<p>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</p>
</li>
<li>
<p>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</p>
</li>
<li>
<p>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</p>
</li>
</ul>
<p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>
<blockquote>
<p>如何查看 TCP 的连接状态？</p>
</blockquote>
<p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003354831.png" alt="1750003354831"></p>
<blockquote>
<p>TCP 分割数据</p>
</blockquote>
<p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003586972.png" alt="1750003586972"></p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li>
</ul>
<p>数据会被以 <code>MSS</code> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003609298.png" alt="1750003609298"></p>
<blockquote>
<p>TCP 报文生成</p>
</blockquote>
<p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code>）。</p>
<p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p>
<p>至此，网络包的报文如下图。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003618461.png" alt="1750003618461"></p>
<blockquote>
<p>此时，遇上了 TCP 的  数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？”</p>
</blockquote>
<hr>
<h2 id="远程定位-——-IP">远程定位 —— IP</h2>
<p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p>
<blockquote>
<p>IP 包头格式</p>
</blockquote>
<p>我们先看看 IP 报文头部的格式：</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003628441.png" alt="1750003628441"></p>
<p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址 IP</strong>：</p>
<ul>
<li>源地址 IP，即是客户端输出的 IP 地址；</li>
<li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li>
</ul>
<p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p>
<blockquote>
<p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p>
</blockquote>
<p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p>
<p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p>
<p>在 Linux 操作系统，我们可以使用 <code>route -n</code> 命令查看当前系统的路由表。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003637280.png" alt="1750003637280"></p>
<p>举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 <code>192.168.10.200</code>。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003642953.png" alt="1750003642953"></p>
<ol>
<li>首先先和第一条目的子网掩码（<code>Genmask</code>）进行 <strong>与运算</strong>，得到结果为 <code>192.168.10.0</code>，但是第一个条目的 <code>Destination</code> 是 <code>192.168.3.0</code>，两者不一致所以匹配失败。</li>
<li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li>
</ol>
<p>那么假设 Web 服务器的目标地址是 <code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p>
<p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p>
<blockquote>
<p>IP 报文生成</p>
</blockquote>
<p>至此，网络包的报文如下图。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003651638.png" alt="1750003651638"></p>
<blockquote>
<p>此时，加上了 IP 头部的数据包表示：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力，不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”</p>
</blockquote>
<hr>
<h2 id="两点传输-——-MAC">两点传输 —— MAC</h2>
<p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p>
<blockquote>
<p>MAC 包头格式</p>
</blockquote>
<p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003662249.png" alt="1750003662249"></p>
<p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p>
<p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p>
<ul>
<li><code>0800</code> ：IP 协议</li>
<li><code>0806</code> ：ARP 协议</li>
</ul>
<blockquote>
<p>MAC 发送方和接收方如何确认？</p>
</blockquote>
<p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p>
<p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p>
<p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给 <code>Gateway</code> 列中的 IP 地址就可以了。</p>
<blockquote>
<p>既然知道要发给谁，那如何获取对方的 MAC 地址呢？</p>
</blockquote>
<p>不知道对方 MAC 地址？不知道就喊呗。</p>
<p>此时就需要 <code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003669410.png" alt="1750003669410"></p>
<p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p>
<p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p>
<p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p>
<blockquote>
<p>好像每次都要广播获取，这不是很麻烦吗？</p>
</blockquote>
<p>放心，在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p>
<p>也就是说，在发包时：</p>
<ul>
<li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li>
<li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li>
</ul>
<blockquote>
<p>查看 ARP 缓存内容</p>
</blockquote>
<p>在 Linux 系统中，我们可以使用 <code>arp -a</code> 命令来查看 ARP 缓存的内容。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003677846.png" alt="1750003677846"></p>
<blockquote>
<p>MAC 报文生成</p>
</blockquote>
<p>至此，网络包的报文如下图。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003686373.png" alt="1750003686373"></p>
<blockquote>
<p>此时，加上了 MAC 头部的数据包万分感谢，说道：“感谢 MAC 大佬，我知道我下一步要去哪了！我现在有很多头部兄弟，相信我可以到达最终的目的地！”。<br>
带着众多头部兄弟的数据包，终于准备要出门了。</p>
</blockquote>
<hr>
<h2 id="出口-——-网卡">出口 —— 网卡</h2>
<p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
<p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p>
<p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003422881.png" alt="1750003422881"></p>
<ul>
<li>起始帧分界符是一个用来表示包起始位置的标记</li>
<li>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</li>
</ul>
<p>最后网卡会将包转为电信号，通过网线发送出去。</p>
<blockquote>
<p>唉，真是不容易，发一个包，真是历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目的地的征途了！</p>
</blockquote>
<hr>
<h2 id="送别者-——-交换机">送别者 —— 交换机</h2>
<p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p>
<blockquote>
<p>交换机的包接收操作</p>
</blockquote>
<p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p>
<p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p>
<p>交换机的 MAC 地址表主要包含两个信息：</p>
<ul>
<li>一个是设备的 MAC 地址，</li>
<li>另一个是该设备连接在交换机的哪个端口上。</li>
</ul>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003709687.png" alt="1750003709687"></p>
<p>举个例子，如果收到的包的接收方 MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <code>3</code> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p>
<p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p>
<blockquote>
<p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p>
</blockquote>
<p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p>
<p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p>
<p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p>
<p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p>
<p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p>
<p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p>
<p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p>
<p>以下两个属于广播地址：</p>
<ul>
<li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li>
<li>IP 地址中的 <code>255.255.255.255</code></li>
</ul>
<blockquote>
<p>数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！”</p>
</blockquote>
<hr>
<h2 id="出境大门-——-路由器">出境大门 —— 路由器</h2>
<blockquote>
<p>路由器与交换机的区别</p>
</blockquote>
<p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p>
<p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p>
<p>不过在具体的操作过程上，路由器和交换机是有区别的。</p>
<ul>
<li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li>
<li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li>
</ul>
<blockquote>
<p>路由器基本原理</p>
</blockquote>
<p>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</p>
<p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p>
<blockquote>
<p>路由器的包接收操作</p>
</blockquote>
<p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p>
<p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p>
<p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p>
<blockquote>
<p>查询路由表确定输出端口</p>
</blockquote>
<p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p>
<p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p>
<p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p>
<p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003721861.png" alt="1750003721861"></p>
<p>具体的工作流程根据上图，举个例子。</p>
<p>假设地址为 <code>10.10.1.101</code> 的计算机要向地址为 <code>192.168.1.100</code> 的服务器发送一个包，这个包先到达图中的路由器。</p>
<p>判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。</p>
<p>路由匹配和前面讲的一样，每个条目的子网掩码和 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。</p>
<p>如第二条目的子网掩码 <code>255.255.255.0</code> 与 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到结果是 <code>192.168.1.0</code> ，这与第二条目的目标地址 <code>192.168.1.0</code> 匹配，该第二条目记录就会被作为转发目标。</p>
<p>实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」。</p>
<blockquote>
<p>路由器的发送操作</p>
</blockquote>
<p>接下来就会进入包的<strong>发送操作</strong>。</p>
<p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p>
<ul>
<li>如果网关是一个 IP 地址，则这个 IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li>
<li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li>
</ul>
<p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p>
<p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p>
<p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p>
<p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p>
<p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p>
<p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p>
<p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址（NAT除外）</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p>
<blockquote>
<p>数据包通过多个路由器道友的帮助，在网络世界途经了很多路程，最终抵达了目的地的城门！城门值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再经由城内的交换机帮助下，最终转发到了目的地了。数据包感慨万千的说道：“多谢这一路上，各路大侠的相助！”</p>
</blockquote>
<hr>
<h2 id="互相扒皮-——-服务器-与-客户端">互相扒皮 —— 服务器 与 客户端</h2>
<p>数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？</p>
<p>服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？</p>
<p><img src="/2025/06/16/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E5%87%BBURL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/1750003733095.png" alt="1750003733095"></p>
<p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p>
<p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p>
<p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号，HTTP 的服务器正在监听这个端口号。</p>
<p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p>
<p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>
<p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p>
<p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p>
<p>最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p>
<p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p>
<p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p>
<p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p>
<hr>
<h2 id="一个数据包臭不要脸的感受">一个数据包臭不要脸的感受</h2>
<blockquote>
<p>下面内容的「我」，代表「臭美的数据包角色」。注：（括号的内容）代表我的吐槽，三连呸！</p>
</blockquote>
<p>我一开始我虽然孤单、不知所措，但没有停滞不前。我依然满怀信心和勇气开始了征途。（<strong>你当然有勇气，你是应用层数据，后面有底层兄弟当靠山，我呸！</strong>）</p>
<p>我很庆幸遇到了各路神通广大的大佬，有可靠传输的 TCP、有远程定位功能的 IP、有指明下一站位置的 MAC 等（<strong>你当然会遇到，因为都被计算机安排好的，我呸！</strong>）。</p>
<p>这些大佬都给我前面加上了头部，使得我能在交换机和路由器的转发下，抵达到了目的地！（<strong>哎，你也不容易，不吐槽了，放过你！</strong>）</p>
<p>这一路上的经历，让我认识到了网络世界中各路大侠协作的重要性，是他们维护了网络世界的秩序，感谢他们！（<strong>我呸，你应该感谢众多计算机科学家！</strong>）</p>
<hr>
<h2 id="读者问答">读者问答</h2>
<blockquote>
<p>读者问：“笔记本的是自带交换机的吗？交换机现在我还不知道是什么”</p>
</blockquote>
<p>笔记本不是交换机，交换机通常是 2 个网口以上。</p>
<p>现在家里的路由器其实有了交换机的功能了。交换机可以简单理解成一个设备，三台电脑网线接到这个设备，这三台电脑就可以互相通信了，交换机嘛，交换数据这么理解就可以。</p>
<blockquote>
<p>读者问：“如果知道你电脑的 Mac 地址，我可以直接给你发消息吗？”</p>
</blockquote>
<p>Mac 地址只能是两个设备之间传递时使用的，如果你要从大老远给我发消息，是离不开 IP 的。</p>
<blockquote>
<p>读者问：“请问公网服务器的 Mac 地址是在什么时机通过什么方式获取到的？我看 ARP 获取 Mac 地址只能获取到内网机器的 Mac 地址吧？”</p>
</blockquote>
<p>在发送数据包时，如果目标主机不是本地局域网，填入的 Mac 地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 Mac 地址，从而转发到这个服务器主机。</p>
<p>转发的过程中，源 IP 地址和目标 IP 地址是不会变的（前提：没有使用 NAT 网络的），源 MAC 地址和目标 MAC 地址是会变化的。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: TCP/IP网络层结构详解</title>
    <url>/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1>TCP/IP 网络模型的四层结构详解</h1>
<h2 id="概述">概述</h2>
<p>为什么要有 TCP/IP 网络模型？</p>
<p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信。由于设备的多样性（不同厂商、不同操作系统、不同硬件架构），为了实现设备间的互联互通，就协商出了一套<strong>通用的网络协议标准</strong>。</p>
<p>这个网络协议采用<strong>分层设计</strong>的理念，每一层都有明确的职责和功能，层与层之间通过标准接口进行通信。这种设计方式的优势包括：</p>
<ul>
<li><strong>模块化</strong>：每层可以独立开发和维护</li>
<li><strong>可扩展性</strong>：可以在不影响其他层的情况下升级某一层</li>
<li><strong>标准化</strong>：不同厂商的设备可以互操作</li>
<li><strong>复杂性管理</strong>：将复杂的网络通信问题分解为多个简单的子问题</li>
</ul>
<p>接下来根据「TCP/IP 网络模型」分别对每一层进行详细介绍。</p>
<h2 id="应用层（Application-Layer）">应用层（Application Layer）</h2>
<h3 id="基本概念">基本概念</h3>
<p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>。应用层是网络协议栈的最顶层，<strong>直接为用户提供网络服务</strong>。我们电脑或手机上使用的所有网络应用软件都是在应用层实现的。</p>
<h3 id="主要协议和功能">主要协议和功能</h3>
<p>应用层包含了众多的协议，每个协议都为特定的应用场景服务：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>端口</th>
<th>功能</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HTTP/HTTPS</strong></td>
<td>80/443</td>
<td>超文本传输协议</td>
<td>网页浏览、API调用</td>
</tr>
<tr>
<td><strong>FTP</strong></td>
<td>20/21</td>
<td>文件传输协议</td>
<td>文件上传下载</td>
</tr>
<tr>
<td><strong>SMTP</strong></td>
<td>25</td>
<td>简单邮件传输协议</td>
<td>邮件发送</td>
</tr>
<tr>
<td><strong>POP3/IMAP</strong></td>
<td>110/143</td>
<td>邮件接收协议</td>
<td>邮件接收</td>
</tr>
<tr>
<td><strong>DNS</strong></td>
<td>53</td>
<td>域名解析协议</td>
<td>域名到IP地址转换</td>
</tr>
<tr>
<td><strong>Telnet</strong></td>
<td>23</td>
<td>远程登录协议</td>
<td>远程终端访问</td>
</tr>
<tr>
<td><strong>SSH</strong></td>
<td>22</td>
<td>安全外壳协议</td>
<td>安全的远程登录</td>
</tr>
</tbody>
</table>
<h3 id="工作原理">工作原理</h3>
<p>当两个不同设备的应用需要通信时，应用层会：</p>
<ol>
<li><strong>封装应用数据</strong>：将用户数据按照特定协议格式进行封装</li>
<li><strong>调用传输层服务</strong>：通过系统调用（如socket API）将数据传递给传输层</li>
<li><strong>处理应用逻辑</strong>：专注于业务逻辑，无需关心底层传输细节</li>
</ol>
<p><strong>实际例子</strong>：当你在浏览器中访问 <code>https://www.example.com</code> 时：</p>
<ol>
<li>应用层的HTTP协议构造请求报文</li>
<li>通过socket接口调用传输层的TCP服务</li>
<li>TCP负责可靠传输，应用层无需关心数据如何到达服务器</li>
</ol>
<h3 id="运行环境">运行环境</h3>
<p>应用层工作在操作系统的<strong>用户态</strong>（User Space），而传输层及以下各层工作在<strong>内核态</strong>（Kernel Space）。这种设计的好处是：</p>
<ul>
<li><strong>安全性</strong>：用户程序无法直接访问内核，提高系统安全性</li>
<li><strong>稳定性</strong>：应用程序崩溃不会影响系统内核</li>
<li><strong>灵活性</strong>：用户可以自由开发应用程序</li>
</ul>
<h2 id="传输层（Transport-Layer）">传输层（Transport Layer）</h2>
<h3 id="基本概念-2">基本概念</h3>
<p><strong>传输层</strong>是应用层和网络层之间的桥梁，为应用层提供<strong>端到端的数据传输服务</strong>。传输层的核心作用是实现<strong>进程到进程</strong>的通信。</p>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000198486.png" alt="1750000198486"></p>
<h3 id="TCP协议详解">TCP协议详解</h3>
<p><strong>TCP</strong>（<strong>Transmission Control Protocol，传输控制协议</strong>）是一个面向连接的、可靠的传输协议。</p>
<h4 id="TCP的关键特性：">TCP的关键特性：</h4>
<ol>
<li><strong>面向连接</strong>：通信前必须建立连接（三次握手）</li>
<li><strong>可靠传输</strong>：保证数据按序、无重复、无丢失地到达</li>
<li><strong>流量控制</strong>：防止发送方发送速度过快导致接收方缓冲区溢出</li>
<li><strong>拥塞控制</strong>：根据网络状况调整发送速率，避免网络拥塞</li>
<li><strong>全双工通信</strong>：双方可以同时发送和接收数据</li>
</ol>
<h4 id="TCP的工作机制：">TCP的工作机制：</h4>
<p><strong>数据分段</strong>：当应用层数据超过 <strong>MSS（Maximum Segment Size，最大报文段长度）</strong> 时，TCP会将数据分割成多个段：</p>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000205916.png" alt="1750000205916"></p>
<ul>
<li><strong>MSS通常为1460字节</strong>（以太网MTU 1500字节 - IP头部20字节 - TCP头部20字节）</li>
<li>每个TCP段都有独立的序列号，便于接收方重新组装</li>
<li>如果某个段丢失，只需重传该段，而不是整个数据</li>
</ul>
<p><strong>可靠性保障机制</strong>：</p>
<ul>
<li><strong>序列号和确认号</strong>：每个字节都有唯一的序列号</li>
<li><strong>超时重传</strong>：发送方设置重传定时器，超时未收到ACK则重传</li>
<li><strong>快速重传</strong>：收到3个重复ACK时立即重传</li>
<li><strong>滑动窗口</strong>：提高传输效率，允许发送多个未确认的段</li>
</ul>
<h3 id="UDP协议详解">UDP协议详解</h3>
<p>（<strong>UDPUser Datagram Protocol，用户数据报协议</strong>）是一个无连接的、不可靠的传输协议。</p>
<h4 id="UDP的特点：">UDP的特点：</h4>
<ol>
<li><strong>简单高效</strong>：头部只有8字节，开销小</li>
<li><strong>无连接</strong>：发送数据前无需建立连接</li>
<li><strong>不可靠</strong>：不保证数据到达、顺序和完整性</li>
<li><strong>实时性好</strong>：无需等待确认，传输延迟低</li>
</ol>
<h4 id="UDP的应用场景：">UDP的应用场景：</h4>
<ul>
<li><strong>实时音视频</strong>：如直播、视频通话（对延迟敏感，可接受少量丢包）</li>
<li><strong>DNS查询</strong>：请求数据小，重传成本低</li>
<li><strong>DHCP</strong>：网络配置协议，简单请求-响应模式</li>
<li><strong>在线游戏</strong>：对实时性要求高，可通过应用层补偿丢包</li>
</ul>
<h3 id="端口号机制">端口号机制</h3>
<p>传输层使用<strong>端口号</strong>来区分不同的应用进程：</p>
<h4 id="端口号分类：">端口号分类：</h4>
<ul>
<li><strong>知名端口（0-1023）</strong>：由IANA分配给标准服务</li>
<li><strong>注册端口（1024-49151）</strong>：注册给特定应用</li>
<li><strong>动态端口（49152-65535）</strong>：操作系统动态分配给客户端</li>
</ul>
<h4 id="端口号工作原理：">端口号工作原理：</h4>
<p>当数据到达目标主机时，传输层根据目标端口号将数据递交给相应的应用进程。例如：</p>
<ul>
<li>Web服务器监听80端口</li>
<li>客户端浏览器使用动态端口（如50123）</li>
<li>数据包中同时包含源端口和目标端口，确保双向通信</li>
</ul>
<h2 id="网络层（Internet-Layer）">网络层（Internet Layer）</h2>
<h3 id="基本概念-3">基本概念</h3>
<p>传输层并不负责数据在网络中的实际传输路径选择。实际网络环境错综复杂，中间有各种各样的路由器、交换机和线路。<strong>网络层</strong>的职责就是在这个复杂的网络中为数据包寻找最佳路径，实现<strong>主机到主机</strong>的通信。</p>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000215075.png" alt="1750000215075"></p>
<h3 id="IP协议详解">IP协议详解</h3>
<p><strong>IP协议</strong>（<strong>Internet Protocol</strong>）是网络层的核心协议，提供无连接的数据报服务。</p>
<h4 id="IP报文结构：">IP报文结构：</h4>
<p>IP协议将传输层的数据作为载荷，加上IP头部形成IP数据报：</p>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000222363.png" alt="1750000222363"></p>
<p><strong>IP头部关键字段</strong>：</p>
<ul>
<li><strong>版本</strong>：IP协议版本（IPv4为4，IPv6为6）</li>
<li><strong>头部长度</strong>：IP头部长度（最小20字节）</li>
<li><strong>总长度</strong>：整个IP数据报长度（最大65535字节）</li>
<li><strong>标识、标志、片偏移</strong>：用于数据报分片和重组</li>
<li><strong>生存时间（TTL）</strong>：防止数据报在网络中无限循环</li>
<li><strong>协议</strong>：指示上层协议类型（TCP=6，UDP=17）</li>
<li><strong>源IP地址和目标IP地址</strong>：标识发送方和接收方</li>
</ul>
<h4 id="IP分片机制：">IP分片机制：</h4>
<p>当IP数据报大小超过链路的<strong>MTU</strong>（<strong>Maximum Transmission Unit</strong>）时，需要进行分片：</p>
<ul>
<li><strong>以太网MTU通常为1500字节</strong></li>
<li>大的IP数据报被分割成多个小片段</li>
<li>每个片段都有独立的IP头部</li>
<li>目标主机负责重新组装所有片段</li>
</ul>
<h3 id="IP地址和子网">IP地址和子网</h3>
<h4 id="IP地址结构：">IP地址结构：</h4>
<p>以IPv4为例，IP地址是32位的二进制数，通常用点分十进制表示（如192.168.1.1）。</p>
<p>IP地址分为两部分：</p>
<ul>
<li><strong>网络号</strong>：标识子网</li>
<li><strong>主机号</strong>：标识子网内的具体主机</li>
</ul>
<h4 id="子网掩码计算：">子网掩码计算：</h4>
<p>子网掩码用于区分网络号和主机号。例如：</p>
<p><strong>示例</strong>：IP地址 10.100.122.2，子网掩码 255.255.255.0（/24）</p>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000230907.png" alt="1750000230907"></p>
<p><strong>计算过程</strong>：</p>
<ol>
<li><strong>网络地址计算</strong>：IP地址 AND 子网掩码
<ul>
<li>10.100.122.2 AND 255.255.255.0 = 10.100.122.0</li>
</ul>
</li>
<li><strong>主机地址计算</strong>：IP地址 AND (NOT 子网掩码)
<ul>
<li>10.100.122.2 AND 0.0.0.255 = 0.0.0.2</li>
</ul>
</li>
</ol>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000237830.png" alt="1750000237830"></p>
<h4 id="地址分类：">地址分类：</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>地址范围</th>
<th>默认子网掩码</th>
<th>网络数量</th>
<th>主机数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>A类</td>
<td>1.0.0.0-126.255.255.255</td>
<td>255.0.0.0 (/8)</td>
<td>126</td>
<td>16,777,214</td>
</tr>
<tr>
<td>B类</td>
<td>128.0.0.0-191.255.255.255</td>
<td>255.255.0.0 (/16)</td>
<td>16,384</td>
<td>65,534</td>
</tr>
<tr>
<td>C类</td>
<td>192.0.0.0-223.255.255.255</td>
<td>255.255.255.0 (/24)</td>
<td>2,097,152</td>
<td>254</td>
</tr>
</tbody>
</table>
<h3 id="路由机制">路由机制</h3>
<h4 id="路由基本概念：">路由基本概念：</h4>
<p>路由是指数据包在网络中从源主机到目标主机所经过的路径选择过程。</p>
<p><strong>路由 vs 寻址</strong>：</p>
<ul>
<li><strong>寻址</strong>：确定目标在哪里（类似于导航确定目的地）</li>
<li><strong>路由</strong>：选择到达目标的最佳路径（类似于选择行驶路线）</li>
</ul>
<h4 id="路由表：">路由表：</h4>
<p>每个路由器维护一个路由表，包含以下信息：</p>
<ul>
<li><strong>目标网络</strong>：要到达的网络地址</li>
<li><strong>下一跳</strong>：数据包应该发送给哪个路由器</li>
<li><strong>接口</strong>：从哪个网络接口发送</li>
<li><strong>度量值</strong>：路径的代价（跳数、带宽、延迟等）</li>
</ul>
<h4 id="路由算法：">路由算法：</h4>
<p><strong>静态路由</strong>：</p>
<ul>
<li>管理员手动配置路由表</li>
<li>适用于小型、拓扑稳定的网络</li>
</ul>
<p><strong>动态路由</strong>：</p>
<ul>
<li>路由器自动学习和更新路由信息</li>
<li>常见协议：RIP、OSPF、BGP</li>
</ul>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000244693.png" alt="1750000244693"></p>
<p><strong>路由决策过程</strong>：</p>
<ol>
<li>查看目标IP地址</li>
<li>在路由表中查找最匹配的网络条目（最长前缀匹配）</li>
<li>将数据包转发给下一跳路由器</li>
<li>重复此过程直到到达目标网络</li>
</ol>
<h2 id="网络接口层（Link-Layer）">网络接口层（Link Layer）</h2>
<h3 id="基本概念-4">基本概念</h3>
<p><strong>网络接口层</strong>（也称数据链路层）是TCP/IP模型的最底层，负责在物理网络上传输数据帧。这一层直接与硬件交互，处理比特流在物理介质上的传输。</p>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000251901.png" alt="1750000251901"></p>
<h3 id="以太网技术">以太网技术</h3>
<h4 id="什么是以太网？">什么是以太网？</h4>
<p>以太网是目前最广泛使用的局域网技术。以太网的组成部分包括：</p>
<ul>
<li><strong>网络接口卡（NIC）</strong>：电脑上的以太网接口、Wi-Fi接口</li>
<li><strong>网络设备</strong>：交换机、路由器上的千兆、万兆以太网口</li>
<li><strong>传输介质</strong>：网线（双绞线）、光纤等</li>
<li><strong>协议标准</strong>：IEEE 802.3标准</li>
</ul>
<p>以太网是一种在「局域网」内连接附近设备的技术，使设备之间可以进行通讯。</p>
<h4 id="以太网的发展：">以太网的发展：</h4>
<table>
<thead>
<tr>
<th>标准</th>
<th>速率</th>
<th>介质</th>
<th>最大距离</th>
</tr>
</thead>
<tbody>
<tr>
<td>10Base-T</td>
<td>10 Mbps</td>
<td>双绞线</td>
<td>100m</td>
</tr>
<tr>
<td>100Base-TX</td>
<td>100 Mbps</td>
<td>双绞线</td>
<td>100m</td>
</tr>
<tr>
<td>1000Base-T</td>
<td>1 Gbps</td>
<td>双绞线</td>
<td>100m</td>
</tr>
<tr>
<td>10GBase-T</td>
<td>10 Gbps</td>
<td>双绞线</td>
<td>100m</td>
</tr>
</tbody>
</table>
<h3 id="MAC地址机制">MAC地址机制</h3>
<h4 id="MAC地址结构：">MAC地址结构：</h4>
<p><strong>MAC（Media Access Control）地址</strong>是网络接口的硬件地址，长度为48位（6字节），通常用十六进制表示：</p>
<ul>
<li><strong>格式</strong>：XX:XX:XX:XX:XX:XX（如 00:1B:44:11:3A:B7）</li>
<li><strong>全球唯一</strong>：由IEEE统一分配，理论上每个网卡都有唯一的MAC地址</li>
<li><strong>厂商标识</strong>：前3字节是厂商标识（OUI，Organizationally Unique Identifier）</li>
</ul>
<h4 id="MAC地址-vs-IP地址：">MAC地址 vs IP地址：</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>MAC地址</th>
<th>IP地址</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用范围</strong></td>
<td>本地链路（局域网）</td>
<td>全球互联网</td>
</tr>
<tr>
<td><strong>分配方式</strong></td>
<td>硬件固化，全球唯一</td>
<td>网络管理员分配，可变</td>
</tr>
<tr>
<td><strong>地址结构</strong></td>
<td>平面地址，无层次性</td>
<td>层次地址，有网络号和主机号</td>
</tr>
<tr>
<td><strong>路由支持</strong></td>
<td>不支持路由</td>
<td>支持路由</td>
</tr>
</tbody>
</table>
<h4 id="为什么需要MAC地址？">为什么需要MAC地址？</h4>
<p>虽然IP地址可以标识网络中的主机，但在同一个局域网内，设备之间的直接通信必须使用MAC地址，原因包括：</p>
<ol>
<li><strong>局域网工作机制</strong>：以太网交换机工作在数据链路层，只能识别MAC地址</li>
<li><strong>ARP协议</strong>：将IP地址解析为MAC地址，实现IP层到链路层的映射</li>
<li><strong>帧转发</strong>：同一网络内的数据传输基于MAC地址进行帧转发</li>
</ol>
<h3 id="ARP协议">ARP协议</h3>
<h4 id="ARP工作原理：">ARP工作原理：</h4>
<p>**ARP（Address Resolution Protocol，地址解析协议）**用于将IP地址解析为MAC地址。</p>
<p><strong>ARP工作过程</strong>：</p>
<ol>
<li><strong>发送ARP请求</strong>：主机A要与主机B通信，但只知道B的IP地址</li>
<li><strong>广播查询</strong>：A在局域网内广播ARP请求&quot;谁有IP地址X？&quot;</li>
<li><strong>目标响应</strong>：拥有该IP地址的主机B回复自己的MAC地址</li>
<li><strong>缓存记录</strong>：A将IP-MAC映射关系存储在ARP缓存表中</li>
<li><strong>发送数据</strong>：A使用获得的MAC地址构造以太网帧并发送</li>
</ol>
<h4 id="ARP缓存表：">ARP缓存表：</h4>
<p>操作系统维护ARP缓存表，避免重复查询：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看ARP缓存表</span></span><br><span class="line">arp -a</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">192.168.1.1 (192.168.1.1) at 00:1a:2b:3c:4d:5e [ether] on eth0</span><br><span class="line">192.168.1.100 (192.168.1.100) at 00:11:22:33:44:55 [ether] on eth0</span><br></pre></td></tr></table></figure>
<h3 id="数据帧结构">数据帧结构</h3>
<h4 id="以太网帧格式：">以太网帧格式：</h4>
<p>以太网帧的基本结构如下：</p>
<table>
<thead>
<tr>
<th>前导符</th>
<th>目标MAC</th>
<th>源MAC</th>
<th>类型/长度</th>
<th>数据</th>
<th>FCS</th>
</tr>
</thead>
<tbody>
<tr>
<td>8字节</td>
<td>6字节</td>
<td>6字节</td>
<td>2字节</td>
<td>46-1500字节</td>
<td>4字节</td>
</tr>
</tbody>
</table>
<p><strong>字段说明</strong>：</p>
<ul>
<li><strong>前导符</strong>：用于同步，包含帧起始定界符</li>
<li><strong>目标MAC地址</strong>：接收方的MAC地址</li>
<li><strong>源MAC地址</strong>：发送方的MAC地址</li>
<li><strong>类型/长度</strong>：指示上层协议类型（如0x0800表示IPv4）</li>
<li><strong>数据</strong>：来自网络层的IP数据报</li>
<li><strong>FCS</strong>：帧校验序列，用于错误检测</li>
</ul>
<h3 id="网络接口层的主要功能">网络接口层的主要功能</h3>
<ol>
<li><strong>成帧</strong>：将网络层的IP数据报封装成帧</li>
<li><strong>物理寻址</strong>：使用MAC地址在局域网内定位设备</li>
<li><strong>错误检测</strong>：通过校验和检测传输错误</li>
<li><strong>流量控制</strong>：控制帧的发送速率</li>
<li><strong>介质访问控制</strong>：管理多个设备对共享介质的访问</li>
</ol>
<h2 id="数据封装与传输过程">数据封装与传输过程</h2>
<h3 id="发送过程（数据封装）">发送过程（数据封装）</h3>
<p>当应用程序发送数据时，数据会经历以下封装过程：</p>
<ol>
<li><strong>应用层</strong>：产生应用数据（如HTTP请求）</li>
<li><strong>传输层</strong>：添加TCP/UDP头部，形成段（Segment）</li>
<li><strong>网络层</strong>：添加IP头部，形成数据报（Packet）</li>
<li><strong>网络接口层</strong>：添加以太网头部和尾部，形成帧（Frame）</li>
</ol>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000266759.png" alt="1750000266759"></p>
<h3 id="接收过程（数据解封装）">接收过程（数据解封装）</h3>
<p>当目标主机接收到数据时，会进行相反的解封装过程：</p>
<ol>
<li><strong>网络接口层</strong>：检查帧校验和，移除以太网头部和尾部</li>
<li><strong>网络层</strong>：检查IP头部，确认是否为本机数据，移除IP头部</li>
<li><strong>传输层</strong>：根据端口号找到目标进程，移除TCP/UDP头部</li>
<li><strong>应用层</strong>：接收到纯净的应用数据</li>
</ol>
<h3 id="实际传输示例">实际传输示例</h3>
<p><strong>场景</strong>：用户在浏览器中访问 <code>http://www.example.com</code></p>
<p><strong>详细过程</strong>：</p>
<ol>
<li>
<p><strong>DNS解析</strong>：</p>
<ul>
<li>浏览器发送DNS查询获取 <a href="http://www.example.com">www.example.com</a> 的IP地址</li>
<li>DNS服务器返回IP地址（如 93.184.216.34）</li>
</ul>
</li>
<li>
<p><strong>建立TCP连接</strong>：</p>
<ul>
<li>浏览器向目标IP的80端口发起TCP连接</li>
<li>进行三次握手建立连接</li>
</ul>
</li>
<li>
<p><strong>发送HTTP请求</strong>：</p>
<ul>
<li>应用层：构造HTTP GET请求</li>
<li>传输层：添加TCP头部（源端口：动态分配，目标端口：80）</li>
<li>网络层：添加IP头部（源IP：本机IP，目标IP：93.184.216.34）</li>
<li>网络接口层：添加以太网头部（目标MAC：网关MAC地址）</li>
</ul>
</li>
<li>
<p><strong>路由转发</strong>：</p>
<ul>
<li>数据帧首先发送到本地网关</li>
<li>路由器根据路由表逐跳转发数据包</li>
<li>每一跳都会重新封装链路层头部</li>
</ul>
</li>
<li>
<p><strong>服务器响应</strong>：</p>
<ul>
<li>Web服务器接收到请求，处理后返回HTML内容</li>
<li>响应数据经过相同的封装和路由过程返回给客户端</li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2>
<h3 id="TCP-IP四层模型概览">TCP/IP四层模型概览</h3>
<p>TCP/IP网络模型从上到下分为四层，每层都有明确的职责：</p>
<p><img src="/2025/06/15/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP-IP%E7%BD%91%E7%BB%9C%E5%B1%82%E7%BB%93%E6%9E%84/1750000261014.png" alt="1750000261014"></p>
<h3 id="各层的核心职责">各层的核心职责</h3>
<ol>
<li>
<p><strong>应用层</strong>：</p>
<ul>
<li>为用户提供网络应用服务</li>
<li>处理应用协议（HTTP、FTP、SMTP等）</li>
<li>工作在用户态</li>
</ul>
</li>
<li>
<p><strong>传输层</strong>：</p>
<ul>
<li>提供端到端的数据传输服务</li>
<li>实现进程间通信（端口号机制）</li>
<li>提供可靠性保障（TCP）或高效传输（UDP）</li>
</ul>
</li>
<li>
<p><strong>网络层</strong>：</p>
<ul>
<li>实现主机间的数据传输</li>
<li>提供路由和寻址功能</li>
<li>处理数据包的跨网络传输</li>
</ul>
</li>
<li>
<p><strong>网络接口层</strong>：</p>
<ul>
<li>处理物理网络上的数据传输</li>
<li>实现帧的封装和解封装</li>
<li>提供硬件寻址（MAC地址）</li>
</ul>
</li>
</ol>
<h3 id="数据传输单位">数据传输单位</h3>
<table>
<thead>
<tr>
<th>层次</th>
<th>传输单位</th>
<th>主要内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>消息/报文（Message）</td>
<td>应用数据</td>
</tr>
<tr>
<td>传输层</td>
<td>段（Segment）</td>
<td>TCP/UDP头部 + 应用数据</td>
</tr>
<tr>
<td>网络层</td>
<td>数据报/包（Packet）</td>
<td>IP头部 + 段</td>
</tr>
<tr>
<td>网络接口层</td>
<td>帧（Frame）</td>
<td>以太网头部 + 数据报 + 校验</td>
</tr>
</tbody>
</table>
<h3 id="设计优势">设计优势</h3>
<p>TCP/IP分层设计的核心优势：</p>
<ol>
<li><strong>模块化设计</strong>：各层功能独立，便于开发和维护</li>
<li><strong>标准化接口</strong>：层间通过标准接口通信，保证互操作性</li>
<li><strong>可扩展性</strong>：可以独立升级某一层而不影响其他层</li>
<li><strong>复杂性管理</strong>：将复杂问题分解为简单的子问题</li>
<li><strong>厂商中立</strong>：不同厂商的设备可以互联互通</li>
</ol>
<p>这种分层设计使得互联网能够成为一个开放、可扩展、可互操作的全球网络基础设施，为现代信息社会的发展奠定了坚实的技术基础。</p>
]]></content>
      <categories>
        <category>技术八股</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>后端</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 112 - 路径总和（Path Sum）</title>
    <url>/2025/06/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code>，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code>。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">路径：5 → 4 → 11 → 2，和为 22</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/1749983022014.png" alt="1749983022014"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 → 2): 和为 3</span><br><span class="line">(1 → 3): 和为 4</span><br><span class="line">不存在和为 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/1749983039532.png" alt="1749983039532"></p>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心思想是使用 <strong>递归</strong> 和 <strong>深度优先搜索（DFS）</strong> 来遍历二叉树的所有从根节点到叶子节点的路径。</p>
<h3 id="核心思路分析">核心思路分析</h3>
<ol>
<li>
<p><strong>递归结构</strong>：对于每个节点，我们需要判断是否存在一条从该节点到叶子节点的路径，使得路径和等于剩余的目标值。</p>
</li>
<li>
<p><strong>状态转移</strong>：每当我们访问一个节点时，将目标和减去当前节点的值，然后递归地在左右子树中寻找剩余目标和的路径。</p>
</li>
<li>
<p><strong>边界条件</strong>：</p>
<ul>
<li>如果节点为空，返回 <code>false</code></li>
<li>如果节点是叶子节点且节点值等于剩余目标和，返回 <code>true</code></li>
</ul>
</li>
<li>
<p><strong>递归逻辑</strong>：对于非叶子节点，只要左子树或右子树中存在满足条件的路径，就返回 <code>true</code>。</p>
</li>
</ol>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li><strong>空树处理</strong>：如果根节点为空，直接返回 <code>false</code></li>
<li><strong>叶子节点判断</strong>：如果当前节点是叶子节点，检查其值是否等于剩余的目标和</li>
<li><strong>递归搜索</strong>：对于非叶子节点，递归搜索左右子树，目标和更新为 <code>targetSum - root.Val</code></li>
<li><strong>结果合并</strong>：只要左子树或右子树中有一条路径满足条件，就返回 <code>true</code></li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>让我们逐步分析代码实现：</p>
<h3 id="Go-语言实现">Go 语言实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 边界条件：空树没有路径</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点：检查当前节点值是否等于剩余目标和</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == targetSum &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归搜索左右子树，目标和减去当前节点值</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) ||</span><br><span class="line">           hasPathSum(root.Right, targetSum-root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码关键点解析">代码关键点解析</h3>
<ol>
<li>
<p><strong>空节点处理</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当遍历到空节点时，说明这条路径无法到达叶子节点，返回 <code>false</code>。</p>
</li>
<li>
<p><strong>叶子节点判断</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == targetSum &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当节点是叶子节点（左右子树都为空）且节点值等于剩余目标和时，才找到了满足条件的路径。</p>
</li>
<li>
<p><strong>递归搜索</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) ||</span><br><span class="line">       hasPathSum(root.Right, targetSum-root.Val)</span><br></pre></td></tr></table></figure>
<p>递归地在左右子树中寻找路径，目标和更新为 <code>targetSum - root.Val</code>。使用逻辑或操作符，只要有一条路径满足条件就返回 <code>true</code>。</p>
</li>
</ol>
<h2 id="算法执行过程示例">算法执行过程示例</h2>
<p>以示例 1 为例，让我们跟踪算法的执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">树结构：     5     targetSum = 22</span><br><span class="line">           / \</span><br><span class="line">          4   8</span><br><span class="line">         /   / \</span><br><span class="line">        11  13  4</span><br><span class="line">       / \      \</span><br><span class="line">      7   2      1</span><br><span class="line"></span><br><span class="line">执行过程：</span><br><span class="line">1. hasPathSum(5, 22)</span><br><span class="line">   - 不是叶子节点，递归调用子树</span><br><span class="line">   - hasPathSum(4, 17) || hasPathSum(8, 14)</span><br><span class="line"></span><br><span class="line">2. hasPathSum(4, 17)</span><br><span class="line">   - 不是叶子节点，递归调用</span><br><span class="line">   - hasPathSum(11, 13) || hasPathSum(null, 13)</span><br><span class="line"></span><br><span class="line">3. hasPathSum(11, 13)</span><br><span class="line">   - 不是叶子节点，递归调用</span><br><span class="line">   - hasPathSum(7, 6) || hasPathSum(2, 11)</span><br><span class="line"></span><br><span class="line">4. hasPathSum(7, 6)</span><br><span class="line">   - 是叶子节点，但 7 ≠ 6，返回 false</span><br><span class="line"></span><br><span class="line">5. hasPathSum(2, 11)</span><br><span class="line">   - 是叶子节点，但 2 ≠ 11，返回 false</span><br><span class="line"></span><br><span class="line">6. hasPathSum(null, 13) 返回 false</span><br><span class="line"></span><br><span class="line">7. 继续搜索右子树...</span><br><span class="line"></span><br><span class="line">最终在路径 5→4→11→2 找到和为 22 的路径。</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-n">时间复杂度：$O(n)$</h3>
<p>其中 $n$ 是二叉树中的节点数。在最坏情况下，我们需要访问树中的每个节点一次来寻找满足条件的路径。</p>
<h3 id="空间复杂度：-O-h">空间复杂度：$O(h)$</h3>
<p>其中 $h$ 是树的高度。空间复杂度主要来自递归调用栈的深度：</p>
<ul>
<li>最好情况（平衡树）：$O(\log n)$</li>
<li>最坏情况（退化为链表）：$O(n)$</li>
</ul>
<h2 id="相关变题与扩展">相关变题与扩展</h2>
<ol>
<li><strong>路径总和 II（LeetCode 113）</strong>：返回所有满足条件的路径</li>
<li><strong>路径总和 III（LeetCode 437）</strong>：路径不必从根节点开始或在叶子节点结束</li>
<li><strong>二叉树的最大路径和（LeetCode 124）</strong>：寻找任意路径的最大和</li>
</ol>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>递归思维</strong>：将复杂问题分解为相同结构的子问题</li>
<li><strong>状态传递</strong>：通过参数传递当前状态（剩余目标和）</li>
<li><strong>边界条件</strong>：正确处理空节点和叶子节点的情况</li>
<li><strong>逻辑操作</strong>：合理使用逻辑或操作符进行结果合并</li>
</ol>
<p>这道题是二叉树递归问题的经典代表，掌握了这种思路后，可以轻松解决很多类似的树形结构问题。重点是理解递归的本质：<strong>将大问题分解为结构相同的小问题，通过解决小问题来解决大问题</strong>。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 117 - 填充每个节点的下一个右侧节点指针 II（Populating Next Right Pointers in Each Node II）</title>
    <url>/2025/06/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-ii/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个二叉树，填充它的每个 <code>next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 <code>next</code> 指针都被设置为 <code>NULL</code>。</p>
<p><strong>注意：</strong> 这道题与第 116 题的区别在于，这里的二叉树不一定是完美二叉树。</p>
<h3 id="示例">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line"></span><br><span class="line">     1 → NULL</span><br><span class="line">   /  \</span><br><span class="line">  2 → 3 → NULL</span><br><span class="line"> / \    \</span><br><span class="line">4→ 5 → 7 → NULL</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-ii/1749962458461.png" alt="1749962458461"></p>
<p><strong>约束条件：</strong></p>
<ul>
<li>树中节点的数量在 <code>[0, 6000]</code> 范围内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心是要为每一层的节点建立从左到右的连接关系。我们需要处理的是一个<strong>非完美二叉树</strong>，这意味着每层的节点数可能不同，某些节点可能没有左子树或右子树。</p>
<p><strong>关键洞察：</strong> 我们需要按层处理节点，将同一层的节点从左到右连接起来。</p>
<p>让我详细介绍三种不同的解法：</p>
<h2 id="解法一：哈希表-深度优先搜索（DFS）">解法一：哈希表 + 深度优先搜索（DFS）</h2>
<h3 id="核心思想">核心思想</h3>
<p>使用哈希表记录每一层最右侧的节点，通过 DFS 遍历时，如果当前层已经有节点了，就将该节点的 <code>next</code> 指针指向当前节点，然后更新当前层的最右侧节点。</p>
<h3 id="实现细节">实现细节</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Left *Node</span><br><span class="line">    Right *Node</span><br><span class="line">    Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span></span> *Node &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表记录每一层的最右侧节点</span></span><br><span class="line">    levelMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 深度优先搜索遍历</span></span><br><span class="line">    dfs(root, <span class="number">0</span>, levelMap)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *Node, level <span class="type">int</span>, levelMap <span class="keyword">map</span>[<span class="type">int</span>]*Node)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前层已经有节点了，将前一个节点的 next 指向当前节点</span></span><br><span class="line">    <span class="keyword">if</span> prevNode, exists := levelMap[level]; exists &#123;</span><br><span class="line">        prevNode.Next = node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前层的最右侧节点</span></span><br><span class="line">    levelMap[level] = node</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先遍历左子树，再遍历右子树（保证从左到右的顺序）</span></span><br><span class="line">    dfs(node.Left, level+<span class="number">1</span>, levelMap)</span><br><span class="line">    dfs(node.Right, level+<span class="number">1</span>, levelMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析">执行过程分析</h3>
<p>以示例树为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   /  \</span><br><span class="line">  2    3</span><br><span class="line"> / \    \</span><br><span class="line">4   5    7</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Level 0</strong>: 处理节点 1，<code>levelMap[0] = 1</code></li>
<li><strong>Level 1</strong>: 处理节点 2，<code>levelMap[1] = 2</code>；处理节点 3，<code>2.next = 3</code>，<code>levelMap[1] = 3</code></li>
<li><strong>Level 2</strong>: 处理节点 4，<code>levelMap[2] = 4</code>；处理节点 5，<code>4.next = 5</code>，<code>levelMap[2] = 5</code>；处理节点 7，<code>5.next = 7</code>，<code>levelMap[2] = 7</code></li>
</ol>
<h2 id="解法二：广度优先搜索（BFS）-层序遍历">解法二：广度优先搜索（BFS）+ 层序遍历</h2>
<h3 id="核心思想-2">核心思想</h3>
<p>使用队列进行层序遍历，逐层处理节点。对于每一层，我们知道该层的节点数量，可以将同一层的节点依次连接起来。</p>
<h3 id="实现细节-2">实现细节</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectBFS</span><span class="params">(root *Node)</span></span> *Node &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用队列进行层序遍历</span></span><br><span class="line">    queue := []*Node&#123;root&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue) <span class="comment">// 当前层的节点数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:] <span class="comment">// 出队</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果不是当前层的最后一个节点，连接到下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; size<span class="number">-1</span> &#123;</span><br><span class="line">                node.Next = queue[<span class="number">0</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将子节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析-2">执行过程分析</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始: queue = [1]</span><br><span class="line"></span><br><span class="line">第一轮 (Level 0):</span><br><span class="line">- size = 1</span><br><span class="line">- 处理节点 1，queue = [2, 3]</span><br><span class="line"></span><br><span class="line">第二轮 (Level 1):</span><br><span class="line">- size = 2</span><br><span class="line">- 处理节点 2，2.next = 3，queue = [3, 4, 5]</span><br><span class="line">- 处理节点 3，queue = [4, 5, 7]</span><br><span class="line"></span><br><span class="line">第三轮 (Level 2):</span><br><span class="line">- size = 3</span><br><span class="line">- 处理节点 4，4.next = 5，queue = [5, 7]</span><br><span class="line">- 处理节点 5，5.next = 7，queue = [7]</span><br><span class="line">- 处理节点 7，queue = []</span><br></pre></td></tr></table></figure>
<h2 id="解法三：O-1-空间复杂度优化">解法三：O(1) 空间复杂度优化</h2>
<h3 id="核心思想-3">核心思想</h3>
<p>利用已经建立的 <code>next</code> 指针来遍历下一层，不使用额外的数据结构。我们维护两个指针：</p>
<ul>
<li><code>levelStart</code>: 当前层的起始节点</li>
<li><code>prev</code>: 下一层的前一个节点</li>
</ul>
<h3 id="实现细节-3">实现细节</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectOptimized</span><span class="params">(root *Node)</span></span> *Node &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// levelStart 指向当前层的起始节点</span></span><br><span class="line">    levelStart := root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> levelStart != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> prev *Node     <span class="comment">// 下一层的前一个节点</span></span><br><span class="line">        <span class="keyword">var</span> nextStart *Node <span class="comment">// 下一层的起始节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> node := levelStart; node != <span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">            <span class="comment">// 处理左子节点</span></span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">                    prev.Next = node.Left</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextStart = node.Left <span class="comment">// 记录下一层的起始节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                prev = node.Left</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理右子节点</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> prev != <span class="literal">nil</span> &#123;</span><br><span class="line">                    prev.Next = node.Right</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nextStart = node.Right <span class="comment">// 记录下一层的起始节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                prev = node.Right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动到下一层</span></span><br><span class="line">        levelStart = nextStart</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>哈希表 DFS</th>
<th>队列 BFS</th>
<th>O(1) 空间优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单，易理解</td>
<td>层次清晰，符合直觉</td>
<td>空间效率最高</td>
</tr>
<tr>
<td>缺点</td>
<td>需要额外哈希表</td>
<td>需要队列存储</td>
<td>实现复杂，理解难度大</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>所有三种方法的时间复杂度都是 <strong>O(n)</strong>，其中 n 是树中节点的数量。我们需要访问每个节点恰好一次。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li><strong>哈希表 DFS</strong>: O(n)，最坏情况下哈希表需要存储所有层的信息</li>
<li><strong>队列 BFS</strong>: O(n)，最坏情况下队列需要存储最底层的所有节点</li>
<li><strong>O(1) 优化</strong>: O(1)，只使用常数额外空间</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>层序遍历的两种实现方式</strong>：队列 BFS 和利用已建立的 next 指针</li>
<li><strong>空间优化技巧</strong>：利用问题的特殊性质（next 指针）来避免使用额外数据结构</li>
<li><strong>DFS vs BFS</strong>：对于树的层次处理，BFS 通常更直观，但 DFS 配合哈希表也能解决</li>
<li><strong>常见陷阱</strong>：
<ul>
<li>忘记处理空节点的情况</li>
<li>在 O(1) 解法中，容易搞混当前层和下一层的指针关系</li>
<li>DFS 时要注意遍历顺序（先左后右）</li>
</ul>
</li>
</ol>
<p>这道题是一个很好的练习，展示了如何用不同的思路解决同一个问题，以及如何在保持正确性的前提下优化空间复杂度。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>Medium</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 69 - x 的平方根（Sqrt(x)）</title>
    <url>/2025/06/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个非负整数 x，计算并返回 x 的算术平方根。</p>
<p>由于返回类型是整数，结果只保留<strong>整数部分</strong>，小数部分将被<strong>舍去</strong>。</p>
<p><strong>注意</strong>：不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code>。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>$0 \leq x \leq 2^{31} - 1$</li>
</ul>
<h3 id="核心要求">核心要求</h3>
<ul>
<li>返回值必须是<strong>不超过真实平方根的最大整数</strong></li>
<li>不能使用内置的平方根函数</li>
<li>需要处理边界情况和整数溢出</li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>这道题目的核心是要找到<strong>不超过真实平方根的最大整数</strong>。我们可以把这个问题转化为：<strong>在 [0, x] 范围内，找到最大的整数 mid，使得 mid² ≤ x</strong>。</p>
<h3 id="核心洞察">核心洞察</h3>
<p><strong>关键洞察</strong>：这是一个典型的<strong>查找问题</strong>，而且搜索空间具有<strong>单调性</strong>：</p>
<ul>
<li>如果 mid² &gt; x，那么答案一定在 [0, mid-1] 范围内</li>
<li>如果 mid² ≤ x，那么 mid 可能是答案，但更大的答案可能在 [mid+1, x] 范围内</li>
</ul>
<p>这种单调性质使得我们可以使用<strong>二分查找</strong>来解决。</p>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li><strong>初始化搜索范围</strong>：left = 0, right = x</li>
<li><strong>二分查找过程</strong>：
<ul>
<li>计算中点：mid = (left + right) / 2</li>
<li>比较 mid² 与 x 的关系：
<ul>
<li>如果 mid² = x：找到精确平方根，直接返回 mid</li>
<li>如果 mid² &gt; x：答案在左半部分，right = mid - 1</li>
<li>如果 mid² &lt; x：答案可能是 mid 或在右半部分，left = mid + 1</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回结果</strong>：当 left &gt; right 时，返回 right</li>
</ol>
<h3 id="为什么返回-right？">为什么返回 right？</h3>
<p>当二分查找结束时，有 left &gt; right。此时：</p>
<ul>
<li>right 是<strong>最大的满足 mid² ≤ x 的整数</strong></li>
<li>left 是<strong>最小的满足 mid² &gt; x 的整数</strong></li>
</ul>
<p>由于我们要找的是不超过真实平方根的最大整数，所以应该返回 right。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="边界情况处理">边界情况处理</h3>
<ol>
<li><strong>x = 0</strong>：平方根为 0</li>
<li><strong>x = 1</strong>：平方根为 1</li>
<li><strong>大数情况</strong>：注意 mid * mid 可能会整数溢出</li>
</ol>
<h3 id="算法执行示例">算法执行示例</h3>
<p>以 x = 8 为例，展示算法执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始：left = 0, right = 8</span><br><span class="line"></span><br><span class="line">第一轮：mid = 4, 4² = 16 &gt; 8</span><br><span class="line">        → right = 3, left = 0</span><br><span class="line"></span><br><span class="line">第二轮：mid = 1, 1² = 1 &lt; 8  </span><br><span class="line">        → left = 2, right = 3</span><br><span class="line"></span><br><span class="line">第三轮：mid = 2, 2² = 4 &lt; 8</span><br><span class="line">        → left = 3, right = 3</span><br><span class="line"></span><br><span class="line">第四轮：mid = 3, 3² = 9 &gt; 8</span><br><span class="line">        → right = 2, left = 3</span><br><span class="line"></span><br><span class="line">结束：left &gt; right，返回 right = 2</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, x</span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid*mid == x &#123;</span><br><span class="line">            <span class="keyword">return</span> mid        <span class="comment">// 找到精确平方根</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid*mid &gt; x &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>   <span class="comment">// 答案在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>    <span class="comment">// 答案在右半部分或就是mid</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> right             <span class="comment">// 返回不超过平方根的最大整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码关键点">代码关键点</h3>
<ol>
<li><strong>搜索范围</strong>：[0, x] 包含了所有可能的答案</li>
<li><strong>中点计算</strong>：<code>mid = (left + right) / 2</code> 避免了溢出问题</li>
<li><strong>三分支判断</strong>：精确匹配、过大、过小三种情况</li>
<li><strong>返回策略</strong>：返回 right 确保得到正确的整数部分</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>$$T(n) = O(\log x)$$</p>
<p><strong>分析过程</strong>：</p>
<ul>
<li>每次迭代都将搜索范围缩小一半</li>
<li>搜索范围从 x 开始，每次除以 2</li>
<li>最多需要 $\log_2 x$ 次迭代</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<p>$$S(n) = O(1)$$</p>
<p>只使用了常数个额外变量（left, right, mid），空间使用不随输入规模增长。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>二分查找法</th>
<th>牛顿迭代法</th>
<th>暴力枚举</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(\log x)$</td>
<td>$O(\log x)$</td>
<td>$O(\sqrt{x})$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>实现难度</td>
<td>★★★☆☆</td>
<td>★★★★☆</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td>稳定性</td>
<td>很稳定</td>
<td>需要处理精度问题</td>
<td>很稳定</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
<td>★★☆☆☆</td>
</tr>
</tbody>
</table>
<h2 id="扩展思考">扩展思考</h2>
<h3 id="相关问题">相关问题</h3>
<ol>
<li><strong>LeetCode 367 - Valid Perfect Square</strong>：判断一个数是否为完全平方数</li>
<li><strong>LeetCode 50 - Pow(x, n)</strong>：快速幂算法</li>
<li><strong>二分查找的其他应用</strong>：在各种单调函数上的查找问题</li>
</ol>
<h3 id="优化思路">优化思路</h3>
<ol>
<li><strong>搜索范围优化</strong>：对于较大的 x，可以将右边界设为 min(x, 46340)，因为 46340² 接近 2³¹-1</li>
<li><strong>牛顿迭代法</strong>：使用 $x_{n+1} = \frac{1}{2}(x_n + \frac{a}{x_n})$ 可以更快收敛</li>
</ol>
<h2 id="关键收获">关键收获</h2>
<h3 id="算法思想">算法思想</h3>
<ol>
<li><strong>二分查找的本质</strong>：在单调区间内快速定位目标值</li>
<li><strong>问题转化</strong>：将开方问题转化为查找问题</li>
<li><strong>边界处理</strong>：理解为什么返回 right 而不是 left</li>
</ol>
<h3 id="实现技巧">实现技巧</h3>
<ol>
<li><strong>避免溢出</strong>：使用除法而不是乘法来比较大小</li>
<li><strong>循环不变量</strong>：维护 right 是满足条件的最大值</li>
<li><strong>边界情况</strong>：特别注意 x = 0 和 x = 1 的处理</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>返回值错误</strong>：容易混淆应该返回 left 还是 right</li>
<li><strong>整数溢出</strong>：mid * mid 可能超出 int 范围</li>
<li><strong>边界处理</strong>：忘记处理 x = 0 的特殊情况</li>
</ol>
<p>这道题是二分查找在数学问题中的经典应用，掌握了这个模板，就能解决一大类类似的查找问题。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分布式锁的实现原理与 Redlock 算法</title>
    <url>/2025/06/09/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>分布式锁是分布式环境下并发控制的一种机制，用于控制某个共享资源在同一时刻只能被一个应用所使用。Redis 作为共享存储系统，凭借其高性能的读写能力，成为实现分布式锁的热门选择。</p>
<p><img src="/2025/06/09/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/1749398255591.png" alt="分布式锁示意图"></p>
<h2 id="核心概念">核心概念</h2>
<h3 id="分布式锁的基本要求">分布式锁的基本要求</h3>
<p>分布式锁必须满足以下几个核心特性：</p>
<ol>
<li><strong>互斥性</strong>：在任意时刻，只有一个客户端能够获得锁</li>
<li><strong>无死锁</strong>：即使持有锁的客户端崩溃，锁也能够被释放</li>
<li><strong>容错性</strong>：只要大部分 Redis 节点正常运行，客户端就能够获取和释放锁</li>
</ol>
<h3 id="Redis-实现分布式锁的原理">Redis 实现分布式锁的原理</h3>
<p>Redis 本身可以被多个客户端共享访问，是理想的共享存储系统。Redis 的 SET 命令具有 NX 参数，可以实现&quot;key 不存在才插入&quot;的原子操作，这是实现分布式锁的基础。</p>
<h2 id="单节点-Redis-分布式锁实现">单节点 Redis 分布式锁实现</h2>
<h3 id="加锁机制">加锁机制</h3>
<p>基于单个 Redis 节点实现分布式锁需要满足三个关键条件：</p>
<ol>
<li><strong>原子性操作</strong>：加锁包括读取锁变量、检查锁变量值和设置锁变量值三个操作，必须以原子方式完成</li>
<li><strong>设置过期时间</strong>：避免客户端异常导致锁无法释放</li>
<li><strong>唯一标识</strong>：区分来自不同客户端的加锁操作，防止误释放</li>
</ol>
<h3 id="实现命令">实现命令</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>lock_key</code>：锁的键名</li>
<li><code>unique_value</code>：客户端生成的唯一标识，用于区分不同客户端</li>
<li><code>NX</code>：只在 lock_key 不存在时才设置</li>
<li><code>PX 10000</code>：设置过期时间为 10 秒</li>
</ul>
<h3 id="解锁机制">解锁机制</h3>
<p>解锁过程需要确保操作的客户端就是加锁的客户端，使用 Lua 脚本保证原子性：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 解锁 Lua 脚本</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个脚本先比较锁的 unique_value 是否匹配，匹配时才删除锁，避免误释放。</p>
<h2 id="单节点方案的优缺点分析">单节点方案的优缺点分析</h2>
<h3 id="优点">优点</h3>
<ol>
<li><strong>高性能</strong>：Redis 的高性能读写是选择它实现分布式锁的核心原因</li>
<li><strong>实现简便</strong>：Redis 提供的 SET NX 命令使得实现分布式锁非常方便</li>
<li><strong>避免单点故障</strong>：通过集群部署自然避免了单点故障</li>
</ol>
<h3 id="缺点">缺点</h3>
<h4 id="1-超时时间设置难题">1. 超时时间设置难题</h4>
<p>超时时间的设置是一个棘手问题：</p>
<ul>
<li><strong>设置过长</strong>：影响系统性能</li>
<li><strong>设置过短</strong>：可能无法保护共享资源</li>
</ul>
<p><strong>问题场景</strong>：线程 A 获取锁后，由于业务代码执行时间较长，锁超时自动失效，但 A 线程尚未执行完成，此时线程 B 可能意外获得锁，导致两个线程同时操作共享资源。</p>
<p><strong>解决方案 - 锁续约机制</strong>：</p>
<ol>
<li>设置初始超时时间</li>
<li>启动守护线程监控锁状态</li>
<li>在锁即将失效时自动续期</li>
<li>主线程执行完成后销毁续约锁</li>
</ol>
<p>虽然这种方式能解决问题，但实现复杂度较高。</p>
<h4 id="2-主从复制的异步问题">2. 主从复制的异步问题</h4>
<p>Redis 主从复制采用异步方式，可能导致分布式锁不可靠：</p>
<p>如果在 Redis 主节点获取锁后，还未同步到从节点时主节点宕机，新的主节点上没有锁数据，其他应用仍可获取锁，破坏了锁的互斥性。</p>
<h2 id="Redlock-算法-集群环境的解决方案">Redlock 算法 - 集群环境的解决方案</h2>
<h3 id="算法原理">算法原理</h3>
<p>Redis 官方为解决集群环境下分布式锁的可靠性问题，设计了 Redlock（红锁）算法。该算法基于多个独立的 Redis 节点，即使部分节点故障，锁变量仍然存在，客户端可以继续进行锁操作。</p>
<p><strong>核心思路</strong>：客户端与多个独立的 Redis 节点依次请求加锁，如果能够与半数以上的节点成功完成加锁操作，则认为加锁成功。</p>
<h3 id="Redlock-加锁流程">Redlock 加锁流程</h3>
<h4 id="第一步：获取当前时间">第一步：获取当前时间</h4>
<p>客户端记录当前时间戳，用于后续计算总耗时。</p>
<h4 id="第二步：依次向所有节点加锁">第二步：依次向所有节点加锁</h4>
<ul>
<li>使用相同的 SET 命令（带 NX、EX/PX 选项和唯一标识）</li>
<li>对每个节点的加锁操作设置超时时间（注意：这是对加锁操作的超时，不是对锁本身的超时）</li>
<li>如果某个节点故障，不影响 Redlock 算法继续运行</li>
</ul>
<h4 id="第三步：计算加锁总耗时">第三步：计算加锁总耗时</h4>
<p>客户端完成所有节点的加锁操作后，计算整个过程的总耗时（t1）。</p>
<h3 id="加锁成功条件">加锁成功条件</h3>
<p>加锁成功需要<strong>同时</strong>满足两个条件：</p>
<ol>
<li><strong>节点数量条件</strong>：客户端从超过半数（≥ N/2+1）的 Redis 节点成功获取到锁</li>
<li><strong>时间条件</strong>：客户端获取锁的总耗时（t1）没有超过锁的有效时间</li>
</ol>
<h3 id="锁的有效时间重新计算">锁的有效时间重新计算</h3>
<p>加锁成功后，需要重新计算锁的实际有效时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际有效时间 = 锁的最初有效时间 - 客户端获取锁的总耗时（t1）</span><br></pre></td></tr></table></figure>
<h3 id="解锁流程">解锁流程</h3>
<p>无论加锁成功还是失败，客户端都应向所有 Redis 节点发起释放锁的操作，使用与单节点相同的 Lua 脚本。</p>
<h2 id="最佳实践">最佳实践</h2>
<ol>
<li><strong>合理设置超时时间</strong>：根据业务场景评估，避免过长或过短</li>
<li><strong>实现锁续约机制</strong>：对于执行时间不确定的业务</li>
<li><strong>选择合适的节点数量</strong>：Redlock 推荐奇数个节点，如 3、5、7 个</li>
<li><strong>监控锁的使用情况</strong>：及时发现锁竞争激烈的场景</li>
<li><strong>考虑使用专业的分布式锁服务</strong>：如 Zookeeper、etcd 等</li>
</ol>
<h2 id="常见问题与解决方案">常见问题与解决方案</h2>
<h3 id="Q-如何处理网络分区？">Q: 如何处理网络分区？</h3>
<p>A: Redlock 算法通过要求半数以上节点同意来处理网络分区问题，但在严重的网络分区情况下，可能出现脑裂问题。</p>
<h3 id="Q-锁续约的最佳实践？">Q: 锁续约的最佳实践？</h3>
<p>A: 设置续约间隔为锁超时时间的 1/3，避免频繁续约影响性能。</p>
<h3 id="Q-如何选择-Redis-节点数量？">Q: 如何选择 Redis 节点数量？</h3>
<p>A: 推荐使用奇数个节点，3-5 个节点对大多数场景已足够，过多节点会影响性能。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://redis.io/docs/reference/patterns/distributed-locks/">Redis 官方文档 - 分布式锁</a></li>
<li><a href="https://redis.io/docs/reference/patterns/distributed-locks/#the-redlock-algorithm">Redlock 算法详解</a></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
        <tag>分布式锁</tag>
        <tag>Redlock</tag>
        <tag>SET命令</tag>
        <tag>Lua脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库和缓存如何保证一致性？</title>
    <url>/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h1>数据库和缓存如何保证一致性？</h1>
<h2 id="问题背景">问题背景</h2>
<p>当系统用户量不断增长时，数据库往往成为性能瓶颈。此时引入 Redis 作为缓存层是常见的优化方案。</p>
<p>通过缓存，在客户端请求数据时，如果能在缓存中命中数据，就直接返回缓存结果，无需查询数据库，从而减轻数据库压力，提高系统性能。</p>
<p>但是，引入缓存后，我们面临一个新的挑战：<strong>如何保证缓存和数据库之间的数据一致性？</strong></p>
<h2 id="更新策略对比分析">更新策略对比分析</h2>
<h3 id="方案一：先更新数据库，再更新缓存">方案一：先更新数据库，再更新缓存</h3>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398023212.png" alt="1749398023212"></p>
<h4 id="存在的问题">存在的问题</h4>
<p>在并发场景下，这种方案可能会导致数据不一致。</p>
<p><strong>问题场景：</strong><br>
假设「请求 A」和「请求 B」两个请求，同时更新「同一条」数据，可能出现这样的执行顺序：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398033375.png" alt="1749398033375"></p>
<ol>
<li>请求 A 先将数据库的数据更新为 1</li>
<li>在 A 更新缓存前，请求 B 将数据库的数据更新为 2</li>
<li>请求 B 将缓存更新为 2</li>
<li>请求 A 最后将缓存更新为 1</li>
</ol>
<p><strong>结果：</strong> 数据库中的数据是 2，而缓存中的数据却是 1，出现了数据不一致现象。</p>
<h3 id="方案二：先更新缓存，再更新数据库">方案二：先更新缓存，再更新数据库</h3>
<p>这种方案同样存在并发问题。</p>
<p><strong>问题场景：</strong></p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398042881.png" alt="1749398042881"></p>
<ol>
<li>请求 A 先将缓存的数据更新为 1</li>
<li>在 A 更新数据库前，请求 B 将缓存的数据更新为 2</li>
<li>请求 B 将数据库更新为 2</li>
<li>请求 A 最后将数据库的数据更新为 1</li>
</ol>
<p><strong>结果：</strong> 数据库中的数据是 1，而缓存中的数据却是 2，同样出现了数据不一致现象。</p>
<h4 id="结论">结论</h4>
<p>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据时，可能会出现缓存和数据库中的数据不一致的现象。</p>
<h2 id="Cache-Aside-旁路缓存策略">Cache Aside 旁路缓存策略</h2>
<p>既然更新缓存的方案存在并发问题，我们可以考虑另一种策略：<strong>在更新数据时，不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。</strong></p>
<p>这个策略叫做 <strong>Cache Aside 策略</strong>，也称为旁路缓存策略。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398054481.png" alt="1749398054481"></p>
<h3 id="策略详解">策略详解</h3>
<p>Cache Aside 策略分为「读策略」和「写策略」：</p>
<h4 id="写策略步骤">写策略步骤</h4>
<ol>
<li>更新数据库中的数据</li>
<li>删除缓存中的数据</li>
</ol>
<h4 id="读策略步骤">读策略步骤</h4>
<ol>
<li>如果读取的数据命中了缓存，则直接返回数据</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户</li>
</ol>
<h3 id="写策略的执行顺序分析">写策略的执行顺序分析</h3>
<p>在「写策略」中，我们需要选择执行顺序：</p>
<ul>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ul>
<h4 id="方案一：先删除缓存，再更新数据库">方案一：先删除缓存，再更新数据库</h4>
<p><strong>问题场景：</strong><br>
假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398064441.png" alt="1749398064441"></p>
<ol>
<li>请求 A 删除缓存中的内容</li>
<li>请求 B 读取该用户年龄，缓存未命中，从数据库读取到年龄为 20</li>
<li>请求 B 将年龄 20 写入缓存</li>
<li>请求 A 将数据库中的年龄更新为 21</li>
</ol>
<p><strong>结果：</strong> 缓存中是 20（旧值），数据库中是 21（新值），数据不一致。</p>
<h4 id="方案二：先更新数据库，再删除缓存">方案二：先更新数据库，再删除缓存</h4>
<p><strong>问题场景：</strong><br>
假如某个用户数据在缓存中不存在：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398072984.png" alt="1749398072984"></p>
<ol>
<li>请求 A 从数据库中查询到年龄为 20</li>
<li>请求 B 更新数据库中的年龄为 21，并删除缓存</li>
<li>请求 A 将从数据库中读到的年龄 20 写入缓存</li>
</ol>
<p><strong>结果：</strong> 缓存中是 20（旧值），数据库中是 21（新值），数据不一致。</p>
<h4 id="推荐方案">推荐方案</h4>
<p>虽然从理论上分析，「先更新数据库，再删除缓存」也会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p>
<p><strong>原因：</strong></p>
<ul>
<li>缓存的写入通常要远远快于数据库的写入</li>
<li>在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况</li>
<li>一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据</li>
</ul>
<p>因此，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p>
<h3 id="进一步的保障措施">进一步的保障措施</h3>
<p>为了确保万无一失，还可以：</p>
<ol>
<li><strong>给缓存数据加上过期时间</strong>：即使在这期间存在缓存数据不一致，有过期时间来兜底，也能达到最终一致</li>
<li><strong>处理删除缓存失败的情况</strong>：当删除缓存（第二个操作）失败时，需要有重试机制</li>
</ol>
<h2 id="删除缓存失败的解决方案">删除缓存失败的解决方案</h2>
<p>在实际应用中，可能出现这样的问题：明明更新了数据，但是数据要过一段时间才生效。</p>
<p>经过排查发现，问题的原因是：<strong>在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值</strong>。</p>
<h3 id="问题示例">问题示例</h3>
<p>应用要把数据 X 的值从 1 更新为 2：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398096637.png" alt="1749398096637"></p>
<ol>
<li>成功更新了数据库（X = 2）</li>
<li>在 Redis 缓存中删除 X 的缓存操作失败</li>
<li>数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1</li>
</ol>
<p>后续访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有被删除，所以会缓存命中，但是读到的却是旧值 1。</p>
<h3 id="解决方案">解决方案</h3>
<p>针对删除缓存失败的问题，有两种有效的解决方案：</p>
<h4 id="方案一：消息队列重试机制">方案一：消息队列重试机制</h4>
<p>我们可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398106503.png" alt="1749398106503"></p>
<p><strong>工作流程：</strong></p>
<ol>
<li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存（重试机制）</li>
<li>如果重试超过一定次数还是没有成功，需要向业务层发送报错信息</li>
<li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作</li>
</ol>
<h4 id="方案二：订阅-MySQL-binlog">方案二：订阅 MySQL binlog</h4>
<p>「<strong>先更新数据库，再删缓存</strong>」策略的第一步是更新数据库，更新数据库成功就会产生一条变更日志，记录在 binlog 里。</p>
<p>我们可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除。阿里巴巴开源的 <strong>Canal 中间件</strong>就是基于这个实现的。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7/1749398115662.png" alt="1749398115662"></p>
<p><strong>Canal 工作原理：</strong></p>
<ol>
<li>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点</li>
<li>向 MySQL 主节点发送 dump 请求</li>
<li>MySQL 收到请求后，开始推送 Binlog 给 Canal</li>
<li>Canal 解析 Binlog 字节流，转换为便于读取的结构化数据</li>
<li>供下游程序订阅使用，执行缓存删除操作</li>
</ol>
<p>所以，<strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</strong></p>
<h2 id="其他策略补充">其他策略补充</h2>
<h3 id="延迟双删策略">延迟双删策略</h3>
<p>针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「<strong>延迟双删</strong>」。</p>
<p><strong>实现伪代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br><span class="line"><span class="comment">// 更新数据库</span></span><br><span class="line">db.update(X)</span><br><span class="line"><span class="comment">// 睡眠</span></span><br><span class="line">Thread.sleep(N)</span><br><span class="line"><span class="comment">// 再删除缓存</span></span><br><span class="line">redis.delKey(X)</span><br></pre></td></tr></table></figure>
<p><strong>工作原理：</strong><br>
加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。</p>
<p><strong>局限性：</strong></p>
<ul>
<li>睡眠时间需要大于请求 B「从数据库读取数据 + 写入缓存」的时间</li>
<li>具体睡眠多久其实是个<strong>玄学</strong>，很难评估出来</li>
<li>这个方案也只是<strong>尽可能</strong>保证一致性，极端情况下依然可能出现缓存不一致</li>
</ul>
<h3 id="更新缓存策略的优化">更新缓存策略的优化</h3>
<p>如果业务对缓存命中率有很高的要求，可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。</p>
<p><strong>并发问题的解决方案：</strong></p>
<ol>
<li><strong>分布式锁</strong>：在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存（会对写入性能产生影响）</li>
<li><strong>较短的过期时间</strong>：在更新完缓存时，给缓存加上较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期</li>
</ol>
<h2 id="总结">总结</h2>
<h3 id="核心要点">核心要点</h3>
<ol>
<li>
<p><strong>并发问题是关键</strong>：无论选择什么策略，并发更新都是导致数据不一致的根本原因</p>
</li>
<li>
<p><strong>推荐方案</strong>：「先更新数据库，再删除缓存」+ Cache Aside 策略</p>
<ul>
<li>理论上可能存在问题，但实际发生概率很低</li>
<li>缓存写入速度远快于数据库写入</li>
</ul>
</li>
<li>
<p><strong>必要的保障措施</strong>：</p>
<ul>
<li>给缓存设置过期时间作为兜底</li>
<li>处理删除缓存失败的情况</li>
</ul>
</li>
<li>
<p><strong>删除缓存失败的解决方案</strong>：</p>
<ul>
<li>消息队列重试机制</li>
<li>订阅 MySQL binlog</li>
<li>两种方案都采用异步操作缓存</li>
</ul>
</li>
</ol>
<h3 id="方案对比">方案对比</h3>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>先更新数据库，再删除缓存</td>
<td>实际不一致概率低，简单易实现</td>
<td>理论上存在不一致可能</td>
<td>推荐使用</td>
</tr>
<tr>
<td>先删除缓存，再更新数据库</td>
<td>逻辑简单</td>
<td>并发时容易出现不一致</td>
<td>不推荐</td>
</tr>
<tr>
<td>更新数据库 + 更新缓存</td>
<td>缓存命中率高</td>
<td>并发问题明显，需要额外措施</td>
<td>对缓存命中率要求极高的场景</td>
</tr>
<tr>
<td>延迟双删</td>
<td>一定程度解决并发问题</td>
<td>睡眠时间难以确定，仍有风险</td>
<td>特殊场景下的补充方案</td>
</tr>
</tbody>
</table>
<p>通过「消息队列来重试缓存的删除」或「订阅 MySQL binlog 再操作缓存」的方案，可以有效解决缓存删除失败的问题，确保数据库和缓存的一致性。这些方案的共同特点是采用异步操作缓存，提高了系统的可靠性和数据一致性保障。</p>
<h2 id="面试要点">面试要点</h2>
<ol>
<li><strong>能够分析各种方案的并发问题</strong>：清楚地解释为什么会出现数据不一致</li>
<li><strong>推荐 Cache Aside 策略</strong>：「先更新数据库，再删除缓存」</li>
<li><strong>了解实际应用中的保障措施</strong>：过期时间、消息队列重试、binlog 订阅</li>
<li><strong>理解延迟双删的局限性</strong>：不作为主要方案推荐</li>
</ol>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>REDIS</tag>
        <tag>缓存</tag>
        <tag>数据一致性</tag>
        <tag>Cache Aside</tag>
        <tag>Binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 缓存雪崩、穿透、击穿问题详解与解决方案</title>
    <url>/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<h1>Redis 缓存雪崩、穿透、击穿问题详解与解决方案</h1>
<h2 id="概述">概述</h2>
<p>在现代高并发系统中，Redis 作为缓存层极大地提升了系统性能。然而，缓存的引入也带来了新的挑战。本文将深入探讨缓存系统中的三个经典问题：<strong>缓存雪崩</strong>、<strong>缓存穿透</strong>、<strong>缓存击穿</strong>，分析它们的产生原因、造成的影响，以及相应的解决方案。</p>
<p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p>
<p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就崩溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p>
<p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390469334.png" alt="缓存架构图"></p>
<p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong>。</p>
<p>这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390496458.png" alt="三大缓存问题概览"></p>
<hr>
<h2 id="缓存雪崩（Cache-Avalanche）">缓存雪崩（Cache Avalanche）</h2>
<h3 id="问题定义">问题定义</h3>
<p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390508024.png" alt="正常缓存机制"></p>
<p>当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390520684.png" alt="缓存雪崩示意图"></p>
<h3 id="产生原因">产生原因</h3>
<p>缓存雪崩的发生主要有两个原因：</p>
<ol>
<li><strong>大量数据同时过期</strong></li>
<li><strong>Redis 故障宕机</strong></li>
</ol>
<p>不同的诱因，应对的策略也会不同。</p>
<h3 id="解决方案">解决方案</h3>
<h4 id="针对大量数据同时过期的解决方案">针对大量数据同时过期的解决方案</h4>
<p><strong>1. 均匀设置过期时间</strong></p>
<p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p>
<p><strong>2. 互斥锁机制</strong></p>
<p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
<p><strong>重要提醒</strong>：实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p>
<p><strong>3. 双 key 策略</strong></p>
<p>我们对缓存数据可以使用两个 key，一个是<strong>主 key，会设置过期时间</strong>，一个是<strong>备 key，不会设置过期</strong>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p>
<p>当业务线程访问不到「主 key」的缓存数据时，就直接返回「备 key」的缓存数据，然后在更新缓存的时候，<strong>同时更新「主 key」和「备 key」的数据。</strong></p>
<p><strong>优势</strong>：当主 key 过期了，有大量请求获取缓存数据的时候，直接返回备 key 的数据，这样可以快速响应请求。而不用因为 key 失效而导致大量请求被锁阻塞住（采用了互斥锁，仅一个请求来构建缓存），后续再通知后台线程，重新构建主 key 的数据。</p>
<p><strong>4. 后台更新缓存</strong></p>
<p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存&quot;永久有效&quot;，并将更新缓存的工作交由后台线程定时更新</strong>。</p>
<p><strong>注意事项</strong>：缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被&quot;淘汰&quot;</strong>，而在缓存被&quot;淘汰&quot;到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p>
<p><strong>解决数据被淘汰的两种方式：</strong></p>
<p><strong>方式一：频繁检测</strong><br>
后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p>
<p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p>
<p><strong>方式二：消息队列通知</strong><br>
在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p>
<p><strong>缓存预热</strong>：在业务刚上线的时候，我们最好提前把数据缓存起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p>
<h4 id="针对-Redis-故障宕机的解决方案">针对 Redis 故障宕机的解决方案</h4>
<p><strong>1. 服务熔断或请求限流机制</strong></p>
<p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p>
<p>服务熔断机制是保护数据库的正常运行，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p>
<p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
<p><strong>2. 构建 Redis 缓存高可靠集群</strong></p>
<p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p>
<p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p>
<hr>
<h2 id="缓存击穿（Cache-Breakdown）">缓存击穿（Cache Breakdown）</h2>
<h3 id="问题定义-2">问题定义</h3>
<p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频繁访问的数据被称为热点数据。</p>
<p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390552778.png" alt="缓存击穿示意图"></p>
<h3 id="与缓存雪崩的关系">与缓存雪崩的关系</h3>
<p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p>
<h3 id="解决方案-2">解决方案</h3>
<p>应对缓存击穿可以采取前面说到两种方案：</p>
<ol>
<li>
<p><strong>互斥锁方案</strong>：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
</li>
<li>
<p><strong>热点数据永不过期策略</strong>：不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间。</p>
</li>
</ol>
<hr>
<h2 id="缓存穿透（Cache-Penetration）">缓存穿透（Cache Penetration）</h2>
<h3 id="问题定义-3">问题定义</h3>
<p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p>
<p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390566052.png" alt="缓存穿透示意图"></p>
<h3 id="产生原因-2">产生原因</h3>
<p>缓存穿透的发生一般有这两种情况：</p>
<ol>
<li><strong>业务误操作</strong>：缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据</li>
<li><strong>黑客恶意攻击</strong>：故意大量访问某些读取不存在数据的业务</li>
</ol>
<h3 id="解决方案-3">解决方案</h3>
<p>应对缓存穿透的方案，常见的方案有三种：</p>
<p><strong>1. 非法请求的限制</strong></p>
<p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断出请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p>
<p><strong>2. 缓存空值或者默认值</strong></p>
<p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p>
<p><strong>3. 使用布隆过滤器快速判断数据是否存在</strong></p>
<p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p>
<p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p>
<h3 id="布隆过滤器工作原理">布隆过滤器工作原理</h3>
<p>布隆过滤器由「初始值都为 0 的位图数组」和「N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p>
<h4 id="布隆过滤器标记过程">布隆过滤器标记过程</h4>
<p>布隆过滤器会通过 3 个操作完成标记：</p>
<ol>
<li><strong>第一步</strong>：使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值</li>
<li><strong>第二步</strong>：将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置</li>
<li><strong>第三步</strong>：将每个哈希值在位图数组的对应位置的值设置为 1</li>
</ol>
<h4 id="布隆过滤器示例">布隆过滤器示例</h4>
<p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390582756.png" alt="布隆过滤器示例"></p>
<p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p>
<h4 id="布隆过滤器的特点">布隆过滤器的特点</h4>
<p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p>
<p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p>
<hr>
<h2 id="总结">总结</h2>
<p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p>
<p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p>
<p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p>
<p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9or%E7%A9%BF%E9%80%8For%E5%87%BB%E7%A9%BF/1749390596934.png" alt="三大缓存问题对比表"></p>
<h2 id="面试要点">面试要点</h2>
<p>在技术面试中，这三个缓存问题经常被提及，掌握以下要点：</p>
<ol>
<li><strong>能准确区分三者的区别</strong>：雪崩（大量key过期或Redis宕机）、击穿（热点key过期）、穿透（数据不存在）</li>
<li><strong>熟悉各种解决方案的适用场景</strong>：互斥锁适合击穿，布隆过滤器适合穿透，集群+限流适合雪崩</li>
<li><strong>了解每种方案的优缺点</strong>：如互斥锁可能导致阻塞，布隆过滤器存在误判等</li>
<li><strong>能结合实际业务场景分析</strong>：比如秒杀场景的热点数据、爬虫攻击的不存在数据等</li>
</ol>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
        <tag>缓存</tag>
        <tag>缓存雪崩</tag>
        <tag>缓存穿透</tag>
        <tag>缓存击穿</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Cluster 集群详解：架构原理、哈希槽与故障转移</title>
    <url>/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1>Redis Cluster 集群详解：架构原理、哈希槽与故障转移</h1>
<p>当面试官问：&quot;Redis的cluster集群原理，客户端是怎样知道该访问哪个分片的？&quot;时，你是否能够完整回答？本文将从多个维度深入解析Redis Cluster集群的核心机制。</p>
<h2 id="概述">概述</h2>
<p>Redis Cluster是Redis 3.0版本开始官方提供的一种分布式解决方案，它实现了数据的自动分片、故障转移和线性扩容能力。相比主从和哨兵模式，Cluster解决了单机内存限制和在线扩容的问题。</p>
<h2 id="为什么需要Redis-Cluster？">为什么需要Redis Cluster？</h2>
<h3 id="哨兵模式的局限性">哨兵模式的局限性</h3>
<p>哨兵模式虽然实现了读写分离和自动故障切换，但存在以下问题：</p>
<ol>
<li><strong>数据冗余</strong>：每个节点存储相同数据，浪费内存资源</li>
<li><strong>扩容困难</strong>：无法在线扩容，扩容需要停机操作</li>
<li><strong>性能瓶颈</strong>：单机内存限制，无法处理超大数据集</li>
</ol>
<h3 id="Cluster模式的优势">Cluster模式的优势</h3>
<p>Redis Cluster通过数据分片技术，将数据分散存储到多个节点：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749383883337.png" alt="1749383883337"></p>
<p><strong>对比优势：</strong></p>
<ul>
<li><strong>数据分片</strong>：每个节点只存储部分数据，充分利用集群资源</li>
<li><strong>线性扩容</strong>：支持在线添加/删除节点，实现动态扩容</li>
<li><strong>高可用</strong>：内置故障检测和自动故障转移机制</li>
<li><strong>性能提升</strong>：分布式架构，突破单机性能限制</li>
</ul>
<h2 id="核心机制：哈希槽分片">核心机制：哈希槽分片</h2>
<h3 id="哈希槽原理">哈希槽原理</h3>
<p>Redis Cluster采用**哈希槽（Hash Slot）**机制实现数据分片：</p>
<ul>
<li><strong>槽位总数</strong>：16384个槽位（0-16383）</li>
<li><strong>分配算法</strong>：<code>slot = CRC16(key) % 16384</code></li>
<li><strong>槽位分配</strong>：每个主节点负责一部分槽位</li>
</ul>
<h3 id="槽位分配示例">槽位分配示例</h3>
<p>假设集群有3个主节点A、B、C：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">节点A：负责槽位 0-5460     （5461个槽位）</span><br><span class="line">节点B：负责槽位 5461-10922  （5462个槽位） </span><br><span class="line">节点C：负责槽位 10923-16383 （5461个槽位）</span><br></pre></td></tr></table></figure>
<h3 id="客户端路由流程">客户端路由流程</h3>
<ol>
<li><strong>计算槽位</strong>：客户端根据key计算对应槽位</li>
<li><strong>选择节点</strong>：根据槽位映射找到目标节点</li>
<li><strong>发送请求</strong>：直接向目标节点发送操作命令</li>
</ol>
<h2 id="重定向机制">重定向机制</h2>
<p>当客户端访问的数据不在当前节点时，Redis通过重定向机制处理：</p>
<h3 id="MOVED重定向">MOVED重定向</h3>
<p><strong>适用场景</strong>：正常情况下的槽位重定向</p>
<p><strong>处理流程</strong>：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749383898270.png" alt="1749383898270"></p>
<ol>
<li>客户端向节点A请求key1的数据</li>
<li>节点A发现key1不属于自己的槽位</li>
<li>返回MOVED错误，包含正确节点的地址</li>
<li>客户端更新槽位映射，直接访问正确节点</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; GET user:1001</span><br><span class="line">-MOVED 9189 192.168.1.102:6379</span><br></pre></td></tr></table></figure>
<h3 id="ASK重定向">ASK重定向</h3>
<p><strong>适用场景</strong>：集群扩容/缩容期间的数据迁移</p>
<p><strong>处理流程</strong>：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749383910842.png" alt="1749383910842"></p>
<ol>
<li>客户端访问源节点，数据可能已迁移</li>
<li>源节点返回ASK重定向到目标节点</li>
<li>客户端向目标节点发送ASKING命令</li>
<li>执行实际的数据操作</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; GET user:1001</span><br><span class="line">-ASK 9189 192.168.1.103:6379</span><br><span class="line">&gt; ASKING</span><br><span class="line">OK</span><br><span class="line">&gt; GET user:1001</span><br><span class="line">&quot;user_data&quot;</span><br></pre></td></tr></table></figure>
<h3 id="重定向对比">重定向对比</h3>
<table>
<thead>
<tr>
<th>重定向类型</th>
<th>触发条件</th>
<th>客户端行为</th>
<th>持续时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>MOVED</td>
<td>槽位固定分配不匹配</td>
<td>更新槽位映射表</td>
<td>永久有效</td>
</tr>
<tr>
<td>ASK</td>
<td>数据迁移过程中</td>
<td>临时重定向，不更新映射</td>
<td>迁移期间</td>
</tr>
</tbody>
</table>
<h2 id="Gossip通信协议">Gossip通信协议</h2>
<h3 id="协议概述">协议概述</h3>
<p>Redis Cluster使用<strong>Gossip协议</strong>实现节点间的信息同步，这是一种去中心化的通信机制。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749383923502.png" alt="1749383923502"></p>
<h3 id="消息类型">消息类型</h3>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>用途</th>
<th>发送时机</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PING</strong></td>
<td>心跳检测</td>
<td>每秒向随机节点发送</td>
</tr>
<tr>
<td><strong>PONG</strong></td>
<td>心跳响应</td>
<td>收到PING/MEET消息时回复</td>
</tr>
<tr>
<td><strong>MEET</strong></td>
<td>节点加入</td>
<td>新节点加入集群时</td>
</tr>
<tr>
<td><strong>FAIL</strong></td>
<td>故障广播</td>
<td>检测到节点故障时</td>
</tr>
</tbody>
</table>
<h3 id="通信机制">通信机制</h3>
<p><strong>集群总线</strong>：</p>
<ul>
<li>端口：服务端口 + 10000（如6379 → 16379）</li>
<li>协议：二进制协议，效率更高</li>
<li>频率：每秒随机选择节点进行通信</li>
</ul>
<p><strong>信息传播</strong>：</p>
<ul>
<li>每次PING消息携带发送者已知的节点信息</li>
<li>接收者更新本地的集群拓扑信息</li>
<li>通过多轮传播实现最终一致性</li>
</ul>
<h2 id="故障检测与转移">故障检测与转移</h2>
<h3 id="故障检测">故障检测</h3>
<h4 id="主观下线（PFAIL）">主观下线（PFAIL）</h4>
<p><strong>检测条件</strong>：</p>
<ul>
<li>某节点在<code>cluster-node-timeout</code>时间内无响应</li>
<li>单个节点的判断，可能存在误判</li>
</ul>
<p><strong>标记流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">节点A → PING → 节点B（无响应）</span><br><span class="line">节点A标记节点B为PFAIL状态</span><br></pre></td></tr></table></figure>
<h4 id="客观下线（FAIL）">客观下线（FAIL）</h4>
<p><strong>检测条件</strong>：</p>
<ul>
<li>超过半数主节点认为目标节点不可用</li>
<li>集群达成共识，确认节点故障</li>
</ul>
<p><strong>确认流程</strong>：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749383935543.png" alt="1749383935543"></p>
<ol>
<li>节点A将B标记为PFAIL</li>
<li>A通过Gossip将B的PFAIL状态传播</li>
<li>其他节点收到消息，如果也认为B故障，则投票</li>
<li>当故障投票数 &gt; 集群主节点数/2时，B被标记为FAIL</li>
</ol>
<h3 id="故障转移">故障转移</h3>
<p><strong>转移条件</strong>：</p>
<ul>
<li>主节点被标记为客观下线</li>
<li>该主节点至少有一个从节点可用</li>
</ul>
<p><strong>转移流程</strong>：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749384093494.png" alt="1749384093494"></p>
<ol>
<li><strong>资格检查</strong>：从节点检查自身是否具备替换主节点的条件</li>
<li><strong>准备选举</strong>：计算选举延迟时间，数据越新延迟越短</li>
<li><strong>发起选举</strong>：向所有主节点发送选举请求</li>
<li><strong>投票统计</strong>：收集足够选票（&gt;主节点数/2）后，提升为主节点</li>
<li><strong>更新配置</strong>：广播配置更新，完成故障转移</li>
</ol>
<h2 id="为什么哈希槽是16384？">为什么哈希槽是16384？</h2>
<p>这是一个经典的面试问题，作者的原始回答提到了几个关键因素：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749384103361.png" alt="1749384103361"></p>
<h3 id="内存优化考虑">内存优化考虑</h3>
<p><strong>槽位存储</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> slots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>];</span><br></pre></td></tr></table></figure>
<p><strong>空间对比</strong>：</p>
<ul>
<li>65536个槽位：65536 ÷ 8 ÷ 1024 = 8KB</li>
<li>16384个槽位：16384 ÷ 8 ÷ 1024 = 2KB</li>
<li><strong>节省空间</strong>：每个节点节省6KB，100个节点集群节省600KB</li>
</ul>
<h3 id="网络开销考虑">网络开销考虑</h3>
<p><strong>心跳包大小</strong>：</p>
<ul>
<li>Gossip协议需要在心跳包中携带槽位信息</li>
<li>16384个槽位使心跳包更小，网络开销更低</li>
<li>对于大规模集群，网络效率更重要</li>
</ul>
<h3 id="集群规模考虑">集群规模考虑</h3>
<p><strong>实际需求</strong>：</p>
<ul>
<li>Redis官方建议集群节点数不超过1000</li>
<li>16384个槽位对于1000个节点完全够用</li>
<li>每个节点平均16个槽位，分配粒度合理</li>
</ul>
<h3 id="位运算优化">位运算优化</h3>
<p><strong>计算优化</strong>：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/1749384123768.png" alt="1749384123768"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用位运算替代取模运算</span></span><br><span class="line">slot = crc16(key) &amp; <span class="number">0x3FFF</span>;  <span class="comment">// 等价于 % 16384</span></span><br></pre></td></tr></table></figure>
<p><strong>性能优势</strong>：</p>
<ul>
<li>位运算比取模运算效率更高</li>
<li>16384 = 2^14，可以使用位运算优化</li>
<li>0x3FFF = 16383，即 2^14 - 1</li>
</ul>
<h2 id="最佳实践">最佳实践</h2>
<h3 id="集群部署建议">集群部署建议</h3>
<ol>
<li>
<p><strong>节点配置</strong>：</p>
<ul>
<li>至少3个主节点（保证故障转移投票）</li>
<li>每个主节点配置1-2个从节点</li>
<li>建议奇数个主节点</li>
</ul>
</li>
<li>
<p><strong>硬件规划</strong>：</p>
<ul>
<li>主从节点部署在不同物理机</li>
<li>保证网络延迟低且稳定</li>
<li>合理配置内存和CPU资源</li>
</ul>
</li>
<li>
<p><strong>参数调优</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster-enabled yes                    # 启用集群模式</span><br><span class="line">cluster-node-timeout 15000           # 节点超时时间</span><br><span class="line">cluster-require-full-coverage no     # 允许部分槽位不可用时继续服务</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="客户端最佳实践">客户端最佳实践</h3>
<ol>
<li>
<p><strong>连接管理</strong>：</p>
<ul>
<li>使用支持集群的客户端库</li>
<li>维护完整的槽位映射表</li>
<li>实现智能重试机制</li>
</ul>
</li>
<li>
<p><strong>性能优化</strong>：</p>
<ul>
<li>批量操作使用pipeline</li>
<li>避免跨槽位的事务操作</li>
<li>合理设计key的分布</li>
</ul>
</li>
</ol>
<h2 id="常见问题与解决方案">常见问题与解决方案</h2>
<h3 id="Q1：如何避免数据倾斜？">Q1：如何避免数据倾斜？</h3>
<p><strong>问题</strong>：某些节点数据量远超其他节点</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>设计均匀分布的key</li>
<li>避免使用热点key</li>
<li>监控各节点的内存使用情况</li>
</ul>
<h3 id="Q2：集群扩容时数据如何迁移？">Q2：集群扩容时数据如何迁移？</h3>
<p><strong>迁移流程</strong>：</p>
<ol>
<li>添加新节点到集群</li>
<li>重新分配槽位给新节点</li>
<li>执行数据迁移操作</li>
<li>更新客户端槽位映射</li>
</ol>
<h3 id="Q3：如何处理网络分区？">Q3：如何处理网络分区？</h3>
<p><strong>防护机制</strong>：</p>
<ul>
<li>设置合理的<code>cluster-node-timeout</code></li>
<li>使用<code>cluster-require-full-coverage</code>控制服务可用性</li>
<li>部署时考虑网络拓扑，避免单点故障</li>
</ul>
<h2 id="总结">总结</h2>
<p>Redis Cluster通过哈希槽机制实现了数据的自动分片和负载均衡，通过Gossip协议保证了集群信息的一致性，通过完善的故障检测和转移机制确保了高可用性。理解这些核心机制，不仅能帮助你在面试中胸有成竹，更能在实际项目中合理设计和运维Redis集群。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://redis.io/topics/cluster-tutorial">Redis官方文档 - Redis Cluster</a></li>
<li><a href="https://redisbook.readthedocs.io/en/latest/feature/cluster.html">Redis设计与实现 - 集群</a></li>
<li><a href="https://github.com/redis/redis/blob/unstable/src/cluster.c">Redis源码解析 - Cluster实现</a></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
        <tag>故障转移</tag>
        <tag>集群</tag>
        <tag>分布式</tag>
        <tag>哈希槽</tag>
        <tag>Gossip协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 哨兵模式详解：故障转移的自动化解决方案</title>
    <url>/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[<h1>Redis 哨兵模式详解：故障转移的自动化解决方案</h1>
<blockquote>
<p>Redis 哨兵（Sentinel）是 Redis 高可用架构的核心组件，它通过监控、故障检测和自动故障转移，确保 Redis 主从架构的稳定性和可用性。</p>
</blockquote>
<h2 id="为什么需要哨兵机制？">为什么需要哨兵机制？</h2>
<p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383596204.png" alt="哨兵架构概览"></p>
<h3 id="传统主从架构的局限性">传统主从架构的局限性</h3>
<ul>
<li><strong>单点故障风险</strong>：主节点故障导致整个系统无法写入</li>
<li><strong>人工干预成本</strong>：需要手动选择新主节点并重新配置</li>
<li><strong>切换时间长</strong>：人工故障转移流程复杂且耗时</li>
<li><strong>客户端重连复杂</strong>：需要手动更新客户端配置</li>
</ul>
<p>这时如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。</p>
<p>Redis 在 2.8 版本以后提供的<strong>哨兵（Sentinel）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
<h2 id="哨兵机制的工作原理">哨兵机制的工作原理</h2>
<p>哨兵其实是一个运行在特殊模式下的 Redis 进程，所以它也是一个节点。从&quot;哨兵&quot;这个名字也可以看得出来，它相当于是&quot;观察者节点&quot;，观察的对象是主从节点。</p>
<p>当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些&quot;动作&quot;，来修复异常状态。</p>
<h3 id="哨兵的三大核心职责">哨兵的三大核心职责</h3>
<p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383613400.png" alt="哨兵职责图"></p>
<ol>
<li>
<p><strong>监控（Monitoring）</strong></p>
<ul>
<li>定期检查主从节点的健康状态</li>
<li>维护节点状态信息</li>
<li>检测网络连接质量</li>
</ul>
</li>
<li>
<p><strong>选主（Master Selection）</strong></p>
<ul>
<li>在主节点故障时选举新的主节点</li>
<li>执行故障转移操作</li>
<li>重新配置主从关系</li>
</ul>
</li>
<li>
<p><strong>通知（Notification）</strong></p>
<ul>
<li>向客户端通知主节点变更</li>
<li>更新从节点的复制目标</li>
<li>发布故障转移事件</li>
</ul>
</li>
</ol>
<h2 id="故障检测机制：如何判断主节点真的故障了？">故障检测机制：如何判断主节点真的故障了？</h2>
<h3 id="主观下线（Subjective-Down）">主观下线（Subjective Down）</h3>
<p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383622604.png" alt="故障检测流程"></p>
<p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p>
<h3 id="客观下线（Objective-Down）">客观下线（Objective Down）</h3>
<p><strong>为什么需要客观下线？</strong></p>
<p>之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p>
<p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>（<em>最少需要三台机器来部署哨兵集群</em>），<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</strong>。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p><strong>客观下线的判定流程：</strong></p>
<p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383632190.png" alt="客观下线投票"></p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 <strong>quorum</strong> 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p>
<blockquote>
<p><strong>配置示例</strong>：现在有 3 个哨兵，quorum 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为&quot;客观下线&quot;了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。</p>
</blockquote>
<p><strong>最佳实践</strong>：quorum 的值一般设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2。</p>
<h2 id="哨兵-Leader-选举机制">哨兵 Leader 选举机制</h2>
<h3 id="为什么需要-Leader-选举？">为什么需要 Leader 选举？</h3>
<p>前面说过，为了更加&quot;客观&quot;的判断主节点故障了，一般不会只由单个哨兵的检测结果来判断，而是多个哨兵一起判断，这样可以减少误判概率，所以<strong>哨兵是以哨兵集群的方式存在的</strong>。</p>
<p>问题来了，由哨兵集群中的哪个节点进行主从故障转移呢？</p>
<p>所以这时候，还需要在哨兵集群中选出一个 leader，让 leader 来执行主从切换。</p>
<h3 id="Leader-选举流程">Leader 选举流程</h3>
<p><strong>1. 候选者确定</strong><br>
哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。</p>
<p><strong>2. 投票过程</strong><br>
举个例子，假设有三个哨兵。当哨兵 B 先判断到主节点「主观下线后」，就会给其他实例发送 <code>is-master-down-by-addr</code> 命令。接着，其他哨兵会根据自己和主节点的网络连接情况，做出赞成投票或者拒绝投票的响应。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383645583.png" alt="Leader选举流程"></p>
<p>当哨兵 B 收到赞成票数达到哨兵配置文件中的 quorum 配置项设定的值后，就会将主节点标记为「客观下线」，此时的哨兵 B 就是一个 Leader 候选者。</p>
<p><strong>3. 选举条件</strong><br>
候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。</p>
<p>任何一个「候选者」要成为 Leader，必须满足两个条件：</p>
<ul>
<li><strong>第一</strong>：拿到半数以上的赞成票</li>
<li><strong>第二</strong>：拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值</li>
</ul>
<p><strong>4. 投票规则</strong></p>
<ul>
<li>每个哨兵只有一次投票机会</li>
<li>可以投给自己或投给别人</li>
<li>只有候选者才能把票投给自己</li>
<li>先到先得的投票原则</li>
</ul>
<h3 id="为什么哨兵节点至少要有-3-个？">为什么哨兵节点至少要有 3 个？</h3>
<p><strong>双节点的问题</strong>：<br>
如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票。</p>
<p>所以，如果哨兵集群中有个哨兵挂掉了，那么就只剩一个哨兵了，如果这个哨兵想要成为 Leader，这时票数就没办法达到 2 票，就无法成功成为 Leader，这时是无法进行主从节点切换的。</p>
<p><strong>三节点的优势</strong>：<br>
因此，通常我们至少会配置 3 个哨兵节点。这时，如果哨兵集群中有个哨兵挂掉了，那么还剩下两个哨兵，如果这个哨兵想要成为 Leader，这时还是有机会达到 2 票的，所以还是可以选举成功的，不会导致无法进行主从节点切换。</p>
<h3 id="实际场景分析">实际场景分析</h3>
<p><strong>案例分析</strong>：Redis 1 主 4 从，5 个哨兵，quorum 设置为 3，如果 2 个哨兵故障，当主节点宕机时，哨兵能否判断主节点&quot;客观下线&quot;？主从能否自动切换？</p>
<p><strong>分析结果</strong>：</p>
<ul>
<li>
<p><strong>哨兵集群可以判定主节点&quot;客观下线&quot;</strong>。哨兵集群还剩下 3 个哨兵，当一个哨兵判断主节点&quot;主观下线&quot;后，询问另外 2 个哨兵后，有可能能拿到 3 张赞同票，这时就达到了 quorum 的值，因此，哨兵集群可以判定主节点为&quot;客观下线&quot;。</p>
</li>
<li>
<p><strong>哨兵集群可以完成主从切换</strong>。当有个哨兵标记主节点为「客观下线」后，就会进行选举 Leader 的过程，因为此时哨兵集群还剩下 3 个哨兵，那么还是可以拿到半数以上（5/2+1=3）的票，而且也达到了 quorum 值，满足了选举 Leader 的两个条件，所以就能选举成功，因此哨兵集群可以完成主从切换。</p>
</li>
</ul>
<p><strong>最佳实践建议</strong>：</p>
<ul>
<li><strong>quorum 的值建议设置为哨兵个数的二分之一加 1</strong>，例如 3 个哨兵就设置 2，5 个哨兵设置为 3</li>
<li><strong>哨兵节点的数量应该是奇数</strong>，避免脑裂问题</li>
</ul>
<h2 id="主从故障转移详细流程">主从故障转移详细流程</h2>
<p>在哨兵集群中通过投票的方式，选举出了哨兵 leader 后，就可以进行主从故障转移的过程了：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383657283.png" alt="故障转移流程"></p>
<p>主从故障转移操作包含以下四个步骤：</p>
<h3 id="步骤一：选出新主节点">步骤一：选出新主节点</h3>
<p>故障转移操作第一步要做的就是在已下线主节点属下的所有「从节点」中，挑选出一个状态良好、数据完整的从节点，然后向这个「从节点」发送 <code>SLAVEOF no one</code> 命令，将这个「从节点」转换为「主节点」。</p>
<h4 id="从节点筛选策略">从节点筛选策略</h4>
<p><strong>1. 初步筛选</strong></p>
<ul>
<li>过滤掉已经下线的从节点</li>
<li>过滤掉网络状态不佳的从节点</li>
</ul>
<p><strong>网络状态判断标准</strong>：Redis 有个叫 <code>down-after-milliseconds * 10</code> 配置项，如果发生断连的次数超过了 10 次，就说明这个从节点的网络状况不好，不适合作为新主节点。</p>
<p><strong>2. 三轮考察选择</strong></p>
<p><strong>第一轮：优先级考察</strong></p>
<ul>
<li>Redis 有个叫 <code>slave-priority</code> 配置项，可以给从节点设置优先级</li>
<li>优先级越小排名越靠前</li>
<li>根据服务器性能配置来设置从节点的优先级</li>
</ul>
<p><strong>第二轮：复制进度考察</strong><br>
如果优先级相同，则比较复制进度：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383672550.png" alt="复制进度示意图"></p>
<ul>
<li>主节点用 <code>master_repl_offset</code> 记录最新写操作位置</li>
<li>从节点用 <code>slave_repl_offset</code> 记录当前复制进度</li>
<li><code>slave_repl_offset</code> 最接近 <code>master_repl_offset</code> 的从节点优先</li>
</ul>
<p><strong>第三轮：ID 号考察</strong></p>
<ul>
<li>如果优先级和复制进度都相同，比较从节点 ID 号</li>
<li>ID 号小的从节点胜出</li>
</ul>
<h4 id="选主流程总结">选主流程总结</h4>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383680804.png" alt="选主流程图"></p>
<p>在选举出从节点后，哨兵 leader 向被选中的从节点发送 <code>SLAVEOF no one</code> 命令，让这个从节点解除从节点的身份，将其变为新主节点。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383688317.png" alt="新主节点升级"></p>
<p>在发送 <code>SLAVEOF no one</code> 命令之后，哨兵 leader 会以每秒一次的频率向被升级的从节点发送 <code>INFO</code> 命令，并观察命令回复中的角色信息，当被升级节点的角色信息从原来的 slave 变为 master 时，哨兵 leader 就知道被选中的从节点已经顺利升级为主节点了。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383701839.png" alt="主节点升级完成"></p>
<h3 id="步骤二：将从节点指向新主节点">步骤二：将从节点指向新主节点</h3>
<p>当新主节点出现之后，哨兵 leader 下一步要做的就是，让已下线主节点属下的所有「从节点」指向「新主节点」，这一动作可以通过向「从节点」发送 <code>SLAVEOF</code> 命令来实现。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383711332.png" alt="从节点重新指向"></p>
<p>所有从节点指向新主节点后的拓扑图如下：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383718230.png" alt="新拓扑结构"></p>
<h3 id="步骤三：通知客户端主节点已更换">步骤三：通知客户端主节点已更换</h3>
<p>经过前面一系列的操作后，哨兵集群终于完成主从切换的工作，那么新主节点的信息要如何通知给客户端呢？</p>
<p>这主要<strong>通过 Redis 的发布者/订阅者机制来实现</strong>的。每个哨兵节点提供发布者/订阅者机制，客户端可以从哨兵订阅消息。</p>
<h4 id="哨兵提供的事件频道">哨兵提供的事件频道</h4>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383729144.png" alt="事件频道列表"></p>
<p>哨兵提供的消息订阅频道有很多，不同频道包含了主从节点切换过程中的不同关键事件：</p>
<ul>
<li><code>+switch-master</code>：主节点切换完成</li>
<li><code>+slave</code>：新从节点连接</li>
<li><code>+failover-start</code>：故障转移开始</li>
<li><code>+failover-end</code>：故障转移结束</li>
</ul>
<p><strong>客户端通知流程</strong>：</p>
<ol>
<li>客户端和哨兵建立连接</li>
<li>客户端订阅哨兵提供的频道</li>
<li>主从切换完成后，哨兵向 <code>+switch-master</code> 频道发布新主节点的 IP 地址和端口</li>
<li>客户端收到消息，更新连接配置</li>
</ol>
<p>通过发布者/订阅者机制，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控到主从节点切换过程中发生的各个重要事件，有助于了解切换进度。</p>
<h3 id="步骤四：将旧主节点变为从节点">步骤四：将旧主节点变为从节点</h3>
<p>故障转移操作最后要做的是，继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 <code>SLAVEOF</code> 命令，让它成为新主节点的从节点：</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383740898.png" alt="旧主节点变从节点"></p>
<p>至此，整个主从节点的故障转移的工作结束。</p>
<h2 id="哨兵集群的组建机制">哨兵集群的组建机制</h2>
<h3 id="哨兵自动发现机制">哨兵自动发现机制</h3>
<p>在我第一次搭建哨兵集群的时候，当时觉得很诧异。因为在配置哨兵的信息时，竟然只需要填下面这几个参数，设置主节点名字、主节点的 IP 地址和端口号以及 quorum 值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br></pre></td></tr></table></figure>
<p>不需要填其他哨兵节点的信息，它们是如何感知对方的，又是如何组成哨兵集群的？</p>
<h3 id="基于发布-订阅的发现机制">基于发布/订阅的发现机制</h3>
<p><strong>哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的</strong>。</p>
<p>在主从集群中，主节点上有一个名为 <code>__sentinel__:hello</code> 的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383750958.png" alt="哨兵相互发现"></p>
<p><strong>发现流程</strong>：</p>
<ol>
<li>哨兵 A 把自己的 IP 地址和端口信息发布到 <code>__sentinel__:hello</code> 频道</li>
<li>哨兵 B 和 C 订阅了该频道</li>
<li>哨兵 B 和 C 从频道获取哨兵 A 的连接信息</li>
<li>哨兵 B、C 与哨兵 A 建立网络连接</li>
<li>通过同样方式，所有哨兵互相发现并建立连接</li>
</ol>
<h3 id="从节点信息获取">从节点信息获取</h3>
<p>哨兵集群会对「从节点」的运行状态进行监控，那哨兵集群如何知道「从节点」的信息？</p>
<p><strong>信息获取流程</strong>：</p>
<ol>
<li>主节点知道所有「从节点」的信息</li>
<li>哨兵每 10 秒向主节点发送 <code>INFO</code> 命令</li>
<li>主节点返回从节点列表信息</li>
<li>哨兵根据从节点连接信息建立连接</li>
<li>在连接上持续监控从节点状态</li>
</ol>
<p><img src="/2025/06/08/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/1749383759411.png" alt="从节点信息获取"></p>
<p>正是通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，然后组成集群，同时，哨兵又通过 <code>INFO</code> 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p>
<h2 id="哨兵模式的核心特性总结">哨兵模式的核心特性总结</h2>
<h3 id="核心功能">核心功能</h3>
<p><strong>1. 故障检测</strong></p>
<ul>
<li>主观下线：单个哨兵的判断</li>
<li>客观下线：多个哨兵的共同判断</li>
<li>减少误判，提高可靠性</li>
</ul>
<p><strong>2. 自动故障转移</strong></p>
<ul>
<li>Leader 选举：确保单点执行故障转移</li>
<li>智能选主：基于优先级、复制进度、ID 的选择策略</li>
<li>完整的切换流程：从选主到通知客户端</li>
</ul>
<p><strong>3. 高可用保障</strong></p>
<ul>
<li>集群化部署：避免单点故障</li>
<li>自动化运维：减少人工干预</li>
<li>实时监控：持续健康检查</li>
</ul>
<h3 id="部署建议">部署建议</h3>
<p><strong>1. 节点数量</strong></p>
<ul>
<li>最少 3 个哨兵节点</li>
<li>推荐奇数个节点（3、5、7）</li>
<li>避免网络分区导致的脑裂</li>
</ul>
<p><strong>2. 配置参数</strong></p>
<ul>
<li><code>quorum</code> 设置为节点数 / 2 + 1</li>
<li><code>down-after-milliseconds</code> 根据网络延迟调整</li>
<li><code>failover-timeout</code> 设置合理的故障转移超时</li>
</ul>
<p><strong>3. 网络部署</strong></p>
<ul>
<li>哨兵节点分布在不同机器/机房</li>
<li>保证网络连通性和稳定性</li>
<li>考虑客户端到哨兵的网络质量</li>
</ul>
<h2 id="总结">总结</h2>
<p>Redis 在 2.8 版本以后提供的<strong>哨兵（Sentinel）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
<p>哨兵一般是以集群的方式部署，至少需要 3 个哨兵节点，哨兵集群主要负责三件事情：<strong>监控、选主、通知</strong>。</p>
<h3 id="工作流程总结">工作流程总结</h3>
<p><strong>1. 第一轮投票：判断主节点下线</strong><br>
当哨兵集群中的某个哨兵判定主节点下线（主观下线）后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p>
<p><strong>2. 第二轮投票：选出哨兵 leader</strong><br>
某个哨兵判定主节点客观下线后，该哨兵就会发起投票，告诉其他哨兵，它想成为 leader，想成为 leader 的哨兵节点，要满足两个条件：</p>
<ul>
<li>第一，拿到半数以上的赞成票</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值</li>
</ul>
<p><strong>3. 由哨兵 leader 进行主从故障转移</strong><br>
选举出了哨兵 leader 后，就可以进行主从故障转移的过程了。该操作包含以下四个步骤：</p>
<ul>
<li>
<p><strong>第一步</strong>：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：</p>
<ul>
<li>过滤掉已经离线的从节点</li>
<li>过滤掉历史网络连接状态不好的从节点</li>
<li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点</li>
</ul>
</li>
<li>
<p><strong>第二步</strong>：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」</p>
</li>
<li>
<p><strong>第三步</strong>：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端</p>
</li>
<li>
<p><strong>第四步</strong>：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点</p>
</li>
</ul>
<h3 id="技术原理">技术原理</h3>
<p>哨兵节点通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，相互连接，然后组成哨兵集群，同时哨兵又通过 <code>INFO</code> 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《Redis 核心技术与实战》</li>
<li>《Redis 设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>Redis</tag>
        <tag>哨兵</tag>
        <tag>故障转移</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 224 - 基本计算器（Basic Calculator）</title>
    <url>/2025/06/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个字符串表达式 <code>s</code>，请你实现一个基本计算器来计算并返回它的值。</p>
<p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code>。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>$1 \leq s.length \leq 3 \times 10^5$</li>
<li><code>s</code> 由数字、<code>'+'</code>、<code>'-'</code>、<code>'('</code>、<code>')'</code>、和 <code>' '</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
<li><code>'+'</code> 不能用作一元运算的正号</li>
<li><code>'-'</code> 可以用作一元运算的负号</li>
<li>输入中不存在两个连续的操作符</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心在于<strong>处理带括号的表达式计算</strong>。关键难点是：</p>
<ol>
<li><strong>符号的传递</strong>：括号内的符号需要与括号外的符号相乘</li>
<li><strong>优先级处理</strong>：括号具有最高优先级</li>
<li><strong>状态保存</strong>：进入括号时需要保存当前状态</li>
</ol>
<h3 id="核心思想">核心思想</h3>
<p>使用<strong>栈</strong>来处理括号的嵌套：</p>
<ul>
<li><strong>遇到 <code>(</code></strong>：将当前的结果和符号压入栈中，重新开始计算</li>
<li><strong>遇到 <code>)</code></strong>：从栈中弹出之前的结果和符号，与当前结果合并</li>
</ul>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li>
<p><strong>初始化变量</strong>：</p>
<ul>
<li><code>stack</code>：存储历史状态的栈</li>
<li><code>sign</code>：当前数字的符号（1 或 -1）</li>
<li><code>res</code>：当前表达式的计算结果</li>
</ul>
</li>
<li>
<p><strong>遍历字符串</strong>：</p>
<ul>
<li><strong>数字</strong>：解析完整数字，加到结果中</li>
<li><strong>符号 <code>+/-</code></strong>：更新下一个数字的符号</li>
<li><strong>左括号 <code>(</code></strong>：保存当前状态到栈，重置计算</li>
<li><strong>右括号 <code>)</code></strong>：恢复之前状态，合并计算结果</li>
</ul>
</li>
<li>
<p><strong>状态转换图</strong>：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通计算 ──┐</span><br><span class="line">           │ 遇到 &#x27;(&#x27;</span><br><span class="line">           ↓</span><br><span class="line">       保存状态到栈</span><br><span class="line">           │</span><br><span class="line">           ↓</span><br><span class="line">       重新开始计算</span><br><span class="line">           │ 遇到 &#x27;)&#x27;</span><br><span class="line">           ↓</span><br><span class="line">       从栈恢复状态</span><br><span class="line">           │</span><br><span class="line">           ↓</span><br><span class="line">       合并计算结果</span><br></pre></td></tr></table></figure>
<h2 id="实现细节">实现细节</h2>
<h3 id="关键点分析">关键点分析</h3>
<ol>
<li>
<p><strong>符号处理</strong>：</p>
<ul>
<li>使用 <code>sign</code> 变量记录当前数字的符号</li>
<li>遇到 <code>+</code> 设置 <code>sign = 1</code>，遇到 <code>-</code> 设置 <code>sign = -1</code></li>
</ul>
</li>
<li>
<p><strong>括号处理</strong>：</p>
<ul>
<li>左括号：<code>stack.push(sign)</code> → <code>stack.push(res)</code> → 重置状态</li>
<li>右括号：弹出 <code>preRes</code> 和 <code>preSign</code>，计算 <code>preSign * res + preRes</code></li>
</ul>
</li>
<li>
<p><strong>数字解析</strong>：</p>
<ul>
<li>连续读取数字字符，构建完整的数字</li>
<li>注意处理多位数字的情况</li>
</ul>
</li>
</ol>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以 <code>&quot;(1+(4+5+2)-3)+(6+8)&quot;</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤详解：</span><br><span class="line">1. 遇到 &#x27;(&#x27;：stack = [1, 0], res = 0, sign = 1</span><br><span class="line">2. 数字 1：res = 1</span><br><span class="line">3. 遇到 &#x27;+&#x27;：sign = 1</span><br><span class="line">4. 遇到 &#x27;(&#x27;：stack = [1, 0, 1, 1], res = 0, sign = 1</span><br><span class="line">5. 数字 4：res = 4</span><br><span class="line">6. 遇到 &#x27;+&#x27;：sign = 1</span><br><span class="line">7. 数字 5：res = 9</span><br><span class="line">8. 遇到 &#x27;+&#x27;：sign = 1</span><br><span class="line">9. 数字 2：res = 11</span><br><span class="line">10. 遇到 &#x27;)&#x27;：preRes = 1, preSign = 1, res = 1 * 11 + 1 = 12</span><br><span class="line">11. 遇到 &#x27;-&#x27;：sign = -1</span><br><span class="line">12. 数字 3：res = 12 + (-1) * 3 = 9</span><br><span class="line">13. 遇到 &#x27;)&#x27;：preRes = 0, preSign = 1, res = 1 * 9 + 0 = 9</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;      <span class="comment">// 存储历史状态的栈</span></span><br><span class="line">    sign := <span class="number">1</span>             <span class="comment">// 当前数字的符号：1表示正，-1表示负</span></span><br><span class="line">    res := <span class="number">0</span>              <span class="comment">// 当前表达式的计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        char := s[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> unicode.IsDigit(<span class="type">rune</span>(char)) &#123;</span><br><span class="line">            <span class="comment">// 解析完整的数字（可能是多位数）</span></span><br><span class="line">            num := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &amp;&amp; unicode.IsDigit(<span class="type">rune</span>(s[i])) &#123;</span><br><span class="line">                num = num*<span class="number">10</span> + <span class="type">int</span>(s[i]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">            i-- <span class="comment">// 回退一位，因为外层循环会自动 i++</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将数字加到当前结果中</span></span><br><span class="line">            res += sign * num</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 下一个数字为正数</span></span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 下一个数字为负数</span></span><br><span class="line">            sign = <span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 遇到左括号：保存当前状态，重新开始计算</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, sign)  <span class="comment">// 保存当前符号</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, res)   <span class="comment">// 保存当前结果</span></span><br><span class="line">            res = <span class="number">0</span>                      <span class="comment">// 重置结果</span></span><br><span class="line">            sign = <span class="number">1</span>                     <span class="comment">// 重置符号</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 遇到右括号：恢复之前状态，合并结果</span></span><br><span class="line">            preRes := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]    <span class="comment">// 弹出之前的结果</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            preSign := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]   <span class="comment">// 弹出之前的符号</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 合并计算：preSign * 当前结果 + 之前结果</span></span><br><span class="line">            res = preSign*res + preRes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 忽略空格字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$</li>
<li>每个字符最多被访问一次，数字字符可能需要额外的内层循环来构建完整数字</li>
<li>栈操作（入栈、出栈）都是 $O(1)$ 时间复杂度</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li><strong>空间复杂度</strong>：$O(n)$</li>
<li>在最坏情况下（如 <code>&quot;((((1))))&quot;</code> ），栈的深度等于括号的嵌套深度</li>
<li>最大嵌套深度可能达到 $O(n)$</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<h3 id="核心思想-2">核心思想</h3>
<ol>
<li><strong>栈处理括号</strong>：使用栈保存和恢复计算状态是处理嵌套结构的经典方法</li>
<li><strong>符号传递</strong>：括号内外符号的正确传递是解题关键</li>
<li><strong>状态管理</strong>：合理设计状态变量（<code>res</code>、<code>sign</code>、<code>stack</code>）</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>多位数字处理</strong>：确保正确解析完整的数字，而不是单个字符</li>
<li><strong>循环索引</strong>：内层数字解析循环后需要回退索引</li>
<li><strong>符号初始化</strong>：进入新括号时要重置符号为正</li>
</ol>
<h3 id="扩展应用">扩展应用</h3>
<ul>
<li>这种栈的状态保存技巧可应用于：
<ul>
<li>表达式求值类问题</li>
<li>括号匹配问题</li>
<li>递归结构的迭代实现</li>
</ul>
</li>
</ul>
<h3 id="相关问题">相关问题</h3>
<ul>
<li>LeetCode 227: 基本计算器 II（处理乘除运算）</li>
<li>LeetCode 772: 基本计算器 III（同时处理加减乘除和括号）</li>
<li>LeetCode 394: 字符串解码（类似的栈状态保存思路）</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Hard</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 452 - 用最少数量的箭引爆气球（Minimum Number of Arrows to Burst Balloons）</title>
    <url>/2025/06/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙上。墙上的气球用一个二维数组 <code>points</code> 表示，其中 <code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code> 之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>，且满足 <code>xstart ≤ x ≤ xend</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code>，返回引爆所有气球所必须射出的<strong>最小弓箭数</strong>。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class="line">-在x = 11处射出箭，击破气球[10,16]和[7,12]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br><span class="line">解释：每个气球需要射出一支箭，总共需要4支箭。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">- 在x = 2处射出箭，击破气球[1,2]和[2,3]。</span><br><span class="line">- 在x = 4处射出箭，击破气球[3,4]和[4,5]。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>1 ≤ points.length ≤ 10^5</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-2^31 ≤ xstart &lt; xend ≤ 2^31 - 1</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这是一个经典的<strong>区间重叠问题</strong>，可以用<strong>贪心算法</strong>来解决。核心思想是：<strong>尽可能让每支箭射中更多的气球</strong>。</p>
<h3 id="关键洞察">关键洞察</h3>
<p><strong>关键洞察</strong>：如果我们按照气球的右端点进行排序，然后贪心地选择射箭位置，就能保证用最少的箭数。</p>
<p>具体思路：</p>
<ol>
<li><strong>按右端点排序</strong>：将所有气球按照右端点从小到大排序</li>
<li><strong>贪心选择</strong>：每次选择当前能射中的气球中右端点最小的位置射箭</li>
<li><strong>更新状态</strong>：射出一箭后，所有被这支箭射中的气球都被移除，继续处理剩余气球</li>
</ol>
<h3 id="算法步骤">算法步骤</h3>
<h4 id="步骤-1：排序">步骤 1：排序</h4>
<p>按照每个气球的右端点 <code>points[i][1]</code> 进行升序排序。</p>
<h4 id="步骤-2：贪心选择">步骤 2：贪心选择</h4>
<ul>
<li>初始化箭数 <code>ans = 1</code>（至少需要一支箭）</li>
<li>记录第一支箭的射击位置为第一个气球的右端点 <code>maxRight = points[0][1]</code></li>
</ul>
<h4 id="步骤-3：遍历处理">步骤 3：遍历处理</h4>
<p>对于每个后续气球：</p>
<ul>
<li>如果当前气球的左端点 <code>point[0] &gt; maxRight</code>，说明当前箭无法射中这个气球</li>
<li>需要射出新的一箭：<code>ans++</code>，并更新射击位置 <code>maxRight = point[1]</code></li>
<li>否则，当前箭可以射中这个气球，无需额外操作</li>
</ul>
<h3 id="为什么按右端点排序？">为什么按右端点排序？</h3>
<p>按右端点排序的原因是：<strong>贪心地选择尽可能靠右的位置射箭，能够覆盖更多的气球</strong>。</p>
<p>考虑两个重叠的区间 <code>[a1, b1]</code> 和 <code>[a2, b2]</code>，其中 <code>b1 ≤ b2</code>：</p>
<ul>
<li>如果在 <code>b1</code> 处射箭，可以同时射中两个气球</li>
<li>如果在 <code>b2</code> 处射箭，只能射中第二个气球</li>
<li>因此选择 <code>b1</code>（较小的右端点）更优</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="排序策略">排序策略</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> points[i][<span class="number">1</span>] &lt; points[j][<span class="number">1</span>]  <span class="comment">// 按右端点升序排序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="贪心判断">贪心判断</h3>
<p>对于每个气球，判断其左端点是否大于当前箭的射击位置：</p>
<ul>
<li><code>point[0] &gt; maxRight</code>：需要新箭</li>
<li><code>point[0] ≤ maxRight</code>：当前箭可以射中</li>
</ul>
<h3 id="执行示例">执行示例</h3>
<p>以 <code>points = [[10,16],[2,8],[1,6],[7,12]]</code> 为例：</p>
<ol>
<li><strong>排序后</strong>：<code>[[1,6],[2,8],[7,12],[10,16]]</code></li>
<li><strong>初始状态</strong>：<code>ans = 1</code>, <code>maxRight = 6</code></li>
<li><strong>处理 [2,8]</strong>：<code>2 ≤ 6</code>，当前箭可射中，无需新箭</li>
<li><strong>处理 [7,12]</strong>：<code>7 &gt; 6</code>，需要新箭，<code>ans = 2</code>, <code>maxRight = 12</code></li>
<li><strong>处理 [10,16]</strong>：<code>10 ≤ 12</code>，当前箭可射中，无需新箭</li>
<li><strong>结果</strong>：<code>ans = 2</code></li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 按右端点升序排序</span></span><br><span class="line">    sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> points[i][<span class="number">1</span>] &lt; points[j][<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    ans := <span class="number">1</span>                    <span class="comment">// 至少需要一支箭</span></span><br><span class="line">    maxRight := points[<span class="number">0</span>][<span class="number">1</span>]    <span class="comment">// 第一支箭的射击位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历剩余气球</span></span><br><span class="line">    <span class="keyword">for</span> _, point := <span class="keyword">range</span> points &#123;</span><br><span class="line">        <span class="keyword">if</span> point[<span class="number">0</span>] &gt; maxRight &#123;    <span class="comment">// 当前箭无法射中这个气球</span></span><br><span class="line">            ans++                   <span class="comment">// 需要新箭</span></span><br><span class="line">            maxRight = point[<span class="number">1</span>]     <span class="comment">// 更新射击位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则当前箭可以射中，继续下一个气球</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>时间复杂度</strong>：$O(n \log n)$</p>
<ul>
<li>排序操作需要 $O(n \log n)$ 时间</li>
<li>遍历数组需要 $O(n)$ 时间</li>
<li>总体时间复杂度为 $O(n \log n)$</li>
</ul>
<p><strong>空间复杂度</strong>：$O(1)$</p>
<ul>
<li>只使用了常数个额外变量</li>
<li>排序是原地进行的（Go 的 sort.Slice 是原地排序）</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<h3 id="核心算法概念">核心算法概念</h3>
<ol>
<li><strong>贪心算法</strong>：在每一步都做出当前看起来最优的选择</li>
<li><strong>区间重叠问题</strong>：通过排序和贪心策略解决</li>
<li><strong>排序策略的选择</strong>：按右端点排序是关键</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>排序方向错误</strong>：必须按右端点升序排序，不是左端点</li>
<li><strong>边界条件处理</strong>：注意 <code>point[0] &gt; maxRight</code> 的判断条件</li>
<li><strong>初始化错误</strong>：箭数应该初始化为 1，不是 0</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li>LeetCode 435: 无重叠区间</li>
<li>LeetCode 253: 会议室 II</li>
<li>LeetCode 56: 合并区间</li>
</ul>
<h3 id="算法模板">算法模板</h3>
<p>这类区间重叠问题的通用解法：</p>
<ol>
<li>根据问题特点选择排序策略（左端点或右端点）</li>
<li>贪心地处理每个区间</li>
<li>维护必要的状态信息（如当前覆盖范围）</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>贪心算法</tag>
        <tag>排序</tag>
        <tag>区间问题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 57. 插入区间 - Go 题解</title>
    <url>/2025/06/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>给你一个 <strong>无重叠的</strong>、<strong>按照区间起始端点排序的</strong> 区间列表 <code>intervals</code>，其中 <code>intervals[i] = [starti, endi]</code> 表示第 <code>i</code> 个区间的开始和结束，并且 <code>intervals</code> 中的区间不重叠。</p>
<p>另给出一个新区间 <code>newInterval = [start, end]</code>。</p>
<p>你需要将 <code>newInterval</code> 插入 <code>intervals</code> 中，并保证 <code>intervals</code> 仍然是按起始端点排序的无重叠区间。</p>
<p><strong>示例 1:</strong></p>
<ul>
<li><strong>输入:</strong> <code>intervals = [[1,3],[6,9]]</code>, <code>newInterval = [2,5]</code></li>
<li><strong>输出:</strong> <code>[[1,5],[6,9]]</code></li>
</ul>
<p><strong>示例 2:</strong></p>
<ul>
<li><strong>输入:</strong> <code>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, <code>newInterval = [4,8]</code></li>
<li><strong>输出:</strong> <code>[[1,2],[3,10],[12,16]]</code></li>
<li><strong>解释:</strong> 新区间 <code>[4,8]</code> 与 <code>[3,5]</code>, <code>[6,7]</code>, <code>[8,10]</code> 重叠。</li>
</ul>
<h3 id="解题思路">解题思路</h3>
<p>这道题的核心是在一个有序且无重叠的区间列表中插入一个新区间，并合并所有重叠的区间。由于原区间列表已经是有序的，我们可以通过一次遍历来完成这个任务。</p>
<p>我们的目标是构建一个新的结果列表 <code>res</code>。遍历原始区间 <code>intervals</code>，对于每个区间，有三种情况：</p>
<ol>
<li>
<p><strong>当前区间在 <code>newInterval</code> 的左侧且无交集</strong>：<br>
如果当前区间的结束点 <code>interval[1]</code> 小于 <code>newInterval</code> 的起始点 <code>left</code>，说明当前区间与新区间没有交集，并且位于新区间之前。我们可以直接将当前区间加入结果列表 <code>res</code>。</p>
</li>
<li>
<p><strong>当前区间在 <code>newInterval</code> 的右侧且无交集</strong>：<br>
如果当前区间的起始点 <code>interval[0]</code> 大于 <code>newInterval</code> 的结束点 <code>right</code>，说明当前区间与新区间没有交集，并且位于新区间之后。这时，我们需要先将合并后的新区间（可能是 <code>newInterval</code> 本身，也可能是它与其他区间合并后的结果）加入结果列表 <code>res</code>，然后再加入当前区间。为了防止重复添加，我们用一个 <code>merged</code> 标志位来记录是否已经添加过合并区间。</p>
</li>
<li>
<p><strong>当前区间与 <code>newInterval</code> 有交集</strong>：<br>
只要不满足以上两种情况，就说明当前区间与 <code>newInterval</code> 存在重叠。我们需要更新 <code>newInterval</code> 的边界，使其能够覆盖当前区间。具体做法是：</p>
<ul>
<li>将 <code>newInterval</code> 的左边界 <code>left</code> 更新为 <code>min(left, interval[0])</code>。</li>
<li>将 <code>newInterval</code> 的右边界 <code>right</code> 更新为 <code>max(right, interval[1])</code>。<br>
这样，遍历结束后，<code>[left, right]</code> 就代表了 <code>newInterval</code> 与所有重叠区间合并后的最终区间。</li>
</ul>
</li>
</ol>
<p>遍历结束后，如果 <code>merged</code> 标志位仍然是 <code>false</code>，说明合并后的区间还没有被添加到结果列表中（这通常发生在 <code>newInterval</code> 与所有原区间都合并，或者它位于所有原区间的末尾），此时需要手动将其添加到 <code>res</code> 中。</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=57 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [57] 插入区间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(intervals [][]<span class="type">int</span>, newInterval []<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">	left, right := newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]</span><br><span class="line">	merged := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> _, interval := <span class="keyword">range</span> intervals &#123;</span><br><span class="line">		<span class="comment">// 当前区间在 newInterval 的右侧且无交集</span></span><br><span class="line">		<span class="keyword">if</span> interval[<span class="number">0</span>] &gt; right &#123;</span><br><span class="line">			<span class="keyword">if</span> !merged &#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;left, right&#125;)</span><br><span class="line">				merged = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			res = <span class="built_in">append</span>(res, interval)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> interval[<span class="number">1</span>] &lt; left &#123;</span><br><span class="line">			<span class="comment">// 当前区间在 newInterval 的左侧且无交集</span></span><br><span class="line">			res = <span class="built_in">append</span>(res, interval)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 有交集，更新 newInterval 的范围</span></span><br><span class="line">			<span class="keyword">if</span> interval[<span class="number">0</span>] &lt; left &#123;</span><br><span class="line">				left = interval[<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> interval[<span class="number">1</span>] &gt; right &#123;</span><br><span class="line">				right = interval[<span class="number">1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !merged &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;left, right&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>: $O(n)$，其中 $n$ 是 <code>intervals</code> 的长度。我们只需要遍历一次区间列表。</li>
<li><strong>空间复杂度</strong>: $O(n)$，我们需要一个额外的空间来存储结果列表。在最坏的情况下（没有区间合并），结果列表会包含所有原始区间和新区间。</li>
</ul>
<h3 id="关键收获">关键收获</h3>
<p>本题的关键在于利用输入区间的有序性。通过一次遍历，我们可以清晰地划分出与新区间不重叠的左侧部分、重叠部分以及不重叠的右侧部分，从而高效地完成插入和合并操作。这种思路在处理区间问题时非常常用。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>Go</tag>
        <tag>区间</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 202 - 快乐数 (Happy Number)</title>
    <url>/2025/06/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p>「快乐数」定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li>
<li>如果这个过程 结果为 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 快乐数 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong><br>
输入：n = 19<br>
输出：true<br>
解释：<br>
1² + 9² = 82<br>
8² + 2² = 68<br>
6² + 8² = 100<br>
1² + 0² + 0² = 1</p>
<p><strong>示例 2：</strong><br>
输入：n = 2<br>
输出：false</p>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 2^31 - 1</code></li>
</ul>
<h3 id="解题思路">解题思路</h3>
<p>判断一个数是否为&quot;快乐数&quot;的核心在于检测在转换过程中是否会出现循环。如果数字最终变为 1，那么它是快乐数。如果进入一个不包含 1 的循环，那么它就不是快乐数。</p>
<p>这个问题可以巧妙地使用<strong>快慢指针</strong>（Floyd 循环查找算法）来解决，这种方法常用于判断链表等序列中是否存在环。</p>
<ol>
<li>我们定义一个辅助函数 <code>calculateHappy(num)</code>，用于计算一个数各位数字的平方和。</li>
<li>在主函数 <code>isHappy(n)</code> 中，我们初始化两个指针：
<ul>
<li><code>low</code>（慢指针）：每次通过 <code>calculateHappy</code> 转换一次。</li>
<li><code>fast</code>（快指针）：每次通过 <code>calculateHappy</code> 转换两次。</li>
</ul>
</li>
<li>我们不断迭代这个转换过程：
<ul>
<li><code>low = calculateHappy(low)</code></li>
<li><code>fast = calculateHappy(calculateHappy(fast))</code></li>
</ul>
</li>
<li>如果 <code>fast</code> 指针追上了 <code>low</code> 指针（即 <code>low == fast</code>），这意味着我们进入了一个循环。</li>
<li>循环结束时，如果相遇点的值是 1，则原始数 <code>n</code> 是快乐数；否则，它不是快乐数。</li>
</ol>
<p><strong>为什么快慢指针能检测循环？</strong></p>
<ul>
<li>如果序列中没有循环（理论上对于快乐数问题，它总会进入循环或到达1），快指针将永远领先于慢指针。</li>
<li>如果序列中有循环，慢指针进入循环后，快指针最终会在循环内追上慢指针。想象一下在操场跑圈，跑得快的人总会追上跑得慢的人。</li>
</ul>
<h3 id="实现细节">实现细节</h3>
<h4 id="calculateHappy-num-int-函数"><code>calculateHappy(num int)</code> 函数</h4>
<p>这个函数负责计算给定数字 <code>num</code> 的各位数字的平方和。</p>
<ul>
<li>它通过一个循环来处理数字的每一位：
<ul>
<li><code>digit := num % 10</code> 获取最低位的数字。</li>
<li><code>res += digit * digit</code> 将该数字的平方累加到结果 <code>res</code> 中。</li>
<li><code>num /= 10</code> 移除最低位的数字。</li>
</ul>
</li>
<li>循环直到 <code>num</code> 变为 0，此时所有位都已处理完毕。</li>
</ul>
<h4 id="isHappy-n-int-函数"><code>isHappy(n int)</code> 函数</h4>
<ul>
<li>初始化慢指针 <code>low</code> 为原始数 <code>n</code>。</li>
<li>初始化快指针 <code>fast</code> 为 <code>calculateHappy(n)</code>（即走了一步）。</li>
<li>进入主循环，条件是 <code>low != fast</code>。
<ul>
<li>在循环内部，慢指针走一步：<code>low = calculateHappy(low)</code>。</li>
<li>快指针走两步：<code>fast = calculateHappy(calculateHappy(fast))</code>。</li>
</ul>
</li>
<li>当 <code>low == fast</code> 时，循环终止。此时，它们相遇在某个点上。</li>
<li>返回 <code>fast == 1</code>（或 <code>low == 1</code>），判断相遇点是否为 1。</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc app=leetcode.cn id=202 lang=golang</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// [202] 快乐数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 使用快慢指针判断是否会陷入循环</span></span><br><span class="line">	<span class="comment">// 慢指针每次走一步</span></span><br><span class="line">	low := n</span><br><span class="line">	<span class="comment">// 快指针每次走两步，初始走一步</span></span><br><span class="line">	fast := calculateHappy(n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当快慢指针相遇时，退出循环</span></span><br><span class="line">	<span class="comment">// 如果 n 本身是 1，calculateHappy(1) 是 1，low 和 fast 初始就可能相等，但需要先判断</span></span><br><span class="line">    <span class="comment">// 如果 n=1, low=1, fast=calculateHappy(1)=1. 循环不进入，直接返回 fast==1 (true).</span></span><br><span class="line">    <span class="comment">// 如果 n 不是 1, 但 calculateHappy(n) = n (例如 n=7, calculateHappy(7)=49, calculateHappy(49)=97...), 不会立即陷入.</span></span><br><span class="line">	<span class="keyword">for</span> low != fast &#123;</span><br><span class="line">		low = calculateHappy(low)</span><br><span class="line">		fast = calculateHappy(calculateHappy(fast)) <span class="comment">// 快指针再走两步</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果相遇点是 1，则是快乐数；否则不是</span></span><br><span class="line">	<span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculateHappy 计算一个数各位数字平方和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateHappy</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">		digit := num % <span class="number">10</span></span><br><span class="line">		res += digit * digit</span><br><span class="line">		num /= <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>
<p><strong>时间复杂度：(O(\log n))</strong></p>
<ul>
<li><code>calculateHappy(m)</code> 函数的复杂度与数字 <code>m</code> 的位数相关，即 (O(\log m))。</li>
<li>对于一个数 <code>n</code>，经过 <code>calculateHappy</code> 转换后，其值会显著减小。例如，对于一个 <code>d</code> 位数，其最大可能的平方和是 (d \times 9^2)。
<ul>
<li>如果 <code>n = 999</code> (3位数), (3 \times 9^2 = 3 \times 81 = 243).</li>
<li>如果 <code>n = 1999999999</code> (10位数, 约 (2 \times 10^9)), 最大平方和 (1^2 + 9 \times 9^2 = 1 + 729 = 730).</li>
<li>对于 (2^{31}-1) (最大约 (2.1 \times 10^9)), 也是10位数，最大平方和类似，不会超过几百。</li>
</ul>
</li>
<li>这意味着无论初始的 <code>n</code> 有多大，经过少数几步转换后，数值会落入一个较小的范围内（例如，小于几百）。</li>
<li>一旦数值进入这个小范围，后续的转换序列和任何可能的循环都将在这个有限的数字集合中发生。Floyd 算法检测到循环或达到 1 的迭代次数是有限的，可以视为一个常数 (C)。</li>
<li>因此，总的时间复杂度主要由初始几次对较大数 <code>n</code> 进行 <code>calculateHappy</code> 转换所主导，即 (O(\log n))。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度：(O(1))</strong></p>
<ul>
<li>我们只使用了 <code>low</code> 和 <code>fast</code> 两个变量来存储中间值，不随输入 <code>n</code> 的大小而改变。</li>
</ul>
</li>
</ul>
<h3 id="关键收获">关键收获</h3>
<ul>
<li><strong>循环检测</strong>：快乐数问题本质上是一个序列中的循环检测问题。</li>
<li><strong>快慢指针 (Floyd 算法)</strong>：这是一种非常经典且高效的循环检测算法，空间复杂度为 (O(1))。</li>
<li><strong>状态收敛</strong>：理解数字经过&quot;各位平方和&quot;转换后会迅速减小并进入一个有限的状态空间，是理解算法有效性的关键。</li>
<li><strong>辅助函数</strong>：将核心计算（如 <code>calculateHappy</code>）封装在辅助函数中可以使主逻辑更清晰。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
        <tag>难度 (Easy)</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 128 最长连续序列：一个循环引发的性能血案</title>
    <url>/2025/06/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="问题简述">问题简述</h2>
<p>给定一个未排序的整数数组 <code>nums</code>，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p><strong>示例：</strong></p>
<ul>
<li><strong>输入：</strong> <code>nums = [100, 4, 200, 1, 3, 2]</code></li>
<li><strong>输出：</strong> <code>4</code></li>
<li><strong>解释：</strong> 最长数字连续序列是 <code>[1, 2, 3, 4]</code>。它的长度为 4。</li>
</ul>
<p>要求算法的时间复杂度为 O(n)。</p>
<h2 id="两种解法，天差地别">两种解法，天差地别</h2>
<p>这个问题的一个经典解法是使用哈希表来优化查找。核心思路是：</p>
<ol>
<li>将所有数字存入一个哈希表，实现 O(1) 的查找效率。</li>
<li>遍历数组，对于每个数字，如果我们发现它是一个连续序列的起点（即它的前一个数 <code>num-1</code> 不在哈希表中），我们就开始向后计算这个序列的长度。</li>
</ol>
<p>然而，正是在这第二步的&quot;遍历&quot;中，一个细节决定了代码的性能是&quot;超时&quot;还是&quot;通过&quot;。</p>
<h3 id="解法一：遍历原始数组（导致超时）">解法一：遍历原始数组（导致超时）</h3>
<p>这是一个很自然会想到的实现方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @lc app=leetcode.cn id=128 lang=golang</span></span><br><span class="line"><span class="comment">// 超时版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">	hashTable := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		hashTable[num] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关键点：这里遍历的是原始数组 nums</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="comment">// 如果 num-1 存在，说明 num 不是序列的起点，跳过</span></span><br><span class="line">		<span class="keyword">if</span> hashTable[num<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从 num 开始计算连续序列的长度</span></span><br><span class="line">		currentLen := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := num; hashTable[i]; i++ &#123;</span><br><span class="line">			currentLen++</span><br><span class="line">		&#125;</span><br><span class="line">		ans = max(ans, currentLen)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能瓶颈分析">性能瓶颈分析</h4>
<p>这段代码的问题出在第二个 <code>for</code> 循环，它遍历的是原始数组 <code>nums</code>。如果 <code>nums</code> 中包含大量重复的元素，就会导致重复计算。</p>
<p><strong>考虑一个最坏情况：</strong><br>
假设输入 <code>nums</code> 是 <code>[1, 1, 1, 1, 1, 2, 3, 4, 5]</code>。</p>
<ol>
<li>哈希表 <code>hashTable</code> 会是 <code>&#123;1:true, 2:true, 3:true, 4:true, 5:true&#125;</code>。</li>
<li>当外层循环第一次遇到 <code>1</code> 时，它发现 <code>hashTable[0]</code> 不存在，于是开始计算序列长度，从 <code>1</code> 遍历到 <code>5</code>，计算出长度为 5。</li>
<li>当外层循环第二次、第三次、直到第五次遇到 <code>1</code> 时，它会<strong>一遍又一遍地重复</strong>上面的计算过程。</li>
</ol>
<p>对于一个长度为 <code>N</code> 的数组，如果其中有 <code>k</code> 个重复的序列起点，而序列的平均长度为 <code>L</code>，那么时间复杂度会趋近于 <code>O(k*L)</code>，在最坏情况下 <code>k</code> 和 <code>L</code> 都可能与 <code>N</code> 相关，导致整体复杂度接近 <code>O(N²)</code>，从而在数据量大时超时。</p>
<h3 id="解法二：遍历哈希表（AC-通过）">解法二：遍历哈希表（AC 通过）</h3>
<p>现在我们来看优化后的版本，改动非常微小。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @lc app=leetcode.cn id=128 lang=golang</span></span><br><span class="line"><span class="comment">// 通过版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">	hashTable := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		hashTable[num] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关键点：这里遍历的是哈希表的键</span></span><br><span class="line">	<span class="keyword">for</span> num := <span class="keyword">range</span> hashTable &#123;</span><br><span class="line">		<span class="comment">// 如果 num-1 存在，说明 num 不是序列的起点，跳过</span></span><br><span class="line">		<span class="keyword">if</span> hashTable[num<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从 num 开始计算连续序列的长度</span></span><br><span class="line">		currentLen := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := num; hashTable[i]; i++ &#123;</span><br><span class="line">			currentLen++</span><br><span class="line">		&#125;</span><br><span class="line">		ans = max(ans, currentLen)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能提升分析">性能提升分析</h4>
<p>唯一的改动，就是将第二个循环的遍历对象从 <code>nums</code> 数组换成了 <code>hashTable</code>。</p>
<p><strong>为什么这个改动如此关键？</strong><br>
因为哈希表（在 Go 中是 <code>map</code>）的键（key）是<strong>唯一的</strong>。当我们将 <code>nums</code> 存入 <code>hashTable</code> 时，所有重复的元素都被自然地去除了。</p>
<p><code>for num := range hashTable</code> 遍历的是 <code>nums</code> 数组中所有<strong>不重复的元素</strong>。</p>
<p>回到刚才的例子 <code>[1, 1, 1, 1, 1, 2, 3, 4, 5]</code>：</p>
<ol>
<li><code>hashTable</code> 依然是 <code>&#123;1:true, 2:true, 3:true, 4:true, 5:true&#125;</code>。</li>
<li>当外层循环遍历到键 <code>1</code> 时，它会计算一次序列长度（为 5）。</li>
<li>当遍历到 <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code> 这些键时，因为它们的前一个数（<code>num-1</code>）都在哈希表中，所以都会被 <code>continue</code> 语句直接跳过。</li>
</ol>
<p>这种方法巧妙地保证了，<strong>每一个连续序列只会被其起点计算一次</strong>。每个数字最多被访问两次（一次是外层循环的检查，一次是内层循环的递增），因此总的时间复杂度是严格的 O(n)。</p>
<h2 id="方法比较与总结">方法比较与总结</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>解法一：遍历原始数组</th>
<th>解法二：遍历哈希表</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>最坏 O(n²)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>核心差异</td>
<td>遍历含重复元素的数组</td>
<td>遍历去重后的键集合</td>
</tr>
<tr>
<td>结果</td>
<td>超时</td>
<td>通过</td>
</tr>
</tbody>
</table>
<h3 id="关键收获">关键收获</h3>
<p>这个例子生动地告诉我们：</p>
<blockquote>
<p>在设计算法时，选择正确的遍历对象和利用数据结构（如哈希表）的内生特性（如键唯一性）至关重要。一个看似微不足道的改动，可能就是 O(n²) 和 O(n) 的区别。</p>
</blockquote>
<p>下次遇到需要去重和查找的场景时，记得优先考虑遍历哈希表本身，而不是遍历原始的、可能含大量重复元素的输入数据。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>Go</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 49 - 字母异位词分组（Group Anagrams）</title>
    <url>/2025/06/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个字符串数组，请你将<strong>字母异位词</strong>组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong>是由重新排列源单词的所有字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>1 &lt;= strs.length &lt;= 10^4</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心是如何判断两个字符串是否为字母异位词。字母异位词的特点是：<strong>它们包含完全相同的字母，且每个字母出现的次数也相同</strong>。基于这一特点，我们有两种主要解法。</p>
<h3 id="解法一：排序">解法一：排序</h3>
<p>最直观的方法是对每个字符串进行排序。如果两个字符串是字母异位词，那么排序后它们将完全相同。我们可以使用排序后的字符串作为哈希表的键，将原始字符串添加到对应的分组中。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>创建一个哈希表，键为排序后的字符串，值为原始字符串列表</li>
<li>遍历输入的字符串数组</li>
<li>对每个字符串进行排序，得到排序后的字符串</li>
<li>将原始字符串添加到哈希表中对应键的列表中</li>
<li>返回哈希表中所有的值列表</li>
</ol>
<h3 id="解法二：计数">解法二：计数</h3>
<p>排序的方法简单直观，但时间复杂度较高。我们可以通过统计每个字符串中字符的出现次数来优化。由于题目限定只包含小写字母，我们可以使用一个长度为 26 的数组来记录每个字符的出现次数。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li>创建一个哈希表，键为字符计数数组，值为原始字符串列表</li>
<li>遍历输入的字符串数组</li>
<li>对每个字符串，创建一个长度为 26 的计数数组，统计每个字母出现的次数</li>
<li>将计数数组作为键，将原始字符串添加到哈希表中对应的列表中</li>
<li>返回哈希表中所有的值列表</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="解法一：排序-2">解法一：排序</h3>
<p>在 Go 语言中，我们可以使用 <code>sort</code> 包对字符串进行排序。但需要注意的是，Go 的字符串是不可变的，我们需要先将其转换为字节切片，排序后再转回字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortStr</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    s2 := []<span class="type">byte</span>(s)</span><br><span class="line">    sort.Slice(s2, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s2[i] &lt; s2[j]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们使用排序后的字符串作为哈希表的键：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    hashTable := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        sortedStr := sortStr(str)</span><br><span class="line">        <span class="keyword">if</span> index, ok := hashTable[sortedStr]; ok &#123;</span><br><span class="line">            res[index] = <span class="built_in">append</span>(res[index], str)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, []<span class="type">string</span>&#123;str&#125;)</span><br><span class="line">            hashTable[sortedStr] = <span class="built_in">len</span>(res) - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二：计数-2">解法二：计数</h3>
<p>在计数方法中，我们使用一个长度为 26 的整数数组来统计每个字母出现的次数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    mp := <span class="keyword">map</span>[[<span class="number">26</span>]<span class="type">int</span>][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        cnt := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">            cnt[b-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">        &#125;</span><br><span class="line">        mp[cnt] = <span class="built_in">append</span>(mp[cnt], str)</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(mp))</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个实现中，我们使用 <code>[26]int</code> 类型的数组作为哈希表的键。在 Go 中，数组是可比较的，可以作为哈希表的键，而切片则不行。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>解法一：排序</th>
<th>解法二：计数</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n * k * log(k))</td>
<td>O(n * k)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
</tr>
<tr>
<td>优点</td>
<td>思路简单直观</td>
<td>更高效，尤其是对于长字符串</td>
</tr>
<tr>
<td>缺点</td>
<td>对于长字符串效率较低</td>
<td>实现稍微复杂一些</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<p>其中，n 是字符串数组的长度，k 是字符串的平均长度。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="解法一：排序-3">解法一：排序</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times k \times \log(k))$，其中 n 是字符串数组的长度，k 是字符串的平均长度。对每个字符串排序需要 $O(k \times \log(k))$ 的时间，总共有 n 个字符串。</li>
<li><strong>空间复杂度</strong>：$O(n \times k)$，需要存储所有字符串。</li>
</ul>
<h3 id="解法二：计数-3">解法二：计数</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n \times k)$，其中 n 是字符串数组的长度，k 是字符串的平均长度。我们需要遍历每个字符串中的每个字符。</li>
<li><strong>空间复杂度</strong>：$O(n \times k)$，需要存储所有字符串。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>字母异位词的本质</strong>：字母异位词本质上是包含相同字母且每个字母出现次数相同的字符串。</li>
<li><strong>哈希表的应用</strong>：这道题展示了哈希表在分组问题中的典型应用。</li>
<li><strong>键的选择</strong>：在使用哈希表时，选择合适的键是关键。这里我们可以使用排序后的字符串或字符计数数组作为键。</li>
<li><strong>Go语言特性</strong>：在 Go 中，数组是可比较的，可以作为哈希表的键，而切片则不行。这是一个需要注意的语言特性。</li>
<li><strong>时间复杂度优化</strong>：通过使用计数方法而不是排序，我们可以将时间复杂度从 $O(n \times k \times \log(k))$ 降低到 $O(n \times k)$。</li>
</ol>
<p>这道题是哈希表应用的经典例题，掌握了这道题的解法，对于其他涉及字符串分组或字母异位词的问题也会有很好的帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 73 - 矩阵置零（Matrix Zeroes）解题思路与错误分析</title>
    <url>/2025/06/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode-73-matrix-zeroes/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<strong>原地</strong>算法。</p>
<h2 id="解题思路">解题思路</h2>
<p>这个问题看似简单，但实际上有一些需要注意的细节，特别是在原地修改矩阵时容易出现错误。我总结了三种解决方案，从简单到优化的顺序。</p>
<h3 id="方法一：使用额外空间记录">方法一：使用额外空间记录</h3>
<p>最直观的方法是先遍历一次矩阵，记录哪些行和列需要置零，然后再进行置零操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">    cols := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录需要置零的行和列</span></span><br><span class="line">    zeroRows := <span class="built_in">make</span>([]<span class="type">bool</span>, rows)</span><br><span class="line">    zeroCols := <span class="built_in">make</span>([]<span class="type">bool</span>, cols)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次遍历，标记需要置零的行和列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                zeroRows[i] = <span class="literal">true</span></span><br><span class="line">                zeroCols[j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次遍历，执行置零操作</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> zeroRows[i] || zeroCols[j] &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m*n)，需要遍历矩阵两次</li>
<li>空间复杂度：O(m+n)，需要两个额外数组记录行列状态</li>
</ul>
<h3 id="方法二：使用矩阵首行和首列作为标记">方法二：使用矩阵首行和首列作为标记</h3>
<p>为了优化空间复杂度，我们可以利用矩阵的第一行和第一列来记录哪些行和列需要置零。但需要特别处理第一行和第一列本身是否需要置零。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">    cols := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记第一行和第一列是否需要置零</span></span><br><span class="line">    firstRowHasZero := <span class="literal">false</span></span><br><span class="line">    firstColHasZero := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查第一行是否有零</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span> &#123;</span><br><span class="line">            firstRowHasZero = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查第一列是否有零</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            firstColHasZero = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用第一行和第一列记录其他行列的零状态</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; cols; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据第一行和第一列的标记，置零其他行和列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; cols; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span> &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第一行有零，将第一行全部置零</span></span><br><span class="line">    <span class="keyword">if</span> firstRowHasZero &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cols; j++ &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第一列有零，将第一列全部置零</span></span><br><span class="line">    <span class="keyword">if</span> firstColHasZero &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m*n)</li>
<li>空间复杂度：O(1)，只使用了常数个额外变量</li>
</ul>
<h3 id="方法三：进一步优化的原地算法">方法三：进一步优化的原地算法</h3>
<p>我们可以通过一个技巧进一步简化方法二，只使用第一行来记录信息，并用一个额外变量记录第一列的状态。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">    cols := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    firstColHasZero := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次遍历，标记第一行和第一列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="comment">// 检查第一列是否有零</span></span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            firstColHasZero = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; cols; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后向前遍历，根据标记置零</span></span><br><span class="line">    <span class="keyword">for</span> i := rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := cols - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span> &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> firstColHasZero &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m*n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="我的错误分析">我的错误分析</h2>
<p>这道题我已经错了两次了，让我详细分析一下两次的错误原因。</p>
<h3 id="第一次错误解法">第一次错误解法</h3>
<p>第一次的解法没有保存第一行和第一列的原始状态：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	row := <span class="built_in">len</span>(matrix)</span><br><span class="line">	col := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> matrix[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">				matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">				matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col; j++ &#123;</span><br><span class="line">				matrix[i][j] = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; col; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> matrix[<span class="number">0</span>][i] == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; row; j++ &#123;</span><br><span class="line">				matrix[j][i] = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要问题：</p>
<ol>
<li><strong>没有保存首行和首列的原始状态</strong>：没有事先记录第一行和第一列是否原本就有0</li>
<li><strong>标记和置零顺序错误</strong>：直接根据已被修改的首行首列进行置零操作</li>
<li><strong>处理第一行和第一列的交叉点问题</strong>：matrix[0][0]同时表示行和列标记，信息冲突</li>
</ol>
<h3 id="第二次错误解法（最新的错误）">第二次错误解法（最新的错误）</h3>
<p>第二次我已经知道要保存第一行和第一列的原始状态，但在处理内部元素时又犯了新错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	row := <span class="built_in">len</span>(matrix)</span><br><span class="line">	col := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	row0, col0 := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 正确保存了第一列的原始状态</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> row &#123;</span><br><span class="line">		<span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">			col0 = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 正确保存了第一行的原始状态</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> col &#123;</span><br><span class="line">		<span class="keyword">if</span> matrix[<span class="number">0</span>][i] == <span class="number">0</span> &#123;</span><br><span class="line">			row0 = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 正确标记了需要置零的行和列</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> matrix[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">				matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">				matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ❌ 错误：分离处理行和列，且从第0行开始</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; col; j++ &#123;</span><br><span class="line">				matrix[i][j] = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; col; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> matrix[<span class="number">0</span>][i] == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; row; j++ &#123;</span><br><span class="line">				matrix[j][i] = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后面的处理是正确的...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二次错误的关键问题</strong>：</p>
<ol>
<li><strong>错误的处理顺序</strong>：从 i=0 开始处理行，这会影响第一行，但第一行应该最后单独处理</li>
<li><strong>分离处理逻辑错误</strong>：用两个分离的循环分别处理行和列，而不是统一处理所有内部元素</li>
<li><strong>逻辑不一致</strong>：这种分离处理可能导致某些位置被重复修改或遗漏</li>
</ol>
<p><strong>正确的处理方式</strong>应该是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确：统一处理所有内部元素，从(1,1)开始</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; row; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; col; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span> &#123;</span><br><span class="line">            matrix[i][j] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因总结">错误原因总结</h3>
<p>两次错误都反映了对原地算法的理解不够深入：</p>
<ol>
<li><strong>第一次</strong>：没有意识到需要保存第一行和第一列的原始状态</li>
<li><strong>第二次</strong>：虽然保存了原始状态，但在处理内部元素时采用了错误的分离处理策略</li>
</ol>
<p><strong>关键教训</strong>：在原地修改矩阵时，必须严格区分：</p>
<ul>
<li>信息收集阶段（标记）</li>
<li>信息处理阶段（置零内部元素）</li>
<li>边界处理阶段（处理第一行第一列）</li>
</ul>
<p>三个阶段不能混淆，否则会导致错误的结果。</p>
<h2 id="总结">总结</h2>
<p>矩阵置零问题是一个典型的原地修改矩阵的问题，关键在于如何记录需要置零的行和列信息而不干扰原矩阵的遍历过程。我在这道题上犯了两次错误，深刻体现了原地算法的复杂性。</p>
<p><strong>最优解法的核心思想</strong>：</p>
<ol>
<li>利用矩阵的第一行和第一列作为标记空间</li>
<li>用额外变量记录第一行和第一列本身是否需要置零</li>
<li>严格按照三个阶段执行：标记→处理内部→处理边界</li>
</ol>
<p><strong>关键教训</strong>：</p>
<ul>
<li><strong>第一次错误</strong>教会我必须保存第一行第一列的原始状态</li>
<li><strong>第二次错误</strong>教会我不能分离处理行和列，必须统一处理所有内部元素</li>
<li><strong>核心原则</strong>：在原地算法中，要严格区分信息收集、信息处理和边界处理三个阶段，避免阶段间的相互干扰</li>
</ul>
<p>这道题的空间复杂度可以优化到 O(1)，但实现的复杂度远高于看起来的样子。每一个细节都很重要，一个小的逻辑错误就可能导致整个算法失败。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>矩阵</tag>
        <tag>原地算法</tag>
        <tag>空间优化</tag>
        <tag>🔥二次错误</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从复制详解：原理、优化与故障处理</title>
    <url>/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1>Redis主从复制详解</h1>
<h2 id="前言">前言</h2>
<p>在之前的文章中，我们学习了Redis的AOF和RDB持久化技术，这两种技术可以保证即使服务器重启也不会丢失数据（或仅丢失少量数据）。</p>
<p>但是，将所有数据存储在一台服务器上仍然存在风险：</p>
<ul>
<li><strong>服务器宕机</strong>：数据恢复需要时间，期间无法提供服务</li>
<li><strong>硬盘故障</strong>：可能导致数据完全丢失</li>
</ul>
<p>为了解决这些<strong>单点故障</strong>问题，最好的方案是将数据备份到多台服务器上，让这些服务器都能对外提供服务。这样即使一台服务器出现故障，其他服务器仍能继续工作。</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956095442.png" alt="1748956095442"></p>
<p>但这样又带来了新的问题：</p>
<ul>
<li>多台服务器之间如何保持数据一致性？</li>
<li>读写操作应该如何分配？</li>
</ul>
<p>Redis通过<strong>主从复制模式</strong>解决了这些问题。</p>
<h2 id="什么是主从复制？">什么是主从复制？</h2>
<p>主从复制是一种数据同步机制，具有以下特点：</p>
<ol>
<li><strong>一主多从</strong>：一个主服务器（Master），多个从服务器（Slave）</li>
<li><strong>读写分离</strong>：主服务器负责写操作，从服务器负责读操作</li>
<li><strong>自动同步</strong>：主服务器的写操作会自动同步到从服务器</li>
</ol>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956101047.png" alt="1748956101047"></p>
<p>这样设计的好处是：</p>
<ul>
<li>保证了数据的一致性</li>
<li>提高了系统的可用性</li>
<li>实现了读写分离，提升了性能</li>
</ul>
<h2 id="主从复制的工作原理">主从复制的工作原理</h2>
<h3 id="建立主从关系">建立主从关系</h3>
<p>要建立主从关系，我们使用<code>replicaof</code>命令（Redis 5.0之前使用<code>slaveof</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在从服务器上执行</span></span><br><span class="line">replicaof &lt;主服务器IP&gt; &lt;主服务器端口&gt;</span><br></pre></td></tr></table></figure>
<p>执行这个命令后，从服务器就会成为主服务器的从服务器，并开始同步数据。</p>
<h3 id="第一次同步过程">第一次同步过程</h3>
<p>主从服务器的第一次同步分为三个阶段：</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956109396.png" alt="1748956109396"></p>
<h4 id="第一阶段：建立连接、协商同步">第一阶段：建立连接、协商同步</h4>
<ol>
<li>
<p><strong>发送psync命令</strong>：从服务器向主服务器发送<code>psync</code>命令</p>
<ul>
<li><code>runID</code>：主服务器的唯一标识（第一次为&quot;?&quot;）</li>
<li><code>offset</code>：复制进度（第一次为-1）</li>
</ul>
</li>
<li>
<p><strong>响应FULLRESYNC</strong>：主服务器返回<code>FULLRESYNC</code>命令</p>
<ul>
<li>包含主服务器的runID和当前复制进度offset</li>
<li>表示将进行全量复制</li>
</ul>
</li>
</ol>
<h4 id="第二阶段：主服务器同步数据">第二阶段：主服务器同步数据</h4>
<ol>
<li><strong>生成RDB文件</strong>：主服务器执行<code>bgsave</code>命令生成RDB快照</li>
<li><strong>发送RDB文件</strong>：将RDB文件传输给从服务器</li>
<li><strong>加载RDB文件</strong>：从服务器清空旧数据，加载新的RDB文件</li>
</ol>
<p><strong>重要</strong>：在生成、传输、加载RDB期间，主服务器收到的新写命令会保存在<code>replication buffer</code>缓冲区中。</p>
<h4 id="第三阶段：发送增量数据">第三阶段：发送增量数据</h4>
<ol>
<li>从服务器加载完RDB后，发送确认消息给主服务器</li>
<li>主服务器将<code>replication buffer</code>中的增量数据发送给从服务器</li>
<li>从服务器执行这些命令，完成数据同步</li>
</ol>
<h3 id="命令传播">命令传播</h3>
<p>第一次同步完成后，主从服务器维护一个<strong>长连接</strong>：</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956117873.png" alt="1748956117873"></p>
<ul>
<li>主服务器通过这个连接持续将写命令发送给从服务器</li>
<li>从服务器执行这些命令，保持数据一致性</li>
<li>使用长连接避免了频繁建立连接的开销</li>
</ul>
<h2 id="性能优化策略">性能优化策略</h2>
<h3 id="分摊主服务器压力">分摊主服务器压力</h3>
<p>当从服务器数量很多时，主服务器可能面临压力：</p>
<ul>
<li>频繁fork进程生成RDB文件</li>
<li>大量网络带宽用于传输RDB文件</li>
</ul>
<p><strong>解决方案</strong>：建立多级主从架构</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956126945.png" alt="1748956126945"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让从服务器也成为其他服务器的主服务器</span></span><br><span class="line">replicaof &lt;中间服务器IP&gt; 6379</span><br></pre></td></tr></table></figure>
<p>这样可以：</p>
<ul>
<li>减轻主服务器的CPU压力</li>
<li>分摊网络带宽使用</li>
<li>提高整体的扩展性</li>
</ul>
<h2 id="增量复制机制">增量复制机制</h2>
<h3 id="网络断开重连问题">网络断开重连问题</h3>
<p>在命令传播阶段，如果网络中断会怎么办？</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956137173.png" alt="1748956137173"></p>
<p><strong>Redis 2.8之前</strong>：重新进行全量复制（效率低）<br>
<strong>Redis 2.8之后</strong>：采用增量复制（只同步断线期间的数据）</p>
<h3 id="增量复制过程">增量复制过程</h3>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956142843.png" alt="1748956142843"></p>
<ol>
<li><strong>重连请求</strong>：从服务器发送psync命令（offset不是-1）</li>
<li><strong>响应CONTINUE</strong>：主服务器决定采用增量复制</li>
<li><strong>发送增量数据</strong>：主服务器发送断线期间的写命令</li>
</ol>
<h3 id="关键组件">关键组件</h3>
<h4 id="repl-backlog-buffer环形缓冲区">repl_backlog_buffer环形缓冲区</h4>
<ul>
<li><strong>作用</strong>：保存最近的写命令</li>
<li><strong>特点</strong>：环形结构，写满后覆盖旧数据</li>
<li><strong>默认大小</strong>：1MB</li>
</ul>
<h4 id="replication-offset复制偏移量">replication offset复制偏移量</h4>
<ul>
<li><strong>master_repl_offset</strong>：主服务器写入位置</li>
<li><strong>slave_repl_offset</strong>：从服务器读取位置</li>
</ul>
<h3 id="同步策略判断">同步策略判断</h3>
<p>主服务器根据偏移量差异决定同步方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 slave要读取的数据 在 repl_backlog_buffer中：</span><br><span class="line">    执行增量复制</span><br><span class="line">否则：</span><br><span class="line">    执行全量复制</span><br></pre></td></tr></table></figure>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/1748956152362.png" alt="1748956152362"></p>
<h3 id="缓冲区大小优化">缓冲区大小优化</h3>
<p>为避免频繁全量复制，需要合理设置缓冲区大小：</p>
<p><strong>计算公式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl_backlog_buffer_size = write_size_per_second × 断线重连时间(秒)</span><br></pre></td></tr></table></figure>
<p><strong>举例</strong>：</p>
<ul>
<li>主服务器每秒产生1MB写命令</li>
<li>平均断线重连需要5秒</li>
<li>建议缓冲区大小：5MB × 2 = 10MB</li>
</ul>
<p><strong>配置方法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置文件</span></span><br><span class="line">repl-backlog-size 10mb</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>Redis主从复制包含三种核心机制：</p>
<ol>
<li><strong>全量复制</strong>：第一次同步，传输完整数据</li>
<li><strong>命令传播</strong>：基于长连接的实时同步</li>
<li><strong>增量复制</strong>：网络恢复后的差异同步</li>
</ol>
<p><strong>关键优化点</strong>：</p>
<ul>
<li>使用多级主从架构分摊压力</li>
<li>合理配置repl_backlog_buffer大小</li>
<li>保证主从节点网络稳定性</li>
</ul>
<h2 id="面试题详解">面试题详解</h2>
<h3 id="Redis主从节点是长连接还是短连接？">Redis主从节点是长连接还是短连接？</h3>
<p><strong>答案</strong>：长连接</p>
<p><strong>解释</strong>：主从服务器在完成第一次全量同步后，会维护一个TCP长连接用于命令传播，避免频繁建立和断开连接的性能开销。</p>
<h3 id="怎么判断Redis某个节点是否正常工作？">怎么判断Redis某个节点是否正常工作？</h3>
<p><strong>答案</strong>：通过ping-pong心跳检测机制</p>
<p><strong>详细说明</strong>：</p>
<ul>
<li><strong>主节点监控</strong>：默认每10秒向从节点发送ping命令（可通过<code>repl-ping-slave-period</code>配置）</li>
<li><strong>从节点上报</strong>：每1秒发送<code>replconf ack&#123;offset&#125;</code>命令，包含：
<ul>
<li>实时监测网络状态</li>
<li>上报复制偏移量</li>
<li>检查数据是否丢失</li>
</ul>
</li>
<li><strong>失效判断</strong>：当一半以上节点ping某个节点无响应时，认为该节点下线</li>
</ul>
<h3 id="主从复制架构中，过期key如何处理？">主从复制架构中，过期key如何处理？</h3>
<p><strong>答案</strong>：由主节点统一处理</p>
<p><strong>处理流程</strong>：</p>
<ol>
<li>主节点检测到key过期或通过淘汰算法删除key</li>
<li>主节点模拟发送<code>del</code>命令给所有从节点</li>
<li>从节点收到删除命令后执行相应操作</li>
<li>保证主从节点对过期key处理的一致性</li>
</ol>
<h3 id="Redis是同步复制还是异步复制？">Redis是同步复制还是异步复制？</h3>
<p><strong>答案</strong>：异步复制</p>
<p><strong>特点</strong>：</p>
<ul>
<li>主节点收到写命令后立即返回给客户端</li>
<li>写命令先存入内部缓冲区，然后异步发送给从节点</li>
<li>优点：响应速度快，不阻塞主节点</li>
<li>缺点：可能存在短暂的数据不一致</li>
</ul>
<h3 id="主从复制中两个Buffer有什么区别？">主从复制中两个Buffer有什么区别？</h3>
<p><strong>replication buffer vs repl backlog buffer</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>replication buffer</th>
<th>repl backlog buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>出现阶段</strong></td>
<td>全量复制 + 增量复制</td>
<td>仅增量复制</td>
</tr>
<tr>
<td><strong>分配方式</strong></td>
<td>每个从节点一个</td>
<td>整个主节点一个</td>
</tr>
<tr>
<td><strong>满了之后</strong></td>
<td>断开连接，重新全量复制</td>
<td>覆盖旧数据（环形结构）</td>
</tr>
<tr>
<td><strong>主要作用</strong></td>
<td>缓存待发送的命令</td>
<td>支持增量复制</td>
</tr>
</tbody>
</table>
<h3 id="如何应对主从数据不一致？">如何应对主从数据不一致？</h3>
<p><strong>产生原因</strong>：主从复制是异步的，存在网络延迟</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>
<p><strong>网络优化</strong>：</p>
<ul>
<li>保证主从节点网络连接质量</li>
<li>避免跨机房部署</li>
</ul>
</li>
<li>
<p><strong>监控复制进度</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看复制进度</span></span><br><span class="line">INFO replication</span><br></pre></td></tr></table></figure>
<ul>
<li>监控<code>master_repl_offset</code>和<code>slave_repl_offset</code>差值</li>
<li>当差值超过阈值时，暂时停止从该从节点读取数据</li>
</ul>
</li>
<li>
<p><strong>设置合理阈值</strong>：</p>
<ul>
<li>根据业务需求设置可接受的数据延迟范围</li>
<li>在一致性和可用性之间找到平衡</li>
</ul>
</li>
</ol>
<h3 id="主从切换如何减少数据丢失？">主从切换如何减少数据丢失？</h3>
<p><strong>数据丢失场景</strong>：</p>
<h4 id="1-异步复制数据丢失">1. 异步复制数据丢失</h4>
<p><strong>原因</strong>：主节点收到写请求后立即返回，但还未同步到从节点时宕机</p>
<p><strong>解决方案</strong>：配置<code>min-slaves-max-lag</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当所有从节点复制延迟超过10秒时，主节点拒绝写入</span></span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>
<p><strong>降级策略</strong>：</p>
<ul>
<li>将数据写入本地缓存/磁盘</li>
<li>使用消息队列（如Kafka）缓存数据</li>
<li>主节点恢复后重新写入</li>
</ul>
<h4 id="2-脑裂数据丢失">2. 脑裂数据丢失</h4>
<p><strong>原因</strong>：网络分区导致出现两个主节点，旧主节点数据在重新加入时被清空</p>
<p><strong>解决方案</strong>：组合使用两个参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">至少需要1个从节点连接</span></span><br><span class="line">min-slaves-to-write 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制延迟不能超过12秒</span></span><br><span class="line">min-slaves-max-lag 12</span><br></pre></td></tr></table></figure>
<p><strong>保护机制</strong>：</p>
<ul>
<li>当条件不满足时，主节点拒绝写入</li>
<li>防止在网络分区期间写入无法同步的数据</li>
<li>确保只有健康的主节点能接收写请求</li>
</ul>
<p><strong>实际案例</strong>：<br>
假设配置：</p>
<ul>
<li><code>min-slaves-to-write = 1</code></li>
<li><code>min-slaves-max-lag = 12s</code></li>
<li>哨兵<code>down-after-milliseconds = 10s</code></li>
</ul>
<p>当主节点卡住15秒时：</p>
<ol>
<li>哨兵在10秒后判断主节点下线，开始主从切换</li>
<li>由于超过12秒无法与从节点同步，主节点停止接收写请求</li>
<li>切换完成后，只有新主节点能接收请求，避免数据丢失</li>
</ol>
<h3 id="主从如何做到故障自动切换？">主从如何做到故障自动切换？</h3>
<p><strong>问题</strong>：主节点故障时，从节点无法自动升级为主节点</p>
<p><strong>解决方案</strong>：Redis哨兵机制（Sentinel）</p>
<p><strong>哨兵功能</strong>：</p>
<ul>
<li><strong>故障发现</strong>：自动检测主节点是否可用</li>
<li><strong>故障转移</strong>：自动选举新的主节点</li>
<li><strong>通知应用</strong>：将变更通知给客户端</li>
<li><strong>配置管理</strong>：更新主从配置信息</li>
</ul>
<p><strong>实现高可用</strong>：</p>
<ul>
<li>无需人工干预</li>
<li>快速故障恢复</li>
<li>保证服务连续性</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>高可用</tag>
        <tag>Redis</tag>
        <tag>主从复制</tag>
        <tag>数据同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 过期删除策略和内存淘汰策略有什么区别？</title>
    <url>/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
    <content><![CDATA[<h1>Redis 过期删除策略和内存淘汰策略有什么区别？</h1>
<p>Redis 的「内存淘汰策略」和「过期删除策略」，很多小伙伴容易混淆。就像家里的冰箱一样，这两个机制虽然都是在&quot;清理东西&quot;，但是触发的条件和清理的方式完全不同。</p>
<p>今天就跟大家理一理，「内存淘汰策略」和「过期删除策略」到底有什么区别。</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940271743.png" alt="1748940271743"></p>
<h2 id="过期删除策略">过期删除策略</h2>
<p>Redis 可以给数据设置&quot;保质期&quot;（过期时间），就像超市里的商品都有保质期一样。当数据过期后，Redis 需要有相应的机制来清理这些&quot;过期商品&quot;，这就是过期键值删除策略的作用。</p>
<h3 id="如何给数据设置-保质期-？">如何给数据设置&quot;保质期&quot;？</h3>
<p>Redis 提供了多种方式来给数据设置过期时间，就像给食物贴上不同格式的保质期标签一样。</p>
<p><strong>设置过期时间的命令：</strong></p>
<ul>
<li><code>expire &lt;key&gt; &lt;n&gt;</code>：设置数据在 n 秒后过期
<ul>
<li>例如：<code>expire milk 86400</code> 表示牛奶在 86400 秒（1天）后过期</li>
</ul>
</li>
<li><code>pexpire &lt;key&gt; &lt;n&gt;</code>：设置数据在 n 毫秒后过期（更精确）
<ul>
<li>例如：<code>pexpire bread 3600000</code> 表示面包在 3600000 毫秒（1小时）后过期</li>
</ul>
</li>
<li><code>expireat &lt;key&gt; &lt;n&gt;</code>：设置数据在某个具体时间点过期
<ul>
<li>例如：<code>expireat fruit 1655654400</code> 表示水果在时间戳 1655654400 后过期</li>
</ul>
</li>
<li><code>pexpireat &lt;key&gt; &lt;n&gt;</code>：设置数据在某个具体时间点过期（精确到毫秒）</li>
</ul>
<p><strong>在存储数据时同时设置过期时间：</strong></p>
<ul>
<li><code>set &lt;key&gt; &lt;value&gt; ex &lt;n&gt;</code>：存数据的同时设置过期时间（秒）</li>
<li><code>set &lt;key&gt; &lt;value&gt; px &lt;n&gt;</code>：存数据的同时设置过期时间（毫秒）</li>
<li><code>setex &lt;key&gt; &lt;n&gt; &lt;value&gt;</code>：存数据的同时设置过期时间（秒）</li>
</ul>
<p><strong>查看剩余&quot;保质期&quot;：</strong></p>
<p>使用 <code>TTL &lt;key&gt;</code> 命令可以查看数据还有多长时间过期，就像查看食物还能放多久一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储牛奶，设置60秒后过期</span></span><br><span class="line">&gt; setex milk 60 <span class="string">&quot;fresh_milk&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看牛奶还能放多久</span></span><br><span class="line">&gt; ttl milk</span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br><span class="line">&gt; ttl milk</span><br><span class="line">(<span class="built_in">integer</span>) 52</span><br></pre></td></tr></table></figure>
<p><strong>取消过期时间：</strong></p>
<p>如果突然不想让数据过期了，可以使用 <code>PERSIST &lt;key&gt;</code> 命令，就像把食物放进冷冻室永久保存一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取消牛奶的过期时间</span></span><br><span class="line">&gt; persist milk</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果，-1 表示永不过期</span></span><br><span class="line">&gt; ttl milk </span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure>
<h3 id="Redis-怎么知道数据已经-过期-了？">Redis 怎么知道数据已经&quot;过期&quot;了？</h3>
<p>每当我们给数据设置过期时间时，Redis 就会把这个信息记录在一个叫做**“过期字典”**的地方，就像超市的管理系统记录每个商品的保质期一样。</p>
<p>这个过期字典的结构很简单：</p>
<ul>
<li><strong>字典的 key</strong>：指向具体的数据</li>
<li><strong>字典的 value</strong>：记录这个数据什么时候过期</li>
</ul>
<p>过期字典的数据结构如下图所示：</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940284285.png" alt="1748940284285"></p>
<p><strong>判断数据是否过期的流程：</strong></p>
<p>当我们要使用某个数据时，Redis 会先检查这个数据是否在&quot;过期字典&quot;中：</p>
<ul>
<li>如果不在：说明这个数据没有设置过期时间，可以正常使用</li>
<li>如果在：就拿出过期时间和当前时间比较
<ul>
<li>如果还没到过期时间：可以正常使用</li>
<li>如果已经过期：这个数据就不能用了</li>
</ul>
</li>
</ul>
<p>这个判断流程如下图所示：</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940292820.png" alt="1748940292820"></p>
<h3 id="过期数据的清理方式有哪些？">过期数据的清理方式有哪些？</h3>
<p>就像处理过期食物一样，我们有不同的清理策略。让我们用生活中的例子来理解这三种策略：</p>
<blockquote>
<p><strong>定时删除策略</strong>：设置闹钟提醒</p>
</blockquote>
<p><strong>工作方式</strong>：给每个数据设置一个&quot;闹钟&quot;，时间一到就立即删除。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>过期数据能立即被清理，内存利用率最高</li>
<li>就像设置闹钟提醒扔垃圾，垃圾不会堆积</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果过期数据很多，就需要很多&quot;闹钟&quot;，会消耗大量 CPU 资源</li>
<li>就像同时设置100个闹钟，会让你忙得团团转</li>
</ul>
<blockquote>
<p><strong>惰性删除策略</strong>：用时再检查</p>
</blockquote>
<p><strong>工作方式</strong>：不主动清理过期数据，只有在要使用某个数据时，才检查它是否过期。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>很省 CPU 资源，因为只在需要时才检查</li>
<li>就像冰箱里的食物，只有在要吃的时候才检查是否过期</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果某个过期数据一直没人用，它就会一直占用内存空间</li>
<li>就像冰箱里放了很久的过期食物，如果不去看就不会清理</li>
</ul>
<blockquote>
<p><strong>定期删除策略</strong>：定期大扫除</p>
</blockquote>
<p><strong>工作方式</strong>：每隔一段时间随机检查一批数据，删除其中过期的。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>在 CPU 消耗和内存利用之间找到了平衡</li>
<li>就像定期整理冰箱，既不会太累，也不会让过期食物堆积太多</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>清理效果不如定时删除彻底</li>
<li>资源消耗比惰性删除多一些</li>
<li>很难确定多久检查一次最合适</li>
</ul>
<h3 id="Redis-选择了哪种策略？">Redis 选择了哪种策略？</h3>
<p>Redis 很聪明，它没有只用一种策略，而是选择了**“惰性删除 + 定期删除”**的组合，就像我们既会在用食物前检查是否过期，也会定期整理冰箱一样。</p>
<blockquote>
<p><strong>Redis 的惰性删除实现</strong></p>
</blockquote>
<p>Redis 在每次访问数据之前，都会先检查这个数据是否过期：</p>
<ul>
<li>如果过期了：删除这个数据，返回空值给用户</li>
<li>如果没过期：正常返回数据</li>
</ul>
<p>这个检查流程如下图：</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940304775.png" alt="1748940304775"></p>
<blockquote>
<p><strong>Redis 的定期删除实现</strong></p>
</blockquote>
<p><strong>检查频率</strong>：Redis 默认每秒进行 10 次过期检查，这个频率可以通过配置文件调整（参数名：hz，默认值是 10）。</p>
<p><strong>检查流程</strong>：</p>
<ol>
<li>随机选择 20 个设置了过期时间的数据</li>
<li>检查这 20 个数据是否过期，删除已过期的</li>
<li>如果过期数据超过 5 个（即超过 25%），继续重复步骤 1</li>
<li>如果过期数据少于 25%，等待下次检查</li>
</ol>
<p><strong>时间限制</strong>：为了防止检查时间过长影响正常服务，每次检查最多不超过 25 毫秒。</p>
<p>用伪代码描述这个流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//统计过期的数量</span></span><br><span class="line">    expired = <span class="number">0</span>；</span><br><span class="line">    <span class="comment">//每次检查20个</span></span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">        <span class="comment">//1. 随机选择1个有过期时间的数据</span></span><br><span class="line">        <span class="comment">//2. 检查是否过期，如果过期就删除，expired++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果检查时间超过限制，立即退出</span></span><br><span class="line">    <span class="keyword">if</span> (时间超过<span class="number">25</span>毫秒) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果过期数据超过25%，继续检查，否则结束本轮 */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (expired &gt; <span class="number">20</span>/<span class="number">4</span>); </span><br></pre></td></tr></table></figure>
<p>定期删除的完整流程如下图：</p>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940315515.png" alt="1748940315515"></p>
<h2 id="内存淘汰策略">内存淘汰策略</h2>
<p>如果说过期删除策略是清理&quot;过期食物&quot;，那么内存淘汰策略就是当&quot;冰箱满了&quot;时决定扔掉什么东西。</p>
<p>当 Redis 使用的内存超过了我们设置的上限时，就会启动内存淘汰策略来删除一些数据，确保 Redis 能继续正常工作。</p>
<h3 id="如何设置-Redis-的-冰箱大小-？">如何设置 Redis 的&quot;冰箱大小&quot;？</h3>
<p>在 Redis 的配置文件中，可以通过 <code>maxmemory</code> 参数设置最大内存限制：</p>
<p><strong>不同系统的默认设置：</strong></p>
<ul>
<li><strong>64位系统</strong>：默认没有限制（maxmemory = 0），可能导致内存用完系统崩溃</li>
<li><strong>32位系统</strong>：默认限制为 3GB，因为32位系统最多只能使用 4GB 内存</li>
</ul>
<h3 id="Redis-的内存淘汰策略有哪些？">Redis 的内存淘汰策略有哪些？</h3>
<p>Redis 提供了 8 种内存淘汰策略，可以分为两大类：</p>
<p><strong>第一类：不淘汰数据</strong></p>
<p><strong>noeviction</strong>（默认策略）：</p>
<ul>
<li>当内存满了，不删除任何数据</li>
<li>新的写入操作会报错，但查询和删除操作正常</li>
<li>就像冰箱满了就不再放新东西，但可以继续使用已有的</li>
</ul>
<p><strong>第二类：淘汰数据</strong></p>
<p>这类策略又分为两个子类：</p>
<p><strong>在有过期时间的数据中选择：</strong></p>
<ul>
<li><strong>volatile-random</strong>：随机删除有过期时间的数据</li>
<li><strong>volatile-ttl</strong>：优先删除快要过期的数据</li>
<li><strong>volatile-lru</strong>：删除有过期时间的数据中，最久没用过的</li>
<li><strong>volatile-lfu</strong>：删除有过期时间的数据中，使用频率最低的</li>
</ul>
<p><strong>在所有数据中选择：</strong></p>
<ul>
<li><strong>allkeys-random</strong>：随机删除任意数据</li>
<li><strong>allkeys-lru</strong>：删除所有数据中最久没用过的</li>
<li><strong>allkeys-lfu</strong>：删除所有数据中使用频率最低的</li>
</ul>
<blockquote>
<p><strong>查看当前策略</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">2) <span class="string">&quot;noeviction&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>修改策略</strong></p>
</blockquote>
<p>有两种方法：</p>
<ol>
<li><strong>临时修改</strong>：<code>config set maxmemory-policy allkeys-lru</code>（重启后失效）</li>
<li><strong>永久修改</strong>：在配置文件中设置 <code>maxmemory-policy allkeys-lru</code>（需要重启）</li>
</ol>
<h3 id="LRU-和-LFU-算法有什么区别？">LRU 和 LFU 算法有什么区别？</h3>
<p>这两个算法是内存淘汰的核心，让我们用生活例子来理解：</p>
<blockquote>
<p><strong>LRU 算法：最近最少使用</strong></p>
</blockquote>
<p><strong>核心思想</strong>：最近用过的东西将来可能还会用，很久没用的东西可以扔掉。</p>
<p><strong>生活例子</strong>：</p>
<ul>
<li>就像整理衣柜，把最近穿过的衣服放在容易拿到的地方</li>
<li>把很久没穿的衣服放在最里面，衣柜满了就先扔掉最里面的</li>
</ul>
<p><strong>Redis 的实现方式</strong>：</p>
<ul>
<li>不使用传统的链表（太耗资源）</li>
<li>而是记录每个数据的最后访问时间</li>
<li>内存不够时，随机取5个数据，删除其中最久没用过的</li>
</ul>
<p><strong>LRU 的问题</strong>：<br>
假如你一次性看了很多电影，这些电影可能以后再也不会看，但它们会在&quot;最近使用&quot;列表的前面很久，这就是<strong>缓存污染</strong>。</p>
<blockquote>
<p><strong>LFU 算法：最少频率使用</strong></p>
</blockquote>
<p><strong>核心思想</strong>：经常用的东西将来还会经常用，很少用的东西可以扔掉。</p>
<p><strong>生活例子</strong>：</p>
<ul>
<li>就像整理厨房，经常用的锅碗瓢盆放在方便的地方</li>
<li>很少用的工具可以收起来或扔掉</li>
<li>不是看最近用没用，而是看用的频率高不高</li>
</ul>
<p><strong>Redis 的实现方式</strong>：<br>
Redis 为每个数据记录两个信息：</p>
<ul>
<li><strong>访问时间</strong>：最后一次使用的时间</li>
<li><strong>访问频率</strong>：使用的频繁程度（不是简单的次数）</li>
</ul>
<p><strong>频率的计算很巧妙</strong>：</p>
<ol>
<li><strong>衰减</strong>：时间越久，频率会自动降低</li>
<li><strong>增长</strong>：每次访问会增加频率，但已经很高的频率增长会很慢</li>
</ol>
<p>这样设计的好处：</p>
<ul>
<li>解决了 LRU 的缓存污染问题</li>
<li>一次性访问大量数据不会影响真正常用的数据</li>
</ul>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940330817.png" alt="1748940330817"></p>
<p><strong>可以调整的参数</strong>：</p>
<ul>
<li><code>lfu-decay-time</code>：控制频率衰减速度（值越大衰减越慢）</li>
<li><code>lfu-log-factor</code>：控制频率增长速度（值越大增长越慢）</li>
</ul>
<h2 id="总结">总结</h2>
<p>让我们用一个完整的比喻来总结这两个机制：</p>
<p><strong>过期删除策略</strong>就像管理冰箱里的食物：</p>
<ul>
<li>给食物贴上保质期标签（设置过期时间）</li>
<li>用的时候检查是否过期（惰性删除）</li>
<li>定期整理冰箱清理过期食物（定期删除）</li>
</ul>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940345098.png" alt="1748940345098"></p>
<p><strong>内存淘汰策略</strong>就像冰箱满了时的处理方式：</p>
<ul>
<li>设置冰箱的容量上限</li>
<li>根据不同策略决定扔掉什么东西</li>
</ul>
<p><img src="/2025/06/03/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/1748940352217.png" alt="1748940352217"></p>
<p><strong>两者的区别</strong>：</p>
<ul>
<li><strong>触发条件不同</strong>：过期删除是因为数据过期了，内存淘汰是因为空间不够了</li>
<li><strong>处理对象不同</strong>：过期删除只处理过期数据，内存淘汰可能删除任何数据</li>
<li><strong>目的不同</strong>：过期删除是为了数据时效性，内存淘汰是为了空间管理</li>
</ul>
<p>记住这个核心区别，就不会再搞混了！</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
        <tag>过期删除</tag>
        <tag>内存淘汰</tag>
        <tag>LRU</tag>
        <tag>LFU</tag>
        <tag>缓存策略</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 76 - 最小覆盖子串（Minimum Window Substring）</title>
    <url>/2025/06/03/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子串，返回空字符串。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>m == s.length</code></li>
<li><code>n == t.length</code></li>
<li><code>1 &lt;= m, n &lt;= 10^5</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<h2 id="错误分析">错误分析</h2>
<p>在初始实现中，存在几个关键的逻辑错误，让我们先看看<strong>错误的代码</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误版本的关键部分</span></span><br><span class="line"><span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">    rightAlpha := s[right]</span><br><span class="line">    right++</span><br><span class="line">    windowMap[rightAlpha]++</span><br><span class="line">    <span class="keyword">if</span> windowMap[rightAlpha] &lt;= alphaCnt[rightAlpha] &#123;</span><br><span class="line">        alphaNumCnt++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ❌ 错误的收缩逻辑</span></span><br><span class="line">    <span class="keyword">for</span> windowMap[rightAlpha] &gt; alphaCnt[rightAlpha] &#123;</span><br><span class="line">        leftAlpha := s[left]</span><br><span class="line">        <span class="keyword">if</span> windowMap[leftAlpha] &lt;= alphaCnt[leftAlpha] &#123;</span><br><span class="line">            alphaNumCnt--</span><br><span class="line">        &#125;</span><br><span class="line">        windowMap[leftAlpha]--</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ❌ 错误的有效窗口检查位置</span></span><br><span class="line">    <span class="keyword">if</span> alphaNumCnt == <span class="built_in">len</span>(t) &#123;</span><br><span class="line">        <span class="keyword">if</span> right-left &lt; minLength &#123;</span><br><span class="line">            minLength = right - left</span><br><span class="line">            minStart = left</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主要错误点">主要错误点</h3>
<ol>
<li><strong>错误的收缩时机</strong>：原代码在刚添加字符后立即尝试收缩窗口，这会导致过早地移除必要的字符</li>
<li><strong>错误的收缩条件</strong>：<code>windowMap[rightAlpha] &gt; alphaCnt[rightAlpha]</code> 只考虑刚添加的字符，而不是整个窗口状态</li>
<li><strong>错误的有效性检查</strong>：在收缩后检查窗口有效性，此时窗口可能已经被破坏</li>
</ol>
<h3 id="为什么会出错？">为什么会出错？</h3>
<p>让我们通过示例 <code>s = &quot;ADOBECODEBANC&quot;</code>, <code>t = &quot;ABC&quot;</code> 来分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当处理到第一个 &#x27;A&#x27; 时：</span><br><span class="line">- 右指针：0 → 1，窗口：&#x27;A&#x27;</span><br><span class="line">- alphaNumCnt = 1</span><br><span class="line">- windowMap[&#x27;A&#x27;] = 1, alphaCnt[&#x27;A&#x27;] = 1</span><br><span class="line">- 条件 windowMap[&#x27;A&#x27;] &gt; alphaCnt[&#x27;A&#x27;] 为 false，不收缩 ✓</span><br><span class="line"></span><br><span class="line">当处理到 &#x27;D&#x27;, &#x27;O&#x27;, &#x27;B&#x27; 时：</span><br><span class="line">- 右指针：1 → 4，窗口：&#x27;ADOB&#x27;</span><br><span class="line">- alphaNumCnt = 2 (A, B)</span><br><span class="line">- 这里都是正常的 ✓</span><br><span class="line"></span><br><span class="line">当处理到 &#x27;E&#x27; 时：</span><br><span class="line">- 右指针：4 → 5，窗口：&#x27;ADOBE&#x27;</span><br><span class="line">- &#x27;E&#x27; 不在 t 中，alphaCnt[&#x27;E&#x27;] = 0</span><br><span class="line">- ❌ 原逻辑：windowMap[&#x27;E&#x27;] &gt; alphaCnt[&#x27;E&#x27;] 为 true (1 &gt; 0)</span><br><span class="line">- ❌ 开始收缩，可能移除 &#x27;A&#x27; 或 &#x27;B&#x27;，破坏窗口有效性</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2>
<p>这是一个典型的<strong>滑动窗口</strong>问题。核心思路是：</p>
<ol>
<li><strong>扩张窗口</strong>：不断向右移动右指针，直到窗口包含 <code>t</code> 的所有字符</li>
<li><strong>收缩窗口</strong>：当窗口有效时，尝试向右移动左指针来最小化窗口</li>
<li><strong>记录答案</strong>：在收缩过程中更新最小窗口</li>
</ol>
<h3 id="算法流程">算法流程</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化：left = 0, right = 0</span><br><span class="line">记录 t 中每个字符的需求数量</span><br><span class="line">记录当前窗口中每个字符的数量</span><br><span class="line">记录已满足的字符数量</span><br><span class="line"></span><br><span class="line">while right &lt; len(s):</span><br><span class="line">    1. 将 s[right] 加入窗口</span><br><span class="line">    2. 如果加入的字符有助于满足 t 的需求，更新满足计数</span><br><span class="line">    3. 当窗口包含 t 的所有字符时：</span><br><span class="line">       a. 尝试更新最小窗口记录</span><br><span class="line">       b. 收缩窗口（移除 s[left]）</span><br><span class="line">       c. 如果移除的字符破坏了窗口有效性，停止收缩</span><br><span class="line">    4. right++</span><br></pre></td></tr></table></figure>
<h3 id="关键洞察">关键洞察</h3>
<ul>
<li><strong>何时收缩</strong>：只有当窗口<strong>已经有效</strong>时才收缩</li>
<li><strong>如何判断有效</strong>：当 <code>alphaNumCnt == len(t)</code> 时窗口有效</li>
<li><strong>收缩策略</strong>：贪心地收缩，直到窗口不再有效</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 统计 t 中每个字符的需求数量</span></span><br><span class="line">    alphaCnt := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">256</span>)</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> t &#123;</span><br><span class="line">        alphaCnt[c]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化变量</span></span><br><span class="line">    minLength := <span class="built_in">len</span>(s) + <span class="number">1</span>  <span class="comment">// 设为不可能的值，便于判断是否找到答案</span></span><br><span class="line">    minStart := <span class="number">0</span></span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    windowMap := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">256</span>)  <span class="comment">// 窗口中每个字符的数量</span></span><br><span class="line">    alphaNumCnt := <span class="number">0</span>  <span class="comment">// 已满足的 t 中字符的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 滑动窗口主循环</span></span><br><span class="line">    <span class="keyword">for</span> right &lt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="comment">// 扩张窗口：加入 s[right]</span></span><br><span class="line">        rightAlpha := s[right]</span><br><span class="line">        right++</span><br><span class="line">        windowMap[rightAlpha]++</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果新加入的字符有助于满足 t 的需求</span></span><br><span class="line">        <span class="keyword">if</span> windowMap[rightAlpha] &lt;= alphaCnt[rightAlpha] &#123;</span><br><span class="line">            alphaNumCnt++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当窗口有效时，尝试收缩</span></span><br><span class="line">        <span class="keyword">for</span> alphaNumCnt == <span class="built_in">len</span>(t) &#123;</span><br><span class="line">            <span class="comment">// 更新最小窗口记录</span></span><br><span class="line">            <span class="keyword">if</span> right-left &lt; minLength &#123;</span><br><span class="line">                minLength = right - left</span><br><span class="line">                minStart = left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 收缩窗口：移除 s[left]</span></span><br><span class="line">            leftAlpha := s[left]</span><br><span class="line">            <span class="keyword">if</span> windowMap[leftAlpha] &lt;= alphaCnt[leftAlpha] &#123;</span><br><span class="line">                alphaNumCnt--  <span class="comment">// 移除关键字符，窗口将变为无效</span></span><br><span class="line">            &#125;</span><br><span class="line">            windowMap[leftAlpha]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回结果</span></span><br><span class="line">    <span class="keyword">if</span> minLength &gt; <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>  <span class="comment">// 没有找到有效窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[minStart : minStart+minLength]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解析">代码解析</h3>
<ol>
<li><strong>字符计数</strong>：使用数组 <code>alphaCnt</code> 记录 <code>t</code> 中每个字符的需求数量</li>
<li><strong>窗口状态</strong>：<code>windowMap</code> 记录当前窗口中每个字符的数量</li>
<li><strong>有效性判断</strong>：<code>alphaNumCnt</code> 记录已满足需求的字符总数</li>
<li><strong>边界处理</strong>：<code>minLength</code> 初始化为 <code>len(s) + 1</code>，便于判断是否找到解</li>
</ol>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以 <code>s = &quot;ADOBECODEBANC&quot;</code>, <code>t = &quot;ABC&quot;</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step 1: right=1, window=&quot;A&quot;, alphaNumCnt=1, 窗口无效</span><br><span class="line">step 2: right=2, window=&quot;AD&quot;, alphaNumCnt=1, 窗口无效  </span><br><span class="line">step 3: right=3, window=&quot;ADO&quot;, alphaNumCnt=1, 窗口无效</span><br><span class="line">step 4: right=4, window=&quot;ADOB&quot;, alphaNumCnt=2, 窗口无效</span><br><span class="line">step 5: right=5, window=&quot;ADOBE&quot;, alphaNumCnt=2, 窗口无效</span><br><span class="line">step 6: right=6, window=&quot;ADOBEC&quot;, alphaNumCnt=3, 窗口有效！</span><br><span class="line">        开始收缩：left=0→1→2→3，窗口=&quot;DOBEC&quot;→&quot;OBEC&quot;→&quot;BEC&quot;→&quot;EC&quot;</span><br><span class="line">        当 left=3 时，移除 &#x27;B&#x27;，alphaNumCnt=2，窗口无效，停止收缩</span><br><span class="line">        记录答案：minLength=6, minStart=0</span><br><span class="line">...继续处理后续字符...</span><br><span class="line">step 13: right=13, window=&quot;BANC&quot;, alphaNumCnt=3, 窗口有效！</span><br><span class="line">         收缩后得到更短的窗口 &quot;BANC&quot;，更新答案</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-s-t">时间复杂度：$O(|s| + |t|)$</h3>
<ul>
<li>右指针 <code>right</code> 遍历字符串 <code>s</code> 一次：$O(|s|)$</li>
<li>左指针 <code>left</code> 最多也遍历字符串 <code>s</code> 一次：$O(|s|)$</li>
<li>统计字符串 <code>t</code>：$O(|t|)$</li>
<li>总计：$O(|s| + |t|)$</li>
</ul>
<h3 id="空间复杂度：-O-1">空间复杂度：$O(1)$</h3>
<ul>
<li>使用固定大小的数组 <code>alphaCnt</code> 和 <code>windowMap</code>：$O(256) = O(1)$</li>
<li>其他变量都是常数空间</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>滑动窗口的标准模板</strong>：</p>
<ul>
<li>扩张窗口收集元素</li>
<li>当窗口满足条件时收缩窗口</li>
<li>在收缩过程中更新答案</li>
</ul>
</li>
<li>
<p><strong>常见陷阱</strong>：</p>
<ul>
<li>❌ 不要在窗口无效时尝试收缩</li>
<li>❌ 不要过早地移除窗口中的字符</li>
<li>❌ 注意处理字符不在目标字符串中的情况</li>
</ul>
</li>
<li>
<p><strong>优化技巧</strong>：</p>
<ul>
<li>使用数组代替哈希表提高效率</li>
<li>合理设置边界值便于判断</li>
</ul>
</li>
<li>
<p><strong>相关问题</strong>：</p>
<ul>
<li>LeetCode 3: 无重复字符的最长子串</li>
<li>LeetCode 438: 找到字符串中所有字母异位词</li>
<li>LeetCode 567: 字符串的排列</li>
</ul>
</li>
</ol>
<p>这道题是滑动窗口技巧的经典应用，掌握了这个模板后，很多类似的字符串/数组问题都能迎刃而解！</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>Hard</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 30 - 串联所有单词的子串（Substring with Concatenation of All Words）</title>
    <url>/2025/06/02/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>words</code>。<code>words</code> 中所有字符串<strong>长度相同</strong>。</p>
<p><code>s</code> 中的<strong>串联子串</strong>是指一个包含 <code>words</code> 中所有字符串以任意顺序排列连接起来的子串。</p>
<p>返回所有串联子串在 <code>s</code> 中的开始索引。你可以以<strong>任意顺序</strong>返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;barfoothefoobar&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出：[0,9]</span><br><span class="line">解释：</span><br><span class="line">从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;wordgoodgoodgoodword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;barfoobar&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">输出：[0,3]</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>1 &lt;= words.length &lt;= 5000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 30</code></li>
<li><code>words[i]</code> 和 <code>s</code> 由小写英文字母组成</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心挑战在于<strong>高效地找到所有可能的串联子串</strong>。关键洞察是：<strong>所有单词长度相同</strong>，这为我们提供了优化的机会。</p>
<h3 id="朴素解法分析">朴素解法分析</h3>
<p>最直观的想法是：</p>
<ol>
<li>遍历字符串 <code>s</code> 的每个可能起始位置</li>
<li>从该位置开始，按单词长度切分，检查是否恰好包含所有 <code>words</code></li>
<li>使用哈希表统计单词频次</li>
</ol>
<p><strong>朴素解法的问题：</strong></p>
<ul>
<li>时间复杂度：<strong>O(n × m × k)</strong>，其中 n 是字符串长度，m 是单词个数，k 是单词长度</li>
<li>大量重复计算和重复创建哈希表</li>
</ul>
<h3 id="滑动窗口优化思路">滑动窗口优化思路</h3>
<p><strong>核心洞察</strong>：由于每个单词长度都是固定的 <code>wordLen</code>，我们可以将问题分解为 <code>wordLen</code> 个独立的子问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：s = &quot;barfoothefoobar&quot;, words = [&quot;foo&quot;, &quot;bar&quot;], wordLen = 3</span><br><span class="line"></span><br><span class="line">子问题1: 起始位置 0, 3, 6, 9, 12... → bar|foo|the|foo|bar</span><br><span class="line">子问题2: 起始位置 1, 4, 7, 10, 13... → arf|oot|hef|oob|ar</span><br><span class="line">子问题3: 起始位置 2, 5, 8, 11, 14... → rfo|oth|efo|oba|r</span><br></pre></td></tr></table></figure>
<p>对于每个子问题，我们使用<strong>滑动窗口</strong>：</p>
<ol>
<li>维护一个固定大小的窗口（包含 <code>len(words)</code> 个单词）</li>
<li>当窗口右移时，移除左边的单词，添加右边的单词</li>
<li>检查当前窗口是否匹配所有 <code>words</code></li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="滑动窗口的三种情况">滑动窗口的三种情况</h3>
<ol>
<li><strong>遇到有效单词且不超过限制</strong>：正常扩展窗口</li>
<li><strong>遇到有效单词但超过限制</strong>：收缩左边界直到满足限制</li>
<li><strong>遇到无效单词</strong>：重置整个窗口</li>
</ol>
<h3 id="关键数据结构">关键数据结构</h3>
<ul>
<li><code>wordMap</code>：记录目标单词的频次</li>
<li><code>currentMap</code>：记录当前窗口中单词的频次</li>
<li><code>count</code>：当前窗口中有效单词的总数</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<h3 id="优化后的滑动窗口解法">优化后的滑动窗口解法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || <span class="built_in">len</span>(words) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wordLen := <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">    wordCount := <span class="built_in">len</span>(words)</span><br><span class="line">    totalLen := wordLen * wordCount</span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; totalLen &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建单词频次map</span></span><br><span class="line">    wordMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        wordMap[word]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于每个可能的起始余数位置 (0 到 wordLen-1)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wordLen; i++ &#123;</span><br><span class="line">        left := i</span><br><span class="line">        right := i</span><br><span class="line">        currentMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">        count := <span class="number">0</span> <span class="comment">// 当前窗口中匹配的单词数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> right+wordLen &lt;= <span class="built_in">len</span>(s) &#123;</span><br><span class="line">            <span class="comment">// 右边界扩展，取出新单词</span></span><br><span class="line">            rightWord := s[right : right+wordLen]</span><br><span class="line">            right += wordLen</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> _, exists := wordMap[rightWord]; exists &#123;</span><br><span class="line">                currentMap[rightWord]++</span><br><span class="line">                count++</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果某个单词出现次数超过需要的次数，缩小左边界</span></span><br><span class="line">                <span class="keyword">for</span> currentMap[rightWord] &gt; wordMap[rightWord] &#123;</span><br><span class="line">                    leftWord := s[left : left+wordLen]</span><br><span class="line">                    left += wordLen</span><br><span class="line">                    currentMap[leftWord]--</span><br><span class="line">                    count--</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 检查是否找到完整匹配</span></span><br><span class="line">                <span class="keyword">if</span> count == wordCount &#123;</span><br><span class="line">                    result = <span class="built_in">append</span>(result, left)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遇到不在words中的单词，重置窗口</span></span><br><span class="line">                currentMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                left = right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="朴素解法（对比）">朴素解法（对比）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstringNaive</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    wordLen := <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">    wordMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    totalLength := <span class="built_in">len</span>(words) * wordLen</span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        wordMap[word]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(s)-totalLength; i++ &#123;</span><br><span class="line">        wordCnt := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 每次都重新创建</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; i+totalLength; j += wordLen &#123;</span><br><span class="line">            word := s[j : j+wordLen]</span><br><span class="line">            wordCnt[word]++</span><br><span class="line">            <span class="keyword">if</span> wordCnt[word] &gt; wordMap[word] &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j == i+totalLength-wordLen &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>朴素解法</th>
<th>滑动窗口解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n × m × k)</td>
<td>O(n × k)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(m)</td>
<td>O(m)</td>
</tr>
<tr>
<td>核心思想</td>
<td>暴力枚举每个起始位置</td>
<td>按余数分组 + 滑动窗口</td>
</tr>
<tr>
<td>重复计算</td>
<td>大量重复计算</td>
<td>充分利用之前的计算结果</td>
</tr>
<tr>
<td>Map创建</td>
<td>每个起始位置都重新创建</td>
<td>每个子问题只创建一次</td>
</tr>
<tr>
<td>性能表现</td>
<td>只能超过 25% 的提交</td>
<td>能超过 80%+ 的提交</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度详解">时间复杂度详解</h3>
<p><strong>朴素解法：O(n × m × k)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外层循环：O(n) - 遍历所有可能的起始位置</span><br><span class="line">内层循环：O(m × k) - 检查每个起始位置的 m 个单词</span><br><span class="line">总体：O(n × m × k)</span><br></pre></td></tr></table></figure>
<p><strong>滑动窗口：O(n × k)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外层循环：O(k) - 按 wordLen 分组</span><br><span class="line">内层循环：O(n) - 每个字符最多被访问常数次</span><br><span class="line">总体：O(n × k)</span><br></pre></td></tr></table></figure>
<p><strong>关键差异分析：</strong></p>
<p>滑动窗口之所以更快，不仅仅是因为避免了重复创建 Map，更重要的是<strong>算法复杂度的根本性改进</strong>：</p>
<ol>
<li><strong>减少了一个维度</strong>：从 O(n × m × k) 降到 O(n × k)</li>
<li><strong>避免重复计算</strong>：每个字符最多被处理常数次</li>
<li><strong>充分利用单词等长特性</strong>：按余数分组，避免无效枝剪</li>
</ol>
<h3 id="空间复杂度">空间复杂度</h3>
<p>两种解法的空间复杂度都是 <strong>O(m)</strong>，主要用于存储：</p>
<ul>
<li>目标单词的频次映射</li>
<li>当前窗口的单词统计</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<h3 id="算法优化策略">算法优化策略</h3>
<ol>
<li><strong>利用问题特性</strong>：单词等长这个约束条件是优化的关键</li>
<li><strong>滑动窗口思想</strong>：当问题涉及连续子序列时，考虑滑动窗口</li>
<li><strong>分治思想</strong>：将复杂问题分解为简单子问题</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>边界条件处理</strong>：确保循环边界正确，避免数组越界</li>
<li><strong>Map 初始化</strong>：注意在适当时机重置 Map 状态</li>
<li><strong>复杂度分析</strong>：不要仅看表面，要分析算法的本质差异</li>
</ol>
<h3 id="性能优化要点">性能优化要点</h3>
<p>回答文章开头的问题：<strong>时间复杂度确实不同！</strong></p>
<p>虽然重复创建 Map 确实有性能开销，但更根本的差异在于：</p>
<ul>
<li>朴素解法：<strong>O(n × m × k)</strong> - 每个位置都要重新检查所有单词</li>
<li>滑动窗口：<strong>O(n × k)</strong> - 利用窗口滑动，避免重复计算</li>
</ul>
<p>滑动窗口通过<strong>减少一个时间复杂度维度</strong>实现了质的飞跃，这就是为什么性能提升如此显著的根本原因。</p>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><a href="mdc:hexo-blog/2023/06/15/LeetCode-3-Longest-Substring-Without-Repeating-Characters">LeetCode 3: 无重复字符的最长子串</a></li>
<li><a href="mdc:hexo-blog/2023/06/20/LeetCode-76-Minimum-Window-Substring">LeetCode 76: 最小覆盖子串</a></li>
<li><a href="mdc:hexo-blog/2023/06/25/LeetCode-438-Find-All-Anagrams-in-a-String">LeetCode 438: 找到字符串中所有字母异位词</a></li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>Hard</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>滑动窗口</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 209 - 长度最小的子数组（Minimum Size Subarray Sum）</title>
    <url>/2025/06/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个含有 n 个正整数的数组和一个正整数 target ，找出该数组中满足其和 ≥ target 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<h3 id="示例输入输出">示例输入输出</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>1 ≤ target ≤ $10^9$</li>
<li>1 ≤ nums.length ≤ $10^5$</li>
<li>1 ≤ nums[i] ≤ $10^4$</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心是找到<strong>和大于等于目标值的最短连续子数组</strong>。我们可以通过两种主要方法来解决：</p>
<h3 id="方法一：前缀和-双指针"><strong>方法一：前缀和 + 双指针</strong></h3>
<p><strong>核心思想</strong>：预先计算前缀和数组，然后使用双指针技术寻找满足条件的最短子数组。</p>
<p>通过前缀和，我们可以在 $O(1)$ 时间内计算任意区间 <code>[left, right)</code> 的和：<br>
$$\text{sum}(left, right) = \text{prefix}[right] - \text{prefix}[left]$$</p>
<h3 id="方法二：滑动窗口（更优解法）"><strong>方法二：滑动窗口（更优解法）</strong></h3>
<p><strong>核心思想</strong>：使用双指针维护一个滑动窗口，动态调整窗口大小来寻找最短的满足条件的子数组。</p>
<p>这种方法避免了额外空间的使用，只需要维护当前窗口的和。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="方法一：前缀和双指针实现">方法一：前缀和双指针实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建前缀和数组：prefix[i] 表示 nums[0...i-1] 的和</span></span><br><span class="line">    prefix := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        prefix[i+<span class="number">1</span>] = prefix[i] + nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    minLength := math.MaxInt32</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用双指针寻找最小长度的子数组</span></span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">1</span>; right &lt;= n; right++ &#123;</span><br><span class="line">        <span class="comment">// 当前窗口 [left, right) 的和</span></span><br><span class="line">        currentSum := prefix[right] - prefix[left]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前和满足条件，尝试收缩左边界</span></span><br><span class="line">        <span class="keyword">for</span> currentSum &gt;= target &#123;</span><br><span class="line">            minLength = min(minLength, right-left)</span><br><span class="line">            left++</span><br><span class="line">            <span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">                currentSum = prefix[right] - prefix[left]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有找到满足条件的子数组，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> minLength == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：滑动窗口实现（推荐）">方法二：滑动窗口实现（推荐）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    windowSum := <span class="number">0</span></span><br><span class="line">    minLength := math.MaxInt32</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用滑动窗口技术</span></span><br><span class="line">    <span class="keyword">for</span> right &lt; n &#123;</span><br><span class="line">        <span class="comment">// 扩展右边界，增加窗口内的和</span></span><br><span class="line">        windowSum += nums[right]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当窗口内的和满足条件时，尝试收缩左边界</span></span><br><span class="line">        <span class="keyword">for</span> windowSum &gt;= target &#123;</span><br><span class="line">            <span class="comment">// 更新最小长度</span></span><br><span class="line">            minLength = min(minLength, right-left+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 收缩左边界</span></span><br><span class="line">            windowSum -= nums[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动右边界</span></span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有找到满足条件的子数组，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> minLength == math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：获取两个整数的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>前缀和双指针</th>
<th>滑动窗口</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>预处理</td>
<td>需要构建前缀和数组</td>
<td>无需预处理</td>
</tr>
<tr>
<td>代码复杂度</td>
<td>相对复杂</td>
<td>简洁直观</td>
</tr>
<tr>
<td>内存使用</td>
<td>需要额外 $O(n)$ 空间</td>
<td>只需常数空间</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="前缀和双指针方法">前缀和双指针方法</h3>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<ul>
<li>构建前缀和数组：$O(n)$</li>
<li>双指针遍历：$O(n)$（每个元素最多被访问两次）</li>
</ul>
<p><strong>空间复杂度</strong>：$O(n)$</p>
<ul>
<li>前缀和数组需要 $O(n)$ 额外空间</li>
</ul>
<h3 id="滑动窗口方法">滑动窗口方法</h3>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<ul>
<li>虽然有嵌套循环，但每个元素最多被 <code>left</code> 和 <code>right</code> 指针各访问一次</li>
</ul>
<p><strong>空间复杂度</strong>：$O(1)$</p>
<ul>
<li>只使用了几个变量，不依赖于输入数组的大小</li>
</ul>
<h2 id="算法执行示例">算法执行示例</h2>
<p>以 <code>target = 7, nums = [2,3,1,2,4,3]</code> 为例，展示滑动窗口的执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态：left = 0, right = 0, windowSum = 0, minLength = ∞</span><br><span class="line"></span><br><span class="line">Step 1: right = 0, windowSum = 2</span><br><span class="line">        [2] 3 1 2 4 3</span><br><span class="line">         ↑</span><br><span class="line">       left,right</span><br><span class="line"></span><br><span class="line">Step 2: right = 1, windowSum = 5</span><br><span class="line">        [2,3] 1 2 4 3</span><br><span class="line">         ↑   ↑</span><br><span class="line">       left right</span><br><span class="line"></span><br><span class="line">Step 3: right = 2, windowSum = 6</span><br><span class="line">        [2,3,1] 2 4 3</span><br><span class="line">         ↑     ↑</span><br><span class="line">       left   right</span><br><span class="line"></span><br><span class="line">Step 4: right = 3, windowSum = 8 &gt;= 7 ✓</span><br><span class="line">        [2,3,1,2] 4 3</span><br><span class="line">         ↑       ↑</span><br><span class="line">       left     right</span><br><span class="line">        更新 minLength = 4</span><br><span class="line"></span><br><span class="line">Step 5: 收缩 left，windowSum = 6</span><br><span class="line">        2 [3,1,2] 4 3</span><br><span class="line">           ↑     ↑</span><br><span class="line">         left   right</span><br><span class="line"></span><br><span class="line">Step 6: right = 4, windowSum = 10 &gt;= 7 ✓</span><br><span class="line">        2 [3,1,2,4] 3</span><br><span class="line">           ↑       ↑</span><br><span class="line">         left     right</span><br><span class="line">        更新 minLength = 4</span><br><span class="line"></span><br><span class="line">Step 7: 收缩 left，windowSum = 7 &gt;= 7 ✓</span><br><span class="line">        2 3 [1,2,4] 3</span><br><span class="line">             ↑     ↑</span><br><span class="line">           left   right</span><br><span class="line">        更新 minLength = 3</span><br><span class="line"></span><br><span class="line">Step 8: 收缩 left，windowSum = 6</span><br><span class="line">        2 3 1 [2,4] 3</span><br><span class="line">               ↑   ↑</span><br><span class="line">             left right</span><br><span class="line"></span><br><span class="line">Step 9: right = 5, windowSum = 9 &gt;= 7 ✓</span><br><span class="line">        2 3 1 [2,4,3]</span><br><span class="line">               ↑     ↑</span><br><span class="line">             left   right</span><br><span class="line">        更新 minLength = 3</span><br><span class="line"></span><br><span class="line">Step 10: 收缩 left，windowSum = 7 &gt;= 7 ✓</span><br><span class="line">         2 3 1 2 [4,3]</span><br><span class="line">                  ↑   ↑</span><br><span class="line">                left right</span><br><span class="line">         更新 minLength = 2</span><br><span class="line"></span><br><span class="line">最终结果：minLength = 2</span><br></pre></td></tr></table></figure>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>滑动窗口是处理连续子数组问题的经典技法</strong>：通过动态调整窗口边界，可以高效地找到满足条件的子数组。</p>
</li>
<li>
<p><strong>空间换时间的权衡</strong>：前缀和方法用额外空间换取了更直观的实现，但滑动窗口在不增加空间复杂度的情况下同样高效。</p>
</li>
<li>
<p><strong>双指针的移动策略</strong>：</p>
<ul>
<li>当窗口和小于目标值时，扩展右边界增加和</li>
<li>当窗口和大于等于目标值时，收缩左边界寻找更短的解</li>
</ul>
</li>
<li>
<p><strong>常见陷阱</strong>：</p>
<ul>
<li>注意边界条件的处理（空数组、无解情况）</li>
<li>确保指针移动的正确性，避免越界</li>
<li>初始化 <code>minLength</code> 为一个足够大的值</li>
</ul>
</li>
<li>
<p><strong>相关应用</strong>：此类滑动窗口技法可以应用于其他类似问题，如最长无重复字符子串、最小覆盖子串等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
        <tag>Medium</tag>
        <tag>双指针</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 15 - 三数之和（3Sum）</title>
    <url>/2025/05/31/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>nums</code>，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code>，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code>。</p>
<p>请你返回所有和为 0 且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[4] + nums[5] = 0 + (-1) + 1 = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心思想是<strong>将三数之和转化为两数之和问题</strong>。我们可以：</p>
<ol>
<li><strong>固定一个数</strong>：遍历数组，将当前数作为三元组的第一个数</li>
<li><strong>双指针寻找另外两个数</strong>：在剩余数组中用双指针寻找两个数，使得三数之和为 0</li>
<li><strong>排序去重</strong>：先对数组排序，便于双指针操作和去重</li>
</ol>
<h3 id="为什么要排序？">为什么要排序？</h3>
<p>排序的好处：</p>
<ul>
<li><strong>便于双指针操作</strong>：排序后可以根据和的大小移动指针</li>
<li><strong>便于去重</strong>：相同的数会相邻，容易跳过重复元素</li>
<li><strong>提前终止</strong>：如果当前数大于 0，后面的数都更大，不可能找到和为 0 的三元组</li>
</ul>
<h3 id="双指针的移动策略">双指针的移动策略</h3>
<p>对于固定的第一个数 <code>nums[i]</code>，我们需要在 <code>nums[i+1:]</code> 中找到两个数，使得三数之和为 0：</p>
<ul>
<li>如果 <code>nums[i] + nums[left] + nums[right] == 0</code>：找到一个解</li>
<li>如果 <code>nums[i] + nums[left] + nums[right] &lt; 0</code>：和太小，需要增大，<code>left++</code></li>
<li>如果 <code>nums[i] + nums[left] + nums[right] &gt; 0</code>：和太大，需要减小，<code>right--</code></li>
</ul>
<h2 id="实现细节">实现细节</h2>
<p>让我们用一个具体的例子来演示算法的执行过程：</p>
<h3 id="例子演示：nums-1-0-1-2-1-4">例子演示：nums = [-1,0,1,2,-1,-4]</h3>
<h4 id="步骤-1：排序">步骤 1：排序</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原数组：[-1, 0, 1, 2, -1, -4]</span><br><span class="line">排序后：[-4, -1, -1, 0, 1, 2]</span><br><span class="line">          ↑   ↑   ↑  ↑  ↑  ↑</span><br><span class="line">          0   1   2  3  4  5</span><br></pre></td></tr></table></figure>
<h4 id="步骤-2：遍历固定第一个数">步骤 2：遍历固定第一个数</h4>
<p><strong>第一轮：i = 0, nums[i] = -4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组：[-4, -1, -1, 0, 1, 2]</span><br><span class="line">        ↑   ↑            ↑</span><br><span class="line">        i   left        right</span><br></pre></td></tr></table></figure>
<p>寻找 <code>-4 + nums[left] + nums[right] = 0</code>，即 <code>nums[left] + nums[right] = 4</code></p>
<ul>
<li><code>left = 1, right = 5</code>：<code>-1 + 2 = 1 &lt; 4</code>，<code>left++</code></li>
<li><code>left = 2, right = 5</code>：<code>-1 + 2 = 1 &lt; 4</code>，<code>left++</code></li>
<li><code>left = 3, right = 5</code>：<code>0 + 2 = 2 &lt; 4</code>，<code>left++</code></li>
<li><code>left = 4, right = 5</code>：<code>1 + 2 = 3 &lt; 4</code>，<code>left++</code></li>
<li><code>left = 5, right = 5</code>：<code>left &gt;= right</code>，结束</li>
</ul>
<p><strong>第二轮：i = 1, nums[i] = -1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组：[-4, -1, -1, 0, 1, 2]</span><br><span class="line">            ↑   ↑        ↑</span><br><span class="line">            i   left     right</span><br></pre></td></tr></table></figure>
<p>寻找 <code>-1 + nums[left] + nums[right] = 0</code>，即 <code>nums[left] + nums[right] = 1</code></p>
<ul>
<li><code>left = 2, right = 5</code>：<code>-1 + 2 = 1 = 1</code> ✅ <strong>找到解：[-1, -1, 2]</strong></li>
</ul>
<p>找到解后，需要跳过重复元素：</p>
<ul>
<li><code>left++</code>：<code>left = 3</code></li>
<li><code>right--</code>：<code>right = 4</code></li>
<li>检查 <code>nums[left] == nums[left-1]</code>？<code>nums[3] = 0, nums[2] = -1</code>，不相等</li>
<li>检查 <code>nums[right] == nums[right+1]</code>？<code>nums[4] = 1, nums[5] = 2</code>，不相等</li>
</ul>
<p>继续寻找：</p>
<ul>
<li><code>left = 3, right = 4</code>：<code>0 + 1 = 1 = 1</code> ✅ <strong>找到解：[-1, 0, 1]</strong></li>
</ul>
<p><strong>第三轮：i = 2, nums[i] = -1</strong></p>
<p>由于 <code>nums[2] == nums[1]</code>，跳过重复元素。</p>
<p><strong>第四轮：i = 3, nums[i] = 0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组：[-4, -1, -1, 0, 1, 2]</span><br><span class="line">                   ↑  ↑  ↑</span><br><span class="line">                   i left right</span><br></pre></td></tr></table></figure>
<p>寻找 <code>0 + nums[left] + nums[right] = 0</code>，即 <code>nums[left] + nums[right] = 0</code></p>
<ul>
<li><code>left = 4, right = 5</code>：<code>1 + 2 = 3 &gt; 0</code>，<code>right--</code></li>
<li><code>left = 4, right = 4</code>：<code>left &gt;= right</code>，结束</li>
</ul>
<h4 id="最终结果">最终结果</h4>
<p>找到的三元组：<code>[[-1, -1, 2], [-1, 0, 1]]</code></p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)  <span class="comment">// 排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 优化：如果当前数大于0，后面不可能有和为0的三元组</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过重复的第一个数</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        left := i + <span class="number">1</span></span><br><span class="line">        right := n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">            sum := nums[i] + nums[left] + nums[right]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sum == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 找到一个解</span></span><br><span class="line">                res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;nums[i], nums[left], nums[right]&#125;)</span><br><span class="line">                left++</span><br><span class="line">                right--</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 跳过重复的left</span></span><br><span class="line">                <span class="keyword">for</span> left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>] &#123;</span><br><span class="line">                    left++</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 跳过重复的right</span></span><br><span class="line">                <span class="keyword">for</span> left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>] &#123;</span><br><span class="line">                    right--</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">                left++   <span class="comment">// 和太小，增大left</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--  <span class="comment">// 和太大，减小right</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-n-2">时间复杂度：$O(n^2)$</h3>
<ul>
<li>排序：$O(n \log n)$</li>
<li>外层循环：$O(n)$</li>
<li>内层双指针：$O(n)$</li>
<li>总时间复杂度：$O(n \log n) + O(n^2) = O(n^2)$</li>
</ul>
<h3 id="空间复杂度：-O-1">空间复杂度：$O(1)$</h3>
<p>除了存储结果的数组外，只使用了常数级别的额外空间。</p>
<h2 id="关键收获">关键收获</h2>
<h3 id="核心技巧">核心技巧</h3>
<ol>
<li><strong>降维思想</strong>：将三数之和转化为两数之和问题</li>
<li><strong>排序的妙用</strong>：既便于双指针操作，又便于去重</li>
<li><strong>双指针技巧</strong>：根据和的大小决定指针移动方向</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li>
<p><strong>忘记去重</strong>：</p>
<ul>
<li>第一个数的去重：<code>if i &gt; 0 &amp;&amp; nums[i] == nums[i-1]</code></li>
<li>找到解后的去重：跳过相同的 <code>left</code> 和 <code>right</code></li>
</ul>
</li>
<li>
<p><strong>边界条件</strong>：</p>
<ul>
<li>外层循环到 <code>n-2</code>：至少要留两个位置给 <code>left</code> 和 <code>right</code></li>
<li>双指针的边界：<code>left &lt; right</code></li>
</ul>
</li>
<li>
<p><strong>优化细节</strong>：</p>
<ul>
<li>当 <code>nums[i] &gt; 0</code> 时可以提前终止</li>
<li>去重时要注意数组越界</li>
</ul>
</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><strong>两数之和</strong>：本题的基础</li>
<li><strong>四数之和</strong>：可以用类似的思路，固定两个数，双指针找另外两个数</li>
<li><strong>最接近的三数之和</strong>：双指针的变形应用</li>
</ul>
<p>这道题是双指针技巧的经典应用，掌握了这个模板，可以解决很多类似的问题！</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 大Key对持久化性能的影响分析与优化策略</title>
    <url>/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/BIGKEY/</url>
    <content><![CDATA[<h1>Redis 大 Key 对持久化有什么影响？</h1>
<p>有位读者在字节跳动一二面时，被问到：<strong>Redis 的大 Key 对持久化有什么影响？</strong></p>
<p>这是一个很实际的问题，因为在实际工作中，我们经常会遇到一些特别大的数据，比如一个包含几万条记录的列表，或者一个几MB的字符串。这些&quot;大家伙&quot;会给Redis的数据持久化带来什么麻烦呢？</p>
<p>Redis 有两种把数据保存到硬盘的方式：<strong>AOF 日志</strong>和 <strong>RDB 快照</strong>。就像我们平时既会写日记记录每天做了什么（AOF），也会定期拍照留念（RDB）一样。</p>
<p>接下来，我们分别看看大Key是如何影响这两种持久化方式的。</p>
<h2 id="大-Key-对-AOF-日志的影响">大 Key 对 AOF 日志的影响</h2>
<h3 id="AOF-的三种写入策略">AOF 的三种写入策略</h3>
<p>首先要了解 Redis 提供的 3 种 AOF 日志写回硬盘的策略：</p>
<ol>
<li>
<p><strong>Always（总是写入）</strong>：每次执行写操作后，立即把数据同步到硬盘</p>
<ul>
<li>就像写日记时，每写一句话就保存一次文件</li>
</ul>
</li>
<li>
<p><strong>Everysec（每秒写入）</strong>：每次写操作后先放到内存缓冲区，每秒统一写入硬盘</p>
<ul>
<li>就像写日记时，先写在草稿纸上，每过一段时间再誊写到正式的日记本</li>
</ul>
</li>
<li>
<p><strong>No（操作系统决定）</strong>：写操作后放到内存缓冲区，让操作系统自己决定什么时候写入硬盘</p>
<ul>
<li>就像把日记放在那里，什么时候整理完全看心情</li>
</ul>
</li>
</ol>
<p>为了保证数据真正写到硬盘上，需要调用一个叫 <code>fsync()</code> 的函数。你可以把它想象成&quot;强制保存&quot;按钮。</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/BIGKEY/1748595809942.png" alt="1748595809942"></p>
<h3 id="不同策略下大Key的影响">不同策略下大Key的影响</h3>
<p><strong>Always 策略的问题最严重</strong>：</p>
<ul>
<li>每次操作大Key时，主线程必须等待 <code>fsync()</code> 函数执行完成</li>
<li><strong>就像你要把一本厚厚的书完整抄写一遍，在抄完之前什么也不能做</strong></li>
<li>如果大Key有几MB大小，这个等待时间可能会很长，Redis 就&quot;卡&quot;住了</li>
</ul>
<p><strong>Everysec 策略相对较好</strong>：</p>
<ul>
<li>因为 <code>fsync()</code> 是异步执行的（在后台进行），主线程不会被阻塞</li>
<li>就像有个助手帮你抄写，你可以继续做其他事情</li>
</ul>
<p><strong>No 策略不受影响</strong>：</p>
<ul>
<li>从不主动调用 <code>fsync()</code>，所以不会因为大Key而阻塞主线程</li>
</ul>
<blockquote>
<p><strong>小结</strong>：如果使用 Always 策略，大Key会让Redis主线程&quot;卡&quot;很久；其他两种策略影响较小。</p>
</blockquote>
<h2 id="大-Key-对-AOF-重写和-RDB-的影响">大 Key 对 AOF 重写和 RDB 的影响</h2>
<h3 id="什么时候会触发问题？">什么时候会触发问题？</h3>
<p>当AOF日志文件因为记录了很多大Key而变得很大时，Redis会启动 <strong>AOF 重写机制</strong> 来压缩文件大小。</p>
<p>无论是AOF重写还是RDB快照，都需要通过 <code>fork()</code> 函数创建一个&quot;子进程&quot;来处理。你可以把这理解为：<strong>Redis 主线程要&quot;克隆&quot;一个自己出来专门干活，自己继续接待客户</strong>。</p>
<h3 id="fork-过程中的问题">fork 过程中的问题</h3>
<h4 id="第一个问题：复制页表耗时">第一个问题：复制页表耗时</h4>
<p>创建子进程时，操作系统需要复制父进程的&quot;页表&quot;（一个记录虚拟地址和物理地址对应关系的表格）。</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/BIGKEY/1748595821849.png" alt="1748595821849"></p>
<p><strong>简单类比</strong>：</p>
<ul>
<li>想象Redis的内存就像一个大图书馆</li>
<li>页表就像图书馆的索引目录，记录着&quot;第几本书在第几个书架&quot;</li>
<li>创建子进程时，需要把这个目录完整复制一份给子进程</li>
<li><strong>如果Redis存储了很多大Key，就像图书馆藏书特别多，索引目录就会很厚，复制起来就很慢</strong></li>
</ul>
<p><strong>具体影响</strong>：</p>
<ul>
<li>页表越大，复制时间越长</li>
<li>复制期间，Redis 主线程会被阻塞，无法处理客户端请求</li>
<li>可以通过 <code>info</code> 命令查看 <code>latest_fork_usec</code> 指标来了解最近一次 fork 耗时</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 最近一次 fork 操作耗时（微秒）</span><br><span class="line">latest_fork_usec:<span class="number">315</span></span><br></pre></td></tr></table></figure>
<h4 id="第二个问题：写时复制机制">第二个问题：写时复制机制</h4>
<p>fork 完成后，父子进程共享同一份物理内存，但都标记为&quot;只读&quot;。当任何一方要修改数据时，就会触发&quot;<strong>写时复制</strong>&quot;机制。</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/BIGKEY/1748595832830.png" alt="1748595832830"></p>
<p><strong>生活化类比</strong>：</p>
<ul>
<li>想象你和室友共用一本菜谱（共享内存）</li>
<li>一开始大家都只是看看（只读状态）</li>
<li>当你想在菜谱上做笔记时（写操作），就必须把这一页完整复印一份给自己用（写时复制）</li>
<li><strong>如果要修改的是一道很复杂的菜谱（大Key），复印的时间就会很长</strong></li>
</ul>
<p><strong>实际影响</strong>：</p>
<ul>
<li>如果父进程修改了大Key，需要复制对应的物理内存</li>
<li>大Key占用的内存越大，复制时间越长</li>
<li>复制期间，父进程（Redis主线程）会被阻塞</li>
</ul>
<h3 id="内存大页的额外影响">内存大页的额外影响</h3>
<p>Linux系统有个&quot;内存大页&quot;功能，默认情况下内存按4KB为单位分配，开启大页后按2MB为单位分配。</p>
<p><strong>问题在哪里</strong>？</p>
<ul>
<li>正常情况：修改100B数据，只需复制4KB内存页</li>
<li>开启大页：修改100B数据，需要复制整个2MB大页</li>
<li><strong>相当于本来只需要复印一小段文字，现在要复印整张A4纸，效率差了512倍！</strong></li>
</ul>
<p><strong>解决方法</strong>：关闭内存大页（默认已关闭）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
<h3 id="优化建议">优化建议</h3>
<p>如果发现 fork 耗时很长（比如超过1秒），可以这样优化：</p>
<ol>
<li><strong>控制实例大小</strong>：单个Redis实例内存控制在10GB以下</li>
<li><strong>关闭不必要的持久化</strong>：如果只当缓存用，可以关闭AOF和AOF重写</li>
<li><strong>调整主从配置</strong>：适当调大 <code>repl-backlog-size</code>，避免频繁全量同步</li>
</ol>
<blockquote>
<p><strong>小结</strong>：大Key会在两个阶段影响Redis：fork时复制页表耗时，写时复制时复制内存耗时。内存越大，问题越严重。</p>
</blockquote>
<h2 id="大Key的其他影响">大Key的其他影响</h2>
<p>除了持久化问题，大Key还会带来以下麻烦：</p>
<h3 id="1-客户端超时">1. 客户端超时</h3>
<ul>
<li>Redis是单线程处理命令的</li>
<li><strong>就像银行只有一个柜台，如果前面有人办理复杂业务（操作大Key），后面的人都要等</strong></li>
<li>客户端会觉得Redis&quot;卡死&quot;了</li>
</ul>
<h3 id="2-网络阻塞">2. 网络阻塞</h3>
<ul>
<li>每次获取大Key会产生大量网络流量</li>
<li><strong>例如</strong>：1MB的大Key，每秒访问1000次，就会产生1000MB/秒的流量</li>
<li>对于普通千兆网卡来说是灾难性的</li>
</ul>
<h3 id="3-阻塞工作线程">3. 阻塞工作线程</h3>
<ul>
<li>使用 <code>DEL</code> 删除大Key时会阻塞主线程</li>
<li><strong>就像清理一个特别大的垃圾堆，清理期间什么都干不了</strong></li>
</ul>
<h3 id="4-内存分布不均">4. 内存分布不均</h3>
<ul>
<li>在集群环境中，有大Key的节点内存占用更多</li>
<li><strong>就像班级里有几个同学书包特别重，负担不均</strong></li>
</ul>
<h2 id="如何避免大Key问题？">如何避免大Key问题？</h2>
<h3 id="设计阶段预防">设计阶段预防</h3>
<ul>
<li><strong>最重要</strong>：在设计时就把大Key拆分成多个小Key</li>
<li><strong>例如</strong>：把一个包含万条记录的列表，拆分成多个小列表</li>
</ul>
<h3 id="运维阶段处理">运维阶段处理</h3>
<ol>
<li><strong>定期检查</strong>：使用工具定期扫描Redis中的大Key</li>
<li><strong>安全删除</strong>：不要用 <code>DEL</code> 删除大Key，改用 <code>UNLINK</code>（Redis 4.0+）
<ul>
<li><code>DEL</code>：同步删除，会阻塞主线程</li>
<li><code>UNLINK</code>：异步删除，不会阻塞主线程</li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2>
<p><strong>大Key对持久化的影响可以用一句话概括：越大的东西，处理起来越费时间。</strong></p>
<p>具体来说：</p>
<ol>
<li><strong>AOF Always策略</strong>：大Key写入时，fsync耗时长，主线程被阻塞</li>
<li><strong>AOF重写和RDB</strong>：fork时复制页表耗时，写时复制时复制内存耗时</li>
<li><strong>优化原则</strong>：控制Key大小，合理配置持久化策略，定期监控性能指标</li>
</ol>
<p>记住：<strong>预防胜于治疗，在设计阶段就避免大Key是最好的解决方案！</strong></p>
<p>完！</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>Redis</tag>
        <tag>AOF</tag>
        <tag>持久化</tag>
        <tag>BIGKEY</tag>
        <tag>RDB</tag>
        <tag>写时复制</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis RDB 快照持久化：原理、优化与混合持久化</title>
    <url>/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/RDB/</url>
    <content><![CDATA[<h1>Redis RDB 快照：给内存数据拍个&quot;照片&quot;</h1>
<p>大家好，我是小林哥！</p>
<p>想象一下你在旅游时拍照片📷，每张照片都记录了那一瞬间的美好画面。Redis 的 RDB 快照就像给内存数据拍照片一样，把某个时刻内存中的所有数据完整地保存到磁盘上。</p>
<h2 id="什么是RDB快照？">什么是RDB快照？</h2>
<p>Redis 虽然是内存数据库，但为了防止数据丢失，它提供了两种数据持久化方案：</p>
<ul>
<li><strong>AOF 日志</strong>：记录每个操作命令，就像记录日记📝</li>
<li><strong>RDB 快照</strong>：直接保存数据本身，就像拍照片📸</li>
</ul>
<p><strong>简单对比：</strong></p>
<ul>
<li>RDB 保存的是数据的&quot;照片&quot;（二进制数据）</li>
<li>AOF 保存的是操作的&quot;日记&quot;（命令日志）</li>
</ul>
<p><strong>恢复速度对比：</strong></p>
<ul>
<li>RDB：直接把&quot;照片&quot;放回内存，速度快⚡</li>
<li>AOF：要重新执行&quot;日记&quot;里的每个命令，速度慢🐌</li>
</ul>
<h2 id="RDB快照怎么用？">RDB快照怎么用？</h2>
<p>Redis 提供了两个拍照命令：</p>
<h3 id="1-save-命令-同步拍照">1. save 命令 - 同步拍照</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure>
<p><strong>特点：</strong></p>
<ul>
<li>在主线程中执行</li>
<li>拍照期间Redis被&quot;冻住&quot;，无法处理其他请求❄️</li>
<li>适合：Redis即将关闭时使用</li>
</ul>
<h3 id="2-bgsave-命令-异步拍照（推荐）">2. bgsave 命令 - 异步拍照（推荐）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure>
<p><strong>特点：</strong></p>
<ul>
<li>创建子进程去拍照</li>
<li>主线程继续工作，不影响用户请求✅</li>
<li>适合：日常使用</li>
</ul>
<h3 id="3-自动拍照设置">3. 自动拍照设置</h3>
<p>在配置文件中设置自动拍照条件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 900秒内有1次修改就拍照</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 300秒内有10次修改就拍照</span></span><br><span class="line">save 300 10  </span><br><span class="line"><span class="comment"># 60秒内有10000次修改就拍照</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 虽然配置名叫<code>save</code>，实际执行的是<code>bgsave</code></p>
<p><strong>拍照频率的权衡：</strong></p>
<ul>
<li>🔄 <strong>频率太高</strong>：影响性能，占用资源多</li>
<li>🔄 <strong>频率太低</strong>：故障时丢失数据多</li>
<li>📋 <strong>建议</strong>：至少5分钟拍一次，最多可能丢失5分钟数据</li>
</ul>
<h2 id="拍照时数据还能修改吗？">拍照时数据还能修改吗？</h2>
<p><strong>问题：</strong> bgsave 拍照期间，用户还能修改数据吗？</p>
<p><strong>答案：</strong> 能！这得益于一个巧妙的技术——<strong>写时复制（COW）</strong></p>
<h3 id="写时复制技术原理">写时复制技术原理</h3>
<p>用一个生活化的比喻来理解👨‍👩‍👧‍👦：</p>
<p><strong>场景：</strong> 爸爸要给全家福拍照，但是拍照期间孩子们还要继续玩耍</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><strong>共享阶段</strong>：拍照开始时，爸爸和孩子们在同一个房间</li>
<li><strong>不变的情况</strong>：如果孩子们只是安静地看，大家继续在一个房间</li>
<li><strong>有变化的情况</strong>：如果某个孩子要重新摆姿势，就把他/她带到另一个房间</li>
</ol>
<p><strong>技术实现：</strong></p>
<h4 id="第1步：创建子进程（开始拍照）">第1步：创建子进程（开始拍照）</h4>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/RDB/1748595701878.png" alt="1748595701878"></p>
<ul>
<li>父进程（主线程）和子进程最初共享同一块内存</li>
<li>就像爸爸和孩子们在同一个房间</li>
</ul>
<h4 id="第2步：发生数据修改（写时复制）">第2步：发生数据修改（写时复制）</h4>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/RDB/1748595710392.png" alt="1748595710392"></p>
<p>当需要修改数据时：</p>
<ul>
<li>系统会复制一份数据给父进程</li>
<li>父进程在新数据上修改</li>
<li>子进程继续使用原数据拍照</li>
</ul>
<p><strong>核心优势：</strong><br>
✅ 拍照不会阻塞正常业务<br>
✅ 节省内存（只在修改时才复制）<br>
✅ 保证拍照数据的一致性</p>
<h3 id="⚠️-注意事项">⚠️ 注意事项</h3>
<p><strong>内存占用风险：</strong></p>
<ul>
<li>极端情况下，如果拍照期间所有数据都被修改</li>
<li>内存占用可能达到原来的2倍！</li>
<li><strong>建议：</strong> 写操作频繁时要监控内存使用情况</li>
</ul>
<p><strong>数据时效性：</strong></p>
<ul>
<li>RDB保存的是拍照那一瞬间的数据</li>
<li>拍照期间的修改不会被保存</li>
<li>只能等下次拍照才能保存新的修改</li>
</ul>
<h2 id="RDB-AOF-混合持久化：鱼和熊掌兼得">RDB + AOF 混合持久化：鱼和熊掌兼得</h2>
<h3 id="单独使用的问题">单独使用的问题</h3>
<p><strong>RDB的问题：</strong></p>
<ul>
<li>❌ 可能丢失较多数据（两次拍照间隔内的数据）</li>
<li>✅ 恢复速度快</li>
</ul>
<p><strong>AOF的问题：</strong></p>
<ul>
<li>✅ 丢失数据少（最多1秒）</li>
<li>❌ 恢复速度慢</li>
</ul>
<h3 id="混合持久化：完美结合">混合持久化：完美结合</h3>
<p><strong>开启方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在redis.conf中设置</span></span><br><span class="line">aof-use-rdb-preamble <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p><strong>工作原理：</strong><br>
<img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/RDB/1748595726282.png" alt="1748595726282"></p>
<p>混合持久化生成的AOF文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[RDB格式数据] + [AOF格式增量数据]</span><br></pre></td></tr></table></figure>
<p><strong>具体流程：</strong></p>
<ol>
<li><strong>AOF重写时</strong>：先把当前内存数据用RDB格式写入</li>
<li><strong>重写期间</strong>：新的操作命令用AOF格式追加</li>
<li><strong>最终结果</strong>：一个文件包含RDB快照+AOF增量</li>
</ol>
<p><strong>混合持久化的优势：</strong></p>
<ul>
<li>🚀 <strong>恢复快</strong>：先快速加载RDB部分</li>
<li>🛡️ <strong>丢失少</strong>：再加载AOF增量部分</li>
<li>💾 <strong>文件小</strong>：RDB部分压缩率高</li>
</ul>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>RDB</th>
<th>AOF</th>
<th>混合持久化</th>
</tr>
</thead>
<tbody>
<tr>
<td>恢复速度</td>
<td>快⚡</td>
<td>慢🐌</td>
<td>快⚡</td>
</tr>
<tr>
<td>数据完整性</td>
<td>一般😐</td>
<td>好😊</td>
<td>好😊</td>
</tr>
<tr>
<td>文件大小</td>
<td>小📦</td>
<td>大📂</td>
<td>中等📋</td>
</tr>
<tr>
<td>性能影响</td>
<td>低💚</td>
<td>中等💛</td>
<td>低💚</td>
</tr>
</tbody>
</table>
<p><strong>使用建议：</strong></p>
<ul>
<li>🎯 <strong>高性能场景</strong>：单独使用RDB</li>
<li>🛡️ <strong>高可靠性场景</strong>：单独使用AOF</li>
<li>🏆 <strong>生产环境推荐</strong>：开启混合持久化，兼顾性能和可靠性</li>
</ul>
<p>记住：数据持久化就像备份重要文件，选择合适的策略才能在性能和安全之间找到最佳平衡点！📚✨</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>持久化</tag>
        <tag>RDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis AOF 持久化详解：就像给数据库写日记一样简单</title>
    <url>/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/</url>
    <content><![CDATA[<h1>Redis AOF 持久化：给数据库写&quot;日记&quot;</h1>
<h2 id="什么是AOF？一个简单的比喻">什么是AOF？一个简单的比喻</h2>
<p>想象一下，你每天都在记日记，把今天做了什么事情都详细记录下来：</p>
<ul>
<li>“今天买了一个苹果”</li>
<li>“把苹果吃掉了”</li>
<li>“又买了一个橙子”</li>
</ul>
<p>如果有一天你失忆了，只要翻看日记，按照上面记录的事情重新做一遍，就能恢复到失忆前的状态。</p>
<p><strong>Redis的AOF持久化就是这个道理！</strong></p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595527508.png" alt="1748595527508"></p>
<p>AOF (Append Only File) 就是Redis的&quot;日记本&quot;：</p>
<ul>
<li>每当有人修改数据（写操作），Redis就把这个操作记录到AOF文件里</li>
<li>如果Redis重启了，它就读取AOF文件，把里面的操作重新执行一遍</li>
<li>这样数据就恢复了！</li>
</ul>
<blockquote>
<p><strong>注意</strong>：Redis只记录&quot;写操作&quot;（增删改），不记录&quot;读操作&quot;，因为读操作不会改变数据，记录了也没用。</p>
</blockquote>
<h2 id="开启AOF功能">开启AOF功能</h2>
<p>AOF功能默认是关闭的，需要在配置文件里开启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 redis.conf 文件中设置</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595534663.png" alt="1748595534663"></p>
<h2 id="AOF文件长什么样？">AOF文件长什么样？</h2>
<p>AOF文件其实就是个普通的文本文件，我们来看个例子。</p>
<p>当你执行 <code>set name xiaolin</code> 这个命令时，AOF文件里会记录：</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595541605.png" alt="1748595541605"></p>
<p>这看起来有点复杂，让我解释一下：</p>
<ul>
<li><code>*3</code>：表示这个命令有3个部分</li>
<li><code>$3 set</code>：表示第一部分是&quot;set&quot;，长度是3个字符</li>
<li><code>$4 name</code>：表示第二部分是&quot;name&quot;，长度是4个字符</li>
<li><code>$7 xiaolin</code>：表示第三部分是&quot;xiaolin&quot;，长度是7个字符</li>
</ul>
<p>就像是把 <code>set name xiaolin</code> 这个命令拆解并详细记录下来。</p>
<h2 id="AOF的两个优点">AOF的两个优点</h2>
<p>Redis采用了&quot;<strong>先执行命令，再记录日志</strong>&quot;的方式，这样做有两个好处：</p>
<h3 id="优点1：避免记录错误命令">优点1：避免记录错误命令</h3>
<p>就像写日记一样，你只会记录真正发生的事情。如果命令执行失败了，Redis就不会把它写进AOF文件，保证AOF里的命令都是正确的。</p>
<h3 id="优点2：不影响当前操作的速度">优点2：不影响当前操作的速度</h3>
<p>因为是先执行再记录，所以当前的命令不会被记录操作拖慢。</p>
<h2 id="AOF的两个风险">AOF的两个风险</h2>
<p>当然，这种方式也有风险：</p>
<h3 id="风险1：数据丢失">风险1：数据丢失</h3>
<p>就像写日记一样，如果你刚做完一件事，还没来得及记到日记里，突然失忆了，这件事就丢了。</p>
<p>Redis也是一样，如果刚执行完命令，还没来得及写入硬盘，服务器就宕机了，这个数据就丢了。</p>
<h3 id="风险2：可能影响下一个操作">风险2：可能影响下一个操作</h3>
<p>虽然当前操作不受影响，但如果写日记的过程很慢（比如硬盘很忙），就会影响下一个操作。</p>
<h2 id="三种写入策略：什么时候把日记写到硬盘？">三种写入策略：什么时候把日记写到硬盘？</h2>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595562255.png" alt="1748595562255"></p>
<p>Redis写入AOF的过程分三步：</p>
<ol>
<li><strong>执行命令</strong>：比如执行 <code>set name xiaolin</code></li>
<li><strong>写入缓冲区</strong>：先把命令写到内存的缓冲区里</li>
<li><strong>写入硬盘</strong>：再从缓冲区写到硬盘上</li>
</ol>
<p>第三步&quot;什么时候写入硬盘&quot;有三种策略：</p>
<h3 id="策略1：Always（总是立即写入）">策略1：Always（总是立即写入）</h3>
<p><strong>特点</strong>：每执行一个写命令，立即写入硬盘</p>
<ul>
<li><strong>优点</strong>：数据最安全，几乎不会丢失</li>
<li><strong>缺点</strong>：速度最慢，因为每次都要等硬盘写入完成</li>
</ul>
<p><strong>适用场景</strong>：对数据安全要求极高的场景</p>
<h3 id="策略2：Everysec（每秒写入一次）">策略2：Everysec（每秒写入一次）</h3>
<p><strong>特点</strong>：每秒钟把缓冲区的内容写入硬盘一次</p>
<ul>
<li><strong>优点</strong>：平衡了安全性和性能</li>
<li><strong>缺点</strong>：最多可能丢失1秒的数据</li>
</ul>
<p><strong>适用场景</strong>：大多数应用的推荐选择</p>
<h3 id="策略3：No（交给操作系统决定）">策略3：No（交给操作系统决定）</h3>
<p><strong>特点</strong>：Redis不管，由操作系统决定什么时候写入硬盘</p>
<ul>
<li><strong>优点</strong>：性能最好</li>
<li><strong>缺点</strong>：可能丢失较多数据</li>
</ul>
<p><strong>适用场景</strong>：对性能要求高，能容忍数据丢失的场景</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595570963.png" alt="1748595570963"></p>
<h3 id="三种策略的技术原理">三种策略的技术原理</h3>
<p>这三种策略其实是在控制<code>fsync()</code>函数的调用时机：</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595577012.png" alt="1748595577012"></p>
<ul>
<li><strong>Always</strong>：每次写入后立即调用fsync()</li>
<li><strong>Everysec</strong>：创建后台任务每秒调用fsync()</li>
<li><strong>No</strong>：从不调用fsync()，让操作系统自己决定</li>
</ul>
<blockquote>
<p><strong>fsync()函数</strong>：告诉操作系统&quot;现在立即把数据写到硬盘上&quot;，不要再等了。</p>
</blockquote>
<h2 id="AOF重写：给日记本-瘦身">AOF重写：给日记本&quot;瘦身&quot;</h2>
<h3 id="为什么需要重写？">为什么需要重写？</h3>
<p>想象一下，你的日记本记录了：</p>
<ul>
<li>“买了一个苹果”</li>
<li>“把苹果吃掉了”</li>
<li>“又买了一个苹果”</li>
<li>“把苹果又吃掉了”</li>
<li>“再买了一个苹果”</li>
</ul>
<p>日记本越来越厚，但其实最后的状态就是&quot;有一个苹果&quot;。如果重写日记，只需要写&quot;有一个苹果&quot;就够了。</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595586549.png" alt="1748595586549"></p>
<p><strong>AOF重写就是这个道理</strong>：</p>
<ul>
<li>不管一个数据被修改了多少次</li>
<li>重写时只看它现在的最终状态</li>
<li>用一条命令就能表示这个状态</li>
</ul>
<h3 id="重写的好处">重写的好处</h3>
<ol>
<li><strong>AOF文件变小</strong>：减少了冗余命令</li>
<li><strong>恢复数据更快</strong>：执行的命令更少了</li>
<li><strong>节省存储空间</strong>：文件小了，占用磁盘空间少</li>
</ol>
<h3 id="为什么要创建新文件？">为什么要创建新文件？</h3>
<p>重写时不直接修改原AOF文件，而是创建一个新文件，原因很简单：</p>
<ul>
<li>如果重写过程中出错了，原文件还在，数据不会丢失</li>
<li>就像重新写一本新日记，写坏了大不了扔掉，原来的日记还在</li>
</ul>
<h2 id="AOF后台重写：不影响正常服务">AOF后台重写：不影响正常服务</h2>
<h3 id="为什么要后台重写？">为什么要后台重写？</h3>
<p>重写AOF文件是个耗时的工作，就像整理一本很厚的日记本。如果Redis停下来专门做这件事，就没法处理用户的请求了。</p>
<p>所以Redis采用了**“分身术”**：</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595595181.png" alt="1748595595181"></p>
<ol>
<li><strong>主进程</strong>：继续处理用户请求</li>
<li><strong>子进程</strong>：专门负责重写AOF文件</li>
</ol>
<h3 id="写时复制技术：神奇的-分身术">写时复制技术：神奇的&quot;分身术&quot;</h3>
<p>当Redis需要重写AOF时：</p>
<ol>
<li><strong>创建子进程</strong>：Redis创建一个&quot;分身&quot;（子进程）</li>
<li><strong>共享内存</strong>：分身和本体共享同一份数据，节省内存</li>
<li><strong>写时复制</strong>：如果本体修改了数据，操作系统会自动为分身复制一份独立的数据</li>
</ol>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595625080.png" alt="1748595625080"></p>
<p>这就像是：</p>
<ul>
<li>你和你的分身共享一本笔记本</li>
<li>平时你们都只是看笔记本，没问题</li>
<li>如果你要修改笔记，系统会自动给分身复印一份独立的笔记本</li>
<li>这样你们各自修改各自的，互不影响</li>
</ul>
<h3 id="数据一致性问题：怎么保证分身的数据是最新的？">数据一致性问题：怎么保证分身的数据是最新的？</h3>
<p>问题来了：分身在重写AOF期间，本体还在处理新的命令，这样分身的数据就不是最新的了。</p>
<p>Redis的解决方案是&quot;<strong>双写</strong>&quot;：</p>
<p><img src="/2025/05/30/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%8C%81%E4%B9%85%E5%8C%96/AOF/1748595635910.png" alt="1748595635910"></p>
<p>在重写期间，每个写命令都会被写入两个地方：</p>
<ol>
<li><strong>AOF缓冲区</strong>：正常的AOF文件</li>
<li><strong>AOF重写缓冲区</strong>：专门给重写用的缓冲区</li>
</ol>
<p>当分身完成重写后：</p>
<ol>
<li>分身告诉本体：“我写完了！”</li>
<li>本体把重写缓冲区里的新命令追加到新AOF文件后面</li>
<li>用新AOF文件替换掉旧的AOF文件</li>
</ol>
<p>这样就保证了数据的完整性和一致性。</p>
<h3 id="哪些操作会阻塞主进程？">哪些操作会阻塞主进程？</h3>
<p>虽然重写是在后台进行的，但有两个时候会阻塞主进程：</p>
<ol>
<li><strong>创建子进程时</strong>：需要复制页表等数据结构，数据越大阻塞时间越长</li>
<li><strong>写时复制时</strong>：如果修改的是大数据（bigkey），复制内存的时间会比较长</li>
</ol>
<h2 id="总结：AOF就像给数据库写日记">总结：AOF就像给数据库写日记</h2>
<p>让我们用最简单的话总结一下AOF：</p>
<ol>
<li><strong>基本原理</strong>：像写日记一样，把每个写操作都记录下来</li>
<li><strong>恢复数据</strong>：重启时按照日记重新执行一遍操作</li>
<li><strong>写入策略</strong>：可以选择立即写入、每秒写入或让系统决定</li>
<li><strong>文件重写</strong>：定期整理日记，去掉重复和过时的内容</li>
<li><strong>后台重写</strong>：用&quot;分身&quot;来整理日记，不影响正常工作</li>
</ol>
<p><strong>选择建议</strong>：</p>
<ul>
<li>要求数据绝对安全：选择Always策略</li>
<li>平衡安全和性能：选择Everysec策略（推荐）</li>
<li>追求最高性能：选择No策略</li>
</ul>
<p>AOF持久化虽然恢复数据比较慢（因为要重新执行所有命令），但它的优点是数据丢失少，特别适合对数据安全要求高的场景。</p>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li>《Redis 设计与实现》</li>
<li>《Redis 核心技术与实战 - 极客时间》</li>
<li>《Redis 源码分析》</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>AOF</tag>
        <tag>持久化</tag>
        <tag>fsync</tag>
        <tag>重写机制</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 68 - 文本左右对齐（Text Justification）</title>
    <url>/2025/05/30/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-68-%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个单词数组 <code>words</code> 和一个长度 <code>maxWidth</code>，重新排版单词，使其成为每行恰好有 <code>maxWidth</code> 个字符，且左右两端对齐的文本。</p>
<p>你应该使用&quot;贪心算法&quot;来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>' '</code> 填充，使得每行恰好有 <code>maxWidth</code> 个字符。</p>
<p>要求单词之间的空格应该尽可能平均分配。如果某一行单词间的空格不能平均分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p><strong>文本的最后一行应为左对齐，且单词之间不插入额外的空格。</strong></p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>1 &lt;= words.length &lt;= 300</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>words[i]</code> 由小写英文字母和符号组成</li>
<li><code>1 &lt;= maxWidth &lt;= 100</code></li>
<li><code>words[i].length &lt;= maxWidth</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心是<strong>模拟</strong>文本编辑器的左右对齐功能。我们需要：</p>
<ol>
<li><strong>贪心策略</strong>：每行尽可能多地放置单词</li>
<li><strong>空格分配</strong>：将剩余空格均匀分布在单词间</li>
<li><strong>特殊处理</strong>：最后一行采用左对齐</li>
</ol>
<h3 id="算法步骤">算法步骤</h3>
<h4 id="步骤-1：贪心填充单词">步骤 1：贪心填充单词</h4>
<p>对于每一行，我们使用贪心算法尽可能多地放置单词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前行长度 = 单词总长度 + 单词间隔数（单词数 - 1）</span><br></pre></td></tr></table></figure>
<p>如果添加下一个单词会超过 <code>maxWidth</code>，就开始处理当前行。</p>
<h4 id="步骤-2：计算空格分配">步骤 2：计算空格分配</h4>
<p>对于非最后一行，需要计算如何分配空格：</p>
<ul>
<li><strong>总空格数</strong> = <code>maxWidth</code> - 单词字符总数</li>
<li><strong>间隔数</strong> = 单词数 - 1</li>
<li><strong>每个间隔的基础空格</strong> = 总空格数 ÷ 间隔数</li>
<li><strong>额外空格数</strong> = 总空格数 % 间隔数</li>
</ul>
<p><strong>关键策略</strong>：额外空格从左到右依次分配，确保左侧空格不少于右侧。</p>
<h4 id="步骤-3：处理特殊情况">步骤 3：处理特殊情况</h4>
<ol>
<li><strong>单个单词的行</strong>：单词后填充空格到 <code>maxWidth</code></li>
<li><strong>最后一行</strong>：左对齐，单词间只用一个空格分隔，末尾填充空格</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="核心算法可视化">核心算法可视化</h3>
<p>以 <code>[&quot;This&quot;, &quot;is&quot;, &quot;an&quot;]</code> 为例，<code>maxWidth = 16</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤 1：计算空格分配</span><br><span class="line">单词: &quot;This&quot; &quot;is&quot; &quot;an&quot;  (长度: 4 + 2 + 2 = 8)</span><br><span class="line">总空格: 16 - 8 = 8</span><br><span class="line">间隔数: 3 - 1 = 2</span><br><span class="line">基础空格: 8 ÷ 2 = 4</span><br><span class="line">额外空格: 8 % 2 = 0</span><br><span class="line"></span><br><span class="line">步骤 2：构建结果</span><br><span class="line">&quot;This&quot; + 4空格 + &quot;is&quot; + 4空格 + &quot;an&quot;</span><br><span class="line">结果: &quot;This    is    an&quot;</span><br></pre></td></tr></table></figure>
<h3 id="空格分配策略">空格分配策略</h3>
<p>当空格无法平均分配时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：[&quot;What&quot;, &quot;must&quot;, &quot;be&quot;], maxWidth = 16</span><br><span class="line">单词长度: 4 + 4 + 2 = 10</span><br><span class="line">总空格: 16 - 10 = 6</span><br><span class="line">间隔数: 2</span><br><span class="line">基础空格: 6 ÷ 2 = 3</span><br><span class="line">额外空格: 6 % 2 = 0</span><br><span class="line"></span><br><span class="line">但如果是 [&quot;What&quot;, &quot;must&quot;, &quot;be&quot;], maxWidth = 17:</span><br><span class="line">总空格: 17 - 10 = 7</span><br><span class="line">基础空格: 7 ÷ 2 = 3</span><br><span class="line">额外空格: 7 % 2 = 1 (给第一个间隔)</span><br><span class="line"></span><br><span class="line">结果: &quot;What    must   be&quot;</span><br><span class="line">      ↑4空格    ↑3空格</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullJustify</span><span class="params">(words []<span class="type">string</span>, maxWidth <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    result := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    line := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        <span class="comment">// 检查是否需要换行</span></span><br><span class="line">        <span class="keyword">if</span> length + <span class="built_in">len</span>(word) + <span class="built_in">len</span>(line) &gt; maxWidth &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, justify(line, maxWidth))</span><br><span class="line">            line = []<span class="type">string</span>&#123;word&#125;</span><br><span class="line">            length = <span class="built_in">len</span>(word)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            line = <span class="built_in">append</span>(line, word)</span><br><span class="line">            length += <span class="built_in">len</span>(word)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理最后一行（左对齐）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lastLine := strings.Join(line, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        lastLine += strings.Repeat(<span class="string">&quot; &quot;</span>, maxWidth-<span class="built_in">len</span>(lastLine))</span><br><span class="line">        result = <span class="built_in">append</span>(result, lastLine)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justify</span><span class="params">(words []<span class="type">string</span>, maxWidth <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(words) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> words[<span class="number">0</span>] + strings.Repeat(<span class="string">&quot; &quot;</span>, maxWidth-<span class="built_in">len</span>(words[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算需要分配的空格数</span></span><br><span class="line">    wordChars := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        wordChars += <span class="built_in">len</span>(word)</span><br><span class="line">    &#125;</span><br><span class="line">    totalSpaces := maxWidth - wordChars</span><br><span class="line">    gaps := <span class="built_in">len</span>(words) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配空格</span></span><br><span class="line">    spacePerGap := totalSpaces / gaps</span><br><span class="line">    extraSpaces := totalSpaces % gaps</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result strings.Builder</span><br><span class="line">    result.Grow(maxWidth)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        result.WriteString(word)</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(words)<span class="number">-1</span> &#123; <span class="comment">// 不是最后一个单词</span></span><br><span class="line">            spaces := spacePerGap</span><br><span class="line">            <span class="keyword">if</span> i &lt; extraSpaces &#123;</span><br><span class="line">                spaces++</span><br><span class="line">            &#125;</span><br><span class="line">            result.WriteString(strings.Repeat(<span class="string">&quot; &quot;</span>, spaces))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析">执行过程分析</h3>
<p>以示例 1 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]</span><br><span class="line">maxWidth = 16</span><br><span class="line"></span><br><span class="line">第一行处理:</span><br><span class="line">- &quot;This&quot; (4) + &quot;is&quot; (2) + &quot;an&quot; (2) = 8 + 2间隔 = 10 ≤ 16 ✓</span><br><span class="line">- 尝试加入 &quot;example&quot; (7): 10 + 1 + 7 = 18 &gt; 16 ✗</span><br><span class="line">- 处理 [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;]: 空格分配 8个，平均分配到2个间隔</span><br><span class="line">- 结果: &quot;This    is    an&quot;</span><br><span class="line"></span><br><span class="line">第二行处理:</span><br><span class="line">- &quot;example&quot; (7) + &quot;of&quot; (2) + &quot;text&quot; (4) = 13 + 2间隔 = 15 ≤ 16 ✓</span><br><span class="line">- 尝试加入 &quot;justification.&quot;: 超出限制</span><br><span class="line">- 处理 [&quot;example&quot;, &quot;of&quot;, &quot;text&quot;]: 剩余3个空格，分配到2个间隔</span><br><span class="line">- 结果: &quot;example  of text&quot;</span><br><span class="line"></span><br><span class="line">最后一行:</span><br><span class="line">- [&quot;justification.&quot;] 左对齐，后补空格</span><br><span class="line">- 结果: &quot;justification.  &quot;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>$$T(n) = O(n)$$</p>
<p>其中 $n$ 是单词总数。每个单词只被处理一次，字符串构建操作虽然涉及空格计算，但总的字符数是固定的（$\text{maxWidth} \times \text{行数}$）。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>$$S(n) = O(k)$$</p>
<p>其中 $k$ 是结果的总字符数。除了存储结果外，只使用了常数额外空间来存储当前行的单词。</p>
<h2 id="算法特点分析">算法特点分析</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>评价</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n)$</td>
<td>每个单词只处理一次，字符串构建时间与总输出长度成正比</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(k)$</td>
<td>主要用于存储结果，$k$ 为输出字符总数</td>
</tr>
<tr>
<td>代码简洁度</td>
<td>★★★★☆</td>
<td>逻辑清晰，使用 Go 标准库简化实现</td>
</tr>
<tr>
<td>易理解性</td>
<td>★★★★☆</td>
<td>算法思路直观，分步骤处理易于理解</td>
</tr>
<tr>
<td>实现难度</td>
<td>★★★☆☆</td>
<td>需要正确处理多种边界情况</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<h3 id="核心算法思想">核心算法思想</h3>
<ol>
<li><strong>贪心策略</strong>：每行尽可能多地放置单词，这是最优策略</li>
<li><strong>数学分配</strong>：使用除法和取模运算实现空格的均匀分配</li>
<li><strong>边界处理</strong>：区分普通行、单词行和最后一行的不同处理逻辑</li>
</ol>
<h3 id="常见陷阱与避免方法">常见陷阱与避免方法</h3>
<ol>
<li>
<p><strong>空格分配错误</strong>：</p>
<ul>
<li>❌ 错误：平均分配空格后忽略余数</li>
<li>✅ 正确：余数空格从左到右依次分配</li>
</ul>
</li>
<li>
<p><strong>最后一行处理</strong>：</p>
<ul>
<li>❌ 错误：最后一行也进行左右对齐</li>
<li>✅ 正确：最后一行只需左对齐</li>
</ul>
</li>
<li>
<p><strong>单词行处理</strong>：</p>
<ul>
<li>❌ 错误：单个单词也尝试进行空格分配</li>
<li>✅ 正确：单个单词直接右侧填充空格</li>
</ul>
</li>
</ol>
<h3 id="扩展应用">扩展应用</h3>
<p>这个算法的思想可以应用到：</p>
<ul>
<li>文档排版系统</li>
<li>代码格式化工具</li>
<li>表格对齐算法</li>
<li>UI 布局分配算法</li>
</ul>
<p><strong>参考链接</strong>：<a href="https://leetcode.cn/problems/text-justification/description/">LeetCode 68. 文本左右对齐</a></p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 28 - 找出字符串中第一个匹配项的下标（Find the Index of the First Occurrence in a String）</title>
    <url>/2025/05/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code>。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>1 &lt;= haystack.length, needle.length &lt;= 10^4</code></li>
<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题是经典的字符串匹配问题，最优解是使用 <strong>KMP（Knuth-Morris-Pratt）算法</strong>。KMP算法的核心思想是：<strong>当匹配失败时，利用已匹配的前缀信息，避免从头开始重新匹配</strong>。</p>
<h3 id="KMP算法核心概念">KMP算法核心概念</h3>
<ol>
<li><strong>next数组（部分匹配表）</strong>：记录模式串中每个位置的最长相等前后缀长度</li>
<li><strong>失配跳转</strong>：当字符不匹配时，根据next数组跳转到合适位置，而不是从头开始</li>
</ol>
<h3 id="算法步骤详解">算法步骤详解</h3>
<h4 id="视频讲解">视频讲解</h4>
<p><video src="./KMPAnimation.mp4" controls></video></p>
<h4 id="步骤1：构建next数组">步骤1：构建next数组</h4>
<p>next数组的定义：<code>next[i]</code> 表示模式串 <code>needle[0...i]</code> 的最长相等前后缀的长度。</p>
<p><strong>构建过程示例</strong>（以 <code>needle = &quot;ababaca&quot;</code> 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模式串：  a  b  a  b  a  c  a</span><br><span class="line">索引：    0  1  2  3  4  5  6</span><br><span class="line">next：   [0  0  1  2  3  0  1]</span><br></pre></td></tr></table></figure>
<p>详细构建过程：</p>
<ul>
<li><code>i=0</code>: <code>next[0] = 0</code>（规定为0）</li>
<li><code>i=1</code>: <code>&quot;ab&quot;</code> 无相等前后缀，<code>next[1] = 0</code></li>
<li><code>i=2</code>: <code>&quot;aba&quot;</code> 最长相等前后缀是 <code>&quot;a&quot;</code>，长度为1，<code>next[2] = 1</code></li>
<li><code>i=3</code>: <code>&quot;abab&quot;</code> 最长相等前后缀是 <code>&quot;ab&quot;</code>，长度为2，<code>next[3] = 2</code></li>
<li><code>i=4</code>: <code>&quot;ababa&quot;</code> 最长相等前后缀是 <code>&quot;aba&quot;</code>，长度为3，<code>next[4] = 3</code></li>
<li><code>i=5</code>: <code>&quot;ababac&quot;</code> 无相等前后缀，<code>next[5] = 0</code></li>
<li><code>i=6</code>: <code>&quot;ababaca&quot;</code> 最长相等前后缀是 <code>&quot;a&quot;</code>，长度为1，<code>next[6] = 1</code></li>
</ul>
<h4 id="步骤2：模式匹配">步骤2：模式匹配</h4>
<p>使用构建好的next数组进行字符串匹配。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="KMP算法的两个关键函数">KMP算法的两个关键函数</h3>
<ol>
<li><strong>构建next数组</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildNext</span><span class="params">(str <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(str)</span><br><span class="line">	next := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		<span class="comment">// 当前字符不匹配时，回退j</span></span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j] &#123;</span><br><span class="line">			j = next[j<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字符匹配，j前进</span></span><br><span class="line">		<span class="keyword">if</span> str[i] == str[j] &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		next[i] = j</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>执行匹配</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">	next := buildNext(needle)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 当前字符不匹配时，根据next数组跳转</span></span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j] &#123;</span><br><span class="line">			j = next[j<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字符匹配，j前进</span></span><br><span class="line">		<span class="keyword">if</span> haystack[i] == needle[j] &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 完全匹配</span></span><br><span class="line">		<span class="keyword">if</span> j == m &#123;</span><br><span class="line">			<span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="具体例子演示">具体例子演示</h3>
<p>让我们用 <code>haystack = &quot;ababcababa&quot;</code> 和 <code>needle = &quot;ababa&quot;</code> 来演示整个过程：</p>
<h4 id="1-构建next数组">1. 构建next数组</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">needle = &quot;ababa&quot;</span><br><span class="line">索引：    0  1  2  3  4</span><br><span class="line">next：   [0  0  1  2  3]</span><br></pre></td></tr></table></figure>
<p>构建过程：</p>
<ul>
<li><code>i=1, j=0</code>: <code>'b' != 'a'</code>，<code>next[1] = 0</code></li>
<li><code>i=2, j=0</code>: <code>'a' == 'a'</code>，<code>j++</code>，<code>next[2] = 1</code></li>
<li><code>i=3, j=1</code>: <code>'b' == 'b'</code>，<code>j++</code>，<code>next[3] = 2</code></li>
<li><code>i=4, j=2</code>: <code>'a' == 'a'</code>，<code>j++</code>，<code>next[4] = 3</code></li>
</ul>
<h4 id="2-执行匹配过程">2. 执行匹配过程</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">haystack: a b a b c a b a b a</span><br><span class="line">索引:     0 1 2 3 4 5 6 7 8 9</span><br><span class="line">needle:   a b a b a</span><br><span class="line">          ↑           (i=0, j=0)</span><br></pre></td></tr></table></figure>
<p><strong>匹配步骤</strong>：</p>
<ol>
<li><code>i=0, j=0</code>: <code>'a' == 'a'</code> ✓, <code>j++</code></li>
<li><code>i=1, j=1</code>: <code>'b' == 'b'</code> ✓, <code>j++</code></li>
<li><code>i=2, j=2</code>: <code>'a' == 'a'</code> ✓, <code>j++</code></li>
<li><code>i=3, j=3</code>: <code>'b' == 'b'</code> ✓, <code>j++</code></li>
<li><code>i=4, j=4</code>: <code>'c' != 'a'</code> ✗, <strong>失配！</strong></li>
</ol>
<p><strong>失配处理</strong>：</p>
<ul>
<li><code>j = next[j-1] = next[3] = 2</code></li>
<li>跳转后继续比较 <code>haystack[4]</code> 和 <code>needle[2]</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">haystack: a b a b c a b a b a</span><br><span class="line">          a b a b a   (已匹配部分)</span><br><span class="line">              a b a b a (跳转后的对齐)</span><br><span class="line">                  ↑   (i=4, j=2)</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>i=4, j=2</code>: <code>'c' != 'a'</code> ✗, 继续失配</li>
<li><code>j = next[j-1] = next[1] = 0</code></li>
<li><code>i=4, j=0</code>: <code>'c' != 'a'</code> ✗, <code>j</code>保持为0</li>
<li><code>i=5, j=0</code>: <code>'a' == 'a'</code> ✓, <code>j++</code></li>
<li>继续匹配… 最终在位置5找到完整匹配</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// KMP算法实现</span></span><br><span class="line">	n, m := <span class="built_in">len</span>(haystack), <span class="built_in">len</span>(needle)</span><br><span class="line">	next := buildNext(needle)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 当前字符不匹配时，根据next数组跳转</span></span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j] &#123;</span><br><span class="line">			j = next[j<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字符匹配，j前进</span></span><br><span class="line">		<span class="keyword">if</span> haystack[i] == needle[j] &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> j == m &#123;</span><br><span class="line">			<span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildNext</span><span class="params">(str <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(str)</span><br><span class="line">	next := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">1</span>, <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		<span class="comment">// 当前字符不匹配时，回退j</span></span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; str[i] != str[j] &#123;</span><br><span class="line">			j = next[j<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字符匹配，j前进</span></span><br><span class="line">		<span class="keyword">if</span> str[i] == str[j] &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		next[i] = j</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解析">代码解析</h3>
<p><strong>主函数 <code>strStr</code></strong>：</p>
<ul>
<li>获取两个字符串的长度 <code>n</code> 和 <code>m</code></li>
<li>调用 <code>buildNext</code> 函数构建next数组</li>
<li>使用双指针 <code>i</code> 和 <code>j</code> 进行KMP匹配</li>
<li>当失配时，根据next数组进行智能跳转</li>
<li>当完全匹配时，返回起始位置 <code>i - m + 1</code></li>
</ul>
<p><strong>辅助函数 <code>buildNext</code></strong>：</p>
<ul>
<li>创建长度为 <code>m</code> 的next数组，初始化 <code>next[0] = 0</code></li>
<li>使用双指针 <code>i</code> 和 <code>j</code> 构建next数组</li>
<li>当字符不匹配时，根据已有的next值进行回退</li>
<li>当字符匹配时，更新next数组</li>
</ul>
<h3 id="算法优势">算法优势</h3>
<p>这个实现的优点：</p>
<ol>
<li><strong>代码结构清晰</strong>：将next数组构建抽取为独立函数，职责分离</li>
<li><strong>易于理解</strong>：主函数专注于匹配逻辑，辅助函数专注于预处理</li>
<li><strong>可复用性强</strong>：<code>buildNext</code> 函数可以在其他需要next数组的场景中复用</li>
<li><strong>空间效率高</strong>：只使用必要的空间存储next数组</li>
</ol>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>暴力匹配</th>
<th>KMP算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n×m)</td>
<td>O(n+m)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(m)</td>
</tr>
<tr>
<td>预处理</td>
<td>无</td>
<td>需要构建next数组</td>
</tr>
<tr>
<td>失配处理</td>
<td>回退到起始位置+1</td>
<td>智能跳转，避免重复比较</td>
</tr>
<tr>
<td>适用场景</td>
<td>短模式串</td>
<td>长模式串或重复匹配</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>时间复杂度</strong>：$O(n + m)$</p>
<ul>
<li>构建next数组：$O(m)$</li>
<li>模式匹配：$O(n)$</li>
<li>虽然有嵌套循环，但每个字符最多被比较常数次</li>
</ul>
<p><strong>空间复杂度</strong>：$O(m)$</p>
<ul>
<li>next数组需要 $O(m)$ 空间</li>
</ul>
<h2 id="KMP算法优化详解">KMP算法优化详解</h2>
<h3 id="1-next数组的本质">1. next数组的本质</h3>
<p>next数组记录的是<strong>最长相等前后缀长度</strong>，这样设计的目的是：</p>
<ul>
<li>当失配时，我们知道前面已经匹配的部分中哪些可以复用</li>
<li>避免不必要的回退和重复比较</li>
</ul>
<h3 id="2-失配跳转的数学原理">2. 失配跳转的数学原理</h3>
<p>假设在位置 <code>i</code> 失配，此时已匹配长度为 <code>j</code>：</p>
<ul>
<li>传统方法：回退到起始位置，时间复杂度退化为 $O(n \times m)$</li>
<li>KMP方法：跳转到 <code>next[j-1]</code>，利用已匹配信息，时间复杂度保持 $O(n + m)$</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>KMP的核心思想</strong>：利用已匹配的信息，避免无效的重复比较</li>
<li><strong>next数组是关键</strong>：正确理解和构建next数组是掌握KMP的重点</li>
<li><strong>失配处理策略</strong>：<code>j = next[j-1]</code> 而不是 <code>j = 0</code>，这是效率提升的关键</li>
<li><strong>时间复杂度保证</strong>：虽然有嵌套循环，但每个位置最多被访问常数次</li>
<li><strong>实际应用价值</strong>：KMP在文本编辑器、搜索引擎等场景中有重要应用</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ul>
<li><strong>边界条件</strong>：空字符串的处理</li>
<li><strong>索引计算</strong>：返回值应该是 <code>i - m + 1</code> 而不是 <code>i</code></li>
<li><strong>next数组理解</strong>：要明确是&quot;长度&quot;而不是&quot;索引&quot;</li>
<li><strong>失配逻辑</strong>：必须是 <code>j &gt; 0</code> 时才能跳转</li>
</ul>
<p>这道题不仅考查字符串处理能力，更重要的是对KMP算法思想的深入理解。掌握KMP算法对于解决复杂的字符串匹配问题具有重要意义。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>KMP算法</tag>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：ListPack 详解</title>
    <url>/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/listpack/</url>
    <content><![CDATA[<h1>ListPack 详解</h1>
<h2 id="1-ListPack-的由来">1. ListPack 的由来</h2>
<h3 id="1-1-压缩列表的痛点">1.1 <a href="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/">压缩列表</a>的痛点</h3>
<p>虽然 QuickList 通过&quot;分段压缩列表&quot;的方式减轻了连锁更新带来的性能影响，但并未从根本上解决问题，因为：</p>
<ul>
<li>QuickList 内部仍然使用压缩列表存储数据</li>
<li>连锁更新问题源于压缩列表的<strong>结构设计</strong>
<ul>
<li>引入<code>prevLen</code>字段，记录前一个节点的长度，当前一个节点长度发生变化时，有可能导致后续节点的<code>prevLen</code>字段也发生变化，但是原先的<code>prevLen</code>字段长度无法记录前一个节点的长度，于是<code>prevLen</code>字段也要变大，导致当前节点长度也要变大，于是连锁更新就发生了。</li>
</ul>
</li>
<li>当压缩列表中的元素较多时，性能问题仍然存在</li>
</ul>
<h3 id="1-2-革新的需求">1.2 革新的需求</h3>
<p>要彻底解决这个问题，Redis 开发团队决定：</p>
<blockquote>
<p>设计一个全新的数据结构来替代压缩列表，从根本上消除连锁更新的隐患</p>
</blockquote>
<p>于是，在 <strong>Redis 5.0 版本</strong>中，ListPack 数据结构应运而生。</p>
<h2 id="2-什么是-ListPack？">2. 什么是 ListPack？</h2>
<p>ListPack 是一种专为 Redis 设计的紧凑型线性数据结构：</p>
<ul>
<li><strong>设计目标</strong>：替代压缩列表，消除连锁更新问题</li>
<li><strong>核心特点</strong>：每个节点不再保存前一个节点的长度</li>
<li><strong>结构布局</strong>：使用连续内存空间存储数据</li>
<li><strong>编码方式</strong>：针对不同类型和大小的数据采用不同编码</li>
</ul>
<h2 id="3-ListPack-vs-压缩列表">3. ListPack vs 压缩列表</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>压缩列表 (ziplist)</th>
<th>ListPack</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存布局</td>
<td>连续内存空间</td>
<td>连续内存空间</td>
</tr>
<tr>
<td>节点设计</td>
<td>保存前一个节点长度</td>
<td>只保存当前节点长度</td>
</tr>
<tr>
<td>连锁更新</td>
<td>存在风险</td>
<td>完全避免</td>
</tr>
<tr>
<td>插入性能</td>
<td>可能导致整体重新分配</td>
<td>局部调整，影响小</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>相对简单</td>
<td>稍微复杂</td>
</tr>
</tbody>
</table>
<h2 id="4-ListPack-结构设计">4. ListPack 结构设计</h2>
<h3 id="4-1-整体结构">4.1 整体结构</h3>
<p>ListPack 由三部分组成：</p>
<ol>
<li><strong>头部</strong>：包含 ListPack 总字节数和元素数量</li>
<li><strong>节点列表</strong>：一系列紧密排列的 ListPack 节点</li>
<li><strong>结尾标识</strong>：特殊字节标记 ListPack 结束</li>
</ol>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/listpack/1748331428008.png" alt="ListPack结构图"></p>
<h3 id="4-2-节点结构">4.2 节点结构</h3>
<p>每个 ListPack 节点包含三个主要部分：</p>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/listpack/1748331435055.png" alt="ListPack节点结构"></p>
<ol>
<li>
<p><strong>encoding</strong>：指定元素的编码类型</p>
<ul>
<li>存储数据的类型（整数/字符串）</li>
<li>存储数据的长度</li>
<li>使用变长编码节省空间</li>
</ul>
</li>
<li>
<p><strong>data</strong>：实际存储的数据内容</p>
<ul>
<li>根据 encoding 指定的类型和长度进行解析</li>
</ul>
</li>
<li>
<p><strong>len</strong>：当前节点的总长度（encoding + data）</p>
<ul>
<li>关键改进：<strong>只记录自身长度</strong>，不记录前一个节点长度</li>
</ul>
</li>
</ol>
<h2 id="5-ListPack-如何解决连锁更新问题？">5. ListPack 如何解决连锁更新问题？</h2>
<h3 id="5-1-连锁更新的本质">5.1 连锁更新的本质</h3>
<p>压缩列表之所以会发生连锁更新，本质上是因为：</p>
<ol>
<li>每个节点需要保存<strong>前一个节点的长度</strong></li>
<li>当前驱节点长度变化时，后续节点都需要更新这个字段</li>
<li>更新可能导致节点自身长度变化，进而影响更多节点</li>
</ol>
<h3 id="5-2-ListPack-的解决方案">5.2 ListPack 的解决方案</h3>
<p>ListPack 的解决方案非常简单但高效：</p>
<blockquote>
<p><strong>只记录当前节点长度，不记录前一个节点长度</strong></p>
</blockquote>
<p>这样一来：</p>
<ul>
<li>当插入/删除/修改节点时，只会影响当前操作的节点</li>
<li>不会导致后续节点的元数据信息变更</li>
<li>有效避免了连锁反应</li>
</ul>
<h2 id="6-ListPack-的应用">6. ListPack 的应用</h2>
<h3 id="6-1-在-Redis-中的应用进程">6.1 在 Redis 中的应用进程</h3>
<p>Redis 版本对应的 ListPack 应用情况：</p>
<ul>
<li>Redis 5.0：引入 ListPack 数据结构</li>
<li>Redis 6.0：部分数据类型开始使用 ListPack</li>
<li>Redis 7.0：全面替代压缩列表</li>
</ul>
<h3 id="6-2-支持的数据类型">6.2 支持的数据类型</h3>
<p>ListPack 目前在 Redis 中主要用于以下数据类型：</p>
<ul>
<li>Hash 对象（小型哈希）</li>
<li>Zset 对象（小型有序集合）</li>
<li>未来会扩展到更多数据类型</li>
</ul>
<h2 id="7-ListPack-的优缺点">7. ListPack 的优缺点</h2>
<h3 id="7-1-优点">7.1 优点</h3>
<ul>
<li><strong>彻底解决</strong>连锁更新问题</li>
<li><strong>保持高效</strong>的内存使用率</li>
<li><strong>兼容</strong>压缩列表的大部分优势</li>
</ul>
<h3 id="7-2-局限性">7.2 局限性</h3>
<ul>
<li>访问特定位置元素依然需要线性遍历</li>
<li>不适合存储大量元素</li>
</ul>
<h2 id="8-小结">8. 小结</h2>
<p>ListPack 是 Redis 对压缩列表的一次成功革新，通过巧妙的结构设计，既保留了压缩列表节省内存的优势，又解决了其性能隐患。这一改进充分体现了 Redis 团队在优化数据结构方面的深思熟虑和不断创新的精神。</p>
<p>从压缩列表到 QuickList 再到 ListPack，我们可以看到 Redis 数据结构的演进历程，每一步都是为了在内存使用效率和操作性能之间寻找更好的平衡点。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
        <tag>压缩列表</tag>
        <tag>ListPack</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：QuickList 详解</title>
    <url>/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/quicklist/</url>
    <content><![CDATA[<h1>QuickList 详解</h1>
<h2 id="1-QuickList-的由来">1. QuickList 的由来</h2>
<p>在 Redis 3.2 版本之前，Redis 的 List 对象底层实现可以是：</p>
<ul>
<li><strong>双向链表</strong>（易于操作但内存开销大）</li>
<li><strong>压缩列表</strong>（节省内存但有性能隐患）</li>
</ul>
<p>而 Redis 3.2 版本开始，List 对象的底层实现统一改为了 <strong>QuickList</strong> 数据结构。</p>
<h2 id="2-什么是-QuickList？">2. 什么是 QuickList？</h2>
<p>QuickList 本质上是「<strong>双向链表 + 压缩列表</strong>」的混合体：</p>
<ul>
<li><strong>结构特点</strong>：每个链表节点都包含一个压缩列表</li>
<li><strong>设计理念</strong>：兼顾了双向链表的快速插入删除和压缩列表的内存节省优势</li>
</ul>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/quicklist/1748329930030.png" alt="QuickList结构示意图"></p>
<h2 id="3-为什么需要-QuickList？">3. 为什么需要 QuickList？</h2>
<h3 id="3-1-压缩列表的问题">3.1 压缩列表的问题</h3>
<p>压缩列表虽然内存利用率高，但存在严重缺陷：</p>
<ul>
<li><strong>连锁更新风险</strong>：当一个元素发生变化，可能导致后续所有元素位置都需要调整</li>
<li><strong>性能下降</strong>：元素数量增加或元素变大时，连锁更新风险增加，操作性能急剧下降</li>
</ul>
<h3 id="3-2-QuickList-的解决方案">3.2 QuickList 的解决方案</h3>
<p>QuickList 巧妙地解决了这个问题：</p>
<ul>
<li><strong>分而治之</strong>：将数据分散在多个小型压缩列表中</li>
<li><strong>限制规模</strong>：通过控制每个压缩列表的大小或元素个数</li>
<li><strong>降低风险</strong>：即使发生连锁更新，影响范围被限制在单个节点内</li>
</ul>
<blockquote>
<p>📌 <strong>核心思想</strong>：压缩列表越小，连锁更新的影响就越小，访问性能就越好。</p>
</blockquote>
<h2 id="4-QuickList-的结构设计">4. QuickList 的结构设计</h2>
<h3 id="4-1-主体结构">4.1 主体结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;      <span class="comment">// 链表头节点指针</span></span><br><span class="line">    quicklistNode *tail;      <span class="comment">// 链表尾节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;      <span class="comment">// 所有压缩列表中的元素总数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;        <span class="comment">// quicklistNode 节点总数</span></span><br><span class="line">    <span class="comment">// 其他配置参数...</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-节点结构">4.2 节点结构</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 后一个节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;           <span class="comment">// 指向压缩列表的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">// 压缩列表的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">// 压缩列表中的元素个数</span></span><br><span class="line">    <span class="comment">// 其他配置参数...</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<h2 id="5-QuickList-如何工作？">5. QuickList 如何工作？</h2>
<h3 id="5-1-元素添加过程">5.1 元素添加过程</h3>
<p>当向 QuickList 添加元素时：</p>
<ol>
<li><strong>先检查</strong>：判断插入位置的压缩列表是否能容纳新元素</li>
<li><strong>能容纳</strong>：直接将元素插入到对应压缩列表中</li>
<li><strong>不能容纳</strong>：创建新的 quicklistNode 节点，并在其中存储新元素</li>
</ol>
<h3 id="5-2-配置参数">5.2 配置参数</h3>
<p>Redis 提供了配置参数 <code>list-max-ziplist-size</code> 来控制压缩列表的大小：</p>
<ul>
<li><strong>正数值</strong>：表示每个压缩列表最多包含的元素个数</li>
<li><strong>负数值</strong>：表示每个压缩列表的最大字节数
<ul>
<li><code>-1</code>: ≤4KB</li>
<li><code>-2</code>: ≤8KB</li>
<li><code>-3</code>: ≤16KB</li>
<li><code>-4</code>: ≤32KB</li>
<li><code>-5</code>: ≤64KB</li>
</ul>
</li>
</ul>
<h2 id="6-QuickList-的优缺点">6. QuickList 的优缺点</h2>
<h3 id="6-1-优点">6.1 优点</h3>
<ul>
<li><strong>内存效率高</strong>：压缩列表节省内存</li>
<li><strong>访问性能好</strong>：分段存储限制了连锁更新的影响范围</li>
<li><strong>操作灵活</strong>：同时支持高效的表头表尾操作</li>
</ul>
<h3 id="6-2-缺点">6.2 缺点</h3>
<ul>
<li><strong>结构复杂</strong>：比单一数据结构的实现更复杂</li>
<li><strong>未完全解决</strong>：虽然降低了风险，但没有彻底消除连锁更新问题</li>
</ul>
<h2 id="7-小结">7. 小结</h2>
<p>QuickList 是 Redis 在内存使用和操作效率之间寻求平衡的产物，通过&quot;分段压缩列表&quot;的方式，有效控制了连锁更新的风险范围。虽然没有彻底解决压缩列表的固有问题，但在实际应用中已经取得了很好的效果。</p>
<p>这也启发了 Redis 后续开发 ListPack 数据结构，以彻底解决连锁更新问题。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
        <tag>压缩列表</tag>
        <tag>QuickList</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：跳表详解</title>
    <url>/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="跳表">跳表</h2>
<p><strong>什么是跳表？</strong></p>
<p>跳表（Skip List）可以简单理解为&quot;<strong>带电梯的多层楼房</strong>&quot;。想象一下：</p>
<ul>
<li>普通链表就像一层楼的走廊，要找某个房间只能一个一个房间地走过去</li>
<li>跳表就像多层楼房，上层楼有&quot;快速通道&quot;，可以快速跳跃到目标区域，然后再到下层精确查找</li>
</ul>
<p>Redis 只有 Zset（有序集合）对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p><strong>为什么 Zset 同时使用跳表和哈希表？</strong></p>
<p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样设计的好处是：</p>
<ul>
<li><strong>跳表负责范围查询</strong>：比如查找分数在 80-90 之间的所有学生</li>
<li><strong>哈希表负责单点查询</strong>：比如快速查找张三的具体分数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p><strong>数据一致性是如何保证的？</strong></p>
<p>Zset 对象在执行数据插入或更新时，会同时在跳表和哈希表中进行相同操作，确保两个数据结构的信息保持一致。就像酒店的房间登记系统，既要在楼层分布图上标记，也要在客户信息表中记录。</p>
<p>具体来说：</p>
<ul>
<li><strong>支持范围查询</strong>（如 ZRANGEBYSCORE 操作）：依靠跳表的有序特性</li>
<li><strong>支持快速单点查询</strong>（如 ZSCORE 操作）：依靠哈希表的 O(1) 查找</li>
</ul>
<p><strong>为什么通常只说跳表是 Zset 的底层结构？</strong></p>
<p>虽然 Zset 实际使用的是「哈希表 + 跳表」的组合结构，但我们讨论时通常只提跳表，是因为：</p>
<ul>
<li>哈希表主要起<strong>辅助作用</strong>，用于快速获取元素权重</li>
<li><strong>核心操作都是由跳表实现的</strong>，比如范围查询、排序等</li>
<li>跳表决定了 Zset 的主要特性和性能表现</li>
</ul>
<p>接下来，详细的说下跳表。</p>
<h3 id="跳表结构设计">跳表结构设计</h3>
<p>在理解跳表之前，我们先看看普通链表的问题。</p>
<p><strong>普通链表的查找问题：</strong><br>
链表在查找元素时，只能从头开始一个一个节点地遍历，就像在一条长长的队伍中找人，只能从队头开始一个个问过去，效率很低，时间复杂度是 O(N)。</p>
<p><strong>跳表的解决方案：</strong><br>
跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表。就像给队伍安排了多个&quot;队长&quot;，可以先问队长大概位置，再在小范围内精确查找，这样能快速定位数据。</p>
<p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/1748326331702.png" alt="1748326331702"></p>
<p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p>
<ul>
<li><strong>L0 层级</strong>（最底层）：共有 5 个节点，分别是节点 1、2、3、4、5（包含所有节点）</li>
<li><strong>L1 层级</strong>（中间层）：共有 3 个节点，分别是节点 2、3、5（部分节点）</li>
<li><strong>L2 层级</strong>（最高层）：只有 1 个节点，也就是节点 3（更少节点）</li>
</ul>
<p><strong>查找效率对比：</strong></p>
<ul>
<li><strong>普通链表</strong>：要找节点 4，需要从头开始：1→2→3→4，查找 4 次</li>
<li><strong>跳表查找</strong>：只需要 2 次跳跃：
<ol>
<li>从 L2 层直接跳到节点 3</li>
<li>从节点 3 在 L0 层向前一步找到节点 4</li>
</ol>
</li>
</ul>
<p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p>
<p><strong>跳表节点是怎么实现多层级的？</strong></p>
<p>要理解跳表的多层级结构，我们需要看看「跳表节点」的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的 level 数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<p>让我们逐个分析这个结构体的字段：</p>
<p><strong>1. 数据存储字段：</strong></p>
<ul>
<li><code>sds ele</code>：存储 Zset 对象的元素值（比如学生姓名&quot;张三&quot;）</li>
<li><code>double score</code>：存储元素的权重值（比如学生分数 85.5）</li>
</ul>
<p><strong>2. 后向指针：</strong></p>
<ul>
<li><code>struct zskiplistNode *backward</code>：指向前一个节点</li>
<li>作用：方便从跳表尾节点开始倒序遍历，就像可以从队尾往前走一样</li>
</ul>
<p><strong>3. 关键的多层级实现：</strong></p>
<ul>
<li><code>struct zskiplistLevel level[]</code>：这是实现多层级的关键！</li>
</ul>
<p><strong>level 数组是如何工作的？</strong></p>
<ul>
<li>level 数组中的每个元素代表跳表的一层</li>
<li><code>level[0]</code> 表示第一层（L0），<code>level[1]</code> 表示第二层（L1），以此类推</li>
<li>每层包含两个信息：
<ul>
<li><code>forward</code>：指向下一个跳表节点的指针</li>
<li><code>span</code>：跨度，记录两个节点之间的距离</li>
</ul>
</li>
</ul>
<p>比如，下面这张图，展示了各个节点的跨度。</p>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/1748326342079.png" alt="1748326342079"></p>
<p><strong>跨度（span）的作用是什么？</strong></p>
<p>很多人第一眼看到跨度，会以为是用来辅助遍历的，但实际上并不是。遍历操作只需要用前向指针（forward）就可以完成了。</p>
<p><strong>跨度的真正作用：计算节点排位</strong></p>
<ul>
<li>跳表中的节点都是按分数排序的</li>
<li>要计算某个节点在跳表中的排位（排第几名），就需要用到跨度</li>
<li>计算方法：从头节点到目标节点的查找路径上，将沿途经过的所有层的跨度累加起来</li>
</ul>
<p><strong>举个例子：</strong><br>
查找图中节点 3 在跳表中的排位：</p>
<ol>
<li>从头节点开始查找节点 3</li>
<li>查找过程只经过了一个层（L2）</li>
<li>L2 层的跨度是 3</li>
<li>所以节点 3 在跳表中的排位是第 3 名</li>
</ol>
<p>这就像马拉松比赛中的距离标记，通过累加经过的距离标记，可以知道跑了多远。</p>
<p><strong>头节点的特殊性：</strong><br>
图中的头节点其实也是 zskiplistNode 跳表节点，只不过头节点比较特殊：</p>
<ul>
<li>后向指针、权重、元素值都没有用到（所以图中省略了）</li>
<li>主要作用是作为各层链表的起始点</li>
</ul>
<p><strong>跳表的整体管理结构：</strong><br>
那么，由谁来管理整个跳表，定义哪个节点是头节点呢？这就需要介绍「跳表」结构体了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p>跳表结构里包含了四个重要信息：</p>
<ul>
<li>
<p><strong>header/tail</strong>：跳表的头尾节点指针</p>
<ul>
<li>好处：可以在 O(1) 时间内直接访问头节点和尾节点</li>
<li>就像电梯楼层显示器，可以直接知道最高层和最低层</li>
</ul>
</li>
<li>
<p><strong>length</strong>：跳表的节点数量</p>
<ul>
<li>好处：可以在 O(1) 时间内获取跳表有多少个节点</li>
<li>就像楼房的住户统计表，直接知道总共有多少住户</li>
</ul>
</li>
<li>
<p><strong>level</strong>：跳表的最大层数</p>
<ul>
<li>好处：可以在 O(1) 时间内知道跳表的最高层是第几层</li>
<li>就像建筑物的楼层标识，直接知道这栋楼有多高</li>
</ul>
</li>
</ul>
<h3 id="跳表节点查询过程">跳表节点查询过程</h3>
<p><strong>跳表查找的基本策略：</strong><br>
跳表查找就像在多层停车场找车位一样，先从最高层快速定位区域，再逐层下降精确查找。</p>
<p><strong>具体查找过程：</strong><br>
跳表会从头节点的最高层开始，逐一遍历每一层。在每一层查找时，有明确的判断规则：</p>
<p><strong>何时继续在当前层前进？</strong><br>
满足以下任一条件就继续在当前层向前移动：</p>
<ol>
<li><strong>权重比较</strong>：下一个节点的权重 &lt; 目标权重</li>
<li><strong>相同权重时的元素比较</strong>：下一个节点的权重 = 目标权重，但元素值 &lt; 目标元素值</li>
</ol>
<p><strong>何时跳到下一层？</strong><br>
如果上面两个条件都不满足，或者下一个节点为空，就跳到下一层继续查找。</p>
<p>这个策略确保了：</p>
<ul>
<li>在每一层都能快速跳过明显不符合的节点</li>
<li>权重相同时还能根据元素值进行精确比较</li>
<li>逐层下降，最终精确定位目标节点</li>
</ul>
<p>举个例子，下图有个 3 层级的跳表。</p>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/1748326431445.png" alt="1748326431445"></p>
<p><strong>实际查找示例：</strong><br>
假设要查找「元素：abcd，权重：4」的节点，整个查找过程如下：</p>
<p><strong>第一步：从 L2 层开始</strong></p>
<ul>
<li>当前位置：头节点的 L2 层</li>
<li>下一个节点：「元素：abc，权重：3」</li>
<li>判断：3 &lt; 4（目标权重），符合条件1，继续在 L2 层前进</li>
<li>到达「元素：abc，权重：3」节点</li>
</ul>
<p><strong>第二步：继续在 L2 层查找</strong></p>
<ul>
<li>当前位置：「元素：abc，权重：3」的 L2 层</li>
<li>下一个节点：空节点</li>
<li>判断：下一个节点为空，跳到下一层（L1）</li>
</ul>
<p><strong>第三步：在 L1 层查找</strong></p>
<ul>
<li>当前位置：「元素：abc，权重：3」的 L1 层</li>
<li>下一个节点：「元素：abcde，权重：4」</li>
<li>判断：权重相同（4=4），但 “abcde” &gt; “abcd”，不符合条件2，跳到下一层（L0）</li>
</ul>
<p><strong>第四步：在 L0 层查找</strong></p>
<ul>
<li>当前位置：「元素：abc，权重：3」的 L0 层</li>
<li>下一个节点：「元素：abcd，权重：4」</li>
<li>判断：找到目标节点！查找结束</li>
</ul>
<p>这个过程展示了跳表如何利用多层结构快速定位，避免了逐个遍历所有节点。</p>
<h3 id="跳表节点层数设置">跳表节点层数设置</h3>
<p><strong>层级比例对性能的影响</strong></p>
<p>跳表的性能很大程度上取决于相邻两层节点数量的比例。如果比例不当，查询效率会大打折扣。</p>
<p><strong>不良设计的例子：</strong><br>
下图展示了一个设计不佳的跳表，第二层只有 1 个节点，而第一层有 6 个节点。</p>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/1748326449383.png" alt="1748326449383"></p>
<p><strong>问题分析：</strong><br>
如果要查询节点 6，会发生什么？</p>
<ul>
<li>第二层只能跳到节点 3，然后就没有更多节点了</li>
<li>只能在第一层从节点 3 开始：3→4→5→6，逐个查找</li>
<li>这样就失去了跳表的优势，查询复杂度退化为 O(N)</li>
</ul>
<p><strong>理想的层级比例：</strong><br>
为了保持跳表的高效性，<strong>相邻两层的节点数量最理想的比例是 2:1</strong>，这样可以将查找复杂度维持在 O(logN)。</p>
<p><strong>良好设计的例子：</strong><br>
下图展示了一个设计良好的跳表，相邻两层的节点数量比例接近 2:1。</p>
<p><img src="/2025/05/27/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/1748326457615.png" alt="1748326457615"></p>
<blockquote>
<p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1  呢？</p>
</blockquote>
<p><strong>如何维持理想的层级比例？</strong></p>
<p>传统做法是在新增或删除节点时调整跳表结构来维持 2:1 比例，但这会带来额外的计算开销。</p>
<p><strong>Redis 的巧妙解决方案：随机层数生成</strong></p>
<p>Redis 采用了一种更巧妙的方法：<strong>在创建节点时随机生成每个节点的层数</strong>，而不是严格维持 2:1 比例。</p>
<p><strong>随机生成算法：</strong></p>
<ol>
<li>生成一个 [0-1] 范围的随机数</li>
<li>如果随机数 &lt; 0.25（25% 概率），层数增加 1</li>
<li>继续生成下一个随机数，重复步骤 2</li>
<li>直到随机数 ≥ 0.25 为止，确定最终层数</li>
</ol>
<p><strong>这种方法的特点：</strong></p>
<ul>
<li>每增加一层的概率是 25%</li>
<li>层数越高，出现概率越低</li>
<li>层高最大限制是 64（Redis 7.0 中是 32）</li>
</ul>
<p><strong>为什么随机方法有效？</strong></p>
<ul>
<li>25% 的概率意味着平均每 4 个节点中有 1 个会出现在更高层</li>
<li>这自然形成了接近 4:1 的比例关系（虽然不是严格的 2:1，但仍然有效）</li>
<li>避免了复杂的平衡调整操作</li>
</ul>
<p><strong>关于头节点的层数：</strong><br>
前面图例中为了简化说明，头节点只画了 3 层，但实际上<strong>头节点会直接创建最大层数的结构</strong>。如果最大层数限制是 32，那么头节点就有 32 层，这样可以支持任意高度的节点插入。</p>
<p><strong>头节点的创建过程：</strong><br>
从下面的代码可以看到，创建跳表时：</p>
<ul>
<li>头节点的 level 数组有 ZSKIPLIST_MAXLEVEL 个元素（层）</li>
<li>头节点不存储任何实际数据（member 和 score 都为空）</li>
<li>所有层的 forward 指针都指向 NULL</li>
<li>所有层的 span 值都为 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不同版本的最大层数限制：</strong></p>
<ul>
<li>Redis 7.0：32 层</li>
<li>Redis 5.0：64 层</li>
<li>Redis 3.0：32 层</li>
</ul>
<p>可以看到，Redis 在不同版本中对最大层数进行了调整，这是为了在内存使用和性能之间找到更好的平衡点。</p>
<h3 id="为什么用跳表而不用平衡树？">为什么用跳表而不用平衡树？</h3>
<p><strong>常见面试题解析</strong></p>
<p>这是一个非常经典的面试题：为什么 Zset 选择跳表而不是平衡树（如 AVL 树、红黑树等）？</p>
<p>这个问题，我们可以看看 Redis 作者 @antirez 的<a href="https://news.ycombinator.com/item?id=1171423">原话</a>：</p>
<blockquote>
<p>There are a few reasons:</p>
<ol>
<li>
<p>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</p>
</li>
<li>
<p>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p>
</li>
<li>
<p>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p>
</li>
</ol>
</blockquote>
<p><strong>作者观点的总结和深入分析：</strong></p>
<p>作者主要从三个方面说明了选择跳表的原因，让我详细解释一下：</p>
<p><strong>1. 内存使用更灵活</strong></p>
<ul>
<li><strong>平衡树</strong>：每个节点固定包含 2 个指针（左右子树）</li>
<li><strong>跳表</strong>：每个节点的指针数量是动态的，平均为 1/(1-p)</li>
<li>在 Redis 中，p=1/4，所以平均每个节点包含 1.33 个指针</li>
<li><strong>结论</strong>：跳表比平衡树节省内存</li>
</ul>
<p><strong>2. 范围查询更简单</strong></p>
<ul>
<li><strong>平衡树的问题</strong>：找到范围的起始值后，需要进行复杂的中序遍历来找到范围内的所有节点</li>
<li><strong>跳表的优势</strong>：找到起始值后，只需要在第 1 层（最底层）链表上连续遍历即可</li>
<li><strong>比喻</strong>：就像在图书馆找书，跳表相当于找到书架后直接从左到右拿书，而平衡树需要在整个图书馆里按特定顺序跳着找书</li>
</ul>
<p><strong>3. 实现和维护更简单</strong></p>
<ul>
<li><strong>平衡树的复杂性</strong>：插入和删除可能触发复杂的树结构调整（旋转操作），代码复杂，调试困难</li>
<li><strong>跳表的简单性</strong>：插入和删除只需要修改相邻节点的指针，就像在链表中插入节点一样简单</li>
<li><strong>实际好处</strong>：代码易读、易维护、易扩展（比如添加 ZRANK 功能只需要少量代码修改）</li>
</ul>
<p><strong>为什么这些特点对 Redis 很重要？</strong></p>
<ul>
<li><strong>Zset 经常需要范围查询</strong>（ZRANGE、ZREVRANGE 等命令）</li>
<li><strong>Redis 强调简单和可靠性</strong>，复杂的平衡树增加了出错风险</li>
<li><strong>内存是 Redis 的重要考量</strong>，跳表的内存效率更符合需求</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
        <tag>跳表</tag>
        <tag>skiplist</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 135 - 分发糖果（Candy）</title>
    <url>/2025/05/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>想象一下，你是一位老师，要给班上的孩子们分发糖果 🍭。孩子们排成一排，每个孩子都有一个评分（可以理解为考试成绩）。</p>
<p><strong>分糖果的规则很简单：</strong></p>
<ol>
<li>每个孩子至少要有 1 颗糖果（不能让任何孩子空手而归）</li>
<li>如果相邻的两个孩子，评分高的那个必须比评分低的拿到更多糖果</li>
</ol>
<p><strong>你的任务：</strong> 用最少的糖果数量，让所有孩子都满意！</p>
<p><strong>举个例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">孩子评分：[1, 0, 2]</span><br><span class="line">最优分配：[2, 1, 2]  总共需要 5 颗糖果</span><br></pre></td></tr></table></figure>
<p>为什么这样分配？</p>
<ul>
<li>第1个孩子(评分1) vs 第2个孩子(评分0)：1 &gt; 0，所以第1个孩子要比第2个多 → 2颗 vs 1颗 ✅</li>
<li>第2个孩子(评分0) vs 第3个孩子(评分2)：0 &lt; 2，所以第3个孩子要比第2个多 → 1颗 vs 2颗 ✅</li>
</ul>
<h2 id="我最开始的错误想法-😅">我最开始的错误想法 😅</h2>
<h3 id="❌-想法一：只看左边邻居">❌ 想法一：只看左边邻居</h3>
<p>我刚开始想，既然要满足规则，那就从左到右遍历，每次只要比左边邻居满足条件就行了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 这样想是错的！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(ratings)</span><br><span class="line">    candies := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    candies[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment">// 第一个孩子给1颗</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">            candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment">// 比左边多1颗</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candies[i] = <span class="number">1</span>  <span class="comment">// 否则就给1颗</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算总数...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样做错在哪里？</strong></p>
<p>让我们用例子 <code>[1,0,2]</code> 试试：</p>
<ul>
<li>第1个孩子：给1颗</li>
<li>第2个孩子：评分0 &lt; 评分1，所以给1颗</li>
<li>第3个孩子：评分2 &gt; 评分0，所以给2颗</li>
</ul>
<p>结果：<code>[1,1,2]</code></p>
<p><strong>问题出现了！</strong> 第1个孩子评分1，第2个孩子评分0，但是他们都拿1颗糖果！这违反了规则：评分高的应该拿更多糖果。</p>
<p><strong>教训：只看一边是不够的，我们需要同时满足左右两边的关系！</strong></p>
<h3 id="❌-想法二：边遍历边修正">❌ 想法二：边遍历边修正</h3>
<p>然后我想，那我在遍历的时候，发现问题就立即修正：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 这样也是错的！</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">        candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        candies[i] = <span class="number">1</span></span><br><span class="line">        <span class="comment">// 发现左边的孩子糖果可能不够，马上修正</span></span><br><span class="line">        <span class="keyword">if</span> ratings[i<span class="number">-1</span>] &gt; ratings[i] &amp;&amp; candies[i<span class="number">-1</span>] &lt;= candies[i] &#123;</span><br><span class="line">            candies[i<span class="number">-1</span>] = candies[i] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这样还是错的！</strong> 因为当我修改前面孩子的糖果数时，可能又影响了更前面的孩子，需要连锁修正，一遍遍历根本搞不定。</p>
<p><strong>教训：这种问题需要更系统的思考方式！</strong></p>
<h2 id="正确解法：分步骤思考">正确解法：分步骤思考</h2>
<h3 id="💡-核心思想：分而治之">💡 核心思想：分而治之</h3>
<p>既然一次搞定左右关系很困难，那我们就分两步：</p>
<ol>
<li><strong>第一步：</strong> 只考虑左边关系，从左到右遍历</li>
<li><strong>第二步：</strong> 只考虑右边关系，从右到左遍历</li>
<li><strong>最后：</strong> 每个位置取两种要求的最大值</li>
</ol>
<h3 id="方法一：两次遍历（推荐新手理解）">方法一：两次遍历（推荐新手理解）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(ratings)</span><br><span class="line">    left := <span class="built_in">make</span>([]<span class="type">int</span>, n)  <span class="comment">// 存储只考虑左边关系的结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 🚶‍♂️ 第一次遍历：从左到右，只管左边邻居</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment">// 比左边多1颗</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = <span class="number">1</span>  <span class="comment">// 最少1颗</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 🚶‍♀️ 第二次遍历：从右到左，只管右边邻居</span></span><br><span class="line">    right := <span class="number">1</span>  <span class="comment">// 当前位置从右边看需要的糖果数</span></span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; n<span class="number">-1</span> &amp;&amp; ratings[i] &gt; ratings[i+<span class="number">1</span>] &#123;</span><br><span class="line">            right++  <span class="comment">// 比右边多1颗</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = <span class="number">1</span>  <span class="comment">// 最少1颗</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 🎯 关键：取两个要求的最大值</span></span><br><span class="line">        total += max(left[i], right)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>让我们用例子 <code>[1,0,2]</code> 详细走一遍：</strong></p>
<p><strong>第一次遍历（从左到右）：</strong></p>
<ul>
<li>i=0: ratings[0]=1，第一个孩子，给1颗 → left[0]=1</li>
<li>i=1: ratings[1]=0 &lt; ratings[0]=1，给1颗 → left[1]=1</li>
<li>i=2: ratings[2]=2 &gt; ratings[1]=0，给2颗 → left[2]=2</li>
</ul>
<p>结果：left = [1,1,2]</p>
<p><strong>第二次遍历（从右到左）：</strong></p>
<ul>
<li>i=2: ratings[2]=2，最后一个孩子，给1颗 → right=1，total += max(2,1) = 2</li>
<li>i=1: ratings[1]=0 &lt; ratings[2]=2，给1颗 → right=1，total += max(1,1) = 1，total=3</li>
<li>i=0: ratings[0]=1 &gt; ratings[1]=0，给2颗 → right=2，total += max(1,2) = 2，total=5</li>
</ul>
<p><strong>最终结果：</strong> 5颗糖果，分配方案是 [2,1,2] ✅</p>
<h3 id="方法二：一次遍历（高级技巧）">方法二：一次遍历（高级技巧）</h3>
<p>如果你已经理解了上面的方法，我们可以学习一个更巧妙的技巧：用&quot;爬山&quot;的思维来思考这个问题。</p>
<p><strong>核心思想：</strong> 把评分序列想象成一座座山峰和山谷，我们要沿着山路分发糖果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(ratings)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    total := <span class="number">1</span>       <span class="comment">// 第一个孩子的糖果</span></span><br><span class="line">    upSlope := <span class="number">0</span>     <span class="comment">// 当前上坡的长度</span></span><br><span class="line">    downSlope := <span class="number">0</span>   <span class="comment">// 当前下坡的长度</span></span><br><span class="line">    peakHeight := <span class="number">0</span>  <span class="comment">// 山峰的高度（上坡长度）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="comment">// 📈 上坡：评分在上升</span></span><br><span class="line">            downSlope = <span class="number">0</span>           <span class="comment">// 重置下坡</span></span><br><span class="line">            upSlope++               <span class="comment">// 上坡长度+1</span></span><br><span class="line">            peakHeight = upSlope    <span class="comment">// 更新山峰高度</span></span><br><span class="line">            total += upSlope + <span class="number">1</span>    <span class="comment">// 当前孩子得到 upSlope+1 颗糖果</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ratings[i] == ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="comment">// ➡️ 平地：评分相等</span></span><br><span class="line">            upSlope = <span class="number">0</span>     <span class="comment">// 重置所有状态</span></span><br><span class="line">            downSlope = <span class="number">0</span></span><br><span class="line">            peakHeight = <span class="number">0</span></span><br><span class="line">            total += <span class="number">1</span>      <span class="comment">// 平地上只需要1颗糖果</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 📉 下坡：评分在下降</span></span><br><span class="line">            upSlope = <span class="number">0</span>     <span class="comment">// 重置上坡</span></span><br><span class="line">            downSlope++     <span class="comment">// 下坡长度+1</span></span><br><span class="line">            total += downSlope  <span class="comment">// 这是关键的一步！</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 🏔️ 特殊处理：山峰可能需要更多糖果</span></span><br><span class="line">            <span class="keyword">if</span> peakHeight &lt; downSlope &#123;</span><br><span class="line">                total += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>让我用爬山的比喻解释 <code>total += downSlope</code> 这个关键步骤：</strong></p>
<p>想象你在一个下坡路段：<code>[5, 4, 3, 2, 1]</code></p>
<p>按照规则，糖果应该这样分配：<code>[5, 4, 3, 2, 1]</code></p>
<p>当我们走到最后一个孩子（评分1）时：</p>
<ul>
<li>他需要1颗糖果</li>
<li>倒数第2个孩子需要2颗糖果</li>
<li>倒数第3个孩子需要3颗糖果</li>
<li>…</li>
</ul>
<p><code>total += downSlope</code> 巧妙地实现了这个分配：</p>
<ul>
<li>给当前孩子1颗</li>
<li>同时给前面的每个孩子&quot;补&quot;1颗</li>
</ul>
<p><strong>山峰的特殊处理：</strong></p>
<p>这是算法中最精妙的部分！让我详细解释为什么需要 <code>total += 1</code> 这个修正。</p>
<p>考虑这个例子：<code>[1, 3, 2, 1]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /\</span><br><span class="line"> /  \</span><br><span class="line">/    \</span><br></pre></td></tr></table></figure>
<p><strong>关键问题：山峰既是上坡的终点，也是下坡的起点！</strong></p>
<p>让我们分步分析：</p>
<ol>
<li><strong>上坡阶段</strong>：山峰（评分3）因为上坡得到了 <code>peakHeight + 1 = 2</code> 颗糖果</li>
<li><strong>下坡阶段</strong>：当我们处理下坡时
<ul>
<li>最右边的孩子（评分1）得到 1 颗糖果</li>
<li>倒数第2个孩子（评分2）需要比右边多，得到 2 颗糖果</li>
<li>山峰（评分3）需要比右边的孩子（评分2）多，至少需要 3 颗糖果</li>
</ul>
</li>
</ol>
<p><strong>矛盾出现了！</strong></p>
<ul>
<li>山峰从上坡角度只得到了 2 颗糖果</li>
<li>但从下坡角度需要至少 3 颗糖果</li>
</ul>
<p><strong>算法是怎么发现和解决这个问题的？</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当处理下坡时，downSlope = 2（下坡长度）</span></span><br><span class="line">total += downSlope  <span class="comment">// 这给下坡路径分配了糖果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查山峰是否需要额外糖果</span></span><br><span class="line"><span class="keyword">if</span> peakHeight &lt; downSlope &#123;  <span class="comment">// 1 &lt; 2，条件成立</span></span><br><span class="line">    total += <span class="number">1</span>  <span class="comment">// 给山峰补1颗糖果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么补1颗就够了？</strong></p>
<p>这里有个巧妙的数学关系：</p>
<ul>
<li>山峰右边第一个孩子（下坡起点）现在有 <code>downSlope</code> 颗糖果</li>
<li>山峰需要比它多1颗，即需要 <code>downSlope + 1</code> 颗</li>
<li>山峰原来有 <code>peakHeight + 1</code> 颗</li>
<li>差值就是：<code>(downSlope + 1) - (peakHeight + 1) = downSlope - peakHeight</code></li>
<li>当 <code>peakHeight &lt; downSlope</code> 时，差值就是1！</li>
</ul>
<p><strong>用具体数字验证：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子 [1, 3, 2, 1]：</span><br><span class="line">- peakHeight = 1（上坡长度）</span><br><span class="line">- downSlope = 2（下坡长度）</span><br><span class="line">- 山峰原有糖果：1 + 1 = 2颗</span><br><span class="line">- 山峰需要糖果：2 + 1 = 3颗</span><br><span class="line">- 需要补充：3 - 2 = 1颗 ✅</span><br></pre></td></tr></table></figure>
<p>这就是为什么 <code>total += 1</code> 这一行代码如此关键——它确保了山峰能同时满足左右两边的约束条件！</p>
<h2 id="用具体例子演示整个过程">用具体例子演示整个过程</h2>
<p>让我们用 <code>[1, 3, 2, 1]</code> 详细演示一次遍历的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态：</span><br><span class="line">- total = 1 (第一个孩子)</span><br><span class="line">- upSlope = 0, downSlope = 0, peakHeight = 0</span><br><span class="line"></span><br><span class="line">i=1: ratings[1]=3 &gt; ratings[0]=1 (上坡)</span><br><span class="line">- downSlope = 0</span><br><span class="line">- upSlope = 1</span><br><span class="line">- peakHeight = 1  </span><br><span class="line">- total += 2 (upSlope+1)</span><br><span class="line">- total = 1 + 2 = 3</span><br><span class="line"></span><br><span class="line">i=2: ratings[2]=2 &lt; ratings[1]=3 (下坡)</span><br><span class="line">- upSlope = 0</span><br><span class="line">- downSlope = 1</span><br><span class="line">- total += 1 (downSlope)</span><br><span class="line">- total = 3 + 1 = 4</span><br><span class="line">- peakHeight(1) &lt; downSlope(1)? 否，不需要补充</span><br><span class="line"></span><br><span class="line">i=3: ratings[3]=1 &lt; ratings[2]=2 (继续下坡)  </span><br><span class="line">- downSlope = 2</span><br><span class="line">- total += 2 (downSlope)</span><br><span class="line">- total = 4 + 2 = 6</span><br><span class="line">- peakHeight(1) &lt; downSlope(2)? 是！需要补充</span><br><span class="line">- total += 1 = 7</span><br><span class="line"></span><br><span class="line">最终：total = 7，对应分配 [1, 3, 2, 1]</span><br></pre></td></tr></table></figure>
<h2 id="复杂度对比">复杂度对比</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>理解难度</th>
<th>推荐指数</th>
</tr>
</thead>
<tbody>
<tr>
<td>两次遍历</td>
<td>O(n)</td>
<td>O(n)</td>
<td>⭐⭐</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td>一次遍历</td>
<td>O(n)</td>
<td>O(1)</td>
<td>⭐⭐⭐⭐</td>
<td>⭐⭐⭐</td>
</tr>
</tbody>
</table>
<h2 id="常见错误总结">常见错误总结</h2>
<h3 id="1-只考虑一个方向的约束">1. 只考虑一个方向的约束</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误</span></span><br><span class="line"><span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">    candies[i] = candies[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    candies[i] = <span class="number">1</span>  <span class="comment">// 这里没考虑右边邻居</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-边界条件处理不当">2. 边界条件处理不当</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 忘记检查数组长度</span></span><br><span class="line"><span class="comment">// ❌ 数组下标越界</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;  <span class="comment">// 应该是 i &lt; n</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-状态重置遗漏">3. 状态重置遗漏</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 在平地时忘记重置状态</span></span><br><span class="line"><span class="keyword">if</span> ratings[i] == ratings[i<span class="number">-1</span>] &#123;</span><br><span class="line">    total += <span class="number">1</span>  <span class="comment">// 只加了糖果，忘记重置状态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="学到的经验">学到的经验</h2>
<h3 id="🎯-解题思路">🎯 解题思路</h3>
<ol>
<li><strong>分解问题：</strong> 复杂的双向约束 → 分别处理左右约束</li>
<li><strong>贪心策略：</strong> 每个位置取满足所有约束的最小值</li>
<li><strong>优化空间：</strong> 用状态变量代替额外数组</li>
</ol>
<h3 id="🔗-相关问题">🔗 相关问题</h3>
<ul>
<li><a href="/2025/04/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-42-trapping-rain-water/">LeetCode 42: 接雨水</a> - 也用到了&quot;山峰山谷&quot;的思想</li>
<li><a href="/2025/05/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/">LeetCode 84: 柱状图中最大的矩形</a> - 类似的单调性处理</li>
</ul>
<h3 id="💡-记忆口诀">💡 记忆口诀</h3>
<blockquote>
<p><strong>“爬山分糖果，左右都要顾，分步来解决，贪心定最优”</strong></p>
</blockquote>
<p>这道题教会我们：看似复杂的问题，往往可以通过巧妙的分解和贪心策略来解决。关键是要找到正确的思考角度！ 🎉</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>❌错题集</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 134 - 加油站（Gas Station）</title>
    <url>/2025/05/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code>，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。如果题目有解，该答案即为唯一答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 = 3 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 3 + 5 - 2 = 6 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 6 + 1 - 3 = 4 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 4 + 2 - 4 = 2 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可以作为起始索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 = 1 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 1 + 2 - 3 = 0 升汽油</span><br><span class="line">开往 2 号加油站，你需要消耗 4 升汽油，但是你的油箱只有 0 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>
<p><strong>约束：</strong></p>
<ul>
<li>gas.length == n</li>
<li>cost.length == n</li>
<li>1 &lt;= n &lt;= 10^5</li>
<li>0 &lt;= gas[i], cost[i] &lt;= 10^4</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我的初始解法是暴力枚举每个可能的起始位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> start := <span class="number">0</span>; start &lt; n; start++ &#123;</span><br><span class="line">        cnt := <span class="number">0</span></span><br><span class="line">        cur := start</span><br><span class="line">        remain := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cnt &lt; n &#123;</span><br><span class="line">            remain += gas[cur]</span><br><span class="line">            remain -= cost[cur]</span><br><span class="line">            <span class="keyword">if</span> remain &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = (cur + <span class="number">1</span>) % n</span><br><span class="line">            cnt++  <span class="comment">// ❌ 错误点：每次都要完整遍历一圈，导致 O(n²) 复杂度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cnt == n &#123;</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>这个解法在以下测试用例中会<strong>超时</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：gas = [1,1,1,...,1] (10^5个1), cost = [2,2,2,...,2] (10^5个2)</span><br><span class="line">预期输出：-1</span><br><span class="line">时间复杂度：O(n²) = O(10^10) → 超时！</span><br></pre></td></tr></table></figure>
<p><strong>关键问题：</strong></p>
<ol>
<li><strong>时间复杂度过高</strong>：对于每个起始位置，都要尝试绕完整个环路，最坏情况下是 $O(n^2)$</li>
<li><strong>重复计算</strong>：没有利用之前计算的结果，存在大量重复计算</li>
<li><strong>缺乏剪枝</strong>：没有利用问题的数学性质进行优化</li>
</ol>
<p>当 $n = 10^5$ 时，$O(n^2) = 10^{10}$ 次操作，必然超时。</p>
<h2 id="正确解法-贪心算法">正确解法 - 贪心算法</h2>
<p>经过分析，我发现了几个关键洞察：</p>
<h3 id="核心洞察">核心洞察</h3>
<ol>
<li><strong>总量判断</strong>：如果 $\sum gas[i] &lt; \sum cost[i]$，无论从哪里开始都不可能完成一圈</li>
<li><strong>唯一性</strong>：如果能完成一圈，起始点是唯一的</li>
<li><strong>关键定理</strong>：如果从位置 <code>start</code> 开始，能到达位置 <code>i</code> 但无法到达 <code>i+1</code>，那么从 <code>start</code> 到 <code>i</code> 之间的任何位置作为起点都无法到达 <code>i+1</code></li>
</ol>
<h3 id="定理证明">定理证明</h3>
<p>假设从位置 $j$（$start \leq j \leq i$）开始能到达 $i+1$，设：</p>
<ul>
<li>从 $start$ 到 $j-1$ 的净收益：$sum_1 \geq 0$</li>
<li>从 $j$ 到 $i$ 的净收益：$sum_2$</li>
<li>第 $i$ 站的净收益：$diff_i = gas[i] - cost[i]$</li>
</ul>
<p>从 $start$ 开始到达 $i$ 但无法到达 $i+1$：<br>
$$sum_1 + sum_2 + diff_i &lt; 0$$</p>
<p>从 $j$ 开始能到达 $i+1$：<br>
$$sum_2 + diff_i \geq 0$$</p>
<p>这导致矛盾：$sum_1 &lt; 0$，但我们知道从 $start$ 能到达 $j-1$，所以 $sum_1 \geq 0$。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="type">int</span>, cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line">    tank := <span class="number">0</span>    <span class="comment">// 当前油箱剩余</span></span><br><span class="line">    total := <span class="number">0</span>   <span class="comment">// 总的汽油量与消耗量的差值</span></span><br><span class="line">    start := <span class="number">0</span>   <span class="comment">// 起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        diff := gas[i] - cost[i]</span><br><span class="line">        tank += diff</span><br><span class="line">        total += diff</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前油量不够，说明从start到i都无法作为起始点</span></span><br><span class="line">        <span class="comment">// 下一个可能的起始点是i+1</span></span><br><span class="line">        <span class="keyword">if</span> tank &lt; <span class="number">0</span> &#123;</span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">            tank = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果总的汽油量小于总消耗量，无解</span></span><br><span class="line">    <span class="keyword">if</span> total &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法执行过程">算法执行过程</h3>
<p>以 <code>gas = [1,2,3,4,5], cost = [3,4,5,1,2]</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=0: diff=-2, tank=-2, total=-2, tank&lt;0 → start=1, tank=0</span><br><span class="line">i=1: diff=-2, tank=-2, total=-4, tank&lt;0 → start=2, tank=0  </span><br><span class="line">i=2: diff=-2, tank=-2, total=-6, tank&lt;0 → start=3, tank=0</span><br><span class="line">i=3: diff=3,  tank=3,  total=-3, tank≥0 → 继续</span><br><span class="line">i=4: diff=3,  tank=6,  total=0,  tank≥0 → 继续</span><br><span class="line"></span><br><span class="line">最终 total=0≥0，返回 start=3</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>暴力解法</th>
<th>贪心算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>核心思想</td>
<td>枚举所有起始位置</td>
<td>利用数学性质剪枝</td>
</tr>
<tr>
<td>是否超时</td>
<td>❌ 大数据量超时</td>
<td>✅ 高效通过</td>
</tr>
<tr>
<td>实现难度</td>
<td>简单直观</td>
<td>需要理解贪心思想</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度：-O-n">时间复杂度：$O(n)$</h3>
<p>只需要遍历一次数组，每个元素访问一次。</p>
<h3 id="空间复杂度：-O-1">空间复杂度：$O(1)$</h3>
<p>只使用了常数个额外变量：<code>tank</code>、<code>total</code>、<code>start</code>。</p>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>贪心算法的本质</strong>：利用问题的数学性质，避免重复计算</li>
<li><strong>优化思路</strong>：从 $O(n^2)$ 到 $O(n)$ 的关键是找到剪枝条件</li>
<li><strong>证明的重要性</strong>：理解为什么贪心策略是正确的</li>
<li><strong>实际应用</strong>：类似的&quot;环形数组&quot;问题都可以用这种思路优化</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ul>
<li>❌ 忽略总量检查，导致错误判断</li>
<li>❌ 没有重置 <code>tank</code> 为 0，导致累积错误</li>
<li>❌ 边界条件处理不当（如空数组）</li>
</ul>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><a href="https://leetcode.cn/problems/candy/">LeetCode 135 - 分发糖果</a>：类似的贪心思想</li>
<li><a href="https://leetcode.cn/problems/jump-game/">LeetCode 55 - 跳跃游戏</a>：贪心 + 数组遍历</li>
<li><a href="https://leetcode.cn/problems/jump-game-ii/">LeetCode 45 - 跳跃游戏 II</a>：贪心优化</li>
</ul>
<p>通过这道题，我深刻理解了<strong>贪心算法的核心是找到问题的数学性质，避免暴力枚举</strong>。时间复杂度的优化往往来自于对问题本质的深入理解！</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Buffer Pool 详解：数据库性能优化的核心</title>
    <url>/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/</url>
    <content><![CDATA[<h1>MySQL Buffer Pool 详解：数据库性能优化的核心</h1>
<h2 id="为什么要有-Buffer-Pool？">为什么要有 Buffer Pool？</h2>
<p>想象一下，如果每次查询数据都要从硬盘读取，就像每次想看书都要去图书馆借一样，效率会非常低。MySQL 的数据虽然存储在磁盘里，但如果每次都从磁盘读取，性能会非常差。</p>
<p>怎么解决呢？很简单——<strong>加个缓存</strong>！</p>
<p>就像我们会把常用的书放在家里书架上一样，MySQL 会把经常使用的数据放在内存中。当数据从磁盘取出后，先缓存在内存中，下次查询相同数据时，直接从内存读取，速度飞快！</p>
<p>为此，InnoDB 存储引擎设计了一个专门的<strong>缓冲池（Buffer Pool）</strong>，这就是数据库性能优化的核心组件。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229548952.png" alt="1748229548952"></p>
<p>有了缓冲池后，数据库的工作方式就像这样：</p>
<ul>
<li><strong>读取数据时</strong>：先看看 Buffer Pool 里有没有，有的话直接拿来用；没有的话再去磁盘读取，然后放到 Buffer Pool 里备用</li>
<li><strong>修改数据时</strong>：不急着写磁盘，先在 Buffer Pool 里改，把这个页标记为&quot;脏页&quot;（表示已修改），然后让后台线程慢慢写到磁盘</li>
</ul>
<p>这样既提高了读取速度，又避免了频繁的磁盘写入操作。</p>
<h3 id="Buffer-Pool-有多大？">Buffer Pool 有多大？</h3>
<p>Buffer Pool 就像是 MySQL 的&quot;内存仓库&quot;，在 MySQL 启动时向操作系统申请一块连续的内存空间。</p>
<p><strong>默认大小</strong>：只有 128MB（太小了，生产环境肯定不够用）</p>
<p><strong>如何调整</strong>：通过 <code>innodb_buffer_pool_size</code> 参数设置</p>
<ul>
<li><strong>推荐大小</strong>：物理内存的 60%~80%</li>
<li><strong>举例</strong>：如果服务器有 8GB 内存，可以设置为 5-6GB</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前 Buffer Pool 大小</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置 Buffer Pool 大小为 4GB</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">4294967296</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Buffer-Pool-缓存什么？">Buffer Pool 缓存什么？</h3>
<p>你可能会问：Buffer Pool 到底缓存什么数据呢？</p>
<p>首先要了解一个概念：<strong>数据页</strong>。InnoDB 把数据分成一个个&quot;页&quot;，就像把书分成一页页纸一样。每页的大小是 16KB，这是磁盘和内存交换数据的基本单位。</p>
<p><strong>Buffer Pool 的工作原理</strong>：</p>
<ol>
<li>MySQL 启动时，申请一大块内存空间</li>
<li>把这块内存按 16KB 切分成很多&quot;缓存页&quot;</li>
<li>刚开始这些缓存页都是空的</li>
<li>随着查询的进行，磁盘上的数据页会被载入这些缓存页</li>
</ol>
<p><strong>有趣的现象</strong>：MySQL 刚启动时，你会发现虚拟内存很大，但实际物理内存使用很小。这是因为操作系统采用了&quot;懒加载&quot;机制——只有真正访问内存时，才会分配物理内存。</p>
<p><strong>Buffer Pool 缓存的内容</strong>：</p>
<ul>
<li><strong>数据页</strong>：表中的实际数据</li>
<li><strong>索引页</strong>：B+树索引结构</li>
<li><strong>undo 页</strong>：用于事务回滚的数据</li>
<li><strong>插入缓存</strong>：优化插入操作的缓存</li>
<li><strong>自适应哈希索引</strong>：InnoDB 自动创建的哈希索引</li>
<li><strong>锁信息</strong>：并发控制相关信息</li>
</ul>
<p>简单来说，就是把经常用到的各种数据都放在内存里，提高访问速度。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229578943.png" alt="1748229578943"></p>
<h3 id="控制块：缓存页的-身份证">控制块：缓存页的&quot;身份证&quot;</h3>
<p>光有缓存页还不够，还需要管理这些页面。想象一下，如果你有很多书，但没有目录和标签，怎么快速找到想要的那本书呢？</p>
<p>InnoDB 为每个缓存页都创建了一个<strong>控制块</strong>，就像给每个缓存页发了一张&quot;身份证&quot;，记录着：</p>
<ul>
<li><strong>表空间 ID</strong>：这个页属于哪个数据库表</li>
<li><strong>页号</strong>：在表中的第几页</li>
<li><strong>缓存页地址</strong>：在内存中的具体位置</li>
<li><strong>链表节点信息</strong>：用于各种链表管理</li>
</ul>
<p><strong>内存布局</strong>：控制块放在 Buffer Pool 的最前面，后面才是缓存页：</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229586453.png" alt="1748229586453"></p>
<p>你可能注意到了图中的灰色部分——这是<strong>碎片空间</strong>。</p>
<p><strong>为什么会有碎片空间？</strong></p>
<p>这很好理解：每个控制块都要对应一个缓存页，当分配完所有的控制块和缓存页后，可能剩余的内存空间不够再分配一对控制块和缓存页，这部分&quot;剩余&quot;的内存就是碎片空间。</p>
<blockquote>
<p><strong>小贴士</strong>：如果你精确计算 Buffer Pool 的大小，也可以避免产生碎片空间。</p>
</blockquote>
<h3 id="常见疑问：查询一条记录，只缓存这条记录吗？">常见疑问：查询一条记录，只缓存这条记录吗？</h3>
<p><strong>答案是：不是的！</strong></p>
<p>这是一个很有意思的问题。当你查询一条记录时，MySQL 实际上会把<strong>整个页</strong>（16KB）都加载到 Buffer Pool 中。</p>
<p><strong>为什么要这样做？</strong></p>
<p>想象一下在图书馆找书的场景：</p>
<ol>
<li>你想看某本书的第 100 页第 5 行</li>
<li>但图书管理员只能告诉你这本书在哪个书架上</li>
<li>你拿到整本书后，再翻到第 100 页第 5 行</li>
</ol>
<p>MySQL 的工作原理类似：</p>
<ol>
<li><strong>索引定位</strong>：通过索引只能定位到数据在哪个&quot;页&quot;上</li>
<li><strong>加载整页</strong>：把整个 16KB 的页加载到 Buffer Pool</li>
<li><strong>页内查找</strong>：通过页目录定位到具体的记录</li>
</ol>
<p><strong>这样做的好处</strong>：</p>
<ul>
<li><strong>空间局部性</strong>：同一页的其他数据很可能也会被访问</li>
<li><strong>减少 I/O</strong>：一次性读取 16KB 比多次读取小块数据更高效</li>
<li><strong>页是原子单位</strong>：数据库以页为单位管理数据更加高效</li>
</ul>
<blockquote>
<p><strong>延伸阅读</strong>：想了解页结构和索引查询的详细原理，可以参考：<a href="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/">换一个角度看 B+ 树</a></p>
</blockquote>
<h2 id="如何管理-Buffer-Pool？">如何管理 Buffer Pool？</h2>
<p>Buffer Pool 有很多缓存页，就像一个大仓库有很多货架。要高效管理这些页面，MySQL 设计了几种不同的&quot;链表&quot;来分类管理。</p>
<h3 id="空闲页管理：Free-链表">空闲页管理：Free 链表</h3>
<p><strong>问题</strong>：MySQL 需要加载新数据时，怎么快速找到空闲的缓存页？</p>
<p>如果每次都遍历整个 Buffer Pool 来找空闲页，效率太低了。就像在一个大仓库里挨个检查每个货架是否空着一样。</p>
<p><strong>解决方案</strong>：使用 <strong>Free 链表</strong>（空闲链表）</p>
<p>把所有空闲缓存页的控制块串成一个链表，需要空闲页时，直接从链表头取一个就行了。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229596157.png" alt="1748229596157"></p>
<p><strong>Free 链表的组成</strong>：</p>
<ul>
<li><strong>链表头节点</strong>：记录链表的基本信息
<ul>
<li>头节点地址和尾节点地址</li>
<li>当前空闲页的数量</li>
</ul>
</li>
<li><strong>控制块节点</strong>：每个节点对应一个空闲的缓存页</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>需要加载新数据时</strong>：从 Free 链表头部取一个空闲缓存页</li>
<li><strong>填充控制块信息</strong>：记录表空间、页号等信息</li>
<li><strong>从链表中移除</strong>：该控制块不再是&quot;空闲&quot;状态</li>
</ol>
<p>这样的设计让查找空闲页的时间复杂度从 O(n) 降到了 O(1)，大大提高了效率。</p>
<h3 id="脏页管理：Flush-链表">脏页管理：Flush 链表</h3>
<p>Buffer Pool 不仅能提高读性能，还能提高写性能。当你修改数据时，MySQL 并不急着写磁盘，而是先在内存中修改，然后把这个页标记为<strong>脏页</strong>。</p>
<p><strong>什么是脏页？</strong></p>
<ul>
<li><strong>脏页</strong>：内存中的数据已经被修改，但还没同步到磁盘</li>
<li><strong>干净页</strong>：内存和磁盘的数据是一致的</li>
</ul>
<p><strong>问题</strong>：后台线程怎么知道哪些页是脏页，需要写入磁盘呢？</p>
<p><strong>解决方案</strong>：使用 <strong>Flush 链表</strong></p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229649895.png" alt="1748229649895"></p>
<p><strong>Flush 链表的特点</strong>：</p>
<ul>
<li>链表结构和 Free 链表类似</li>
<li>区别是：Flush 链表中的都是脏页的控制块</li>
<li>后台线程定期遍历 Flush 链表，将脏页写入磁盘</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>数据修改时</strong>：页面标记为脏页，控制块加入 Flush 链表</li>
<li><strong>后台刷盘</strong>：后台线程遍历 Flush 链表，写入磁盘</li>
<li><strong>写入完成</strong>：从 Flush 链表中移除，页面变为干净页</li>
</ol>
<p>这种设计实现了<strong>延迟写入</strong>，大大提高了写操作的性能。</p>
<h3 id="缓存淘汰策略：改进版-LRU-算法">缓存淘汰策略：改进版 LRU 算法</h3>
<p>Buffer Pool 的空间是有限的，就像你的书桌空间有限一样。我们希望：</p>
<ul>
<li><strong>常用数据</strong>：一直留在 Buffer Pool 中</li>
<li><strong>不常用数据</strong>：及时淘汰掉，腾出空间</li>
</ul>
<p>这是典型的缓存淘汰问题。最直观的解决方案是使用 <strong>LRU（Least Recently Used）算法</strong>。</p>
<p><strong>经典 LRU 算法原理</strong>：</p>
<ul>
<li><strong>链表头部</strong>：最近使用的数据（热数据）</li>
<li><strong>链表尾部</strong>：最久未使用的数据（冷数据）</li>
<li><strong>淘汰策略</strong>：空间不足时，淘汰链表尾部的数据</li>
</ul>
<p><strong>经典 LRU 算法的操作</strong>：</p>
<ol>
<li><strong>页面命中</strong>（在 Buffer Pool 中）：将该页移动到链表头部</li>
<li><strong>页面未命中</strong>（不在 Buffer Pool 中）：淘汰尾部页面，新页面加入头部</li>
</ol>
<p>让我们通过例子来理解：</p>
<p>假设 LRU 链表长度为 5，当前有页面 1、2、3、4、5：</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229660469.png" alt="1748229660469"></p>
<p><strong>场景一：访问已存在的页面</strong><br>
访问 3 号页时，由于它已经在 Buffer Pool 中，直接移动到头部：</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229667608.png" alt="1748229667608"></p>
<p><strong>场景二：访问不存在的页面</strong><br>
访问 8 号页时，由于它不在 Buffer Pool 中：</p>
<ol>
<li>淘汰尾部的 5 号页</li>
<li>将 8 号页加入到头部</li>
</ol>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229675238.png" alt="1748229675238"></p>
<h3 id="Buffer-Pool-中的三种页面状态">Buffer Pool 中的三种页面状态</h3>
<p>通过前面的学习，我们知道 Buffer Pool 使用三种链表来管理不同状态的页面：</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229683283.png" alt="1748229683283"></p>
<p><strong>三种页面状态</strong>：</p>
<table>
<thead>
<tr>
<th>页面类型</th>
<th>状态描述</th>
<th>所在链表</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Free Page（空闲页）</strong></td>
<td>未被使用的页面</td>
<td>Free 链表</td>
</tr>
<tr>
<td><strong>Clean Page（干净页）</strong></td>
<td>已使用但未修改的页面<br>内存和磁盘数据一致</td>
<td>LRU 链表</td>
</tr>
<tr>
<td><strong>Dirty Page（脏页）</strong></td>
<td>已使用且已修改的页面<br>内存和磁盘数据不一致</td>
<td>LRU 链表 + Flush 链表</td>
</tr>
</tbody>
</table>
<p><strong>页面状态转换</strong>：</p>
<ul>
<li><strong>空闲页 → 干净页</strong>：加载磁盘数据后</li>
<li><strong>干净页 → 脏页</strong>：修改数据后</li>
<li><strong>脏页 → 干净页</strong>：写入磁盘后</li>
<li><strong>任何页 → 空闲页</strong>：从 Buffer Pool 中淘汰后</li>
</ul>
<h3 id="经典-LRU-算法的两大问题">经典 LRU 算法的两大问题</h3>
<p>虽然 LRU 算法思路很好，但 MySQL 并没有直接使用经典的 LRU 算法，因为它无法解决两个关键问题：</p>
<h4 id="问题一：预读失效">问题一：预读失效</h4>
<p><strong>什么是预读机制？</strong></p>
<p>MySQL 有一个很聪明的设计叫&quot;预读&quot;。基于程序的<strong>空间局部性原理</strong>，当你访问某个数据页时，MySQL 会猜测你接下来可能访问相邻的数据页，于是提前加载它们。</p>
<p>就像你在看连续剧，看完第 5 集，很可能接下来会看第 6、7 集，所以视频网站会提前缓存这些集数。</p>
<p><strong>预读失效的问题</strong>：</p>
<p>![示意图：预读页占据 LRU 头部位置]</p>
<p>但是，如果这些预读的页面实际上没有被访问，就会出现问题：</p>
<ol>
<li><strong>预读页占据热点位置</strong>：这些无用的预读页被放在 LRU 链表头部</li>
<li><strong>真正的热数据被淘汰</strong>：Buffer Pool 空间不足时，链表尾部的热数据反而被淘汰</li>
<li><strong>缓存命中率下降</strong>：导致更多的磁盘 I/O</li>
</ol>
<p><strong>具体例子</strong>：</p>
<ul>
<li>你查询用户表的第 100 页数据</li>
<li>MySQL 预读了第 101、102、103 页</li>
<li>但你实际只需要第 100 页的数据</li>
<li>结果：无用的 101、102、103 页占据了宝贵的缓存空间</li>
</ul>
<h4 id="解决方案：LRU-链表分区">解决方案：LRU 链表分区</h4>
<p>我们不能因为害怕预读失效就取消预读机制，因为大部分情况下空间局部性原理是成立的。</p>
<p><strong>核心思想</strong>：让预读的页停留时间尽可能短，真正被访问的页才能进入热点区域。</p>
<p><strong>MySQL 的解决方案</strong>：将 LRU 链表分为两个区域</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229697824.png" alt="1748229697824"></p>
<p><strong>两个区域的设计</strong>：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>位置</th>
<th>作用</th>
<th>默认比例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Young 区域</strong></td>
<td>链表前半部分</td>
<td>存放热点数据</td>
<td>63%</td>
</tr>
<tr>
<td><strong>Old 区域</strong></td>
<td>链表后半部分</td>
<td>存放新加载/预读数据</td>
<td>37%</td>
</tr>
</tbody>
</table>
<p><strong>配置参数</strong>：<code>innodb_old_blocks_pct = 37</code>（表示 old 区域占 37%）</p>
<p><strong>新的工作流程</strong>：</p>
<ol>
<li><strong>预读页面</strong>：直接放入 old 区域头部（不是整个 LRU 的头部）</li>
<li><strong>页面被访问</strong>：从 old 区域移动到 young 区域头部</li>
<li><strong>预读页面未被访问</strong>：在 old 区域自然老化，最终被淘汰</li>
</ol>
<p><strong>好处</strong>：</p>
<ul>
<li>✅ 预读页面不会立即占据热点位置</li>
<li>✅ 真正使用的数据才能进入 young 区域</li>
<li>✅ 未使用的预读页面会较快被淘汰</li>
<li>✅ 热点数据得到更好的保护</li>
</ul>
<p>接下来，给大家举个例子。</p>
<p>假设有一个长度为 10 的 LRU 链表，其中 young 区域占比 70 %，old 区域占比 30 %。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229706232.png" alt="1748229706232"></p>
<p>现在有个编号为 20 的页被预读了，这个页只会被插入到  old 区域头部，而 old 区域末尾的页（10 号）会被淘汰掉。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229713256.png" alt="1748229713256"></p>
<p>如果 20 号页一直不会被访问，它也没有占用到 young 区域的位置，而且还会比 young 区域的数据更早被淘汰出去。</p>
<p>如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 young 区域的头部，young 区域末尾的页（7 号），会被挤到 old 区域，作为 old 区域的头部，这个过程并不会有页被淘汰。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229721586.png" alt="1748229721586"></p>
<p>虽然通过划分 old 区域 和 young 区域避免了预读失效带来的影响，但是还有个问题无法解决，那就是  Buffer Pool  污染的问题。</p>
<blockquote>
<p>什么是  Buffer Pool  污染？</p>
</blockquote>
<p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在  Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool  污染</strong>。</p>
<p>注意，Buffer Pool  污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool  污染。</p>
<p>比如，在一个数据量非常大的表，执行了这条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> &quot;%xiaolin%&quot;;</span><br></pre></td></tr></table></figure>
<p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p>
<ul>
<li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li>
<li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；</li>
<li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li>
<li>如此往复，直到扫描完表中的所有记录。</li>
</ul>
<p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。</p>
<p>举个例子，假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229731726.png" alt="1748229731726"></p>
<p>在批量访问这些数据的时候，会被逐一插入到 young 区域头部。</p>
<p><img src="/2025/05/26/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%86%85%E5%AD%98/BufferPool/1748229738373.png" alt="1748229738373"></p>
<p>可以看到，原本在 young 区域的热点数据 6 和 7 号页都被淘汰了，这就是  Buffer Pool  污染的问题。</p>
<blockquote>
<p>怎么解决出现   Buffer Pool  污染而导致缓存命中率下降的问题？</p>
</blockquote>
<p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。</p>
<p>LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。</p>
<p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li>
<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li>
</ul>
<p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p>
<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool  污染的问题。</p>
<p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4 被访问了才会。</p>
<h3 id="脏页什么时候会被刷入磁盘？">脏页什么时候会被刷入磁盘？</h3>
<p>引入了 Buffer Pool  后，当修改数据时，首先是修改  Buffer Pool  中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。</p>
<p>因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。</p>
<p>可能大家担心，如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？</p>
<p>这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p>
<p>下面几种情况会触发脏页的刷新：</p>
<ul>
<li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li>
<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li>
<li>MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；</li>
<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li>
</ul>
<p>在我们开启了慢 SQL 监控后，如果你发现**「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p>
<p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h2 id="总结">总结</h2>
<p>Buffer Pool 是 MySQL InnoDB 存储引擎的核心组件，通过内存缓存大大提升了数据库的读写性能。</p>
<h3 id="核心概念回顾">核心概念回顾</h3>
<p><strong>基本概念</strong>：</p>
<ul>
<li><strong>作用</strong>：缓存热点数据，减少磁盘 I/O</li>
<li><strong>单位</strong>：以 16KB 的页为基本单位</li>
<li><strong>大小</strong>：默认 128MB，建议设置为物理内存的 60%~80%</li>
</ul>
<p><strong>三种链表管理</strong>：</p>
<table>
<thead>
<tr>
<th>链表类型</th>
<th>管理对象</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Free 链表</strong></td>
<td>空闲页</td>
<td>快速分配空闲缓存页</td>
</tr>
<tr>
<td><strong>Flush 链表</strong></td>
<td>脏页</td>
<td>管理需要写入磁盘的页面</td>
</tr>
<tr>
<td><strong>LRU 链表</strong></td>
<td>所有使用中的页</td>
<td>缓存淘汰策略</td>
</tr>
</tbody>
</table>
<h3 id="MySQL-的-LRU-优化">MySQL 的 LRU 优化</h3>
<p>为了解决经典 LRU 算法的问题，MySQL 做了两个关键优化：</p>
<p><strong>1. 链表分区</strong>：</p>
<ul>
<li><strong>Young 区域</strong>（63%）：存放热点数据</li>
<li><strong>Old 区域</strong>（37%）：存放新加载的数据</li>
<li><strong>解决问题</strong>：预读失效</li>
</ul>
<p><strong>2. 时间门槛</strong>：</p>
<ul>
<li><strong>条件</strong>：页面在 old 区域停留时间 &gt; 1 秒才能进入 young 区域</li>
<li><strong>解决问题</strong>：Buffer Pool 污染（全表扫描等）</li>
</ul>
<h3 id="重要参数">重要参数</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Buffer Pool 大小</span></span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> <span class="number">4</span>G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Old 区域比例</span></span><br><span class="line">innodb_old_blocks_pct <span class="operator">=</span> <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进入 Young 区域的时间门槛</span></span><br><span class="line">innodb_old_blocks_time <span class="operator">=</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<h3 id="性能监控要点">性能监控要点</h3>
<p>如果发现偶尔出现的慢 SQL，可能是脏页刷盘导致的性能抖动，可以考虑：</p>
<ul>
<li>调大 Buffer Pool 大小</li>
<li>调大 redo log 大小</li>
<li>监控脏页比例和刷盘频率</li>
</ul>
<p>Buffer Pool 的设计体现了 MySQL 在性能优化方面的精妙之处，理解其原理对于数据库调优和故障排查都非常重要。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>内存</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>Buffer Pool</tag>
        <tag>数据库优化</tag>
        <tag>内存管理</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 238 - 除自身以外数组的乘积（Product of Array Except Self）</title>
    <url>/2025/05/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>nums</code>，返回数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code> 之中任意元素的全部前缀元素和后缀元素的乘积都在 32 位整数范围内。</p>
<p>请 <strong>不要使用除法</strong>，且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>2 ≤ nums.length ≤ 10⁵</code></li>
<li><code>-30 ≤ nums[i] ≤ 30</code></li>
<li><strong>保证</strong> 数组 <code>nums</code> 之中任意元素的全部前缀元素和后缀元素的乘积都在 32 位整数范围内</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>对于位置 <code>i</code> 的结果，我们需要计算所有除了 <code>nums[i]</code> 以外的元素乘积。可以将这个乘积分解为两部分：</p>
<p><strong>核心思想</strong>：对于位置 <code>i</code>，结果等于 <strong>左侧所有元素的乘积</strong> × <strong>右侧所有元素的乘积</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组: [1, 2, 3, 4]</span><br><span class="line">位置:  0  1  2  3</span><br><span class="line"></span><br><span class="line">对于位置 i=1 (值为2):</span><br><span class="line">左侧乘积: nums[0] = 1</span><br><span class="line">右侧乘积: nums[2] × nums[3] = 3 × 4 = 12</span><br><span class="line">结果: 1 × 12 = 12</span><br></pre></td></tr></table></figure>
<p>根据这个思路，我们可以有多种实现方法。</p>
<h2 id="方法一：暴力解法">方法一：暴力解法</h2>
<h3 id="实现思路">实现思路</h3>
<p>对于每个位置 <code>i</code>，遍历整个数组计算除了 <code>nums[i]</code> 以外所有元素的乘积。</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelfBruteForce</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        product := <span class="number">1</span></span><br><span class="line">        <span class="comment">// 计算除nums[i]以外所有元素的乘积</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i != j &#123;</span><br><span class="line">                product *= nums[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = product</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n^2)$ - 对于每个位置都要遍历整个数组</li>
<li><strong>空间复杂度</strong>：$O(1)$ - 除了结果数组外，只使用常量额外空间</li>
</ul>
<h2 id="方法二：前缀和后缀乘积数组">方法二：前缀和后缀乘积数组</h2>
<h3 id="实现思路-2">实现思路</h3>
<ol>
<li><strong>左乘积数组</strong>：<code>left[i]</code> 表示 <code>nums[i]</code> 左侧所有元素的乘积</li>
<li><strong>右乘积数组</strong>：<code>right[i]</code> 表示 <code>nums[i]</code> 右侧所有元素的乘积</li>
<li><strong>结果</strong>：<code>result[i] = left[i] × right[i]</code></li>
</ol>
<h3 id="详细步骤">详细步骤</h3>
<p>以 <code>nums = [1, 2, 3, 4]</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原数组:     [1, 2, 3, 4]</span><br><span class="line">左乘积:     [1, 1, 2, 6]    // left[i] = nums[0] * ... * nums[i-1]</span><br><span class="line">右乘积:     [24, 12, 4, 1]  // right[i] = nums[i+1] * ... * nums[n-1]</span><br><span class="line">结果:       [24, 12, 8, 6]  // result[i] = left[i] * right[i]</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-2">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelfTwoArrays</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    left := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    right := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建左乘积数组</span></span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        left[i] = left[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建右乘积数组</span></span><br><span class="line">    right[n<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        right[i] = right[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        result[i] = left[i] * right[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$ - 三次遍历数组</li>
<li><strong>空间复杂度</strong>：$O(n)$ - 需要额外的 left 和 right 数组</li>
</ul>
<h2 id="方法三：空间优化解法（推荐）">方法三：空间优化解法（推荐）</h2>
<h3 id="实现思路-3">实现思路</h3>
<p>优化方法二，使用结果数组来存储左乘积，然后用一个变量来维护右乘积，从右向左更新结果。</p>
<h3 id="详细步骤-2">详细步骤</h3>
<ol>
<li><strong>第一遍</strong>：结果数组存储每个位置的左乘积</li>
<li><strong>第二遍</strong>：从右往左遍历，用变量 <code>right</code> 维护右乘积，同时更新结果</li>
</ol>
<h3 id="执行过程演示">执行过程演示</h3>
<p>以 <code>nums = [1, 2, 3, 4]</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化: nums = [1, 2, 3, 4], result = [0, 0, 0, 0]</span><br><span class="line"></span><br><span class="line">第一遍 - 计算左乘积:</span><br><span class="line">i=0: result[0] = 1              → result = [1, 0, 0, 0]</span><br><span class="line">i=1: result[1] = result[0] * nums[0] = 1 * 1 = 1   → result = [1, 1, 0, 0]</span><br><span class="line">i=2: result[2] = result[1] * nums[1] = 1 * 2 = 2   → result = [1, 1, 2, 0]</span><br><span class="line">i=3: result[3] = result[2] * nums[2] = 2 * 3 = 6   → result = [1, 1, 2, 6]</span><br><span class="line"></span><br><span class="line">第二遍 - 计算最终结果:</span><br><span class="line">right = 1</span><br><span class="line">i=3: result[3] *= right = 6 * 1 = 6, right *= nums[3] = 1 * 4 = 4   → result = [1, 1, 2, 6]</span><br><span class="line">i=2: result[2] *= right = 2 * 4 = 8, right *= nums[2] = 4 * 3 = 12  → result = [1, 1, 8, 6]</span><br><span class="line">i=1: result[1] *= right = 1 * 12 = 12, right *= nums[1] = 12 * 2 = 24 → result = [1, 12, 8, 6]</span><br><span class="line">i=0: result[0] *= right = 1 * 24 = 24, right *= nums[0] = 24 * 1 = 24 → result = [24, 12, 8, 6]</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-3">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelf</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一遍：计算左乘积</span></span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        result[i] = result[i<span class="number">-1</span>] * nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二遍：从右往左计算右乘积并更新结果</span></span><br><span class="line">    right := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        result[i] *= right</span><br><span class="line">        right *= nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$ - 两次遍历数组</li>
<li><strong>空间复杂度</strong>：$O(1)$ - 除了结果数组外，只使用常量额外空间</li>
</ul>
<h2 id="方法四：处理零值的特殊解法">方法四：处理零值的特殊解法</h2>
<h3 id="实现思路-4">实现思路</h3>
<p>考虑到数组中可能包含零值，我们可以：</p>
<ol>
<li>统计零的个数</li>
<li>计算所有非零元素的乘积</li>
<li>根据零的个数决定结果</li>
</ol>
<h3 id="代码实现-4">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productExceptSelfWithZeros</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    </span><br><span class="line">    zeroCount := <span class="number">0</span></span><br><span class="line">    product := <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计零的个数和计算非零元素乘积</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">            zeroCount++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product *= num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> zeroCount &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 有多个零，所有位置结果都是0</span></span><br><span class="line">            result[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> zeroCount == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 只有一个零</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;</span><br><span class="line">                result[i] = product</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有零，使用除法</span></span><br><span class="line">            result[i] = product / nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：这个方法违反了题目&quot;不要使用除法&quot;的要求，仅作为思路扩展。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一：暴力</th>
<th>方法二：两数组</th>
<th>方法三：空间优化</th>
<th>方法四：特殊处理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时间复杂度</strong></td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>$O(1)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td><strong>可读性</strong></td>
<td>★★★★☆</td>
<td>★★★★★</td>
<td>★★★★☆</td>
<td>★★★☆☆</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>★☆☆☆☆</td>
<td>★★★★☆</td>
<td>★★★★★</td>
<td>★★★★☆</td>
</tr>
<tr>
<td><strong>推荐度</strong></td>
<td>★☆☆☆☆</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
<td>★★☆☆☆</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>学习理解</td>
<td>面试演示思路</td>
<td>最优解法</td>
<td>违反题目要求</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<h3 id="核心算法概念">核心算法概念</h3>
<ol>
<li><strong>前缀积和后缀积</strong>：将复杂问题分解为左右两部分的乘积</li>
<li><strong>空间优化</strong>：通过重复利用数组空间来减少额外内存使用</li>
<li><strong>双指针思想</strong>：一次从左到右，一次从右到左的遍历模式</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>边界处理</strong>：注意数组首尾元素的特殊处理</li>
<li><strong>初始值设置</strong>：乘积运算的初始值应该是 1，不是 0</li>
<li><strong>理解题意</strong>：题目要求不使用除法，要避免 <code>product / nums[i]</code> 的思路</li>
</ol>
<h3 id="相关问题">相关问题</h3>
<ul>
<li>LeetCode 152: 乘积最大子数组</li>
<li>LeetCode 628: 三个数的最大乘积</li>
<li>LeetCode 724: 寻找数组的中心索引</li>
</ul>
<p>这道题是一个经典的前缀积应用，掌握了这个思路对解决类似的数组乘积问题都很有帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 执行一条 SELECT 语句的完整过程详解</title>
    <url>/2025/05/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1>MySQL 执行一条 SELECT 语句的完整过程详解</h1>
<h2 id="引言">引言</h2>
<p>当我们在 MySQL 中执行一条简单的查询语句时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>看起来只是一行代码，但在 MySQL 内部却经历了一个复杂而精密的执行过程。今天我们就来揭开这个&quot;黑盒子&quot;，看看 MySQL 是如何一步步处理我们的查询请求的。</p>
<h2 id="MySQL-架构概览">MySQL 架构概览</h2>
<p>在深入了解执行流程之前，我们先来看看 MySQL 的整体架构：</p>
<p><img src="/2025/05/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%87%E7%A8%8B/1748166843430.png" alt="MySQL架构图"></p>
<p>MySQL 的架构主要分为两层：</p>
<h3 id="Server-层（服务层）">Server 层（服务层）</h3>
<p><strong>主要职责</strong>：接收请求、解析 SQL、制定执行计划</p>
<ul>
<li><strong>连接器</strong>：负责建立连接，验证用户身份</li>
<li><strong>查询缓存</strong>：缓存查询结果（MySQL 8.0 已移除）</li>
<li><strong>解析器</strong>：解析 SQL 语句，检查语法</li>
<li><strong>优化器</strong>：选择最优的执行方案</li>
<li><strong>执行器</strong>：真正执行 SQL 语句</li>
</ul>
<h3 id="存储引擎层">存储引擎层</h3>
<p><strong>主要职责</strong>：负责数据的实际存储和读取</p>
<ul>
<li>支持多种存储引擎：InnoDB、MyISAM、Memory 等</li>
<li>InnoDB 是当前默认的存储引擎</li>
</ul>
<blockquote>
<p><strong>面试重点</strong>：这种分层架构的好处是什么？</p>
<p>分层架构使得 MySQL 可以支持多种存储引擎，不同的应用场景可以选择最适合的存储引擎，而上层的 SQL 处理逻辑保持不变。</p>
</blockquote>
<h2 id="详细执行流程">详细执行流程</h2>
<h3 id="第一步：连接器-建立-桥梁">第一步：连接器 - 建立&quot;桥梁&quot;</h3>
<p><strong>作用</strong>：建立客户端与 MySQL 服务器之间的连接</p>
<h4 id="连接过程">连接过程</h4>
<ol>
<li><strong>TCP 三次握手</strong>：建立网络连接</li>
<li><strong>身份验证</strong>：验证用户名和密码</li>
<li><strong>权限获取</strong>：读取用户权限并缓存</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接 MySQL 的常用命令</span></span><br><span class="line">mysql -h 127.0.0.1 -u root -p</span><br></pre></td></tr></table></figure>
<h4 id="连接管理">连接管理</h4>
<p><strong>查看当前连接数</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROCESSLIST;</span><br></pre></td></tr></table></figure>
<p><strong>重要参数</strong>：</p>
<ul>
<li><code>max_connections</code>：最大连接数（默认 151）</li>
<li><code>wait_timeout</code>：空闲连接超时时间（默认 8 小时）</li>
</ul>
<h4 id="长连接-vs-短连接">长连接 vs 短连接</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">短连接：连接 → 执行SQL → 断开连接</span><br><span class="line">长连接：连接 → 执行SQL → 执行SQL → ... → 断开连接</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>面试重点</strong>：为什么推荐使用长连接？</p>
<p>长连接可以避免频繁建立和断开连接的开销，提高性能。但需要注意内存占用问题，可以通过定期断开长连接或使用 <code>mysql_reset_connection()</code> 来释放内存。</p>
</blockquote>
<h3 id="第二步：查询缓存-快速通道">第二步：查询缓存 - 快速通道</h3>
<p><strong>作用</strong>：如果之前执行过完全相同的查询，直接返回缓存结果</p>
<h4 id="工作原理">工作原理</h4>
<ul>
<li>以 <code>key-value</code> 形式存储在内存中</li>
<li><code>key</code>：SQL 语句的完整文本</li>
<li><code>value</code>：查询结果</li>
</ul>
<h4 id="为什么被废弃？">为什么被废弃？</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题：只要表有任何更新，所有相关的查询缓存都会被清空</span><br><span class="line">结果：命中率极低，性能提升微乎其微</span><br><span class="line">决定：MySQL 8.0 直接移除了查询缓存功能</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>面试重点</strong>：查询缓存为什么效果不好？</p>
<p>因为查询缓存要求 SQL 语句完全一致才能命中，而且任何表更新都会清空相关缓存，在高并发的写多读少场景下，缓存失效频繁，反而影响性能。</p>
</blockquote>
<h3 id="第三步：解析器-理解-SQL">第三步：解析器 - 理解 SQL</h3>
<p><strong>作用</strong>：解析 SQL 语句，构建语法树</p>
<h4 id="两个主要步骤">两个主要步骤</h4>
<p><strong>1. 词法分析</strong></p>
<ul>
<li>识别 SQL 中的关键字：<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code> 等</li>
<li>提取表名、字段名、条件等信息</li>
</ul>
<p><strong>2. 语法分析</strong></p>
<ul>
<li>检查 SQL 语法是否正确</li>
<li>构建语法树，便于后续处理</li>
</ul>
<p><img src="/2025/05/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%87%E7%A8%8B/1748166913401.png" alt="语法树示例"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法错误示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> FORM product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 错误：FORM 应该是 FROM</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：解析器只检查语法，不检查表或字段是否存在</p>
</blockquote>
<h3 id="第四步：预处理器-验证有效性">第四步：预处理器 - 验证有效性</h3>
<p><strong>作用</strong>：检查 SQL 语句中引用的表和字段是否存在</p>
<h4 id="主要工作">主要工作</h4>
<ol>
<li><strong>检查表是否存在</strong></li>
<li><strong>检查字段是否存在</strong></li>
<li><strong>展开 <code>SELECT *</code></strong>：将 <code>*</code> 替换为具体的字段列表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果 test 表不存在，会在这个阶段报错</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="comment">-- ERROR 1146 (42S02): Table &#x27;database.test&#x27; doesn&#x27;t exist</span></span><br></pre></td></tr></table></figure>
<h3 id="第五步：优化器-制定最佳方案">第五步：优化器 - 制定最佳方案</h3>
<p><strong>作用</strong>：为 SQL 查询选择最优的执行计划</p>
<h4 id="优化器的工作">优化器的工作</h4>
<p><strong>选择索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果 product 表有多个索引，优化器会选择成本最低的</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">AND</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;iPhone%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>查看执行计划</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="执行计划示例">执行计划示例</h4>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>key</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>product</td>
<td>const</td>
<td>PRIMARY</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>type</strong>：访问类型（const &gt; eq_ref &gt; ref &gt; range &gt; ALL）</li>
<li><strong>key</strong>：使用的索引</li>
<li><strong>rows</strong>：预计扫描的行数</li>
</ul>
<blockquote>
<p><strong>面试重点</strong>：优化器如何选择索引？</p>
<p>优化器基于成本模型（Cost-Based Optimizer），会计算不同执行计划的成本，包括 I/O 成本、CPU 成本等，选择总成本最低的执行计划。</p>
</blockquote>
<h3 id="第六步：执行器-真正干活">第六步：执行器 - 真正干活</h3>
<p><strong>作用</strong>：根据执行计划，调用存储引擎接口获取数据</p>
<h4 id="三种典型的执行场景">三种典型的执行场景</h4>
<h4 id="1-主键索引查询">1. 主键索引查询</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong>：</p>
<ol>
<li>调用存储引擎的索引查询接口</li>
<li>存储引擎通过 B+ 树快速定位记录</li>
<li>返回完整记录给执行器</li>
<li>执行器验证条件并返回结果</li>
</ol>
<h4 id="2-全表扫描">2. 全表扫描</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;iPhone&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong>：</p>
<ol>
<li>从表的第一条记录开始读取</li>
<li>逐条检查 <code>name</code> 字段是否等于 ‘iPhone’</li>
<li>符合条件的记录返回给客户端</li>
<li>继续读取下一条记录，直到表结束</li>
</ol>
<h4 id="3-索引下推优化">3. 索引下推优化</h4>
<p><strong>什么是索引下推？</strong><br>
将原本在 Server 层进行的条件判断，&quot;下推&quot;到存储引擎层执行。</p>
<p><strong>举例说明</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设在 (age, reward) 字段上有联合索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">AND</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>
<p><strong>传统方式</strong>：</p>
<ol>
<li>存储引擎返回所有 <code>age &gt; 20</code> 的记录</li>
<li>Server 层再过滤 <code>reward = 100000</code></li>
</ol>
<p><strong>索引下推方式</strong>：</p>
<ol>
<li>存储引擎直接过滤 <code>age &gt; 20 AND reward = 100000</code></li>
<li>只返回完全符合条件的记录</li>
</ol>
<p><strong>优势</strong>：减少回表次数，提高查询效率</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看是否使用了索引下推</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">AND</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="comment">-- Extra 列显示 &quot;Using index condition&quot; 表示使用了索引下推</span></span><br></pre></td></tr></table></figure>
<h2 id="完整流程总结">完整流程总结</h2>
<p>让我们用一个简单的图表来总结整个执行流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端请求</span><br><span class="line">    ↓</span><br><span class="line">连接器（建立连接，验证身份）</span><br><span class="line">    ↓</span><br><span class="line">查询缓存（MySQL 8.0 已移除）</span><br><span class="line">    ↓</span><br><span class="line">解析器（词法分析，语法分析）</span><br><span class="line">    ↓</span><br><span class="line">预处理器（检查表和字段）</span><br><span class="line">    ↓</span><br><span class="line">优化器（选择执行计划）</span><br><span class="line">    ↓</span><br><span class="line">执行器（调用存储引擎）</span><br><span class="line">    ↓</span><br><span class="line">存储引擎（返回数据）</span><br><span class="line">    ↓</span><br><span class="line">返回结果给客户端</span><br></pre></td></tr></table></figure>
<h2 id="常见面试题">常见面试题</h2>
<h3 id="Q1：MySQL-的两层架构有什么好处？">Q1：MySQL 的两层架构有什么好处？</h3>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>解耦</strong>：SQL 处理逻辑与数据存储分离</li>
<li><strong>灵活性</strong>：可以根据需求选择不同的存储引擎</li>
<li><strong>可扩展性</strong>：易于添加新的存储引擎或优化现有功能</li>
</ul>
<h3 id="Q2：为什么-MySQL-8-0-移除了查询缓存？">Q2：为什么 MySQL 8.0 移除了查询缓存？</h3>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>命中率低</strong>：需要 SQL 完全一致才能命中</li>
<li><strong>维护成本高</strong>：任何写操作都会导致相关缓存失效</li>
<li><strong>性能问题</strong>：在高并发场景下，缓存的维护反而成为瓶颈</li>
</ul>
<h3 id="Q3：解析器和预处理器的区别是什么？">Q3：解析器和预处理器的区别是什么？</h3>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>解析器</strong>：只负责语法检查和构建语法树</li>
<li><strong>预处理器</strong>：检查表和字段的存在性，进行语义验证</li>
</ul>
<h3 id="Q4：索引下推的原理和作用是什么？">Q4：索引下推的原理和作用是什么？</h3>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>原理</strong>：将部分条件判断从 Server 层下推到存储引擎层</li>
<li><strong>作用</strong>：减少回表次数，提高查询效率</li>
<li><strong>适用场景</strong>：联合索引中部分字段无法使用索引但包含在索引中的情况</li>
</ul>
<h2 id="性能优化建议">性能优化建议</h2>
<h3 id="1-连接优化">1. 连接优化</h3>
<ul>
<li>使用连接池管理数据库连接</li>
<li>合理设置 <code>max_connections</code> 和 <code>wait_timeout</code></li>
<li>避免创建过多的无用连接</li>
</ul>
<h3 id="2-SQL-优化">2. SQL 优化</h3>
<ul>
<li>避免使用 <code>SELECT *</code>，明确指定需要的字段</li>
<li>合理使用索引，避免全表扫描</li>
<li>利用 <code>EXPLAIN</code> 分析执行计划</li>
</ul>
<h3 id="3-索引优化">3. 索引优化</h3>
<ul>
<li>为经常查询的字段创建索引</li>
<li>避免在小表上创建过多索引</li>
<li>利用覆盖索引减少回表操作</li>
</ul>
<h2 id="总结">总结</h2>
<p>通过这篇文章，我们深入了解了 MySQL 执行一条 SELECT 语句的完整过程：</p>
<ol>
<li><strong>连接器</strong>：建立连接，验证身份</li>
<li><strong>查询缓存</strong>：快速返回缓存结果（已废弃）</li>
<li><strong>解析器</strong>：解析 SQL，构建语法树</li>
<li><strong>预处理器</strong>：验证表和字段的有效性</li>
<li><strong>优化器</strong>：制定最优执行计划</li>
<li><strong>执行器</strong>：调用存储引擎获取数据</li>
</ol>
<p>理解这个过程不仅有助于我们写出更高效的 SQL，也能帮助我们在遇到性能问题时快速定位问题所在。在面试中，这也是一个经常被问到的核心问题。</p>
<blockquote>
<p><strong>记住</strong>：每一个看似简单的查询背后，都有一套精密的机制在保证其正确和高效的执行。</p>
</blockquote>
<hr>
<p><strong>参考资料</strong>：</p>
<ul>
<li>《MySQL 45 讲》</li>
<li>《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>
<li>MySQL 官方文档</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>SQL执行</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 380 - O(1) 时间插入、删除和获取随机元素</title>
    <url>/2025/05/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-380-O1%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>设计一个支持在<strong>平均</strong>时间复杂度 <strong>O(1)</strong> 下，执行以下操作的数据结构：</p>
<ul>
<li><code>insert(val)</code>：当元素 val 不存在时返回 true，并向集合中插入该项，否则返回 false</li>
<li><code>remove(val)</code>：当元素 val 存在时返回 true，并从集合中移除该项，否则返回 false</li>
<li><code>getRandom()</code>：随机返回现有集合中的一项。每个元素应该有<strong>相同的概率</strong>被返回</li>
</ul>
<p>你必须实现类的所有函数，并满足每个函数的<strong>平均</strong>时间复杂度为 <strong>O(1)</strong>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">输出</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br></pre></td></tr></table></figure>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我的初始解法采用了哈希表 + 数组 + begin 指针的设计：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RandomizedSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashTable <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">    nums      []<span class="type">int</span></span><br><span class="line">    begin     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Remove(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index, ok := this.hashTable[val]; ok &#123;</span><br><span class="line">        beginVal := this.nums[this.begin]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ❌ 错误点：只更新了索引，没有交换实际元素位置</span></span><br><span class="line">        this.hashTable[beginVal] = index</span><br><span class="line"></span><br><span class="line">        this.begin++</span><br><span class="line">        <span class="built_in">delete</span>(this.hashTable, val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>这个解法在 Remove 方法中犯了一个严重错误：<strong>只更新了哈希表的索引映射，但没有实际交换数组中的元素位置</strong>，导致索引与实际位置不一致。</p>
<p>让我用具体例子说明问题：</p>
<p><strong>初始状态：</strong></p>
<ul>
<li><code>nums = [1, 2, 3, 4]</code></li>
<li><code>hashTable = &#123;1: 0, 2: 1, 3: 2, 4: 3&#125;</code></li>
<li><code>begin = 0</code></li>
</ul>
<p><strong>删除元素 3 时：</strong></p>
<ol>
<li><code>index = 2</code>（元素 3 的位置）</li>
<li><code>beginVal = nums[0] = 1</code></li>
<li><code>hashTable[1] = 2</code> ❌（将元素 1 的索引改为 2）</li>
<li><code>begin = 1</code></li>
<li>删除 <code>hashTable[3]</code></li>
</ol>
<p><strong>错误结果：</strong></p>
<ul>
<li><code>nums = [1, 2, 3, 4]</code>（数组没变！）</li>
<li><code>hashTable = &#123;1: 2, 2: 1, 4: 3&#125;</code>（元素 1 的索引变成了 2）</li>
<li><code>begin = 1</code></li>
</ul>
<p>现在哈希表说元素 1 在索引 2，但实际上元素 1 还在索引 0，而索引 2 位置是元素 3！这导致了<strong>数据结构内部状态不一致</strong>的严重问题。</p>
<h2 id="正确解法">正确解法</h2>
<p>要实现 O(1) 的插入、删除和随机获取，需要结合<strong>哈希表</strong>和<strong>动态数组</strong>：</p>
<ul>
<li><strong>哈希表</strong>：提供 O(1) 的查找能力</li>
<li><strong>动态数组</strong>：提供 O(1) 的随机访问能力</li>
</ul>
<p>关键是在删除元素时，采用<strong>交换到末尾再删除</strong>的策略，避免数组元素的移动。</p>
<h3 id="方法一：与最后元素交换（推荐）">方法一：与最后元素交换（推荐）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RandomizedSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    hashTable <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>  <span class="comment">// val -&gt; index</span></span><br><span class="line">    nums      []<span class="type">int</span>        <span class="comment">// 存储实际值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> RandomizedSet &#123;</span><br><span class="line">    <span class="keyword">return</span> RandomizedSet&#123;</span><br><span class="line">        hashTable: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>),</span><br><span class="line">        nums:      <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Insert(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.hashTable[val]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 已存在</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到数组末尾</span></span><br><span class="line">    this.hashTable[val] = <span class="built_in">len</span>(this.nums)</span><br><span class="line">    this.nums = <span class="built_in">append</span>(this.nums, val)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Remove(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index, ok := this.hashTable[val]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 不存在</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lastIndex := <span class="built_in">len</span>(this.nums) - <span class="number">1</span></span><br><span class="line">        lastVal := this.nums[lastIndex]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最后一个元素移到要删除的位置</span></span><br><span class="line">        this.nums[index] = lastVal</span><br><span class="line">        this.hashTable[lastVal] = index</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除最后一个元素</span></span><br><span class="line">        this.nums = this.nums[:lastIndex]</span><br><span class="line">        <span class="built_in">delete</span>(this.hashTable, val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> GetRandom() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.nums[rand.Intn(<span class="built_in">len</span>(this.nums))]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：使用-begin-指针的正确实现">方法二：使用 begin 指针的正确实现</h3>
<p>如果坚持使用 begin 指针的设计，需要<strong>实际交换元素位置</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> Remove(val <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index, ok := this.hashTable[val]; ok &#123;</span><br><span class="line">        beginVal := this.nums[this.begin]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 实际交换数组中的元素位置</span></span><br><span class="line">        this.nums[index] = beginVal</span><br><span class="line">        this.nums[this.begin] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ✅ 更新哈希表中的索引</span></span><br><span class="line">        this.hashTable[beginVal] = index</span><br><span class="line"></span><br><span class="line">        this.begin++</span><br><span class="line">        <span class="built_in">delete</span>(this.hashTable, val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *RandomizedSet)</span></span> GetRandom() <span class="type">int</span> &#123;</span><br><span class="line">    validLength := <span class="built_in">len</span>(this.nums) - this.begin</span><br><span class="line">    randomIndex := rand.Intn(validLength) + this.begin</span><br><span class="line">    <span class="keyword">return</span> this.nums[randomIndex]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法核心思想">算法核心思想</h2>
<ol>
<li><strong>哈希表存储值到索引的映射</strong>：实现 O(1) 查找</li>
<li><strong>数组存储实际值</strong>：实现 O(1) 随机访问</li>
<li><strong>删除时与末尾元素交换</strong>：避免数组元素移动，保持 O(1) 复杂度</li>
</ol>
<p>删除操作的关键步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除元素 X：</span><br><span class="line">1. 找到 X 在数组中的位置 index</span><br><span class="line">2. 将数组最后一个元素 Y 移动到 index 位置</span><br><span class="line">3. 更新 Y 在哈希表中的索引为 index</span><br><span class="line">4. 删除数组最后一个元素</span><br><span class="line">5. 从哈希表中删除 X</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度</strong>：所有操作均为 $O(1)$</p>
<ul>
<li>Insert：哈希表插入 + 数组追加 = $O(1)$</li>
<li>Remove：哈希表查找 + 元素交换 + 哈希表删除 = $O(1)$</li>
<li>GetRandom：随机数生成 + 数组访问 = $O(1)$</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：$O(n)$，其中 $n$ 是插入的元素个数</p>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>数据结构一致性</strong>：当你更新索引映射时，必须同时更新实际的数据存储</li>
<li><strong>删除策略</strong>：在需要保持 O(1) 复杂度的场景下，&quot;交换到末尾再删除&quot;是常用技巧</li>
<li><strong>组合数据结构</strong>：哈希表 + 数组的组合可以同时获得快速查找和随机访问的能力</li>
<li><strong>边界情况</strong>：特别注意删除操作中的索引更新逻辑</li>
</ol>
<p>这道题很好地展示了如何通过巧妙的数据结构设计来满足复杂的性能要求，删除操作的实现是关键难点。</p>
<h2 id="相关题目">相关题目</h2>
<ul>
<li><a href="mdc:hexo-blog/2025/05/25/LeetCode-381-Insert-Delete-GetRandom-O1-Duplicates-allowed">LeetCode 381 - O(1) 时间插入、删除和获取随机元素 - 允许重复</a></li>
<li><a href="mdc:hexo-blog/source/_posts/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-146-LRU-Cache.md">LeetCode 146 - LRU 缓存</a></li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>数据结构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 274 - H指数（H-Index）</title>
    <url>/2025/05/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-274-H%E6%8C%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>citations</code>，其中 <code>citations[i]</code> 表示研究者第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <code>h</code> 指数。</p>
<p><strong>H 指数的定义</strong>：h 代表&quot;高引用次数&quot;（high citations），一名科研人员的 h 指数是指他（她）的（<code>n</code> 篇论文中）<strong>总共</strong>有 <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。且其余的 <code>n - h</code> 篇论文每篇被引用次数 <strong>不超过</strong> <code>h</code> 次。</p>
<p>如果 <code>h</code> 有多种可能的值，<strong>h 指数</strong> 是其中的 <strong>最大值</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：citations = [3,0,6,1,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><br><span class="line">     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余 2 篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：citations = [1,3,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>n == citations.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我最初尝试的解法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hIndex</span><span class="params">(citations []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    slices.Sort(citations)</span><br><span class="line">    n := <span class="built_in">len</span>(citations)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> citations[n<span class="number">-1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> citations[i] &lt;= n-i &#123;  <span class="comment">// ❌ 错误点：应该是 &gt;=</span></span><br><span class="line">            res = max(res, citations[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<ol>
<li><strong>条件判断错误</strong>：使用了 <code>citations[i] &lt;= n-i</code>，但根据 H 指数定义，应该是 <code>citations[i] &gt;= n-i</code></li>
<li><strong>返回值逻辑错误</strong>：在寻找满足错误条件的最大引用次数，而不是寻找满足 H 指数定义的最大 h 值</li>
<li><strong>初始值设置不当</strong>：<code>res := 1</code> 无法处理 H 指数为 0 的情况</li>
</ol>
<h2 id="方法一：排序法">方法一：排序法</h2>
<h3 id="解题思路">解题思路</h3>
<p>H 指数的核心思想是：将论文按引用次数排序后，找到一个位置，使得从该位置到数组末尾的所有论文引用次数都至少为这个位置对应的论文数量。</p>
<p>排序后从左到右遍历，对于位置 <code>i</code>：</p>
<ul>
<li>从位置 <code>i</code> 到数组末尾共有 <code>h = n - i</code> 篇论文</li>
<li>如果 <code>citations[i] &gt;= h</code>，说明这 <code>h</code> 篇论文的引用次数都 ≥ h</li>
<li>由于我们要找最大的 h，返回第一个满足条件的 h 值即可</li>
</ul>
<h3 id="实现代码">实现代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hIndex</span><span class="params">(citations []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    slices.Sort(citations)</span><br><span class="line">    n := <span class="built_in">len</span>(citations)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        h := n - i  <span class="comment">// 从位置i到末尾的论文数</span></span><br><span class="line">        <span class="keyword">if</span> citations[i] &gt;= h &#123;</span><br><span class="line">            <span class="keyword">return</span> h</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$，主要是排序的时间复杂度</li>
<li><strong>空间复杂度</strong>：$O(1)$，只使用了常数额外空间</li>
</ul>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以 <code>citations = [3,0,6,1,5]</code> 为例：</p>
<ol>
<li>排序后：<code>[0,1,3,5,6]</code></li>
<li>遍历过程：
<ul>
<li>i=0: h=5, citations[0]=0 &lt; 5 ❌</li>
<li>i=1: h=4, citations[1]=1 &lt; 4 ❌</li>
<li>i=2: h=3, citations[2]=3 ≥ 3 ✅</li>
</ul>
</li>
</ol>
<p>返回 h=3</p>
<h2 id="方法二：计数排序法">方法二：计数排序法</h2>
<h3 id="解题思路-2">解题思路</h3>
<p>由于引用次数有上限（题目中最大为 1000），而且 H 指数最大不会超过论文总数，我们可以用计数排序的思想。</p>
<p>关键观察：</p>
<ul>
<li>H 指数最大为论文总数 n</li>
<li>引用次数超过 n 的论文对 H 指数的贡献等同于引用次数为 n 的论文</li>
</ul>
<h3 id="实现代码-2">实现代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hIndex</span><span class="params">(citations []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(citations)</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个引用次数的论文数量</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> citations &#123;</span><br><span class="line">        <span class="keyword">if</span> c &gt;= n &#123;</span><br><span class="line">            count[n]++  <span class="comment">// 引用次数≥n的都统计到count[n]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count[c]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从高到低计算累计论文数</span></span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := n; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        total += count[i]</span><br><span class="line">        <span class="keyword">if</span> total &gt;= i &#123;  <span class="comment">// 至少有i篇论文引用次数≥i</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，遍历数组两次</li>
<li><strong>空间复杂度</strong>：$O(n)$，需要计数数组</li>
</ul>
<h3 id="执行过程示例-2">执行过程示例</h3>
<p>以 <code>citations = [3,0,6,1,5]</code> 为例：</p>
<ol>
<li>初始化：<code>count = [0,0,0,0,0,0]</code> (长度为 6)</li>
<li>统计：
<ul>
<li>citations[0]=3: count[3]++</li>
<li>citations[1]=0: count[0]++</li>
<li>citations[2]=6≥5: count[5]++</li>
<li>citations[3]=1: count[1]++</li>
<li>citations[4]=5≥5: count[5]++</li>
<li>结果：<code>count = [1,1,0,1,0,2]</code></li>
</ul>
</li>
<li>累计计算：
<ul>
<li>i=5: total=2, 2&lt;5 ❌</li>
<li>i=4: total=2, 2&lt;4 ❌</li>
<li>i=3: total=3, 3≥3 ✅</li>
</ul>
</li>
</ol>
<p>返回 h=3</p>
<h2 id="方法三：二分查找法">方法三：二分查找法</h2>
<h3 id="解题思路-3">解题思路</h3>
<p>H 指数具有单调性：如果 H 指数为 h，那么 H 指数一定不会是 h+1、h+2…。我们可以在[0, n]范围内二分查找最大的满足条件的 h 值。</p>
<p>对于给定的 h，检查是否至少有 h 篇论文的引用次数 ≥h。</p>
<h3 id="实现代码-3">实现代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hIndex</span><span class="params">(citations []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(citations)</span><br><span class="line">    left, right := <span class="number">0</span>, n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> canAchieveH(citations, mid) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否能达到H指数为h</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canAchieveH</span><span class="params">(citations []<span class="type">int</span>, h <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> citations &#123;</span><br><span class="line">        <span class="keyword">if</span> c &gt;= h &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-3">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$，二分查找$O(\log n)$次，每次需要$O(n)$时间检查</li>
<li><strong>空间复杂度</strong>：$O(1)$，只使用了常数额外空间</li>
</ul>
<h3 id="执行过程示例-3">执行过程示例</h3>
<p>以 <code>citations = [3,0,6,1,5]</code> 为例：</p>
<ol>
<li>初始：left=0, right=5</li>
<li>mid=2: canAchieveH([3,0,6,1,5], 2) → count=3≥2 ✅ → left=3</li>
<li>mid=4: canAchieveH([3,0,6,1,5], 4) → count=2&lt;4 ❌ → right=3</li>
<li>mid=3: canAchieveH([3,0,6,1,5], 3) → count=3≥3 ✅ → left=4</li>
<li>left&gt;right，返回 right=3</li>
</ol>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>排序法</th>
<th>计数排序法</th>
<th>二分查找法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n \log n)$</td>
<td>$O(n)$</td>
<td>$O(n \log n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>实现难度</td>
<td>简单</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td>适用场景</td>
<td>通用</td>
<td>引用次数范围较小时</td>
<td>理解二分查找思想</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>理解 H 指数定义</strong>：至少有 h 篇论文的引用次数都 ≥h 次</li>
<li><strong>排序的威力</strong>：通过排序可以将复杂的计数问题转化为简单的位置判断</li>
<li><strong>计数优化</strong>：当数据范围有限时，计数排序可以将时间复杂度降到线性</li>
<li><strong>二分查找的应用</strong>：单调性是应用二分查找的关键条件</li>
<li><strong>边界条件处理</strong>：注意 H 指数可能为 0 的情况</li>
</ol>
<h2 id="总结">总结</h2>
<p>H 指数问题是一个经典的数组处理问题，展示了多种不同的解题思路。排序法最直观易懂，计数排序法在特定条件下最优，二分查找法体现了算法的巧妙性。在实际应用中，建议根据数据特点选择合适的方法。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>排序</tag>
        <tag>二分查找</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>技术八股: MySQL 日志系统详解 - undo log、redo log、binlog</title>
    <url>/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1>MySQL 日志系统：三种日志的作用和原理</h1>
<h2 id="引言：从一个更新语句说起">引言：从一个更新语句说起</h2>
<p>当我们执行一条更新语句时，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t_user <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;xiaolin&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句看起来很简单，但在 MySQL 内部却涉及到三种重要的日志系统：</p>
<ul>
<li><strong>undo log（撤销日志）</strong>：就像是数据的&quot;后悔药&quot;，记录修改前的数据，用于事务回滚</li>
<li><strong>redo log（重做日志）</strong>：就像是数据的&quot;备份保险&quot;，记录修改后的数据，用于故障恢复</li>
<li><strong>binlog（二进制日志）</strong>：就像是数据的&quot;操作记录本&quot;，记录所有变更操作，用于数据备份和主从同步</li>
</ul>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747967912006.png" alt="1747967912006"></p>
<p>这三种日志各有各的用途，它们共同保证了 MySQL 数据的安全性和一致性。接下来我们就详细了解一下这三种日志的作用原理。</p>
<h2 id="为什么需要-undo-log？">为什么需要 undo log？</h2>
<p>我们在执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会<strong>隐式开启事务</strong>来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了。</p>
<p>执行一条语句是否自动提交事务，是由 <code>autocommit</code> 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。</p>
<p>那么，考虑一个问题。一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？</p>
<p>如果我们每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。</p>
<p>实现这一机制就是 <strong>undo log（回滚日志），它保证了事务的 <a href="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">ACID 特性</a>中的原子性（Atomicity）</strong>。</p>
<h3 id="undo-log-的工作原理">undo log 的工作原理</h3>
<p>undo log 就像是一个&quot;反向操作手册&quot;，记录着如何撤销每一个操作。工作流程如下图：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747967926095.png" alt="1747967926095"></p>
<p>每当 InnoDB 引擎要修改一条记录时，都会先把&quot;反向操作&quot;记录到 undo log 中：</p>
<ul>
<li><strong>插入记录</strong>时：记录这条记录的主键，回滚时只需要<strong>删除</strong>这个主键对应的记录</li>
<li><strong>删除记录</strong>时：记录整条记录的内容，回滚时<strong>重新插入</strong>这条记录</li>
<li><strong>更新记录</strong>时：记录被修改字段的<strong>旧值</strong>，回滚时<strong>恢复为旧值</strong></li>
</ul>
<p>举个具体例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 原始记录：id=1, name=&#x27;张三&#x27;, balance=1000</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">900</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>undo log 会记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作类型：UPDATE</span><br><span class="line">表：users</span><br><span class="line">主键：id=1</span><br><span class="line">旧值：balance=1000</span><br></pre></td></tr></table></figure>
<p>如果需要回滚，MySQL 就读取这条 undo log，执行相反操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> balance <span class="operator">=</span> <span class="number">1000</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 恢复旧值</span></span><br></pre></td></tr></table></figure>
<h3 id="版本链：记录修改历史">版本链：记录修改历史</h3>
<p>不同类型的操作会产生不同格式的 undo log，但每条 undo log 都包含两个重要信息：</p>
<ul>
<li><strong>trx_id（事务 ID）</strong>：记录是哪个事务修改了这条数据</li>
<li><strong>roll_pointer（回滚指针）</strong>：指向上一个版本的 undo log</li>
</ul>
<p>通过这些指针，MySQL 可以把同一条记录的所有历史版本串成一条链，这就是<strong>版本链</strong>：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747967935054.png" alt="1747967935054"></p>
<p>想象一条用户记录被多次修改：</p>
<ol>
<li>事务 100：name=‘张三’ → name=‘李四’</li>
<li>事务 200：name=‘李四’ → name=‘王五’</li>
<li>事务 300：name=‘王五’ → name=‘赵六’</li>
</ol>
<p>版本链就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前记录(name=&#x27;赵六&#x27;) → undo log(name=&#x27;王五&#x27;) → undo log(name=&#x27;李四&#x27;) → undo log(name=&#x27;张三&#x27;)</span><br></pre></td></tr></table></figure>
<p>这样，任何时候都能通过版本链找到记录的任何历史版本。</p>
<h3 id="undo-log-的第二个作用：实现-MVCC">undo log 的第二个作用：实现 MVCC</h3>
<p>除了事务回滚，<strong>undo log 还有一个重要作用：配合 ReadView 实现 MVCC（多版本并发控制）</strong>。</p>
<p>简单来说，MVCC 让不同的事务能够&quot;看到&quot;数据的不同版本，从而实现读写不阻塞：</p>
<p><strong>读提交隔离级别</strong>：</p>
<ul>
<li>每次执行 SELECT 都会生成新的 ReadView</li>
<li>可能前后两次读取同一条数据，结果不一样（因为其他事务可能已经修改并提交了）</li>
</ul>
<p><strong>可重复读隔离级别</strong>：</p>
<ul>
<li>事务开始时生成一个 ReadView，整个事务期间都使用这个 ReadView</li>
<li>保证事务期间多次读取同一条数据，结果都是一样的</li>
</ul>
<p>MVCC 的核心机制是：</p>
<ol>
<li>根据事务的 ReadView 和记录的 trx_id、roll_pointer 进行比较</li>
<li>如果当前版本不符合可见性要求，就沿着版本链往前找</li>
<li>直到找到符合条件的历史版本</li>
</ol>
<p>这样就实现了&quot;一个事务在读取数据时，其他事务可以正常修改数据，互不干扰&quot;。</p>
<p>具体的实现细节可以参考：<a href="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">事务隔离级别是怎么实现的？</a></p>
<h3 id="undo-log-的两大作用总结">undo log 的两大作用总结</h3>
<ul>
<li><strong>实现事务回滚</strong>：保障事务的原子性，确保出错时能恢复到事务开始前的状态</li>
<li><strong>实现 MVCC</strong>：通过版本链为不同事务提供数据的不同版本视图，实现读写并发</li>
</ul>
<h2 id="为什么需要-Buffer-Pool？">为什么需要 Buffer Pool？</h2>
<p>想象一下，如果每次查询或修改数据都要直接访问磁盘，那就像每次想看书都要跑图书馆一样，效率会非常低。更聪明的做法是把常用的书借回家放在书桌上，需要时随手就能翻阅。</p>
<p>MySQL 也是同样的思路。由于磁盘读写速度远远慢于内存，MySQL 设计了一个<strong>缓冲池</strong>（<strong>Buffer Pool</strong>）来提高性能：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747967945641.png" alt="1747967945641"></p>
<p>有了 Buffer Pool 之后，数据的读写流程变成：</p>
<p><strong>读取数据时</strong>：</p>
<ul>
<li>先检查 Buffer Pool 中是否已经有这个数据页</li>
<li>如果有，直接从内存读取（速度快）</li>
<li>如果没有，从磁盘加载到 Buffer Pool，再返回数据</li>
</ul>
<p><strong>修改数据时</strong>：</p>
<ul>
<li>直接修改 Buffer Pool 中的数据页</li>
<li>将这个页标记为&quot;脏页&quot;（表示内存和磁盘的数据不一致了）</li>
<li>不立即写入磁盘，而是由后台线程在合适的时机统一刷盘</li>
</ul>
<p>这种&quot;先改内存，后写磁盘&quot;的策略大大提高了数据库的读写性能。</p>
<h3 id="Buffer-Pool-缓存什么？">Buffer Pool 缓存什么？</h3>
<p>InnoDB 将数据按<strong>页</strong>来管理，每页默认大小是 16KB。就像图书馆按册整理书籍一样，MySQL 也是按页整理数据的。</p>
<p><strong>Buffer Pool 的初始化过程</strong>：</p>
<ol>
<li>MySQL 启动时，申请一大块连续内存空间</li>
<li>按 16KB 大小划分成若干个缓存页</li>
<li>这些缓存页初始都是空的，等待数据加载</li>
</ol>
<p>这就解释了为什么 MySQL 刚启动时虚拟内存很大，但物理内存使用很少——只有当缓存页被实际使用时，操作系统才会分配物理内存。</p>
<p><strong>Buffer Pool 主要缓存这些内容</strong>：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747967989940.png" alt="1747967989940"></p>
<ul>
<li><strong>数据页</strong>：存储表中的实际数据</li>
<li><strong>索引页</strong>：存储索引结构，用于快速查找数据</li>
<li><strong>Undo 页</strong>：存储 undo log，用于事务回滚和 MVCC</li>
<li><strong>插入缓存</strong>：优化非主键索引的插入性能</li>
<li><strong>自适应哈希索引</strong>：MySQL 自动创建的哈希索引，加速查询</li>
<li><strong>锁信息</strong>：事务锁的相关信息</li>
</ul>
<h3 id="常见疑问解答">常见疑问解答</h3>
<p><strong>Q：Undo 页记录什么？</strong></p>
<p>当事务开始后，InnoDB 在修改记录前会先生成 undo log。这些 undo log 就存储在 Buffer Pool 的 Undo 页中。</p>
<p><strong>Q：查询一条记录时，只加载这一条记录到 Buffer Pool 吗？</strong></p>
<p>不是的！InnoDB 会把<strong>整个页</strong>（16KB）加载到 Buffer Pool 中，然后通过页内的&quot;页目录&quot;定位到具体的记录。这是因为：</p>
<ul>
<li>磁盘 I/O 的最小单位就是页</li>
<li>同一页内的其他记录很可能也会被访问到（空间局部性原理）</li>
</ul>
<p>想了解更多关于页结构和索引查询的知识，可以参考：<a href="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/">换一个角度看 B+ 树</a></p>
<div class="note info">
            <p><strong>undo log 是如何持久化的？</strong></p><p>很多人会疑问：undo log 存在内存的 Buffer Pool 中，如何保证持久化呢？</p><p>答案是：undo log 和数据页使用相同的持久化策略，都依靠 redo log 来保证。</p><p>具体来说：</p><ul><li>Buffer Pool 中的 undo 页被修改时，也会生成相应的 redo log</li><li>redo log 每秒刷盘一次，事务提交时也会刷盘</li><li>通过这种机制，数据页和 undo 页都能保证持久化</li></ul>
          </div>
<h2 id="为什么需要-redo-log？">为什么需要 redo log？</h2>
<p>Buffer Pool 确实提高了读写效率，但也带来了一个严重的问题：<strong>内存中的数据在断电后会丢失！</strong></p>
<p>想象这样的场景：你在电脑上写了一篇重要文档，还没来得及保存，突然停电了。如果没有自动保存功能，你的心血就白费了。</p>
<p>MySQL 面临同样的风险：Buffer Pool 中修改后的数据（脏页）如果还没写入磁盘，一旦断电重启，这些修改就会消失。</p>
<p>为了解决这个问题，MySQL 采用了 <strong>WAL（Write-Ahead Logging）技术</strong>：</p>
<ol>
<li><strong>先写日志，再写数据</strong>：当有数据需要修改时，InnoDB 先更新内存，然后把这次修改以日志形式记录下来</li>
<li><strong>此时更新就算完成了</strong>：不需要立即把脏页写入磁盘</li>
<li><strong>后台异步刷盘</strong>：由后台线程在合适的时机将脏页写入磁盘</li>
</ol>
<p>这个日志就是 <strong>redo log（重做日志）</strong>，整个过程如下图：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968001777.png" alt="1747968001777"></p>
<h3 id="什么是-redo-log？">什么是 redo log？</h3>
<p><strong>redo log 是物理日志</strong>，它记录的是&quot;在某个数据页的某个位置做了什么修改&quot;。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对表空间 XXX 中的数据页 YYY 在偏移量 ZZZ 的位置，将值从 &#x27;A&#x27; 修改为 &#x27;B&#x27;</span><br></pre></td></tr></table></figure>
<p>这种记录方式的好处是：</p>
<ul>
<li><strong>记录精确</strong>：准确记录了数据的物理变化</li>
<li><strong>恢复快速</strong>：系统崩溃后，直接按照 redo log 重新执行修改即可</li>
<li><strong>占用空间小</strong>：只记录变化的部分，不记录完整数据</li>
</ul>
<p><strong>redo log 的工作流程</strong>：</p>
<ol>
<li>事务执行过程中，每个修改操作都会生成 redo log</li>
<li>事务提交时，确保 redo log 已经写入磁盘</li>
<li>如果系统崩溃，MySQL 重启后会扫描 redo log</li>
<li>根据 redo log 中的记录，重新执行所有已提交事务的修改</li>
</ol>
<p>这样就实现了 <strong>crash-safe</strong>(<strong>崩溃恢复</strong>)能力：即使数据库异常重启，已提交的数据也不会丢失。<strong>redo log 保证了事务的持久性</strong>。</p>
<h3 id="redo-log-vs-undo-log">redo log vs undo log</h3>
<p>这两种日志经常被混淆，让我们对比一下：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>redo log</th>
<th>undo log</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用</strong></td>
<td>保证持久性（崩溃恢复）</td>
<td>保证原子性（事务回滚）和实现 MVCC</td>
</tr>
<tr>
<td><strong>记录内容</strong></td>
<td>修改<strong>之后</strong>的数据状态</td>
<td>修改<strong>之前</strong>的数据状态</td>
</tr>
<tr>
<td><strong>日志类型</strong></td>
<td>物理日志（记录页面变化）</td>
<td>逻辑日志（记录操作过程）</td>
</tr>
<tr>
<td><strong>使用时机</strong></td>
<td>系统崩溃后恢复已提交事务</td>
<td>事务回滚时撤销未提交修改</td>
</tr>
</tbody>
</table>
<p>简单记忆：</p>
<ul>
<li><strong>redo = 重做</strong>：系统崩溃后&quot;重新做一遍&quot;已提交的修改</li>
<li><strong>undo = 撤销</strong>：事务失败时&quot;撤销&quot;未提交的修改</li>
</ul>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968054115.png" alt="1747968054115"></p>
<h3 id="为什么要多此一举？既然都要写磁盘，为什么不直接写数据页？">为什么要多此一举？既然都要写磁盘，为什么不直接写数据页？</h3>
<p>这是一个很好的问题！答案在于<strong>磁盘写入方式的差异</strong>：</p>
<p><strong>redo log 的写入</strong>：</p>
<ul>
<li><strong>顺序写</strong>：redo log 文件是顺序追加写入的</li>
<li>就像在笔记本上从第一页开始，一页页往后写</li>
</ul>
<p><strong>数据页的写入</strong>：</p>
<ul>
<li><strong>随机写</strong>：需要先定位到数据页在磁盘上的具体位置，然后写入</li>
<li>就像在一本很厚的字典里，需要先翻到特定页码，再修改内容</li>
</ul>
<p><strong>磁盘的&quot;顺序写&quot;比&quot;随机写&quot;快得多！</strong></p>
<p>形象比喻：</p>
<ul>
<li>顺序写 = 按顺序看小说，从第 1 页看到第 100 页</li>
<li>随机写 = 在字典里查单词，不断翻来翻去找特定页面</li>
</ul>
<p>因此，WAL 技术带来了两个重要优势：</p>
<ol>
<li><strong>保证持久性</strong>：让 MySQL 具备 crash-safe 能力，任何时候崩溃都不会丢失已提交的数据</li>
<li><strong>提升性能</strong>：将磁盘操作从&quot;随机写&quot;变成&quot;顺序写&quot;，大幅提升写入性能</li>
</ol>
<h3 id="redo-log-的缓存机制">redo log 的缓存机制</h3>
<p>实际上，redo log 也不是直接写入磁盘的。为了避免频繁的磁盘 I/O，MySQL 设计了 <strong>redo log buffer</strong>：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968063556.png" alt="1747968063556"></p>
<p><strong>工作流程</strong>：</p>
<ol>
<li>事务执行时，redo log 先写入 redo log buffer（内存中）</li>
<li>在特定时机，再将 redo log buffer 中的内容刷新到磁盘</li>
</ol>
<p><strong>redo log buffer 的配置</strong>：</p>
<ul>
<li>默认大小：16 MB</li>
<li>配置参数：<code>innodb_log_buffer_size</code></li>
<li>增大缓冲区可以让 MySQL 处理大事务时减少磁盘写入，提升性能</li>
</ul>
<h3 id="redo-log-什么时候刷盘？">redo log 什么时候刷盘？</h3>
<p>redo log 虽然缓存在内存中，但总需要写入磁盘才能真正保证数据安全。主要有以下几个刷盘时机：</p>
<p><strong>自动刷盘时机</strong>：</p>
<ul>
<li><strong>MySQL 正常关闭时</strong>：确保所有日志都持久化</li>
<li><strong>缓冲区写满一半时</strong>：当 redo log buffer 使用量超过 50% 时触发</li>
<li><strong>后台线程定时刷盘</strong>：每隔 1 秒自动将 redo log buffer 持久化到磁盘</li>
</ul>
<p><strong>事务提交时刷盘</strong>：</p>
<ul>
<li>每次事务提交时，会根据 <code>innodb_flush_log_at_trx_commit</code> 参数决定刷盘策略</li>
</ul>
<h3 id="innodb-flush-log-at-trx-commit-参数详解">innodb_flush_log_at_trx_commit 参数详解</h3>
<p>这个参数控制事务提交时 redo log 的刷盘行为，有 3 个可选值：</p>
<p><strong>参数值 = 0（性能最好，安全性最差）</strong>：</p>
<ul>
<li>事务提交时，redo log 停留在 redo log buffer 中，不写入磁盘</li>
<li>依赖后台线程每秒刷盘</li>
<li><strong>风险</strong>：MySQL 进程崩溃会丢失最近 1 秒的所有事务数据</li>
</ul>
<p><strong>参数值 = 1（性能一般，安全性最好）- 默认值</strong>：</p>
<ul>
<li>事务提交时，立即将 redo log buffer 中的内容持久化到磁盘</li>
<li><strong>最安全</strong>：MySQL 异常重启也不会丢失已提交的数据</li>
</ul>
<p><strong>参数值 = 2（性能和安全性的折中）</strong>：</p>
<ul>
<li>事务提交时，将 redo log 写入操作系统的文件缓存（Page Cache）</li>
<li>不立即 fsync 到磁盘，交给操作系统控制</li>
<li><strong>风险</strong>：只有在操作系统崩溃或断电时才会丢失数据</li>
</ul>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968082559.png" alt="1747968082559"></p>
<h3 id="参数选择建议">参数选择建议</h3>
<p><strong>安全性对比</strong>：参数 1 &gt; 参数 2 &gt; 参数 0<br>
<strong>性能对比</strong>：参数 0 &gt; 参数 2 &gt; 参数 1</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><strong>金融、支付系统</strong>：选择参数 1，数据安全最重要</li>
</ul>
<h3 id="后台线程的刷盘策略">后台线程的刷盘策略</h3>
<p>无论 <code>innodb_flush_log_at_trx_commit</code> 设置为什么值，InnoDB 的后台线程每隔 1 秒都会执行刷盘操作：</p>
<p><strong>对于参数 0</strong>：</p>
<ul>
<li>将 redo log buffer → 操作系统 Page Cache → 磁盘</li>
<li>完整的刷盘流程：<code>write()</code> + <code>fsync()</code></li>
</ul>
<p><strong>对于参数 2</strong>：</p>
<ul>
<li>只执行 <code>fsync()</code>，将 Page Cache 中的数据写入磁盘</li>
<li>因为事务提交时已经执行了 <code>write()</code> 操作</li>
</ul>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968096087.png" alt="1747968096087"></p>
<p>这解释了为什么：</p>
<ul>
<li><strong>参数 0</strong>：MySQL 进程崩溃可能丢失 1 秒数据</li>
<li><strong>参数 2</strong>：只有操作系统崩溃才可能丢失 1 秒数据</li>
</ul>
<h3 id="redo-log-文件写满了怎么办？">redo log 文件写满了怎么办？</h3>
<p>redo log 不是无限增长的，而是使用<strong>固定大小的循环文件</strong>来存储。</p>
<p><strong>默认配置</strong>：</p>
<ul>
<li>1 个重做日志文件组（redo log Group）</li>
<li>包含 2 个 redo log 文件：<code>ib_logfile0</code> 和 <code>ib_logfile1</code></li>
<li>每个文件大小固定（比如 1GB），总共可记录 2GB 的操作</li>
</ul>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968106307.png" alt="1747968106307"></p>
<p><strong>循环写入机制</strong>：</p>
<ol>
<li>先写 <code>ib_logfile0</code>，写满后切换到 <code>ib_logfile1</code></li>
<li><code>ib_logfile1</code> 写满后，回到 <code>ib_logfile0</code> 开头继续写</li>
<li>就像一个环形跑道，不断循环</li>
</ol>
<h3 id="循环写入的关键指针">循环写入的关键指针</h3>
<p>MySQL 使用两个指针来管理 redo log 的循环写入：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968119294.png" alt="1747968119294"></p>
<p><strong>write pos（写入位置）</strong>：</p>
<ul>
<li>当前 redo log 记录写到的位置</li>
<li>顺时针方向移动</li>
</ul>
<p><strong>check point（检查点）</strong>：</p>
<ul>
<li>当前可以擦除的位置</li>
<li>也是顺时针方向移动</li>
</ul>
<p><strong>区域划分</strong>：</p>
<ul>
<li><strong>红色区域（write pos ~ check point）</strong>：可以用来记录新的更新操作</li>
<li><strong>蓝色区域（check point ~ write pos）</strong>：已写入但还未刷盘的脏页记录</li>
</ul>
<h3 id="文件写满的处理机制">文件写满的处理机制</h3>
<p><strong>当 write pos 追上 check point 时</strong>：</p>
<ul>
<li>表示 redo log 文件空间用完了</li>
<li><strong>MySQL 被迫停止处理新的更新操作</strong>（系统阻塞！）</li>
<li>必须先清理空间才能继续</li>
</ul>
<p><strong>清理过程</strong>：</p>
<ol>
<li><strong>强制刷盘</strong>：将 Buffer Pool 中的脏页刷新到磁盘</li>
<li><strong>标记可擦除</strong>：标记哪些 redo log 记录可以被覆盖</li>
<li><strong>移动 check point</strong>：check point 向前移动，释放空间</li>
<li><strong>恢复运行</strong>：MySQL 重新开始处理更新操作</li>
</ol>
<p><strong>性能优化建议</strong>：</p>
<ul>
<li>对于高并发系统，适当增大 redo log 文件大小非常重要</li>
<li>避免频繁触发&quot;文件写满&quot;导致的系统阻塞</li>
</ul>
<h2 id="binlog：数据库的-全程录像">binlog：数据库的&quot;全程录像&quot;</h2>
<p>前面我们学习了 undo log（后悔药）和 redo log（备份保险），现在让我们认识第三个重要角色：binlog，可以把它理解为数据库的&quot;全程录像&quot;或&quot;操作记录本&quot;。</p>
<h3 id="binlog-的作用：为什么需要-全程录像-？">binlog 的作用：为什么需要&quot;全程录像&quot;？</h3>
<p>想象一下，你的朋友向你借了一本珍贵的书，为了防止意外，你可能会：</p>
<ol>
<li>📝 记录下谁借了什么书（操作记录）</li>
<li>🕐 记录借书的时间</li>
<li>📄 记录书的具体信息</li>
</ol>
<p><strong>binlog 就像这个借书记录本</strong>，它详细记录了数据库中发生的每一个数据变更操作：</p>
<ul>
<li>什么时候执行了什么 SQL 语句</li>
<li>哪些数据被修改了</li>
<li>修改前后的具体内容</li>
</ul>
<h3 id="binlog-与-redo-log-的区别：为什么需要两套日志？">binlog 与 redo log 的区别：为什么需要两套日志？</h3>
<p>你可能会疑惑：既然有了 redo log，为什么还需要 binlog？这其实是 MySQL 历史发展的结果。</p>
<p><strong>历史背景</strong>：</p>
<ul>
<li>最初的 MySQL 使用 MyISAM 存储引擎，只有 binlog</li>
<li>后来引入 InnoDB 引擎，带来了 redo log</li>
<li>两个日志系统各有特色，互相补充</li>
</ul>
<p><strong>四大关键区别</strong>：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>redo log</th>
<th>binlog</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>归属</strong></td>
<td>InnoDB 存储引擎专用</td>
<td>MySQL Server 层，所有引擎共用</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>崩溃恢复（防止数据丢失）</td>
<td>数据备份、主从复制</td>
</tr>
<tr>
<td><strong>写入方式</strong></td>
<td>循环写（覆盖旧数据）</td>
<td>追加写（保留全部历史）</td>
</tr>
<tr>
<td><strong>日志类型</strong></td>
<td>物理日志（页面级修改）</td>
<td>逻辑日志（SQL 语句级）</td>
</tr>
</tbody>
</table>
<h3 id="binlog-的三种记录格式">binlog 的三种记录格式</h3>
<p>binlog 提供了三种记录格式，就像不同的摄像方式：</p>
<h4 id="1-STATEMENT-格式（语句记录）">1. STATEMENT 格式（语句记录）</h4>
<p><strong>记录内容</strong>：完整的 SQL 语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- binlog 中记录的内容</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：日志文件小，记录简洁<br>
<strong>缺点</strong>：遇到 <code>NOW()</code>、<code>UUID()</code> 等函数时，主从库执行结果可能不一致</p>
<h4 id="2-ROW-格式（行记录）⭐">2. ROW 格式（行记录）⭐</h4>
<p><strong>记录内容</strong>：每一行数据的具体变化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 记录的是具体数据变化</span></span><br><span class="line"><span class="comment">-- 用户ID=1的余额从1000变成900</span></span><br></pre></td></tr></table></figure>
<p><strong>优点</strong>：数据一致性最好，不会有函数导致的问题<br>
<strong>缺点</strong>：批量操作时日志文件会很大</p>
<h4 id="3-MIXED-格式（混合模式）">3. MIXED 格式（混合模式）</h4>
<p><strong>智能选择</strong>：根据 SQL 语句的类型自动选择 STATEMENT 或 ROW 格式</p>
<blockquote>
<p>💡 <strong>版本提示</strong>：MySQL 5.7.7 之前默认是 STATEMENT，之后默认是 ROW</p>
</blockquote>
<h3 id="数据恢复：binlog-vs-redo-log">数据恢复：binlog vs redo log</h3>
<p><strong>场景：数据库被误删了，能用 redo log 恢复吗？</strong></p>
<p>❌ <strong>不能用 redo log 恢复</strong></p>
<ul>
<li>redo log 是循环写，旧数据会被覆盖</li>
<li>只保存未刷盘的最新数据</li>
</ul>
<p>✅ <strong>只能用 binlog 恢复</strong></p>
<ul>
<li>binlog 保存了所有历史操作</li>
<li>可以重新&quot;播放&quot;所有数据变更</li>
</ul>
<p>这就像：</p>
<ul>
<li>redo log 是&quot;最近通话记录&quot;（只保存最新的几条）</li>
<li>binlog 是&quot;完整通话录音&quot;（保存所有内容）</li>
</ul>
<h3 id="主从复制：binlog-的重要应用">主从复制：binlog 的重要应用</h3>
<p>MySQL 的主从复制依赖于 binlog，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968131560.png" alt="1747968131560"></p>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul>
<li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>
<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li>
<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li>
</ul>
<p>具体详细过程如下：</p>
<ul>
<li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
<li>从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968138828.png" alt="1747968138828"></p>
<blockquote>
<p>从库是不是越多越好？</p>
</blockquote>
<p>不是的。</p>
<p>因为从库数量增加，从库连接上来的 I/O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p>
<p>所以在实际使用中，一个主库一般跟 2 ～ 3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。</p>
<blockquote>
<p>MySQL 主从复制还有哪些模型？</p>
</blockquote>
<p>主要有三种：</p>
<ul>
<li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li>
<li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li>
<li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li>
</ul>
<h3 id="binlog-什么时候刷盘？">binlog 什么时候刷盘？</h3>
<p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p>MySQL 给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<blockquote>
<p>什么时候 binlog cache 会写到 binlog 文件？</p>
</blockquote>
<p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968148748.png" alt="1747968148748"></p>
<p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：</p>
<ul>
<li>图中的 write，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I/O。</li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高。</li>
</ul>
<p>MySQL 提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog = N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>在 MySQL 中系统默认的设置是 sync_binlog = 1，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p>
<p>而当 sync_binlog 设置为 0 的时候，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<p>如果能容忍少量事务的 binlog 日志存在丢失风险的情况下，同时为了提高写入的性能，一般可以将 sync_binlog 设置为 100~1000 中的某个数值。</p>
<blockquote>
<p>三个日志讲完了，至此我们可以先小结下，update 语句的执行过程。</p>
</blockquote>
<p>当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。</p>
<p>具体更新一条记录 <code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code> 的流程如下：</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：
<ul>
<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：
<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务，InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。</li>
</ol>
<h2 id="为什么需要两阶段提交？">为什么需要两阶段提交？</h2>
<p>想象这样一个场景：你在银行转账，需要同时做两件事：</p>
<ol>
<li>在你的账户记录中减少 100 元</li>
<li>在朋友的账户记录中增加 100 元</li>
</ol>
<p><strong>如果银行系统在完成第一步后突然宕机，而第二步还没来得及执行，会发生什么？</strong></p>
<ul>
<li>你的钱没了（你的账户减少了 100 元）</li>
<li>朋友没收到钱（朋友的账户没有增加）</li>
<li>这 100 元就&quot;蒸发&quot;了！</li>
</ul>
<p><strong>MySQL 面临的也是类似问题</strong>。当事务提交时，需要同时写入两个日志：</p>
<ul>
<li><strong>redo log</strong>：保证主库数据的持久性</li>
<li><strong>binlog</strong>：用于主从复制，保证从库数据一致</li>
</ul>
<p>如果这两个操作出现&quot;半成功&quot;状态，就会导致主从数据不一致。</p>
<h3 id="问题实例：主从数据不一致">问题实例：主从数据不一致</h3>
<p>假设执行这条更新语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t_user <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;xiaolin&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 原值：name = &#x27;jay&#x27;</span></span><br><span class="line"><span class="comment">-- 新值：name = &#x27;xiaolin&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>情况一：redo log 写入成功，binlog 写入失败</strong></p>
<ul>
<li>主库：通过 redo log 恢复，name = ‘xiaolin’ ✅</li>
<li>从库：没有收到 binlog，name = ‘jay’ ❌</li>
<li><strong>结果</strong>：主从数据不一致</li>
</ul>
<p><strong>情况二：binlog 写入成功，redo log 写入失败</strong></p>
<ul>
<li>主库：redo log 丢失，事务回滚，name = ‘jay’ ❌</li>
<li>从库：收到 binlog 并执行，name = ‘xiaolin’ ✅</li>
<li><strong>结果</strong>：主从数据不一致</li>
</ul>
<h3 id="解决方案：两阶段提交">解决方案：两阶段提交</h3>
<p><strong>两阶段提交就像一个&quot;双重确认&quot;机制</strong>，确保 redo log 和 binlog 要么都成功，要么都失败。</p>
<p><strong>核心思想</strong>：把事务提交拆分成两个阶段</p>
<ul>
<li><strong>准备阶段（Prepare）</strong>：所有参与者准备就绪</li>
<li><strong>提交阶段（Commit）</strong>：协调者宣布正式提交</li>
</ul>
<h3 id="生活化比喻：结婚仪式">生活化比喻：结婚仪式</h3>
<p>想象一场婚礼，需要新郎和新娘都同意才能完成：</p>
<p><strong>准备阶段</strong>：</p>
<ul>
<li>牧师问新郎：“你愿意吗？”</li>
<li>牧师问新娘：“你愿意吗？”</li>
<li>只有两人都说&quot;我愿意&quot;，才能进入下一阶段</li>
</ul>
<p><strong>提交阶段</strong>：</p>
<ul>
<li>如果两人都同意：牧师宣布&quot;你们现在是夫妻了&quot;</li>
<li>如果任何一人拒绝：仪式取消</li>
</ul>
<p>在 MySQL 中：</p>
<ul>
<li><strong>新郎</strong> = redo log</li>
<li><strong>新娘</strong> = binlog</li>
<li><strong>牧师</strong> = 事务协调者</li>
<li><strong>结婚证书</strong> = 事务提交成功</li>
</ul>
<h3 id="两阶段提交的详细过程">两阶段提交的详细过程</h3>
<p>在 MySQL 中，两阶段提交使用<strong>内部 XA 事务</strong>来实现：</p>
<ul>
<li><strong>协调者</strong>：binlog</li>
<li><strong>参与者</strong>：InnoDB 存储引擎（redo log）</li>
</ul>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968172124.png" alt="1747968172124"></p>
<p><strong>具体执行流程</strong>：</p>
<h4 id="准备阶段（Prepare-Phase）">准备阶段（Prepare Phase）</h4>
<ol>
<li><strong>生成事务 ID</strong>：为事务分配一个唯一的 XID（事务标识符）</li>
<li><strong>记录 redo log</strong>：将 XID 写入 redo log，并标记状态为 <code>prepare</code></li>
<li><strong>刷盘保存</strong>：将 prepare 状态的 redo log 持久化到磁盘</li>
</ol>
<blockquote>
<p>💡 <strong>此时事务还没有正式提交</strong>，只是表示 redo log 准备就绪</p>
</blockquote>
<h4 id="提交阶段（Commit-Phase）">提交阶段（Commit Phase）</h4>
<ol>
<li><strong>记录 binlog</strong>：将事务的 XID 和具体操作写入 binlog</li>
<li><strong>binlog 刷盘</strong>：将 binlog 持久化到磁盘</li>
<li><strong>最终提交</strong>：调用存储引擎接口，将 redo log 状态改为 <code>commit</code></li>
<li><strong>redo log 刷盘</strong>：将 commit 状态持久化到磁盘</li>
</ol>
<blockquote>
<p>✅ <strong>事务正式提交成功</strong></p>
</blockquote>
<h3 id="崩溃恢复：如何保证一致性？">崩溃恢复：如何保证一致性？</h3>
<p><strong>关键时刻的崩溃场景</strong>：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968183453.png" alt="1747968183453"></p>
<p><strong>时刻 A 崩溃</strong>（redo log 已写，binlog 未写）：</p>
<ul>
<li>redo log 状态：<code>prepare</code></li>
<li>binlog 状态：无记录</li>
<li><strong>恢复策略</strong>：回滚事务（因为 binlog 中找不到对应的 XID）</li>
</ul>
<p><strong>时刻 B 崩溃</strong>（redo log 和 binlog 都已写，但还未标记 commit）：</p>
<ul>
<li>redo log 状态：<code>prepare</code></li>
<li>binlog 状态：有对应的 XID 记录</li>
<li><strong>恢复策略</strong>：提交事务（因为 binlog 中能找到对应的 XID）</li>
</ul>
<h3 id="恢复判断逻辑">恢复判断逻辑</h3>
<p>MySQL 重启后的自动恢复过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 扫描 redo log 文件</span><br><span class="line">2. 发现状态为 prepare 的事务</span><br><span class="line">3. 提取该事务的 XID</span><br><span class="line">4. 在 binlog 中查找是否存在相同的 XID</span><br><span class="line">   ├── 找到了 → 提交事务 ✅</span><br><span class="line">   └── 没找到 → 回滚事务 ❌</span><br></pre></td></tr></table></figure>
<p><strong>核心原则</strong>：<strong>以 binlog 写入成功为准</strong></p>
<ul>
<li>binlog 写成功 = 事务应该提交（因为从库会收到这个操作）</li>
<li>binlog 写失败 = 事务应该回滚（保持主从一致）</li>
</ul>
<h3 id="为什么以-binlog-为准？">为什么以 binlog 为准？</h3>
<p><strong>原因很简单</strong>：</p>
<ul>
<li>binlog 一旦写入，就会被复制到从库</li>
<li>从库会根据 binlog 执行相同的操作</li>
<li>如果主库不提交这个事务，就会造成主从数据不一致</li>
</ul>
<p><strong>所以必须保证</strong>：主库和从库的处理策略完全一致</p>
<h3 id="特殊情况：未提交事务的-redo-log-刷盘">特殊情况：未提交事务的 redo log 刷盘</h3>
<p><strong>疑问</strong>：事务还没提交，redo log 会被持久化吗？</p>
<p><strong>答案</strong>：会的！</p>
<p><strong>原因</strong>：</p>
<ul>
<li>redo log buffer 中的内容会被后台线程每秒刷盘一次</li>
<li>这意味着未提交事务的 redo log 也可能在磁盘上</li>
</ul>
<p><strong>安全保障</strong>：</p>
<ul>
<li>未提交事务的 binlog 绝对不会被持久化</li>
<li>MySQL 重启时发现&quot;有 redo log 但无 binlog&quot;的事务，会自动回滚</li>
<li>数据一致性得到保证</li>
</ul>
<p><strong>记忆要点</strong>：</p>
<ul>
<li>✅ redo log 可以在事务提交前持久化</li>
<li>❌ binlog 只能在事务提交后持久化</li>
</ul>
<h2 id="两阶段提交有什么问题？">两阶段提交有什么问题？</h2>
<p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p>
<ul>
<li><strong>磁盘 I/O 次数高</strong>：对于“双 1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li>
<li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li>
</ul>
<blockquote>
<p>为什么两阶段提交的磁盘 I/O 次数会很高？</p>
</blockquote>
<p>binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：</p>
<ul>
<li>当 sync_binlog = 1 的时候，表示每次提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘；</li>
<li>当 innodb_flush_log_at_trx_commit = 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；</li>
</ul>
<p>可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中，都会至少调用 2 次刷盘操作，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。</p>
<blockquote>
<p>为什么锁竞争激烈？</p>
</blockquote>
<p>在早期的 MySQL 版本中，通过使用 prepare_commit_mutex 锁来保证事务提交的顺序，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。</p>
<p>通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。</p>
<h3 id="组提交：集体坐公交，一次搞定！">组提交：集体坐公交，一次搞定！</h3>
<p><strong>想象你每天上班都要坐公交车</strong>：</p>
<p><strong>以前的做法</strong>：每个人都打私家车</p>
<ul>
<li>每个事务单独提交，单独刷盘</li>
<li>10 个事务 = 10 次磁盘操作</li>
<li>就像 10 个人开 10 辆车上班，效率低，还堵车</li>
</ul>
<p><strong>组提交的做法</strong>：大家一起坐公交</p>
<ul>
<li><strong>多个事务一起提交，一次刷盘</strong></li>
<li>10 个事务 = 1 次磁盘操作</li>
<li>就像 10 个人坐 1 辆公交车，效率高多了！</li>
</ul>
<p><strong>MySQL 组提交的核心思想</strong>：</p>
<ul>
<li>不让事务&quot;单打独斗&quot;，而是&quot;抱团取暖&quot;</li>
<li>多个事务一起刷盘，大大减少磁盘 I/O 次数</li>
<li><strong>如果 10 个事务单独刷盘成本是 10，那么一起刷盘的成本接近 1</strong></li>
</ul>
<h3 id="组提交的三个阶段">组提交的三个阶段</h3>
<p>为了实现组提交，MySQL 把原来的 commit 阶段拆分成三个更精细的步骤：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968207864.png" alt="1747968207864"></p>
<p><strong>三个阶段的作用</strong>：</p>
<ul>
<li><strong>Flush 阶段</strong>：把 binlog 从内存写到文件（但不刷盘）</li>
<li><strong>Sync 阶段</strong>：多个事务的 binlog 一起刷盘（关键步骤！）</li>
<li><strong>Commit 阶段</strong>：告诉存储引擎正式提交</li>
</ul>
<p><strong>队列机制</strong>：</p>
<ul>
<li>每个阶段都有自己的队列</li>
<li>第一个到达的事务成为&quot;队长&quot;（Leader）</li>
<li>队长负责带领整个队伍完成操作</li>
<li>完成后通知队员们&quot;任务完成&quot;</li>
</ul>
<h3 id="锁粒度优化：从-独占整个银行-到-独占单个窗口">锁粒度优化：从&quot;独占整个银行&quot;到&quot;独占单个窗口&quot;</h3>
<p><strong>以前的锁机制</strong>：</p>
<ul>
<li>就像整个银行只有一个 VIP 通道</li>
<li>一个客户进去后，把整个银行都锁住</li>
<li>其他所有客户都要等着</li>
</ul>
<p><strong>组提交的锁机制</strong>：</p>
<ul>
<li>就像银行有三个专门窗口：取号窗口、办理窗口、确认窗口</li>
<li>每个窗口可以同时服务，只是窗口内部需要排队</li>
<li><strong>锁粒度变小，并发度提高</strong></li>
</ul>
<h3 id="redo-log-也有组提交吗？">redo log 也有组提交吗？</h3>
<p><strong>这要看 MySQL 版本</strong>：</p>
<p><strong>MySQL 5.6</strong>：❌ 没有 redo log 组提交</p>
<ul>
<li>每个事务在 prepare 阶段各自刷盘</li>
<li>就像每个人都要单独过安检</li>
</ul>
<p><strong>MySQL 5.7+</strong>：✅ 有 redo log 组提交</p>
<ul>
<li>把 redo log 刷盘推迟到 flush 阶段</li>
<li>多个事务的 redo log 一起刷盘</li>
<li><strong>binlog 和 redo log 都能享受组提交的好处</strong></li>
</ul>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968216941.png" alt="1747968216941"></p>
<p>这个要看 MySQL 版本，MySQL 5.6 没有 redo log 组提交，MySQL 5.7 有 redo log 组提交。</p>
<p>在 MySQL 5.6 的组提交逻辑中，每个事务各自执行 prepare 阶段，也就是各自将 redo log 刷盘，这样就没办法对 redo log 进行组提交。</p>
<p>所以在 MySQL 5.7 版本中，做了个改进，在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段，也就是说 prepare 阶段融合在了 flush 阶段。</p>
<p>这个优化是将 redo log 的刷盘延迟到了 flush 阶段之中，sync 阶段之前。通过延迟写 redo log 的方式，为 redolog 做了一次组写入，这样 binlog 和 redo log 都进行了优化。</p>
<p>接下来介绍每个阶段的过程，注意下面的过程针对的是“双 1”配置（sync_binlog 和 innodb_flush_log_at_trx_commit 都配置为 1）。</p>
<blockquote>
<p>flush 阶段</p>
</blockquote>
<p>第一个事务会成为 flush 阶段的 Leader，此时后面到来的事务都是 Follower：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968216941.png" alt="1747968216941"></p>
<p>接着，获取队列中的事务组，由绿色事务组的 Leader 对 rodo log 做一次 write + fsync，即一次将同组事务的 redolog 刷盘：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968226511.png" alt="1747968226511"></p>
<p>完成了 prepare 阶段后，将绿色这一组事务执行过程中产生的 binlog 写入 binlog 文件（调用 write，不会调用 fsync，所以不会刷盘，binlog 缓存在操作系统的文件系统中）。</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968233827.png" alt="1747968233827"></p>
<p>从上面这个过程，可以知道 flush 阶段队列的作用是<strong>用于支撑 redo log 的组提交</strong>。</p>
<p>如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务。</p>
<blockquote>
<p>sync 阶段</p>
</blockquote>
<p>绿色这一组事务的 binlog 写入到 binlog 文件后，并不会马上执行刷盘的操作，而是<strong>会等待一段时间</strong>，这个等待的时长由 <code>Binlog_group_commit_sync_delay</code> 参数控制，<strong>目的是为了组合更多事务的 binlog，然后再一起刷盘</strong>，如下过程：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968240604.png" alt="1747968240604"></p>
<p>不过，在等待的过程中，如果事务的数量提前达到了 <code>Binlog_group_commit_sync_no_delay_count</code> 参数设置的值，就不用继续等待了，就马上将 binlog 刷盘，如下图：</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968249657.png" alt="1747968249657"></p>
<p>从上面的过程，可以知道 sync 阶段队列的作用是<strong>用于支持 binlog 的组提交</strong>。</p>
<p>如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：</p>
<ul>
<li><code>binlog_group_commit_sync_delay= N</code>，表示在等待 N 微妙后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「binlog 文件」持久化到磁盘。</li>
<li><code>binlog_group_commit_sync_no_delay_count = N</code>，表示如果队列中的事务数达到 N 个，就忽视 binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。</li>
</ul>
<p>如果在这一步完成后数据库崩溃，由于 binlog 中已经有了事务记录，MySQL 会在重启后通过 redo log 刷盘的数据继续进行事务的提交。</p>
<blockquote>
<p>commit 阶段</p>
</blockquote>
<p>最后进入 commit 阶段，调用引擎的提交事务接口，将 redo log 状态设置为 commit。</p>
<p><img src="/2025/05/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97/1747968257038.png" alt="1747968257038"></p>
<p>commit 阶段队列的作用是承接 sync 阶段的事务，完成最后的引擎提交，使得 sync 可以尽早的处理下一组事务，最大化组提交的效率。</p>
<h2 id="MySQL-磁盘-I-O-很高，有什么优化的方法？">MySQL 磁盘 I/O 很高，有什么优化的方法？</h2>
<p>现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，我们可以通过控制以下参数，来“延迟”binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：</p>
<ul>
<li>设置组提交的两个参数：binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「redo log 文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。</li>
</ul>
<h2 id="总结">总结</h2>
<p>具体更新一条记录 <code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code> 的流程如下：</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：
<ul>
<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：
<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务，InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，先生成对应 redo log，并存入 redo log buffer 里面，当事务提交时，将 redo log 写入 redo log file，并更新 buffer pool 中的数据页，将其放入 flush 链表并标记脏页和记录 redo log 对应的 lsn 到该页的 oldest_modification，这个时候更新就算完成了。为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：
<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<hr>
<p>参考资料：</p>
<ul>
<li>《MySQL 45 讲》</li>
<li>《MySQL 是怎样运行的？》</li>
<li><a href="https://developer.aliyun.com/article/617776">https://developer.aliyun.com/article/617776</a></li>
<li><a href="http://mysql.taobao.org/monthly/2021/10/01/">http://mysql.taobao.org/monthly/2021/10/01/</a></li>
<li><a href="https://www.cnblogs.com/Neeo/articles/13883976.html">https://www.cnblogs.com/Neeo/articles/13883976.html</a></li>
<li><a href="https://www.cnblogs.com/mengxinJ/p/14211427.html">https://www.cnblogs.com/mengxinJ/p/14211427.html</a></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>MVCC</tag>
        <tag>undo log</tag>
        <tag>redo log</tag>
        <tag>binlog</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 80 - 删除有序数组中的重复项 II（Remove Duplicates from Sorted Array II）</title>
    <url>/2025/05/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个有序数组 <code>nums</code>，请你<strong>原地</strong>删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong>，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。</span><br><span class="line">不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。</span><br><span class="line">不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>nums</code> 已按<strong>非严格递增</strong>顺序排列</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题是经典的<strong>双指针</strong>问题，核心思想是维护一个&quot;有效区域&quot;，确保每个元素最多出现两次。</p>
<h3 id="核心洞察">核心洞察</h3>
<p><strong>关键洞察</strong>：对于位置 <code>left</code>，如果 <code>nums[left-2] != nums[right]</code>，那么 <code>nums[right]</code> 可以安全地放入位置 <code>left</code>，因为这保证了最多连续两个相同元素。</p>
<h3 id="算法步骤">算法步骤</h3>
<ol>
<li><strong>初始化</strong>：由于前两个元素无论如何都可以保留，所以从索引 2 开始处理</li>
<li><strong>双指针遍历</strong>：
<ul>
<li><code>left</code>：指向下一个要填入的位置</li>
<li><code>right</code>：遍历整个数组</li>
</ul>
</li>
<li><strong>判断条件</strong>：比较 <code>nums[left-2]</code> 和 <code>nums[right]</code>
<ul>
<li>如果不相等，说明 <code>nums[right]</code> 可以放入，因为它与前面第二个元素不同</li>
<li>如果相等，说明已经有两个相同元素了，跳过当前元素</li>
</ul>
</li>
</ol>
<h3 id="可视化示例">可视化示例</h3>
<p>以 <code>nums = [1,1,1,2,2,3]</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态: [1,1,1,2,2,3]</span><br><span class="line">           ↑     ↑</span><br><span class="line">         left  right</span><br><span class="line"></span><br><span class="line">步骤1: nums[0] != nums[2] → 1 != 1 (false)</span><br><span class="line">       right++</span><br><span class="line"></span><br><span class="line">步骤2: nums[0] != nums[3] → 1 != 2 (true)</span><br><span class="line">       nums[2] = nums[3] = 2</span><br><span class="line">       [1,1,2,2,2,3]</span><br><span class="line">             ↑   ↑</span><br><span class="line">           left right</span><br><span class="line"></span><br><span class="line">步骤3: nums[1] != nums[4] → 1 != 2 (true)</span><br><span class="line">       nums[3] = nums[4] = 2</span><br><span class="line">       [1,1,2,2,2,3]</span><br><span class="line">               ↑ ↑</span><br><span class="line">             left right</span><br><span class="line"></span><br><span class="line">步骤4: nums[2] != nums[5] → 2 != 3 (true)</span><br><span class="line">       nums[4] = nums[5] = 3</span><br><span class="line">       [1,1,2,2,3,3]</span><br><span class="line">                 ↑</span><br><span class="line">               left</span><br><span class="line"></span><br><span class="line">最终结果: [1,1,2,2,3], length = 5</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界情况：长度小于等于2时，所有元素都可以保留</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双指针：left指向下一个要填入的位置，right遍历数组</span></span><br><span class="line">    left, right := <span class="number">2</span>, <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right &lt; n &#123;</span><br><span class="line">        <span class="comment">// 关键判断：如果当前元素与left-2位置的元素不同</span></span><br><span class="line">        <span class="comment">// 说明可以安全放入，保证最多连续两个相同元素</span></span><br><span class="line">        <span class="keyword">if</span> nums[left<span class="number">-2</span>] != nums[right] &#123;</span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析">执行过程分析</h3>
<p>以 <code>nums = [0,0,1,1,1,1,2,3,3]</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始: [0,0,1,1,1,1,2,3,3]  left=2, right=2</span><br><span class="line">      </span><br><span class="line">right=2: nums[0] != nums[2] → 0 != 1 (true)</span><br><span class="line">         nums[2] = 1, left=3</span><br><span class="line">         [0,0,1,1,1,1,2,3,3]</span><br><span class="line"></span><br><span class="line">right=3: nums[1] != nums[3] → 0 != 1 (true)  </span><br><span class="line">         nums[3] = 1, left=4</span><br><span class="line">         [0,0,1,1,1,1,2,3,3]</span><br><span class="line"></span><br><span class="line">right=4: nums[2] != nums[4] → 1 != 1 (false)</span><br><span class="line">         跳过</span><br><span class="line"></span><br><span class="line">right=5: nums[3] != nums[5] → 1 != 1 (false)</span><br><span class="line">         跳过</span><br><span class="line"></span><br><span class="line">right=6: nums[4] != nums[6] → 1 != 2 (true)</span><br><span class="line">         nums[4] = 2, left=5</span><br><span class="line">         [0,0,1,1,2,1,2,3,3]</span><br><span class="line"></span><br><span class="line">right=7: nums[5] != nums[7] → 1 != 3 (true)</span><br><span class="line">         nums[5] = 3, left=6</span><br><span class="line">         [0,0,1,1,2,3,2,3,3]</span><br><span class="line"></span><br><span class="line">right=8: nums[6] != nums[8] → 2 != 3 (true)</span><br><span class="line">         nums[6] = 3, left=7</span><br><span class="line">         [0,0,1,1,2,3,3,3,3]</span><br><span class="line"></span><br><span class="line">最终结果: [0,0,1,1,2,3,3], length = 7</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>时间复杂度</strong>：$O(n)$</p>
<ul>
<li>只需要遍历数组一次，每个元素最多被访问两次</li>
</ul>
<p><strong>空间复杂度</strong>：$O(1)$</p>
<ul>
<li>只使用了常数个额外变量，原地修改数组</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<h3 id="核心技巧">核心技巧</h3>
<ol>
<li><strong>双指针模式</strong>：一个指针负责遍历，另一个指针维护有效区域</li>
<li><strong>前瞻比较</strong>：通过比较 <code>nums[left-2]</code> 和 <code>nums[right]</code> 来判断是否可以保留元素</li>
<li><strong>原地修改</strong>：直接在原数组上操作，节省空间</li>
</ol>
<h3 id="常见陷阱">常见陷阱</h3>
<ol>
<li><strong>边界处理</strong>：忘记处理数组长度小于等于 2 的情况</li>
<li><strong>索引越界</strong>：<code>left-2</code> 可能越界，需要从索引 2 开始</li>
<li><strong>理解错误</strong>：误以为需要计数每个元素的出现次数</li>
</ol>
<h3 id="扩展应用">扩展应用</h3>
<ul>
<li>可以轻松扩展到&quot;最多保留 k 个重复元素&quot;的情况</li>
<li>类似的原地修改数组问题都可以使用双指针技术</li>
<li>这种模式在处理有序数组时特别有效</li>
</ul>
<h3 id="相关问题">相关问题</h3>
<ul>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">LeetCode 26: Remove Duplicates from Sorted Array</a></li>
<li><a href="https://leetcode.cn/problems/remove-element/">LeetCode 27: Remove Element</a></li>
<li><a href="https://leetcode.cn/problems/move-zeroes/">LeetCode 283: Move Zeroes</a></li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 287 - 寻找重复数</title>
    <url>/2025/05/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code>，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 中只存在一个重复的整数，但这个重复的整数可能会重复多次，请找出这个重复的整数。</p>
<p><strong>要求：</strong></p>
<ul>
<li>不能修改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 O(1) 的空间。</li>
<li>时间复杂度小于 O(n^2) 。</li>
</ul>
<p><strong>示例 1:</strong></p>
<p>输入: <code>nums = [1,3,4,2,2]</code><br>
输出: <code>2</code></p>
<p><strong>示例 2:</strong></p>
<p>输入: <code>nums = [3,1,3,4,2]</code><br>
输出: <code>3</code></p>
<p><strong>示例 3:</strong></p>
<p>输入: <code>nums = [1,1]</code><br>
输出: <code>1</code></p>
<p><strong>示例 4:</strong></p>
<p>输入: <code>nums = [1,1,2]</code><br>
输出: <code>1</code></p>
<p><strong>约束条件:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>nums.length == n + 1</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中只有一个整数出现两次或多次，其余整数均只出现一次。</li>
</ul>
<h3 id="解题思路">解题思路</h3>
<p>这道题的核心难点在于对空间复杂度和时间复杂度的限制，以及不能修改原数组的要求。初看之下，可能会想到用哈希表来记录数字出现的次数，但这样空间复杂度会达到 O(n)。对数组进行排序也不可行，因为题目规定不能修改原数组。</p>
<p>那么，如何在 O(1) 空间复杂度下解决这个问题呢？答案是将此问题巧妙地转化为<strong>寻找链表中的环</strong>。</p>
<h4 id="核心思想：快慢指针-Floyd-判圈算法">核心思想：快慢指针 (Floyd 判圈算法)</h4>
<p>我们可以将数组 <code>nums</code> 视为一个链表。数组的<strong>下标</strong>可以看作是链表节点的“隐式”地址，而数组中<strong>存储的值</strong> <code>nums[i]</code> 则可以看作是指向下一个节点的指针（即下一个节点的下标）。</p>
<p>例如，对于数组 <code>nums = [1,3,4,2,2]</code>：</p>
<ul>
<li>我们从下标 <code>0</code> 开始，<code>nums[0] = 1</code>，这意味着从节点 <code>0</code> 跳转到节点 <code>1</code>。</li>
<li>当前在下标 <code>1</code>，<code>nums[1] = 3</code>，所以从节点 <code>1</code> 跳转到节点 <code>3</code>。</li>
<li>当前在下标 <code>3</code>，<code>nums[3] = 2</code>，所以从节点 <code>3</code> 跳转到节点 <code>2</code>。</li>
<li>当前在下标 <code>2</code>，<code>nums[2] = 4</code>，所以从节点 <code>2</code> 跳转到节点 <code>4</code>。</li>
<li>当前在下标 <code>4</code>，<code>nums[4] = 2</code>，所以又从节点 <code>4</code> 跳转回了节点 <code>2</code>。</li>
</ul>
<p>这样，我们就构建了一个以数组下标为节点的序列：<code>0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 2 -&gt; ...</code>。在这个序列中，节点 <code>2</code> 被重复访问，形成了一个环。</p>
<p><strong>环是如何形成的？</strong><br>
我们将数组的每个<strong>索引 <code>i</code></strong> 视为一个节点，而 <code>nums[i]</code> 的值视为从节点 <code>i</code> 出发，指向下一个节点的<strong>索引</strong>。<br>
由于数组 <code>nums</code> 包含 <code>n + 1</code> 个整数，这些整数的范围是 <code>[1, n]</code>。这意味着数组中的值都可以作为有效的数组下标（题目数值范围 <code>[1,n]</code> 保证了 <code>nums[i]</code> 作为下标不会越界访问 <code>0</code> 到 <code>n</code> 之外的区域，除非 <code>n</code> 非常小，但即使如此，其值也在 <code>[1,n]</code> 内，可作为有效下标）。<br>
我们从索引 <code>0</code> 开始（这可以看作是链表的“头部”或起始探测点），然后根据 <code>nums[当前索引]</code> 不断跳转到下一个索引。<br>
序列可以表示为：<code>x_0 = 0</code>, <code>x_1 = nums[x_0]</code>, <code>x_2 = nums[x_1]</code>, …, <code>x_&#123;i+1&#125; = nums[x_i]</code>。<br>
由于数组中只有 <code>n+1</code> 个不同的索引（从 <code>0</code> 到 <code>n</code>），而我们通过 <code>nums[x_i]</code> 进行跳转，这个序列最终必然会访问到一个已经访问过的<strong>索引</strong>，从而形成一个环。这个环的入口点（即第一个被重复访问的索引）就是我们要找的重复数字。</p>
<p>Floyd 判圈算法（也称为龟兔赛跑算法）包含两个主要阶段：</p>
<ol>
<li>
<p><strong>找到相遇点</strong>：设置两个指针，一个慢指针 <code>slow</code>，一个快指针 <code>fast</code>。它们都从我们定义的“链表头”（即数组索引 <code>0</code>）开始。</p>
<ul>
<li><code>slow</code> 每次移动一步：<code>slow = nums[slow]</code> (即 <code>slow</code> 指针更新为其当前指向的数组元素的值，这个值作为下一个索引)。</li>
<li><code>fast</code> 每次移动两步：<code>fast = nums[nums[fast]]</code> (类似地，<code>fast</code> 指针进行两次跳转)。<br>
如果链表中存在环，<code>fast</code> 指针最终会在环内追上 <code>slow</code> 指针。</li>
</ul>
</li>
<li>
<p><strong>找到环的入口</strong>：当 <code>slow</code> 和 <code>fast</code> 相遇后，我们将 <code>slow</code> 指针重置回“链表头”（即索引 <code>0</code>）。然后，<code>slow</code> 和 <code>fast</code> 都以每次一步的速度前进 (<code>slow = nums[slow]</code>, <code>fast = nums[fast]</code>)。它们再次相遇的那个点（索引），就是环的入口，这个索引值也就是我们寻找的重复数字。</p>
</li>
</ol>
<h4 id="算法正确性图解与推导">算法正确性图解与推导</h4>
<p>以 <code>nums = [1,3,4,2,2]</code> 为例：<br>
数组索引作为节点：<code>0, 1, 2, 3, 4</code><br>
数组值作为指向下一个节点的指针：<code>nums[0]=1, nums[1]=3, nums[2]=4, nums[3]=2, nums[4]=2</code></p>
<p>形成的路径（索引序列）：<br>
<code>0 --(nums[0]=1)--&gt; 1 --(nums[1]=3)--&gt; 3 --(nums[3]=2)--&gt; 2 --(nums[2]=4)--&gt; 4 --(nums[4]=2)--&gt; 2 ...</code><br>
这条路径从索引 <code>0</code> 开始，经过 <code>1</code> 和 <code>3</code> 到达 <code>2</code>，然后形成一个环 <code>2 -&gt; 4 -&gt; 2</code>。环的入口点是索引 <code>2</code>。</p>
<p><strong>阶段 1：寻找相遇点</strong><br>
初始时，<code>slow = 0</code>, <code>fast = 0</code>。<br>
根据代码逻辑 (<code>for slow, fast = nums[slow], nums[nums[fast]]; slow != fast; ...</code>)：</p>
<ol>
<li>
<p><strong>首次赋值 (循环初始化部分)</strong>:<br>
<code>slow = nums[0] = 1</code><br>
<code>fast = nums[nums[0]] = nums[1] = 3</code><br>
此时 <code>slow = 1</code>, <code>fast = 3</code>。由于 <code>1 != 3</code>，循环继续。</p>
</li>
<li>
<p><strong>第二次迭代 (循环迭代后部分)</strong>:<br>
<code>slow = nums[slow] = nums[1] = 3</code><br>
<code>fast = nums[nums[fast]] = nums[nums[3]] = nums[2] = 4</code><br>
此时 <code>slow = 3</code>, <code>fast = 4</code>。由于 <code>3 != 4</code>，循环继续。</p>
</li>
<li>
<p><strong>第三次迭代</strong>:<br>
<code>slow = nums[slow] = nums[3] = 2</code><br>
<code>fast = nums[nums[fast]] = nums[nums[4]] = nums[2] = 4</code><br>
此时 <code>slow = 2</code>, <code>fast = 4</code>。由于 <code>2 != 4</code>，循环继续。</p>
</li>
<li>
<p><strong>第四次迭代</strong>:<br>
<code>slow = nums[slow] = nums[2] = 4</code><br>
<code>fast = nums[nums[fast]] = nums[nums[4]] = nums[2] = 4</code><br>
此时 <code>slow = 4</code>, <code>fast = 4</code>。由于 <code>4 == 4</code>，循环终止。<br>
快慢指针在索引 <code>4</code> 处相遇。设相遇点为 <code>M</code>，则 <code>M=4</code>。</p>
</li>
</ol>
<p><strong>阶段 2：寻找环的入口</strong><br>
相遇后，<code>slow</code> 被重置为 <code>0</code>，而 <code>fast</code> 保持在相遇点 <code>M=4</code>。<br>
然后两者同步前进，每次一步：</p>
<ol>
<li>
<p><code>slow = nums[slow] = nums[0] = 1</code><br>
<code>fast = nums[fast] = nums[4] = 2</code><br>
此时 <code>slow = 1</code>, <code>fast = 2</code>。由于 <code>1 != 2</code>，循环继续。</p>
</li>
<li>
<p><code>slow = nums[slow] = nums[1] = 3</code><br>
<code>fast = nums[fast] = nums[2] = 4</code><br>
此时 <code>slow = 3</code>, <code>fast = 4</code>。由于 <code>3 != 4</code>，循环继续。</p>
</li>
<li>
<p><code>slow = nums[slow] = nums[3] = 2</code><br>
<code>fast = nums[fast] = nums[4] = 2</code><br>
此时 <code>slow = 2</code>, <code>fast = 2</code>。由于 <code>2 == 2</code>，循环终止。<br>
两者在索引 <code>2</code> 处相遇。这个点就是环的入口 <code>E</code>，所以 <code>E=2</code>。<br>
函数返回 <code>slow</code> 的值，即 <code>2</code>。这正是 <code>nums = [1,3,4,2,2]</code> 中的重复数字。</p>
</li>
</ol>
<p><strong>为什么此方法能找到重复数字？</strong></p>
<p>设从起点（索引 <code>0</code>）到环的入口点（索引 <code>E</code>）的路径长度为 <code>L</code>。<br>
设环的长度为 <code>C</code>。<br>
当慢指针 <code>slow</code> 和快指针 <code>fast</code> 在环中某点（索引 <code>M</code>）相遇时：<br>
慢指针走过的距离：<code>Dist_slow = L + x</code> (其中 <code>x</code> 是从 <code>E</code> 到 <code>M</code> 沿环方向的距离)<br>
快指针走过的距离：<code>Dist_fast = L + x + k*C</code> (其中 <code>k &gt;= 1</code> 是快指针比慢指针多绕环的圈数)<br>
由于快指针速度是慢指针的两倍，所以 <code>Dist_fast = 2 * Dist_slow</code>。<br>
<code>L + x + k*C = 2 * (L + x)</code><br>
<code>L + x + k*C = 2L + 2x</code><br>
<code>k*C = L + x</code><br>
这意味着 <code>L + x</code> 是环长的整数倍。<br>
我们想找到 <code>L</code>。由上式可得 <code>L = k*C - x</code>。<br>
这个等式告诉我们：从起点 <code>0</code> 走 <code>L</code> 步可以到达环入口 <code>E</code>。同时，从相遇点 <code>M</code>（它距离环入口 <code>E</code> 为 <code>x</code> 步）向前走 <code>L</code> 步，也会到达环入口 <code>E</code>。<br>
这是因为从 <code>M</code> 走 <code>L</code> 步，相当于走了 <code>k*C - x</code> 步。在环上，走 <code>k*C</code> 步等于回到原地，再走 <code>-x</code> 步（即后退 <code>x</code> 步，或者等效于前进 <code>C-x</code> 步，如果 <code>x &gt; 0</code>），都会到达环的入口 <code>E</code>（如果 <code>x=0</code>，则 <code>M</code> 就是 <code>E</code>，走 <code>kC</code> 步也回到 <code>E</code>）。<br>
因此，当一个指针从起点 <code>0</code> 出发，另一个指针从相遇点 <code>M</code> 出发，两者都以相同速度（每次一步）前进时，它们必然会在环的入口点 <code>E</code> 相遇。<br>
这个相遇点 <code>E</code> 是一个索引值。由于题目设定 <code>nums[i]</code> 的值在 <code>[1, n]</code> 范围内，并且这个值被用作下一个索引，那么环的入口索引 <code>E</code> 本身也必须是 <code>[1, n]</code> 范围内的一个值。<br>
如果索引 <code>E</code> 是环的入口，意味着至少有两条不同的“路径”指向了索引 <code>E</code>：一条是首次进入环的路径 (<code>... -&gt; x_&#123;L-1&#125; --(nums[x_&#123;L-1&#125;]=E)--&gt; E</code>)，另一条是环内的路径 (<code>... -&gt; x_&#123;L+C-1&#125; --(nums[x_&#123;L+C-1&#125;]=E)--&gt; E</code>)。由于 <code>x_&#123;L-1&#125;</code> 和 <code>x_&#123;L+C-1&#125;</code> 是不同的索引（除非 L=0，即起点就在环上），但它们指向的下一个索引都是 <code>E</code> (<code>nums[x_&#123;L-1&#125;] = E</code> 且 <code>nums[x_&#123;L+C-1&#125;] = E</code>)，这表明值 <code>E</code> 就是那个被重复指向的数字，即重复数。</p>
<p>再看一个例子：<code>nums = [3,1,3,4,2]</code>。重复数是 <code>3</code>。<br>
路径（索引序列）：<code>0 --(3)--&gt; 3 --(4)--&gt; 4 --(2)--&gt; 2 --(3)--&gt; 3 ...</code><br>
环是 <code>3 -&gt; 4 -&gt; 2 -&gt; 3</code>。环的入口索引 <code>E = 3</code>。</p>
<p>阶段 1：<code>slow=0, fast=0</code></p>
<ol>
<li><code>slow = nums[0]=3</code>, <code>fast = nums[nums[0]]=nums[3]=4</code>. (<code>slow=3, fast=4</code>)</li>
<li><code>slow = nums[3]=4</code>, <code>fast = nums[nums[4]]=nums[2]=3</code>. (<code>slow=4, fast=3</code>)</li>
<li><code>slow = nums[4]=2</code>, <code>fast = nums[nums[3]]=nums[4]=2</code>. (<code>slow=2, fast=2</code>)<br>
相遇于索引 <code>M=2</code>。</li>
</ol>
<p>阶段 2：<code>slow=0, fast=2</code> (相遇点)</p>
<ol>
<li><code>slow = nums[0]=3</code>, <code>fast = nums[2]=3</code>. (<code>slow=3, fast=3</code>)<br>
相遇于索引 <code>3</code>。返回 <code>slow</code>，即 <code>3</code>。这正是重复的数字。</li>
</ol>
<h3 id="实现细节">实现细节</h3>
<p>Go 语言代码直接实现了上述 Floyd 判圈算法。</p>
<ol>
<li>
<p><strong>初始化</strong>:<br>
<code>slow, fast := 0, 0</code><br>
两个指针都从索引 <code>0</code> 开始。</p>
</li>
<li>
<p><strong>阶段 1: 找到相遇点</strong>:<br>
<code>for slow, fast = nums[slow], nums[nums[fast]]; slow != fast; slow, fast = nums[slow], nums[nums[fast]] &#123; &#125;</code></p>
<ul>
<li>这个 <code>for</code> 循环的结构比较紧凑：
<ul>
<li><strong>初始化部分</strong> (仅执行一次): <code>slow</code> 被赋值为 <code>nums[0]</code>，<code>fast</code> 被赋值为 <code>nums[nums[0]]</code>。</li>
<li><strong>条件判断部分</strong>: 检查 <code>slow != fast</code>。</li>
<li><strong>循环体</strong>: 为空。</li>
<li><strong>迭代后部分</strong>: <code>slow</code> 更新为 <code>nums[当前slow]</code>，<code>fast</code> 更新为 <code>nums[nums[当前fast]]</code>。然后回到条件判断。</li>
</ul>
</li>
<li>循环会一直执行，直到 <code>slow</code> 和 <code>fast</code> 指向相同的索引。</li>
</ul>
</li>
<li>
<p><strong>阶段 2: 找到环的入口 (即重复数字)</strong>:<br>
<code>slow = 0</code></p>
<ul>
<li><code>slow</code> 指针被重置回起始索引 <code>0</code>。<code>fast</code> 指针保持在阶段 1 的相遇点。<br>
<code>for slow != fast &#123;</code><br>
<code>  slow = nums[slow]</code><br>
<code>  fast = nums[fast]</code><br>
<code>&#125;</code></li>
<li>此时，<code>slow</code> 和 <code>fast</code> 都以每次一步的速度前进。</li>
<li>当它们再次相遇时，相遇点（一个索引值）就是环的入口，这个索引值也等于重复的数字。</li>
</ul>
</li>
<li>
<p><strong>返回值</strong>:<br>
<code>return slow</code></p>
<ul>
<li>返回它们在阶段 2 相遇时的索引 <code>slow</code>。</li>
</ul>
</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<p>这里是题目中提供的 Go 语言解决方案：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=287 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [287] 寻找重复数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 阶段 1: 找到快慢指针的相遇点。</span></span><br><span class="line">	<span class="comment">// &#x27;slow&#x27; 和 &#x27;fast&#x27; 变量代表数组中的索引。</span></span><br><span class="line">	<span class="comment">// 初始时，它们都指向索引 0。</span></span><br><span class="line">	slow, fast := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个 for 循环的结构：</span></span><br><span class="line">	<span class="comment">// 1. 初始化子句 (只执行一次): slow 指向 nums[0], fast 指向 nums[nums[0]]。</span></span><br><span class="line">	<span class="comment">// 2. 条件子句: slow != fast。如果为真，执行循环体（在此为空），然后执行迭代后子句。</span></span><br><span class="line">	<span class="comment">// 3. 迭代后子句: slow 更新为 nums[当前slow], fast 更新为 nums[nums[当前fast]]。</span></span><br><span class="line">	<span class="comment">// 这个循环会持续直到 slow 和 fast 相遇。</span></span><br><span class="line">	<span class="keyword">for</span> slow, fast = nums[slow], nums[nums[fast]]; slow != fast; slow, fast = nums[slow], nums[nums[fast]] &#123;</span><br><span class="line">		<span class="comment">// 循环体为空，所有移动逻辑都在 for 语句的头部完成。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阶段 2: 找到环的入口。</span></span><br><span class="line">	<span class="comment">// 将 slow 指针重置回数组的起始位置 (索引 0)。</span></span><br><span class="line">	<span class="comment">// fast 指针保持在阶段 1 中相遇的位置。</span></span><br><span class="line">	slow = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">		slow = nums[slow] <span class="comment">// slow 从起点开始，每次前进一步。</span></span><br><span class="line">		fast = nums[fast] <span class="comment">// fast 从相遇点开始，每次前进一步。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当 slow 和 fast 再次相遇时，它们所在的索引就是环的入口，</span></span><br><span class="line">	<span class="comment">// 这个索引值也正是题目所求的重复数字。</span></span><br><span class="line">	<span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h3 id="方法比较">方法比较</h3>
<p>本题主要考察的就是这种 O(1) 空间复杂度的解法。其他可能想到的方法包括：</p>
<ul>
<li><strong>哈希表/集合</strong>：遍历数组，将数字存入哈希表。如果数字已存在于哈希表中，则说明找到了重复数。
<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n) (不符合题目对空间复杂度的要求)</li>
</ul>
</li>
<li><strong>排序</strong>：对数组进行排序，然后遍历查找相邻且相等的元素。
<ul>
<li>时间复杂度: O(n log n) (取决于所用排序算法)</li>
<li>空间复杂度: O(1) 或 O(n) (取决于排序算法是否为原地排序，且题目要求不能修改原数组)</li>
</ul>
</li>
<li><strong>暴力法</strong>：使用双重循环，比较数组中每一对数字是否相等。
<ul>
<li>时间复杂度: O(n^2) (可能因效率过低而超时，不符合题目对时间复杂度的要求)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方面</th>
<th>快慢指针 (Floyd 算法)</th>
<th>哈希表</th>
<th>排序 + 遍历</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1) 若原地排序*</td>
</tr>
<tr>
<td>修改原数组</td>
<td>否</td>
<td>否</td>
<td>是* / 否 (若复制数组)</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★ (符合所有要求)</td>
<td>★★☆☆☆ (空间不符)</td>
<td>★★☆☆☆ (修改或时间不优)</td>
</tr>
</tbody>
</table>
<p><em>注：若要达到 O(1) 空间复杂度，排序通常需要原地进行，这会修改原数组。如果不修改原数组（例如先复制再排序），则空间复杂度为 O(n)。</em></p>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>
<p><strong>时间复杂度</strong>: O(n)</p>
<ul>
<li>阶段 1 (找到相遇点): 慢指针 <code>slow</code> 最多走 <code>n</code> 步就会进入环。一旦进入环，快指针 <code>fast</code> 最多在环内比慢指针多走一圈的距离就能追上它。整个过程中，数组中的每个元素（作为索引）最多被访问常数次。因此，此阶段的时间复杂度是 O(n)。</li>
<li>阶段 2 (找到环的入口): <code>slow</code> 从数组头部开始，<code>fast</code> 从相遇点开始，它们都走 <code>L</code> 步（其中 <code>L</code> 是从数组头部到环入口的路径长度）。由于 <code>L &lt;= n</code>，此阶段的时间复杂度也是 O(n)。</li>
<li>总时间复杂度为 O(n) + O(n) = O(n)。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>: O(1)</p>
<ul>
<li>算法仅使用了 <code>slow</code> 和 <code>fast</code> 两个额外的整型变量来存储索引。因此，空间复杂度是 O(1)，完全符合题目的要求。</li>
</ul>
</li>
</ul>
<h3 id="关键收获">关键收获</h3>
<ul>
<li><strong>问题转化能力</strong>: 将看似不相关的数组查找问题转化为链表判环问题，是解决本题的核心技巧。这种抽象和建模能力在解决复杂算法问题时至关重要。</li>
<li><strong>Floyd 判圈算法 (龟兔赛跑算法)</strong>:
<ul>
<li>该算法不仅能有效地检测链表中是否存在环，还能精确地定位环的入口点。</li>
<li>它是一种应用广泛的算法，例如在检测单向链表中的循环、某些密码学应用中的序列分析等场景都有应用。</li>
</ul>
</li>
<li><strong>数学原理的理解</strong>: 深刻理解为什么在第二阶段，一个指针从起点出发，另一个指针从相遇点出发，两者同步前进最终会在环的入口相遇，这需要一定的数学推导（如前文“解题思路”部分所述）。
<ul>
<li>核心等式：<code>L = k*C - x</code> (其中 <code>L</code> 是从起点到环入口的距离，<code>C</code> 是环的长度，<code>x</code> 是从环入口到快慢指针首次相遇点的距离)。这个关系确保了第二阶段两个指针会在环入口处相遇。</li>
</ul>
</li>
<li><strong>关注题目约束</strong>: 题目中的限制条件，如“不能修改原数组”、“只能使用 O(1) 的额外空间”，是引导我们找到正确解法方向的关键线索。</li>
</ul>
<p>这道题目是一道非常经典的面试题，深入理解其解法、背后的数学原理以及如何将问题进行抽象转换，对于提升算法思维和解决问题的能力大有裨益。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>链表判环</tag>
        <tag>Floyd算法</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 31 - 下一个排列 (Next Permutation)</title>
    <url>/2025/05/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode-31-next-permutation/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个整数序列，找出其下一个字典序中更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>1,2,3</code> → <code>1,3,2</code></li>
<li><code>3,2,1</code> → <code>1,2,3</code></li>
<li><code>1,1,5</code> → <code>1,5,1</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>&quot;下一个排列&quot;的算法思想可以概括为以下几个步骤：</p>
<ol>
<li>
<p><strong>从右向左查找&quot;较小数&quot;</strong>：<br>
从数组的末尾开始向前扫描，找到第一个满足 nums[i-1] &lt; nums[i] 的索引 i-1。这个 nums[i-1] 就是我们寻找的&quot;较小数&quot;。为什么是 nums[i-1] 呢？因为我们要尽可能地保持高位的数字不变，只在较低位进行调整，以得到字典序&quot;下一个&quot;更大的排列。找到这个 nums[i-1] 后，意味着从 nums[i] 开始到数组末尾的这部分是降序的（或者说是非升序的）。</p>
</li>
<li>
<p><strong>处理特殊情况：已经是最大排列</strong>：<br>
如果在步骤 1 中没有找到这样的 i-1（也就是说，left 仍然是初始值 -1），这意味着整个数组是从大到小排列的（降序）。这种情况下，它已经是字典序最大的排列了。根据题目要求，此时应该将其变为最小的排列，也就是将整个数组反转（变为升序）。</p>
</li>
<li>
<p><strong>从右向左查找&quot;较大数&quot;</strong>：<br>
如果找到了&quot;较小数&quot; nums[left]，接下来我们需要在 nums[left] 右边的部分（即从索引 left+1 到数组末尾）找到一个&quot;较大数&quot;。这个&quot;较大数&quot; nums[right] 必须满足 nums[right] &gt; nums[left]，并且在所有满足条件的数中，它应该是最小的那个，但为了方便实现，我们可以从右向左找第一个大于 nums[left] 的数，这样就能保证 nums[right] 尽可能小且位置靠右，从而使得交换后对后续升序排列的影响最小。</p>
</li>
<li>
<p><strong>交换&quot;较小数&quot;和&quot;较大数&quot;</strong>：<br>
将步骤 1 中找到的&quot;较小数&quot; nums[left] 与步骤 3 中找到的&quot;较大数&quot; nums[right] 进行交换。</p>
</li>
<li>
<p><strong>反转&quot;较小数&quot;之后的部分</strong>：<br>
交换完成后，数组 nums 中索引 left 右边的部分（即从 left+1 到末尾）仍然是降序的。为了得到字典序中紧邻的下一个排列，我们需要将这部分子数组反转，使其变为升序。这样，整个数组就构成了下一个更大的排列。</p>
</li>
</ol>
<p>举个例子 <code>[1, 3, 2]</code>：</p>
<ol>
<li>从右往左，<code>2 &lt; 3</code> 不满足，<code>3 &gt; 1</code>，所以 nums[i-1] 是 <code>1</code> (<code>left = 0</code>)。</li>
<li><code>left</code> 不是 <code>-1</code>。</li>
<li>在 <code>1</code> 的右边 <code>[3, 2]</code> 中，从右往左找第一个大于 <code>1</code> 的数，是 <code>2</code> (<code>right = 2</code>)。</li>
<li>交换 nums[0] 和 nums[2]：<code>[2, 3, 1]</code>。</li>
<li>反转 nums[left+1:] 即 <code>[3, 1]</code> 变为 <code>[1, 3]</code>。最终结果是 <code>[2, 1, 3]</code>。</li>
</ol>
<p>再举个例子 <code>[4, 5, 2, 6, 3, 1]</code>：</p>
<ol>
<li>从右往左：<code>1 &lt; 3</code>，<code>3 &lt; 6</code>，<code>6 &gt; 2</code>。所以 nums[i-1] 是 <code>2</code> (<code>left = 2</code>)。</li>
<li><code>left</code> 不是 <code>-1</code>。</li>
<li>在 <code>2</code> 的右边 <code>[6, 3, 1]</code> 中，从右往左找第一个大于 <code>2</code> 的数：<code>1 &lt; 2</code> (否)，<code>3 &gt; 2</code> (是)。所以 nums[right] 是 <code>3</code> (<code>right = 4</code>)。</li>
<li>交换 nums[left] (<code>2</code>) 和 nums[right] (<code>3</code>)：数组变为 <code>[4, 5, 3, 6, 2, 1]</code>。</li>
<li>反转 nums[left+1:] 即 <code>[6, 2, 1]</code>。反转后变为 <code>[1, 2, 6]</code>。</li>
<li>最终结果：<code>[4, 5, 3, 1, 2, 6]</code>。</li>
</ol>
<h3 id="为什么这个方法是正确的？（通俗解释）">为什么这个方法是正确的？（通俗解释）</h3>
<p>您可以将寻找&quot;下一个排列&quot;的过程想象成给一串数字&quot;升级&quot;，目标是找到一个比当前数字串&quot;大一点点&quot;的新数字串，而且这个&quot;大一点点&quot;的幅度要尽可能小。</p>
<p>想象一下我们有一串数字，比如 <code>[4, 5, 2, 6, 3, 1]</code>，我们要找到比它稍微大一点点的下一个排列。</p>
<ol>
<li>
<p><strong>从右往左，找到第一个&quot;可以变得更大&quot;的数字（我们的&quot;拐点&quot;）</strong></p>
<ul>
<li>我们从最右边的数字开始看。<code>1</code> 没法变得更大（除非前面的数字变了）。<code>3</code> 比 <code>1</code> 大，但 <code>3,1</code> 这个组合已经是 <code>3</code> 开头的最大组合了。<code>6,3,1</code> 也是 <code>6</code> 开头的最大组合。</li>
<li>直到我们看到 <code>2</code> 和 <code>6</code> (<code>nums[i-1]=2</code>, <code>nums[i]=6</code>)。啊哈！这里的 <code>2</code> 是一个&quot;拐点&quot;，因为 <code>2 &lt; 6</code>。这意味着，如果我们把 <code>2</code> 换成一个比它稍微大一点的数，并且让 <code>2</code> 后面的数字排列得尽可能小，我们可能就能找到答案。</li>
<li>这个&quot;拐点&quot;就是我们代码中的 <code>nums[left]</code> (即数字 <code>2</code>)。它左边的 <code>[4, 5]</code> 我们暂时不动，因为改动它们会使得数字串的&quot;升级&quot;幅度过大。我们希望改动尽可能靠右。</li>
<li><strong>特殊情况</strong>：如果一路从右到左都是降序的，比如 <code>[6, 5, 4, 3, 2, 1]</code>，那就说明这已经是&quot;顶级配置&quot;，不可能有比它更大的了。此时，它的&quot;下一个&quot;就是最小的排列 <code>[1, 2, 3, 4, 5, 6]</code>。</li>
</ul>
</li>
<li>
<p><strong>在&quot;拐点&quot;右边，找到一个比它&quot;大一点点&quot;的数字来替换它</strong></p>
<ul>
<li>现在我们盯住了&quot;拐点&quot; <code>2</code>。在它右边的 <code>[6, 3, 1]</code> 中，我们要找一个比 <code>2</code> 大，但又尽可能小的数字。</li>
<li><code>6</code> 比 <code>2</code> 大，<code>3</code> 比 <code>2</code> 大，<code>1</code> 比 <code>2</code> 小。在 <code>6</code> 和 <code>3</code> 中，<code>3</code> 是那个&quot;大一点点&quot;的数字。这个就是我们代码中的 <code>nums[right]</code>。</li>
<li>为什么要找&quot;大一点点&quot;的？因为我们要的只是&quot;下一个&quot;排列，不是随便一个更大的排列。</li>
</ul>
</li>
<li>
<p><strong>交换这两个数字</strong></p>
<ul>
<li>我们把 <code>2</code> 和 <code>3</code> 交换位置。原序列 <code>[4, 5, 2, 6, 3, 1]</code> 变为 <code>[4, 5, 3, 6, 2, 1]</code>。</li>
<li>现在，<code>[4, 5, 3, ...]</code> 肯定比 <code>[4, 5, 2, ...]</code> 要大了。</li>
</ul>
</li>
<li>
<p><strong>将&quot;拐点&quot;之后的部分重新排列成最小的顺序</strong></p>
<ul>
<li>交换后，序列是 <code>[4, 5, 3, 6, 2, 1]</code>。&quot;拐点&quot;之后的部分是 <code>[6, 2, 1]</code>。</li>
<li>为了确保我们得到的是<strong>紧邻</strong>原序列的下一个排列（而不是随便一个更大的排列），我们需要让 <code>[6, 2, 1]</code> 这部分变成它能形成的最小排列。</li>
<li>一个（大致）降序的序列（如 <code>[6, 2, 1]</code>）如何变成最小的排列呢？直接反转它！<code>[6, 2, 1]</code> 反转后变成 <code>[1, 2, 6]</code>。</li>
<li>所以，最终的下一个排列就是 <code>[4, 5, 3, 1, 2, 6]</code>。</li>
</ul>
</li>
</ol>
<p><strong>总结一下这个&quot;升级&quot;策略：</strong></p>
<ul>
<li><strong>找对地方升级</strong>：从右边找到第一个能让数字串&quot;增值&quot;的&quot;拐点&quot;。</li>
<li><strong>小幅度升级</strong>：用一个只比&quot;拐点&quot;大一点点的数字替换它。</li>
<li><strong>后续部队最小化</strong>：让&quot;拐点&quot;后面的数字排列成最小的顺序，确保整体&quot;升级&quot;幅度最小。</li>
</ul>
<p>这样一套操作下来，就能保证我们找到的是字典序中，刚好比原来大一点点的那个排列。</p>
<h2 id="代码实现">代码实现</h2>
<p>以下是优化后的 Go 语言代码实现，并附有详细注释：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 如果数组长度小于等于1，则无需操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 1: 从右向左找到第一个满足 nums[i-1] &lt; nums[i] 的 i-1</span></span><br><span class="line">    <span class="comment">// 这个 nums[i-1] 就是我们要找的&quot;较小数&quot;</span></span><br><span class="line">    <span class="comment">// 它的右边部分 (nums[i] 到 nums[n-1]) 是降序的</span></span><br><span class="line">    left := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i<span class="number">-1</span>] &lt; nums[i] &#123;</span><br><span class="line">            left = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 如果 left == -1，说明整个数组是降序的，已经是最大的排列</span></span><br><span class="line">    <span class="comment">// 此时，下一个排列就是最小的排列，即整个数组反转</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">-1</span> &#123;</span><br><span class="line">        reverse(nums)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3: 从右向左找到第一个满足 nums[j] &gt; nums[left] 的 j</span></span><br><span class="line">    <span class="comment">// 这个 nums[j] 就是我们要找的&quot;较大数&quot;</span></span><br><span class="line">    <span class="comment">// 因为 nums[left+1:] 是降序的，所以从右往左第一个大于 nums[left] 的数</span></span><br><span class="line">    <span class="comment">// 就是 nums[left+1:] 中大于 nums[left] 的最小的数</span></span><br><span class="line">    right := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; left; i-- &#123; <span class="comment">// 注意这里的循环条件是 i &gt; left</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[left] &#123;</span><br><span class="line">            right = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4: 交换 nums[left] 和 nums[right]</span></span><br><span class="line">    nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 5: 反转 nums[left+1:] 部分，使其变为升序</span></span><br><span class="line">    <span class="comment">// 因为交换后，nums[left+1:] 部分仍然是降序的</span></span><br><span class="line">    <span class="comment">// 将其反转可以得到这部分数的最小排列</span></span><br><span class="line">    reverse(nums[left+<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse 函数用于反转一个整数切片 (原地操作)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度</strong>: $O(N)$</p>
<ul>
<li>查找 <code>left</code> 最多需要遍历一次数组，复杂度为 $O(N)$。</li>
<li>查找 <code>right</code> 最多需要遍历一次数组（从 <code>n-1</code>到 <code>left+1</code>），复杂度为 $O(N)$。</li>
<li><code>reverse</code> 函数反转数组的一部分，最多反转整个数组，复杂度为 $O(N)$。</li>
<li>因此，总的时间复杂度是 $O(N)$。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>: $O(1)$</p>
<ul>
<li>算法是在原地修改数组，只使用了几个额外的变量来存储索引，所以空间复杂度是常数级别的。</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li>理解&quot;下一个字典序排列&quot;的含义是关键。目标是找到比当前排列&quot;大一点点&quot;的下一个排列。</li>
<li>算法的核心在于从右边找到一个&quot;拐点&quot;（较小数），然后用右边一个恰好比它大的数（较大数）替换它，并重排剩余部分为最小序列。</li>
<li>这是一个经典的数组操作问题，通过巧妙的查找和反转操作，可以在线性时间和常数空间内解决。</li>
<li>注意边界条件，例如数组本身就是最大排列（完全降序）的情况。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：整数集合详解</title>
    <url>/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>整数集合（intset）是 Redis 中的一个重要底层数据结构，主要用于优化 Set 数据类型在特定场景下的内存使用效率。当一个 Set 集合中的元素都是整数且元素数量较少时，Redis 会使用整数集合而非哈希表来存储数据，从而大幅降低内存占用。整数集合的设计体现了 Redis 对内存效率的极致追求，也是理解 Redis 内存优化策略的典型案例。</p>
<h2 id="核心概念">核心概念</h2>
<h3 id="整数集合的定义">整数集合的定义</h3>
<p>整数集合是 Redis Set 对象的底层实现之一。当一个 Set 对象同时满足以下两个条件时，Redis 会选择使用整数集合作为其底层实现：</p>
<ol>
<li>集合中的元素都是整数值</li>
<li>集合的元素数量不超过一定阈值（默认配置下为 512 个元素）</li>
</ol>
<h3 id="整数集合结构设计">整数集合结构设计</h3>
<p>整数集合本质上是一块连续内存空间，它的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式，决定整数的类型和长度</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组，实际类型取决于encoding</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>虽然 contents 被声明为 int8_t 类型的数组，但实际上它存储的元素类型由 encoding 属性决定：</p>
<ul>
<li><code>INTSET_ENC_INT16</code>：contents 作为 int16_t 类型数组，每个元素占 2 字节</li>
<li><code>INTSET_ENC_INT32</code>：contents 作为 int32_t 类型数组，每个元素占 4 字节</li>
<li><code>INTSET_ENC_INT64</code>：contents 作为 int64_t 类型数组，每个元素占 8 字节</li>
</ul>
<h2 id="实现机制">实现机制</h2>
<h3 id="整数集合的升级操作">整数集合的升级操作</h3>
<p>整数集合的一个关键特性是<strong>升级机制</strong>。当向整数集合中添加一个新元素，如果该元素的类型比集合现有所有元素的类型都要长时，整数集合会进行升级操作：</p>
<ol>
<li>根据新元素的类型扩展 contents 数组的空间</li>
<li>将现有元素转换为新类型并重新排列到正确的位置</li>
<li>将新元素添加到集合中并保持有序性</li>
</ol>
<p>例如，当一个存储 int16_t 类型元素的整数集合需要添加一个 int32_t 类型的新元素时：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/1747897381977.png" alt="升级前的整数集合"></p>
<p>假设要添加的新元素是 65535（需要 int32_t 类型存储），首先需要扩展 contents 数组空间：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/1747897388714.png" alt="扩容后的空间"></p>
<p>然后将原有的三个 int16_t 类型元素转换为 int32_t 类型，并放置到正确的位置：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/1747897403523.png" alt="元素重排后的整数集合"></p>
<h3 id="升级的好处与限制">升级的好处与限制</h3>
<p>整数集合升级的主要好处是<strong>节省内存资源</strong>。如果所有元素都能用较小的整数类型表示，就不必为所有元素都分配最大类型的空间。只有在确实需要更大类型时，整数集合才会进行升级。</p>
<p>然而，整数集合<strong>不支持降级操作</strong>。一旦升级到更大的整数类型，即使删除了所有需要该类型的元素，整数集合也不会回退到较小的类型。这是出于性能考虑的设计决策，避免了频繁的内存重分配操作。</p>
<h2 id="使用方法">使用方法</h2>
<p>Redis 自动管理整数集合的使用，用户无需直接操作。当使用 Set 相关命令且满足使用整数集合的条件时，Redis 会自动选择整数集合作为底层实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个包含整数的集合</span></span><br><span class="line">SADD numbers 1 2 3 4 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看底层实现（在小集合且都是整数时会是intset）</span></span><br><span class="line">OBJECT ENCODING numbers  <span class="comment"># 返回 &quot;intset&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个非整数元素会导致转换为哈希表实现</span></span><br><span class="line">SADD numbers <span class="string">&quot;a&quot;</span></span><br><span class="line">OBJECT ENCODING numbers  <span class="comment"># 返回 &quot;hashtable&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="整数集合的操作复杂度">整数集合的操作复杂度</h2>
<p>整数集合的主要操作时间复杂度如下：</p>
<ul>
<li><strong>查找元素</strong>：O(log N)，使用二分查找</li>
<li><strong>添加元素</strong>：O(N)，可能需要移动大量元素</li>
<li><strong>删除元素</strong>：O(N)，需要移动被删除元素之后的所有元素</li>
</ul>
<p>整数集合虽然节省内存，但在添加和删除操作上并不如哈希表高效，这也是为什么它只用于小型集合的原因。</p>
<h2 id="常见问题与解决方案">常见问题与解决方案</h2>
<h3 id="问题：整数集合何时会转换为哈希表？">问题：整数集合何时会转换为哈希表？</h3>
<p><strong>解决方案</strong>：在以下情况下，Redis 会将整数集合转换为哈希表：</p>
<ol>
<li>添加了非整数元素</li>
<li>元素数量超过了设定阈值（默认为 512）</li>
</ol>
<h3 id="问题：为什么整数集合不支持降级？">问题：为什么整数集合不支持降级？</h3>
<p><strong>解决方案</strong>：不支持降级是出于性能考虑。降级操作需要重新分配内存并移动元素，这些操作成本较高，而且可能会因为反复的升级和降级导致性能波动。</p>
<h2 id="最佳实践">最佳实践</h2>
<ol>
<li><strong>小型整数集合的优势</strong>：当确定 Set 只包含少量整数时，可以放心使用，Redis 会自动优化内存使用</li>
<li><strong>避免混合类型</strong>：如果要利用整数集合的内存优化，确保集合中只存储整数值</li>
<li><strong>控制集合大小</strong>：当整数集合元素数量超过阈值后，会转换为哈希表，失去内存优化的好处</li>
</ol>
<h2 id="面试要点">面试要点</h2>
<ol>
<li><strong>整数集合的定义与使用场景</strong>：用于优化只包含整数且元素数量较少的 Set 集合</li>
<li><strong>升级机制</strong>：当添加更大类型的整数时如何进行升级，以及升级的具体步骤</li>
<li><strong>不支持降级的原因</strong>：性能考虑，避免频繁的内存重分配</li>
<li><strong>整数集合的优缺点</strong>：
<ul>
<li>优点：内存效率高，适合存储小型整数集合</li>
<li>缺点：添加和删除操作的时间复杂度为 O(N)，不如哈希表</li>
</ul>
</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://redisbook.com/">Redis 设计与实现</a></li>
<li><a href="https://redis.io/documentation">Redis 官方文档</a></li>
<li><a href="http://zhangtielei.com/posts/blog-redis-dict.html">Redis 内部数据结构详解</a></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
        <tag>整数集合</tag>
        <tag>intset</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：哈希表详解</title>
    <url>/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="哈希表">哈希表</h2>
<p>哈希表是一种用于存储键值对（key-value）的高效数据结构。在哈希表中，每个键都是唯一的，通过键可以快速查找、更新或删除对应的值。</p>
<p>Redis 的 Hash 对象有两种底层实现：一种是本文将要详细介绍的哈希表，另一种是压缩列表（在最新的 Redis 版本中已被 listpack 替代）。</p>
<p>哈希表的最大优势在于其<strong>时间复杂度为 O(1) 的查询效率</strong>。实现原理是将键通过哈希函数计算得到哈希值，然后通过这个哈希值定位到哈希表（本质是数组）中的具体位置，从而实现快速访问数据。</p>
<p>然而，当哈希表大小固定而数据量不断增加时，<strong>哈希冲突</strong>的概率会显著提高，这会影响查询效率。为解决这一问题，Redis 采用了「链式哈希」和「rehash」两种关键机制，下面将详细介绍。</p>
<h3 id="哈希表结构设计">哈希表结构设计</h3>
<p>Redis 中哈希表的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>从结构体定义可以看出，哈希表本质上是一个数组（<code>dictEntry **table</code>），数组的每个元素都是指向哈希表节点（<code>dictEntry</code>）的指针。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/1747896893898.png" alt="Redis哈希表结构示意图"></p>
<p>哈希表节点的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//键值对中的键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//键值对中的值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p><code>dictEntry</code> 结构不仅包含指向键和值的指针，还包含指向下一个哈希表节点的指针。这个 <code>next</code> 指针使得多个哈希值相同的键值对能够链接成链表，从而解决哈希冲突问题，这就是链式哈希的实现基础。</p>
<p>值得注意的是，<code>dictEntry</code> 结构中的值使用了联合体（<code>union</code>）定义，这意味着值可以是指向实际数据的指针，也可以直接是 64 位整数（有符号或无符号）或双精度浮点数。这种设计能够节省内存空间——当值为整数或浮点数时，可以直接内嵌在 <code>dictEntry</code> 结构中，无需额外的指针引用，从而减少内存开销。</p>
<h3 id="哈希冲突">哈希冲突</h3>
<p>哈希表实际上是一个数组，数组中的每个元素称为哈希桶。键值对在哈希表中的存储位置是通过以下步骤确定的：</p>
<ol>
<li>键通过哈希函数计算得到哈希值</li>
<li>将哈希值与哈希表大小进行取模运算（哈希值 % 哈希表大小）</li>
<li>取模的结果就是该键值对在哈希表数组中的索引位置</li>
</ol>
<p>当两个或多个不同的键经过上述计算后得到相同的索引位置时，就发生了哈希冲突。</p>
<p>例如，假设有一个包含 8 个哈希桶的哈希表。如果 key1 和 key9 通过哈希计算后都映射到哈希桶 1，那么这两个键就发生了哈希冲突，如下图所示：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/1747896904751.png" alt="哈希冲突示例图"></p>
<h3 id="链式哈希">链式哈希</h3>
<p>为了解决哈希冲突，Redis 采用了「链式哈希」（chain hashing）技术。</p>
<p>链式哈希的原理是：当多个键映射到同一个哈希桶时，这些键值对会通过 <code>next</code> 指针连接成一个单向链表。这样，即使发生哈希冲突，也能通过遍历链表找到目标键值对。</p>
<p>以前面的例子为例，当 key1 和 key9 都映射到哈希桶 1 时，它们会形成如下图所示的链表结构：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/1747896913213.png" alt="链式哈希解决冲突示例图"></p>
<p>然而，链式哈希也有其局限性。随着链表长度增加，在链表中查找特定键的时间复杂度会从 O(1) 退化为 O(n)，这会显著降低查询效率。要解决这个问题，需要通过 rehash 操作来扩展哈希表的大小，减少哈希冲突的概率。</p>
<h3 id="rehash-机制">rehash 机制</h3>
<p>在前面介绍哈希表结构时，我们看到了 Redis 使用 <code>dictht</code> 结构体表示哈希表。但在实际使用中，Redis 定义了一个包含两个哈希表的 <code>dict</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//两个哈希表，交替使用，用于 rehash 操作</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; </span><br><span class="line">    …</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>这两个哈希表的设计目的是为了支持 rehash 操作。下图展示了包含两个哈希表的 <code>dict</code> 结构：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/1747896920473.png" alt="Redis dict结构包含两个哈希表"></p>
<p>在正常情况下，所有数据都存储在「哈希表 1」中，而「哈希表 2」并不分配空间。当需要扩展哈希表容量时，Redis 会触发 rehash 操作，该过程分为三个步骤：</p>
<ol>
<li>为「哈希表 2」分配空间，通常是「哈希表 1」容量的两倍</li>
<li>将「哈希表 1」中的所有数据重新计算哈希值并迁移到「哈希表 2」中</li>
<li>迁移完成后，释放「哈希表 1」的空间，将「哈希表 2」设置为「哈希表 1」，并在「哈希表 2」位置创建一个新的空哈希表，为下一次 rehash 做准备</li>
</ol>
<p>rehash 过程如下图所示：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/1747896929113.png" alt="rehash过程示意图"></p>
<p>然而，这种一次性迁移的方式存在问题：当「哈希表 1」中的数据量非常大时，一次性迁移会涉及大量数据拷贝，可能导致 Redis 服务暂时阻塞，无法处理其他请求，这对于要求高性能的 Redis 服务是不可接受的。</p>
<h3 id="渐进式-rehash">渐进式 rehash</h3>
<p>为了避免 rehash 过程中的服务阻塞，Redis 实现了「渐进式 rehash」机制，将数据迁移工作分散到多次操作中完成。</p>
<p>渐进式 rehash 的步骤如下：</p>
<ol>
<li>为「哈希表 2」分配空间</li>
<li>在 rehash 进行期间，每次对哈希表执行增删改查操作时，除了完成请求的操作外，还会顺带将「哈希表 1」中一部分数据迁移到「哈希表 2」</li>
<li>随着客户端请求的不断处理，「哈希表 1」的数据会逐渐迁移完毕，最终完成整个 rehash 过程</li>
</ol>
<p>这种方式巧妙地将大量数据迁移的开销分摊到了多次操作中，避免了一次性 rehash 可能导致的服务阻塞。</p>
<p>在渐进式 rehash 期间，两个哈希表同时有效，数据操作会按照以下规则进行：</p>
<ul>
<li>查找操作：先在「哈希表 1」中查找，如果未找到，再到「哈希表 2」中查找</li>
<li>新增操作：只在「哈希表 2」中进行，确保「哈希表 1」的数据只减不增</li>
<li>更新和删除操作：在两个哈希表中都可能执行，取决于要操作的键所在的哈希表</li>
</ul>
<p>随着 rehash 操作的进行，「哈希表 1」中的数据会逐渐减少，最终变为空表，此时整个 rehash 过程完成。</p>
<h3 id="rehash-触发条件">rehash 触发条件</h3>
<p>rehash 的触发与「负载因子」(load factor) 密切相关。负载因子计算公式为：</p>
<p>$$<br>
负载因子 = 哈希表已保存节点数量 / 哈希表大小<br>
$$</p>
<p>Redis 触发 rehash 操作的条件主要有两个：</p>
<ol>
<li>
<p><strong>当负载因子大于等于 1，且 Redis 没有在执行 RDB 快照（bgsave）或 AOF 重写（bgrewriteaof）时</strong>，触发 rehash 操作。这是一个较为宽松的条件，表示哈希表已经装满，但系统资源尚有空闲，可以进行 rehash。</p>
</li>
<li>
<p><strong>当负载因子大于等于 5 时</strong>，无论当前是否在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。这是一个较为严格的条件，表示哈希冲突已经非常严重，必须立即扩容，否则会严重影响性能。</p>
</li>
</ol>
<p>通过这种机制，Redis 在保证性能的同时，也能够有效管理内存资源，达到性能与资源利用的平衡。</p>
<h2 id="总结">总结</h2>
<p>Redis 哈希表是一种高效的数据结构，通过精心设计实现了 O(1) 时间复杂度的数据访问。其核心机制包括：</p>
<ol>
<li><strong>链式哈希</strong>：通过将具有相同哈希值的键值对链接成链表，有效解决了哈希冲突问题</li>
<li><strong>rehash 机制</strong>：当哈希表负载过高时，通过扩容并重新分布键值对，降低哈希冲突概率</li>
<li><strong>渐进式 rehash</strong>：将数据迁移工作分散到多次操作中，避免服务阻塞，保证了 Redis 的高性能特性</li>
</ol>
<p>这些精心设计的机制使得 Redis 哈希表能够在保持高性能的同时，有效应对大规模数据存储和高并发访问的挑战，是 Redis 高性能的重要基础。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：压缩列表详解</title>
    <url>/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="压缩列表">压缩列表</h2>
<p>压缩列表（ziplist）是 Redis 为了极致优化内存使用而设计的一种数据结构。它将所有元素存储在<strong>一块连续的内存空间</strong>中，通过针对不同长度的数据进行特殊编码，从而<strong>显著节省内存</strong>。这种设计使其能够很好地利用 CPU 缓存。</p>
<p>然而，压缩列表也存在固有的缺陷：</p>
<ul>
<li><strong>查询效率</strong>: 当保存的元素过多时，查询效率会明显下降，因为查找非头尾节点需要遍历。</li>
<li><strong>更新效率</strong>: 新增或修改元素时，可能需要重新分配整个压缩列表的内存空间，极端情况下甚至可能引发**连锁更新（cascade update）**问题。</li>
</ul>
<p>因此，Redis 仅在列表对象（List）、哈希对象（Hash）、有序集合对象（Zset）包含的元素数量较少或元素值较小时，才会选择压缩列表作为其底层实现。</p>
<p>接下来，我们将深入探讨压缩列表的内部结构与运作机制。</p>
<h3 id="压缩列表结构设计">压缩列表结构设计</h3>
<p>压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构，其核心思想是<strong>空间换时间</strong>。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/1747884602034.png" alt="1747884602034"><br>
<em>图1: 压缩列表整体内存布局</em></p>
<p>压缩列表的头部包含以下几个关键字段：</p>
<ul>
<li><em><strong>zlbytes</strong></em> (4字节): 记录整个压缩列表占用的内存字节数。</li>
<li><em><strong>zltail</strong></em> (4字节): 记录压缩列表尾节点相对于起始地址的偏移量，方便快速定位尾节点。</li>
<li><em><strong>zllen</strong></em> (2字节): 记录压缩列表包含的节点数量。</li>
<li><em><strong>zlend</strong></em> (1字节): 特殊标记，固定值为 <code>0xFF</code> (十进制255)，表示压缩列表的结束。</li>
</ul>
<p>通过这些头部字段，我们可以 O(1) 复杂度定位首尾节点。但<strong>查找其他节点时，则需要从头或尾开始逐个遍历，时间复杂度为 O(N)</strong>。因此，压缩列表不适合存储大量元素。</p>
<p>压缩列表中的每个节点（entry）则由以下三部分构成：</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/1747884610200.png" alt="1747884610200"><br>
<em>图2: 压缩列表节点结构</em></p>
<ul>
<li><em><strong>prevlen</strong></em>: 记录前一个节点的长度。这个字段使得压缩列表可以从后向前遍历。其自身占用的空间根据前一个节点的实际长度动态调整（1字节或5字节）。</li>
<li><em><strong>encoding</strong></em>: 记录当前节点实际数据的类型（整数或字符串）和长度。其自身占用的空间根据数据的类型和大小动态调整。</li>
<li><em><strong>data</strong></em>: 存储节点的实际数据，其类型和长度由 <code>encoding</code> 字段决定。</li>
</ul>
<p>这种根据数据实际大小和类型动态调整 <code>prevlen</code> 和 <code>encoding</code> 字段长度的设计，是压缩列表实现<strong>极致内存优化的关键</strong>。</p>
<p>具体来说：</p>
<p><strong>prevlen 字段的长度</strong>:</p>
<ul>
<li>如果前一个节点的长度<strong>小于 254 字节</strong>，<code>prevlen</code> 字段占用 <strong>1 字节</strong>。</li>
<li>如果前一个节点的长度<strong>大于等于 254 字节</strong>，<code>prevlen</code> 字段占用 <strong>5 字节</strong> (第一个字节固定为 <code>0xFE</code>，后四个字节存储实际长度)。</li>
</ul>
<p><strong>encoding 字段的编码规则</strong>:</p>
<p><code>encoding</code> 字段会根据存储的数据是整数还是字符串，以及字符串的长度，采用不同的编码方式，其自身占用的空间可能是1字节、2字节或5字节。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/1747884619843.png" alt="1747884619843"><br>
<em>图3: encoding 字段的编码规则 (content 即 data 字段)</em></p>
<ul>
<li>若<strong>数据是整数</strong>：<code>encoding</code> 字段为 <strong>1 字节</strong>，其具体值指明了整数的类型（如int16, int32等），<code>data</code> 字段则直接存储该整数值。</li>
<li>若<strong>数据是字符串</strong>：<code>encoding</code> 字段的<strong>前几位</strong>用于标识类型和字符串长度的编码方式，<strong>后续位</strong>则存储字符串的实际长度。<code>data</code> 字段存储字符串内容。<code>encoding</code> 字段本身可能占用1、2或5字节。</li>
</ul>
<h3 id="连锁更新">连锁更新</h3>
<p>除了查询效率较低外，压缩列表还面临一个严重的问题：<strong>连锁更新</strong>。</p>
<p>当向压缩列表插入新元素或修改现有元素导致空间不足时，需要重新分配内存。如果这个操作导致某个节点的长度发生变化（例如，从小于254字节变为大于等于254字节），那么其后继节点的 <code>prevlen</code> 字段可能也需要调整大小（从1字节扩展到5字节）。这种调整可能会像多米诺骨牌一样，<strong>从被修改的节点开始，依次向后传播，导致后续多个节点的 <code>prevlen</code> 字段都需要扩展，进而引发多次内存重分配</strong>。</p>
<p><strong>连锁更新的触发条件</strong>：<br>
当一个压缩列表中存在多个连续的、长度接近254字节（例如250-253字节）的节点时，它们各自的后继节点的 <code>prevlen</code> 字段都为1字节。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/1747884628613.png" alt="1747884628613"><br>
<em>图4: 连锁更新前各节点 prevlen 为1字节</em></p>
<p>此时，若在这些节点之前插入一个长度大于等于254字节的新节点（或修改第一个节点使其长度超过253字节），会导致第一个节点的 <code>prevlen</code> 字段从1字节扩展到5字节。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/1747884636779.png" alt="1747884636779"><br>
<em>图5: 新节点导致节点e1的 prevlen 扩展</em></p>
<p>这个扩展操作使得节点e1的总长度增加，如果增加后的长度也超过了253字节，那么e1的后继节点e2原先用1字节存储的 <code>prevlen</code> 也不再足够，同样需要扩展到5字节。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/1747884655205.png" alt="1747884655205"><br>
<em>图6: 连锁更新的多米诺效应</em></p>
<p>这个过程会一直持续下去，直到遇到一个 <code>prevlen</code> 扩展后总长度仍未超过253字节的节点，或者到达列表末尾。</p>
<p><strong>连锁更新的代价是高昂的，因为它涉及到多次连续的内存空间扩展和数据迁移，会严重影响压缩列表的性能。</strong></p>
<h3 id="压缩列表的缺陷与演进">压缩列表的缺陷与演进</h3>
<p>综上所述，压缩列表的主要缺陷在于：</p>
<ul>
<li><strong>读取/查找效率低</strong>：对于非头尾节点的访问，时间复杂度为 O(N)。</li>
<li><strong>写操作代价高</strong>：插入或删除元素可能导致整个列表的内存重分配。</li>
<li><strong>连锁更新风险</strong>：在特定情况下，更新操作可能触发连锁更新，导致严重的性能抖动。</li>
</ul>
<p><strong>尽管压缩列表通过其紧凑的内存布局实现了极致的内存节省，但其性能问题，特别是连锁更新的风险，限制了其适用场景。</strong></p>
<p>因此，压缩列表通常只适用于存储节点数量不多且元素较小的场景。只要节点数量控制在一定范围内，即使发生连锁更新，其影响也是可控的。</p>
<p>为了克服压缩列表的这些不足，同时尽可能保留其节省内存的优点，Redis 在后续版本中引入了新的数据结构：</p>
<ul>
<li><strong>Quicklist</strong> (Redis 3.2 引入)：作为列表对象（List）新的底层实现，它是由多个压缩列表（ziplist）组成的双向链表。这既减少了单个压缩列表的长度，降低了连锁更新的风险和影响范围，又保留了压缩列表的内存效率。</li>
<li><strong>Listpack</strong> (Redis 5.0 引入)：设计上比压缩列表更简单，它去除了 <code>prevlen</code> 字段，转而在每个节点头部记录自己的总长度和编码类型，从而彻底避免了连锁更新问题。Listpack 主要用于替换 Hash 和 Zset 对象底层的压缩列表实现，以及在 Stream 数据类型中使用。</li>
</ul>
<p>这些演进体现了 Redis 在数据结构设计上对内存效率和性能之间的持续权衡与优化。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
        <tag>压缩列表</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：链表详解</title>
    <url>/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表">链表</h2>
<p>链表是除了数组之外，另一种广为人知的基础数据结构。</p>
<p>C 语言标准库并未内置链表，因此 Redis 实现了自定义的链表结构。</p>
<h3 id="链表节点结构设计">链表节点结构设计</h3>
<p>首先，我们来看 Redis 中「链表节点」（<code>listNode</code>）的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<p>从 <code>prev</code> 和 <code>next</code> 指针可以看出，Redis 的链表是双向链表。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/1747824009059.png" alt="Redis 双向链表节点示意图"></p>
<h3 id="链表结构设计">链表结构设计</h3>
<p>在 <code>listNode</code> 的基础上，Redis 进一步封装了 <code>list</code> 结构体来管理整个链表，以方便操作。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p><code>list</code> 结构包含了头指针 <code>head</code>、尾指针 <code>tail</code>、节点数量 <code>len</code>，以及三个函数指针：<code>dup</code> (用于复制节点值)、<code>free</code> (用于释放节点值)、<code>match</code> (用于比较节点值)。这些函数指针使得链表可以存储不同类型的数据并支持自定义操作，赋予了 Redis 链表更强的灵活性。</p>
<p>举个例子，下面是由 <code>list</code> 结构和 3 个 <code>listNode</code> 结构组成的链表。</p>
<p><img src="/2025/05/21/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/1747824019349.png" alt="Redis list 结构与链表节点关系示意图"></p>
<h3 id="链表的优势与缺陷">链表的优势与缺陷</h3>
<p>Redis 的链表实现具有以下优点：</p>
<ul>
<li>节点包含 <code>prev</code> 和 <code>next</code> 指针，构成<strong>双向无环链表</strong>。这使得获取任意节点的前驱和后继节点的时间复杂度都是 O(1)。</li>
<li>通过 <code>list</code> 结构中的 <code>head</code> 和 <code>tail</code> 指针，可以在 O(1) 时间内访问链表的头尾节点。</li>
<li><code>len</code> 属性使得获取链表长度的操作时间复杂度为 O(1)。</li>
<li>节点值通过 <code>void*</code> 指针保存，结合 <code>list</code>结构中的 <code>dup</code>、<code>free</code> 和 <code>match</code> 函数指针，实现了<strong>多态链表</strong>，可以存储不同类型的数据并自定义处理逻辑。</li>
</ul>
<p>链表也存在一些固有的缺陷：</p>
<ul>
<li>节点的内存非连续分配，这降低了 <strong>CPU 缓存的命中率</strong>，影响访问效率。相比之下，数组由于其内存连续性，能更好地利用 CPU 缓存（基于空间局部性原理）。</li>
<li>每个节点除了存储数据外，还需要额外的空间存储前后指针（<code>prev</code> 和 <code>next</code>），导致<strong>内存开销相对较大</strong>。</li>
</ul>
<p>因此，在 Redis 3.0 版本之前，当 List 对象包含的元素较少时，会采用「压缩列表」（ziplist）作为其底层实现，以节省内存并利用其内存紧凑的特性。</p>
<p>然而，压缩列表在某些场景下存在性能瓶颈（例如连锁更新）。为此，Redis 3.2 版本引入了 <code>quicklist</code>，它结合了链表和压缩列表的优点，并成为 List 对象新的底层实现。</p>
<p>后续，Redis 5.0 推出了 <code>listpack</code>，它同样是一种紧凑的序列化数据结构，旨在替代压缩列表。在较新的 Redis 版本中，<code>listpack</code> 已被用于实现 Hash 和 Zset 对象的部分底层结构，逐步取代了原先的压缩列表。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 75 - 颜色分类 (Sort Colors)</title>
    <url>/2025/05/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="问题描述">问题描述</h3>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>你必须在不使用库的 sort 函数的情况下解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<h3 id="解题思路">解题思路</h3>
<p>想象一下，我们手里有一堆混杂着红色（0）、白色（1）和蓝色（2）的珠子，目标是把它们排成红、白、蓝的顺序，而且只能在原来的位置上调整。</p>
<p>我们可以用三个&quot;标记&quot;来帮助我们：</p>
<ol>
<li><code>left</code> 标记：它指向数组最左边，表示&quot;这里应该是红色珠子（0）的地盘&quot;。所有在 <code>left</code> 左边的珠子保证都是红色的。初始时，<code>left</code> 在数组的第一个位置（索引 0）。</li>
<li><code>right</code> 标记：它指向数组最右边，表示&quot;这里应该是蓝色珠子（2）的地盘&quot;。所有在 <code>right</code> 右边的珠子保证都是蓝色的。初始时，<code>right</code> 在数组的最后一个位置。</li>
<li><code>current</code> 标记（在代码中我们用变量 <code>i</code>）：这是我们当前正在检查的珠子。我们从左到右一个一个地看这些珠子。初始时，<code>current</code> 和 <code>left</code> 一样，都在数组的第一个位置。</li>
</ol>
<p>接下来，我们开始移动 <code>current</code> 标记，检查它指向的珠子是什么颜色：</p>
<ul>
<li>
<p><strong>如果 <code>nums[current]</code> 是红色 (0)：</strong></p>
<ul>
<li>太好了！红色珠子就应该在左边。我们把它和 <code>left</code> 标记指向的珠子交换位置。</li>
<li>这样一来，<code>left</code> 标记左边的区域又多了一个确定的红色珠子，所以 <code>left</code> 向右移动一位。</li>
<li><code>current</code> 标记也向右移动一位，去看下一个珠子。因为我们是从左边换过来的，所以换到 <code>current</code> 位置的珠子不可能是蓝色（2），只可能是红色（0）或白色（1），这些都是 <code>current</code> 左边已经处理过的，所以可以直接继续。</li>
</ul>
</li>
<li>
<p><strong>如果 <code>nums[current]</code> 是蓝色 (2)：</strong></p>
<ul>
<li>蓝色珠子应该在最右边。我们把它和 <code>right</code> 标记指向的珠子交换位置。</li>
<li>这样一来，<code>right</code> 标记右边的区域又多了一个确定的蓝色珠子，所以 <code>right</code> 向左移动一位。</li>
<li><strong>重点来了：</strong> <code>current</code> 标记这次先<strong>不移动</strong>！为什么呢？因为从 <code>right</code>那边换过来的珠子颜色是不确定的（可能是红、白、蓝任何一种），我们需要在下一轮循环中重新检查一下 <code>current</code> 当前位置这个新换来的珠子是什么颜色。为了抵消 <code>for</code> 循环末尾 <code>current</code> (即 <code>i</code>)会自动增加的效果，我们会让 <code>i</code> 减 1。</li>
</ul>
</li>
<li>
<p><strong>如果 <code>nums[current]</code> 是白色 (1)：</strong></p>
<ul>
<li>白色珠子就应该在红色和蓝色之间。它现在的位置挺好，不需要动。</li>
<li><code>current</code> 标记向右移动一位，去看下一个珠子。</li>
</ul>
</li>
</ul>
<p>我们一直重复这个过程，直到 <code>current</code> 标记超过了 <code>right</code> 标记。当 <code>current &gt; right</code> 时，就说明所有的珠子都已经各就各位了！</p>
<p>这种方法很巧妙，只需要看一遍所有的珠子（时间复杂度 $O(n)$），而且不需要额外的空间来存放珠子（空间复杂度 $O(1)$）。</p>
<p>让我们通过一个例子来理解这个过程：<code>nums = [2,0,2,1,1,0]</code></p>
<p>初始状态: <code>left = 0</code>, <code>right = 5</code> (数组最后一个索引), <code>current = 0</code><br>
<code>nums = [2, 0, 2, 1, 1, 0]</code><br>
^ ^<br>
curr (i) right<br>
left</p>
<ol>
<li>
<p><code>current = 0</code>, <code>nums[0] = 2</code> (蓝色)。</p>
<ul>
<li>是蓝色！和 <code>nums[right]</code> (即 <code>nums[5]</code>, 值为 0) 交换。</li>
<li>数组变为 <code>[0, 0, 2, 1, 1, 2]</code></li>
<li><code>right</code> 左移到索引 4。</li>
<li><code>current</code> (即 <code>i</code>) 保持在 0 (通过 <code>i--</code> 实现)，因为换过来的 <code>nums[0]</code> (现在是 0) 需要重新检查。<br>
<code>nums = [0, 0, 2, 1, 1, 2]</code><br>
^ ^<br>
curr right<br>
left</li>
</ul>
</li>
<li>
<p><code>current = 0</code>, <code>nums[0] = 0</code> (红色)。</p>
<ul>
<li>是红色！和 <code>nums[left]</code> (即 <code>nums[0]</code>, 值为 0) 交换 (原地不动)。</li>
<li>数组仍为 <code>[0, 0, 2, 1, 1, 2]</code></li>
<li><code>left</code> 右移到索引 1。</li>
<li><code>current</code> (即 <code>i</code>) 右移到索引 1。<br>
<code>nums = [0, 0, 2, 1, 1, 2]</code><br>
^ ^<br>
curr right<br>
left</li>
</ul>
</li>
<li>
<p><code>current = 1</code>, <code>nums[1] = 0</code> (红色)。</p>
<ul>
<li>是红色！和 <code>nums[left]</code> (即 <code>nums[1]</code>, 值为 0) 交换 (原地不动)。</li>
<li>数组仍为 <code>[0, 0, 2, 1, 1, 2]</code></li>
<li><code>left</code> 右移到索引 2。</li>
<li><code>current</code> (即 <code>i</code>) 右移到索引 2。<br>
<code>nums = [0, 0, 2, 1, 1, 2]</code><br>
^ ^<br>
curr right<br>
left</li>
</ul>
</li>
<li>
<p><code>current = 2</code>, <code>nums[2] = 2</code> (蓝色)。</p>
<ul>
<li>是蓝色！和 <code>nums[right]</code> (即 <code>nums[4]</code>, 值为 1) 交换。</li>
<li>数组变为 <code>[0, 0, 1, 1, 2, 2]</code></li>
<li><code>right</code> 左移到索引 3。</li>
<li><code>current</code> (即 <code>i</code>) 保持在 2 (通过 <code>i--</code> 实现)，因为换过来的 <code>nums[2]</code> (现在是 1) 需要重新检查。<br>
<code>nums = [0, 0, 1, 1, 2, 2]</code><br>
^ ^<br>
curr right<br>
left</li>
</ul>
</li>
<li>
<p><code>current = 2</code>, <code>nums[2] = 1</code> (白色)。</p>
<ul>
<li>是白色！位置正确，不动。</li>
<li><code>current</code> (即 <code>i</code>) 右移到索引 3。<br>
<code>nums = [0, 0, 1, 1, 2, 2]</code><br>
^ ^<br>
curr right<br>
left</li>
</ul>
</li>
<li>
<p><code>current = 3</code>, <code>nums[3] = 1</code> (白色)。</p>
<ul>
<li>是白色！位置正确，不动。</li>
<li><code>current</code> (即 <code>i</code>) 右移到索引 4。<br>
<code>nums = [0, 0, 1, 1, 2, 2]</code><br>
^<br>
curr,right<br>
left</li>
</ul>
</li>
<li>
<p><code>current = 4</code>。此时 <code>current</code> (4) &gt; <code>right</code> (3)。循环结束。</p>
</li>
</ol>
<p>最终排序结果: <code>[0,0,1,1,2,2]</code></p>
<h3 id="实现细节">实现细节</h3>
<p>代码的逻辑和我们上面描述的&quot;珠子排序&quot;思路是完全一样的。</p>
<ul>
<li><code>left</code> 变量用来标记红色珠子（0）区域的右边界。</li>
<li><code>right</code> 变量用来标记蓝色珠子（2）区域的左边界。</li>
<li>循环变量 <code>i</code> 就是我们的 <code>current</code> 标记，它从数组开头（索引 0）一直扫描到 <code>right</code> 标记的位置。</li>
</ul>
<p>在 <code>for</code> 循环里面：</p>
<ul>
<li>如果 <code>nums[i]</code> 是 <code>0</code>（红色）：就把它跟 <code>nums[left]</code> 交换，然后 <code>left</code> 和 <code>i</code> 都向右挪一个位置。</li>
<li>如果 <code>nums[i]</code> 是 <code>2</code>（蓝色）：就把它跟 <code>nums[right]</code> 交换，然后 <code>right</code> 向左挪一个位置。<strong>特别注意：</strong> 这时候 <code>i</code> 要减 <code>1</code> (<code>i--</code>)，这是因为从 <code>right</code>那边换过来的珠子我们还没看过是啥颜色，通过 <code>i--</code> 可以抵消掉 <code>for</code> 循环自己会做的 <code>i++</code>，这样下一轮循环就能重新检查当前 <code>i</code> 位置的这个新珠子了。</li>
<li>如果 <code>nums[i]</code> 是 <code>1</code>（白色）：那它就在正确的位置（红和蓝的中间），我们啥也不用做，<code>i</code> 会在 <code>for</code> 循环结束时自动向右挪。</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=75 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [75] 颜色分类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortColors</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span> <span class="comment">// 初始化 left 和 right 标记</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// current 标记 i 从数组头扫描到 right 标记的位置</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123; <span class="comment">// 遇到红色珠子 (0)</span></span><br><span class="line">			<span class="comment">// 和 left 位置的珠子交换</span></span><br><span class="line">			nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">			<span class="comment">// left 标记向右移动</span></span><br><span class="line">			left++</span><br><span class="line">			<span class="comment">// current 标记 (i) 也会在 for 循环末尾自动右移</span></span><br><span class="line">			<span class="comment">// 因为从 left 换过来的珠子只可能是 0 或 1, 已经处理过或即将正确处理</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] == <span class="number">2</span> &#123; <span class="comment">// 遇到蓝色珠子 (2)</span></span><br><span class="line">			<span class="comment">// 和 right 位置的珠子交换</span></span><br><span class="line">			nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">			<span class="comment">// right 标记向左移动</span></span><br><span class="line">			right--</span><br><span class="line">			<span class="comment">// 关键：current 标记 (i) 退一步，重新检查当前位置换过来的新珠子</span></span><br><span class="line">			i--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果 nums[i] == 1 (白色珠子)，啥也不做，i 会自动右移</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h3 id="方法比较">方法比较</h3>
<table>
<thead>
<tr>
<th>方面</th>
<th>双指针法 (荷兰国旗问题解法)</th>
<th>计数排序法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n)$</td>
<td>$O(n)$ (两次遍历)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$ (原地)</td>
<td>$O(k)$ (k=3, 颜色数量)</td>
</tr>
<tr>
<td>优点</td>
<td>原地排序，空间效率高</td>
<td>实现简单直观</td>
</tr>
<tr>
<td>缺点</td>
<td>逻辑稍复杂</td>
<td>需要额外空间</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
</tr>
</tbody>
</table>
<p><strong>计数排序法思路：</strong></p>
<ol>
<li>遍历数组，统计 0, 1, 2 各自出现的次数。</li>
<li>根据统计的次数，重写原数组。先写所有的 0，然后写所有的 1，最后写所有的 2。</li>
</ol>
<p>这种方法也很简单，但题目要求原地排序，并且如果颜色种类很多，计数排序的空间复杂度会上升。对于本题，颜色只有三种，所以空间复杂度是 $O(1)$。</p>
<h3 id="复杂度分析">复杂度分析</h3>
<p><strong>双指针法：</strong></p>
<ul>
<li><strong>时间复杂度：</strong> $O(n)$。<br>
<code>left</code> 和 <code>current</code> 指针从左向右移动，<code>right</code> 指针从右向左移动。每个元素最多被访问和交换常数次。<code>current</code> 指针最多遍历数组一次。</li>
<li><strong>空间复杂度：</strong> $O(1)$。<br>
我们只使用了常数个额外的变量（<code>left</code>, <code>right</code>, <code>current</code>），是在原地修改数组。</li>
</ul>
<h3 id="关键收获">关键收获</h3>
<ul>
<li><strong>双指针（或三标记）是个好技巧</strong>：对于数组排序或分区问题，这种方法非常高效。这个特定的问题也叫&quot;荷兰国旗问题&quot;，因为荷兰国旗就是红、白、蓝三色条纹。</li>
<li><strong>原地排序省地方</strong>：我们没有用额外的数组，直接在原来的数组上操作，这很节省内存。</li>
<li><strong>指针移动要小心</strong>：
<ul>
<li>当遇到蓝色珠子（2）并与右边交换后，<code>current</code> (即 <code>i</code>) 指针需要&quot;退一步&quot; (<code>i--</code>) 是这个算法的关键。这能确保我们不会错过检查从右边换过来的那个未知颜色的珠子。</li>
<li>当遇到红色珠子（0）并与左边交换后，<code>current</code> (即 <code>i</code>) 和 <code>left</code> 都前进。这是因为 <code>left</code> 左边的区域保证都是红色，而 <code>current</code> 是从左往右扫描的，所以从 <code>left</code> 换到 <code>current</code> 位置的珠子不可能是蓝色（2）。它只可能是红色（0）或白色（1）。如果换过来的是红色，<code>current</code> 下次检查时会再次把它放到 <code>left</code>区域；如果换过来的是白色，<code>current</code> 下次检查时会直接跳过。</li>
</ul>
</li>
</ul>
<p>总的来说，这道题通过巧妙的指针操作，实现了高效的颜色排序，是一个值得学习的经典算法。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>双指针</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 72 - 编辑距离 (Edit Distance)</title>
    <url>/2025/05/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定两个单词 <code>word1</code> 和 <code>word2</code>，计算将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题是经典的动态规划问题。我们可以定义 <code>dp[i][j]</code> 表示将 <code>word1</code> 的前 <code>i</code> 个字符转换成 <code>word2</code> 的前 <code>j</code> 个字符所需要的最少操作数。</p>
<h3 id="状态定义">状态定义</h3>
<p><code>dp[i][j]</code>：<code>word1</code> 的子串 <code>word1[0...i-1]</code> (长度为 <code>i</code>) 转换成 <code>word2</code> 的子串 <code>word2[0...j-1]</code> (长度为 <code>j</code>) 所需的最小操作数。</p>
<h3 id="初始化">初始化</h3>
<ol>
<li><code>dp[0][0] = 0</code>：空字符串转换为空字符串，操作数为 0。</li>
<li><code>dp[i][0] = i</code> (当 <code>j=0</code> 时)：<code>word1</code> 的前 <code>i</code> 个字符转换为空字符串，需要 <code>i</code> 次删除操作。<br>
例如，将 “abc” 转换为空字符串，需要删除 ‘a’, ‘b’, ‘c’，共 3 次操作。</li>
<li><code>dp[0][j] = j</code> (当 <code>i=0</code> 时)：空字符串转换成 <code>word2</code> 的前 <code>j</code> 个字符，需要 <code>j</code> 次插入操作。<br>
例如，将空字符串转换成 “xyz”，需要插入 ‘x’, ‘y’, ‘z’，共 3 次操作。</li>
</ol>
<h3 id="状态转移方程">状态转移方程</h3>
<p>考虑 <code>dp[i][j]</code> 的计算，即如何将 <code>word1[0...i-1]</code> 转换成 <code>word2[0...j-1]</code>。我们可以从以下三种情况进行转移：</p>
<ol>
<li>
<p><strong>替换操作 (Modify)</strong>:<br>
如果 <code>word1[i-1] == word2[j-1]</code>，说明 <code>word1</code> 的第 <code>i</code> 个字符与 <code>word2</code> 的第 <code>j</code> 个字符相同。这种情况下，我们不需要对这两个字符进行任何操作，问题就转化为将 <code>word1[0...i-2]</code> 转换成 <code>word2[0...j-2]</code> 的最小操作数。<br>
所以，<code>dp[i][j] = dp[i-1][j-1]</code>。</p>
<p>如果 <code>word1[i-1] != word2[j-1]</code>，说明 <code>word1</code> 的第 <code>i</code> 个字符与 <code>word2</code> 的第 <code>j</code> 个字符不同。我们可以将 <code>word1[i-1]</code> 替换为 <code>word2[j-1]</code>，这样这两个字符就匹配了。此时，操作数加 1，问题转化为将 <code>word1[0...i-2]</code> 转换成 <code>word2[0...j-2]</code> 的最小操作数。<br>
所以，<code>dp[i][j] = dp[i-1][j-1] + 1</code>。</p>
</li>
<li>
<p><strong>删除操作 (Delete)</strong>:<br>
我们可以删除 <code>word1[i-1]</code> 这个字符，然后问题就转化为将 <code>word1[0...i-2]</code> (长度为 <code>i-1</code>) 转换成 <code>word2[0...j-1]</code> (长度为 <code>j</code>) 的最小操作数。<br>
所以，<code>dp[i][j] = dp[i-1][j] + 1</code>。</p>
</li>
<li>
<p><strong>插入操作 (Insert)</strong>:<br>
我们可以在 <code>word1[0...i-1]</code> 的末尾插入一个字符 <code>word2[j-1]</code>，使得 <code>word1</code> 的新子串与 <code>word2[0...j-1]</code> 的末尾字符匹配。然后问题就转化为将 <code>word1[0...i-1]</code> (长度为 <code>i</code>) 转换成 <code>word2[0...j-2]</code> (长度为 <code>j-1</code>) 的最小操作数。<br>
所以，<code>dp[i][j] = dp[i][j-1] + 1</code>。</p>
</li>
</ol>
<p>综合以上三种情况，当 <code>word1[i-1] != word2[j-1]</code> 时，<code>dp[i][j]</code> 应该取这三种操作中操作数最小的一个：<br>
<code>dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1)</code></p>
<p>我们可以将替换操作的两种情况合并。<br>
如果 <code>word1[i-1] == word2[j-1]</code>，则 <code>cost = 0</code>，否则 <code>cost = 1</code>。<br>
那么，<code>dp[i][j]</code> 的状态转移方程可以统一为：<br>
<code>dp[i][j] = min(dp[i-1][j-1] + cost, dp[i-1][j] + 1, dp[i][j-1] + 1)</code></p>
<p>更简洁的写法是：</p>
<ul>
<li>如果 <code>word1[i-1] == word2[j-1]</code>：<br>
<code>dp[i][j] = dp[i-1][j-1]</code> (此时不需要操作，等价于从 <code>dp[i-1][j-1]</code> 转移过来，操作数为 0)</li>
<li>如果 <code>word1[i-1] != word2[j-1]</code>：<br>
<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code><br>
这里 <code>dp[i-1][j-1]</code> 对应替换操作，<code>dp[i-1][j]</code> 对应删除 <code>word1[i-1]</code>，<code>dp[i][j-1]</code> 对应在 <code>word1</code> 末尾插入 <code>word2[j-1]</code>。</li>
</ul>
<p>最终结果是 <code>dp[n][m]</code>，其中 <code>n</code> 是 <code>word1</code> 的长度，<code>m</code> 是 <code>word2</code> 的长度。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filepath: /Users/adrianwang/.leetcode/72.编辑距离.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=72 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [72] 编辑距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n, m := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dp[i][j] 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符所需的最少操作数</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化：理论上可以将所有 dp[i][j] 初始化为 math.MaxInt32</span></span><br><span class="line">	<span class="comment">// 但由于递推关系，这里的初始化可以更精简</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">	<span class="comment">// dp[i][0]：word1 的前 i 个字符转换为空字符串，需要 i 次删除</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// dp[0][j]：空字符串转换成 word2 的前 j 个字符，需要 j 次插入</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= m; j++ &#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = j</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态转移</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= m; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line">				<span class="comment">// 如果 word1[i-1] == word2[j-1]，则当前字符匹配，不需要操作</span></span><br><span class="line">				<span class="comment">// 操作数等于 dp[i-1][j-1]</span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果 word1[i-1] != word2[j-1]，则需要进行操作</span></span><br><span class="line">				<span class="comment">// dp[i-1][j-1] + 1: 替换 word1[i-1] 为 word2[j-1]</span></span><br><span class="line">				<span class="comment">// dp[i-1][j] + 1:   删除 word1[i-1]</span></span><br><span class="line">				<span class="comment">// dp[i][j-1] + 1:   在 word1 末尾插入 word2[j-1]</span></span><br><span class="line">				dp[i][j] = Min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n][m]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Min 返回一组整数中的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 或者返回一个错误，或者根据业务场景返回一个特定的值</span></span><br><span class="line">		<span class="keyword">return</span> math.MaxInt32 <span class="comment">// 示例：如果没有数字，则返回最大整数</span></span><br><span class="line">	&#125;</span><br><span class="line">	minVal := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> num &lt; minVal &#123;</span><br><span class="line">			minVal = num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><strong>时间复杂度</strong>: O(n<em>m)，其中 n 是 <code>word1</code> 的长度，m 是 <code>word2</code> 的长度。因为我们需要填充一个 n</em>m 大小的 DP 表。</li>
<li><strong>空间复杂度</strong>: O(n*m)，用于存储 DP 表。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li><strong>动态规划状态定义</strong>：清晰地定义 <code>dp[i][j]</code> 的含义是解决问题的关键。</li>
<li><strong>边界条件处理</strong>：正确初始化 <code>dp</code> 表的第一行和第一列。</li>
<li><strong>状态转移逻辑</strong>：理解三种基本操作（插入、删除、替换）如何影响状态转移。</li>
<li><strong>字符索引与 DP 索引</strong>：注意字符串索引 <code>word1[i-1]</code> 对应的是 <code>dp</code> 表中的第 <code>i</code> 个元素。</li>
</ul>
<p>这个题目是字符串动态规划中的一个基础且重要的问题，掌握其解法对于理解更复杂的字符串 DP 问题非常有帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 5 - 最长回文子串：动态规划填表顺序错误分析</title>
    <url>/2025/05/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p><strong>示例 1：</strong></p>
<p>输入：s = “babad”<br>
输出：“bab”<br>
解释：“aba” 同样是符合题意的答案。</p>
<p><strong>示例 2：</strong></p>
<p>输入：s = “cbbd”<br>
输出：“bb”</p>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<h2 id="错误的解法与分析">错误的解法与分析</h2>
<p>一个常见的解决此问题的思路是使用动态规划。我们定义 <code>dp[i][j]</code> 表示字符串 <code>s</code> 中从索引 <code>i</code> 到 <code>j</code> 的子串是否是回文串。</p>
<p>状态转移方程可以这样定义：</p>
<ul>
<li>如果 <code>s[i] == s[j]</code>：
<ul>
<li>如果子串长度小于等于 2（即 <code>j - i &lt; 2</code>），那么 <code>dp[i][j]</code> 为 <code>true</code>。</li>
<li>如果子串长度大于 2，那么 <code>dp[i][j]</code> 取决于 <code>dp[i+1][j-1]</code> 是否为回文串。</li>
</ul>
</li>
<li>如果 <code>s[i] != s[j]</code>，那么 <code>dp[i][j]</code> 为 <code>false</code>。</li>
</ul>
<p>以下是一个尝试实现该思路的 Go 代码，但它存在一个关键的错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	maxLen := <span class="number">1</span></span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	end := <span class="number">1</span> <span class="comment">// ❌ 错误点：end 初始化不当，可能导致长度为1时出错</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		dp[i][i] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ❌ 错误点：填表顺序问题</span></span><br><span class="line">	<span class="comment">// 当计算 dp[i][j] 时，dp[i+1][j-1] 可能尚未被计算</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j-i &lt; <span class="number">2</span> &#123; <span class="comment">// 子串长度为2</span></span><br><span class="line">				dp[i][j] = s[i] == s[j]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 子串长度大于2</span></span><br><span class="line">				dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == s[j]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; maxLen &#123;</span><br><span class="line">				maxLen = j - i + <span class="number">1</span></span><br><span class="line">				start = i</span><br><span class="line">				end = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s[start : end+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>主要的错误在于 <strong>DP 表的填充顺序</strong>。</p>
<p>在上述代码中，外层循环 <code>i</code> 从 <code>0</code> 遍历到 <code>n-1</code>，内层循环 <code>j</code> 从 <code>i+1</code> 遍历到 <code>n-1</code>。当我们计算 <code>dp[i][j]</code> 时，它依赖于 <code>dp[i+1][j-1]</code> 的值。</p>
<p>让我们考虑一个例子，比如计算 <code>dp[0][3]</code>。根据状态转移方程，它依赖于 <code>dp[1][2]</code>。<br>
在当前的遍历顺序下：</p>
<ul>
<li><code>i = 0</code>:
<ul>
<li><code>j = 1</code>: 计算 <code>dp[0][1]</code></li>
<li><code>j = 2</code>: 计算 <code>dp[0][2]</code> (依赖 <code>dp[1][1]</code>)</li>
<li><code>j = 3</code>: 计算 <code>dp[0][3]</code> (依赖 <code>dp[1][2]</code>)</li>
</ul>
</li>
</ul>
<p>当 <code>i=0, j=3</code> 时，我们需要 <code>dp[1][2]</code> 的值。但是，<code>dp[1][2]</code> 会在 <code>i=1, j=2</code> 时才被计算。这意味着在计算 <code>dp[0][3]</code> 时，<code>dp[1][2]</code> 还没有被正确计算出来（其值仍为默认的 <code>false</code>），从而导致 <code>dp[0][3]</code> 的计算错误。</p>
<p>此外，<code>end</code> 变量的初始化为 <code>1</code>，当字符串长度为 <code>1</code> 时，如果 <code>maxLen</code> 没有更新（例如字符串本身就是单个字符，已经是回文），<code>s[start : end+1]</code> 会变成 <code>s[0:2]</code>，这会导致数组越界。对于长度为 1 的字符串，<code>start</code>应为<code>0</code>，<code>end</code>应为<code>0</code>。</p>
<h2 id="正确的解法与思路">正确的解法与思路</h2>
<p>为了解决填表顺序的问题，我们需要确保在计算 <code>dp[i][j]</code> 时，其依赖的 <code>dp[i+1][j-1]</code> 已经被计算过。这可以通过改变循环的遍历顺序来实现。</p>
<p>正确的思路是：</p>
<ol>
<li><strong>外层循环 <code>i</code> 从 <code>n-1</code> 向下遍历到 <code>0</code>。</strong></li>
<li><strong>内层循环 <code>j</code> 从 <code>i+1</code> 向上遍历到 <code>n-1</code>。</strong></li>
</ol>
<p>这样，当我们计算 <code>dp[i][j]</code> 时：</p>
<ul>
<li><code>i</code> 的值比 <code>i+1</code> 小。</li>
<li><code>j</code> 的值比 <code>j-1</code> 大。<br>
由于 <code>i</code> 是从大到小遍历的，当计算 <code>dp[i][...]</code> 时，所有 <code>dp[i+1][...]</code> 的行都已经被计算完毕。因此，<code>dp[i+1][j-1]</code> 的值是已知的。</li>
</ul>
<p>同时，对于 <code>end</code> 的初始化，当 <code>maxLen</code> 为 <code>1</code> 时，<code>start</code> 和 <code>end</code> 都应该是 <code>0</code>（或者说，子串就是 <code>s[0:1]</code>）。</p>
<h3 id="正确的-Go-代码实现">正确的 Go 代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span> &#123; <span class="comment">// 处理空字符串或单字符字符串的情况</span></span><br><span class="line">		<span class="keyword">return</span> s</span><br><span class="line">	&#125;</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	maxLen := <span class="number">1</span></span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	<span class="comment">// end 不需要单独初始化为1，通过dp[i][i] 和后续更新来确定</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有长度为1的子串都是回文串</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		dp[i][i] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从后往前遍历 i，确保 dp[i+1][j-1] 已被计算</span></span><br><span class="line">	<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="comment">// 从 i+1 开始遍历 j</span></span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">				<span class="comment">// 如果子串长度为2 (j-i == 1) 或者内部子串 dp[i+1][j-1] 是回文</span></span><br><span class="line">				<span class="keyword">if</span> j-i &lt; <span class="number">2</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &#123;</span><br><span class="line">					dp[i][j] = <span class="literal">true</span></span><br><span class="line">					<span class="keyword">if</span> j-i+<span class="number">1</span> &gt; maxLen &#123;</span><br><span class="line">						maxLen = j - i + <span class="number">1</span></span><br><span class="line">						start = i</span><br><span class="line">						<span class="comment">// end = j // end 可以不在这里更新，最后通过 start 和 maxLen 计算</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 通过 start 和 maxLen 来确定最终的子串</span></span><br><span class="line">	<span class="keyword">return</span> s[start : start+maxLen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个修正后的版本中：</p>
<ol>
<li><code>i</code> 从 <code>n-1</code> 递减到 <code>0</code>。</li>
<li><code>j</code> 从 <code>i+1</code> 递增到 <code>n-1</code>。</li>
<li>简化了 <code>dp[i][j]</code> 的判断逻辑：如果 <code>s[i] == s[j]</code>，那么当子串长度为 2 (<code>j-i == 1</code>，等价于 <code>j-i &lt; 2</code>) 或者内部子串 <code>dp[i+1][j-1]</code> 为回文时，<code>dp[i][j]</code> 才为 <code>true</code>。</li>
<li><code>end</code> 的更新被移除了，最后直接通过 <code>start</code> 和 <code>maxLen</code> 来截取子串，这样更简洁且不易出错。对于 <code>maxLen</code> 初始化为 <code>1</code>，<code>start</code> 初始化为 <code>0</code>，如果循环没有找到更长的回文串，会返回 <code>s[0:1]</code>，这是正确的。</li>
<li>处理了 <code>n &lt; 2</code> 的边界情况。</li>
</ol>
<h2 id="学习总结">学习总结</h2>
<p>动态规划问题的核心之一在于确定正确的状态转移顺序。当一个状态 <code>dp[i][j]</code> 依赖于其他状态时（如本例中的 <code>dp[i+1][j-1]</code>），必须确保在计算当前状态之前，所有依赖的状态都已经被正确计算。</p>
<p>对于二维 DP 表，常见的遍历顺序有：</p>
<ul>
<li>从上到下，从左到右。</li>
<li>从下到上，从左到右。</li>
<li>从上到下，从右到左。</li>
<li>从下到上，从右到左。</li>
</ul>
<p>选择哪种顺序取决于状态之间的依赖关系。在本题中，由于 <code>dp[i][j]</code> 依赖于 <code>dp[i+1][j-1]</code>（即左下方的单元格），因此从下往上（<code>i</code> 递减）、从左往右（<code>j</code> 递增，且 <code>j &gt; i</code>）的遍历顺序是合适的。</p>
<p>另外，初始化边界条件和最终结果的提取方式也需要仔细考虑，以避免数组越界或逻辑错误。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>❌错题集</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1143 - 最长公共子序列 (Longest Common Subsequence)</title>
    <url>/2025/05/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。</p>
<p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>
两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<p>输入：text1 = “abcde”, text2 = “ace”<br>
输出：3<br>
解释：最长公共子序列是 “ace”，它的长度为 3。</p>
<p><strong>示例 2：</strong></p>
<p>输入：text1 = “abc”, text2 = “abc”<br>
输出：3<br>
解释：最长公共子序列是 “abc”，它的长度为 3。</p>
<p><strong>示例 3：</strong></p>
<p>输入：text1 = “abc”, text2 = “def”<br>
输出：0<br>
解释：两个字符串没有公共子序列，返回 0。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题是典型的动态规划问题。动态规划的核心思想是将一个大问题分解为若干个子问题，通过解决这些子问题，并存储它们的结果，来最终解决大问题。</p>
<p><strong>1. 定义 DP 数组的含义</strong></p>
<p>我们创建一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 用来存储字符串 <code>text1</code> 的前 <code>i</code> 个字符（即子串 <code>text1[0...i-1]</code>）与字符串 <code>text2</code> 的前 <code>j</code> 个字符（即子串 <code>text2[0...j-1]</code>）的最长公共子序列的长度。</p>
<p>例如，如果 <code>text1 = &quot;abc&quot;</code>，<code>text2 = &quot;axc&quot;</code>：</p>
<ul>
<li><code>dp[1][1]</code> 表示 <code>text1</code> 的前 1 个字符 “a” 和 <code>text2</code> 的前 1 个字符 “a” 的最长公共子序列长度。</li>
<li><code>dp[3][2]</code> 表示 <code>text1</code> 的前 3 个字符 “abc” 和 <code>text2</code> 的前 2 个字符 “ax” 的最长公共子序列长度。</li>
</ul>
<p><strong>2. 状态转移方程</strong></p>
<p>当我们计算 <code>dp[i][j]</code> 时，我们需要观察 <code>text1</code> 的第 <code>i</code> 个字符（即 <code>text1[i-1]</code>）和 <code>text2</code> 的第 <code>j</code> 个字符（即 <code>text2[j-1]</code>）：</p>
<ul>
<li>
<p><strong>情况一：<code>text1[i-1] == text2[j-1]</code></strong><br>
如果这两个字符相等，那么这个相等的字符 <code>text1[i-1]</code> (或 <code>text2[j-1]</code>) 必然可以作为 <code>text1[0...i-1]</code> 和 <code>text2[0...j-1]</code> 的最长公共子序列的最后一个字符。<br>
因此，<code>dp[i][j]</code> 就等于 <code>text1[0...i-2]</code> 和 <code>text2[0...j-2]</code> 的最长公共子序列的长度，再加上这个共同的字符（长度加 1）。<br>
所以，<code>dp[i][j] = dp[i-1][j-1] + 1</code>。</p>
</li>
<li>
<p><strong>情况二：<code>text1[i-1] != text2[j-1]</code></strong><br>
如果这两个字符不相等，那么 <code>text1[i-1]</code> 和 <code>text2[j-1]</code> 中至少有一个字符不能包含在 <code>text1[0...i-1]</code> 和 <code>text2[0...j-1]</code> 的最长公共子序列中。<br>
这时，<code>dp[i][j]</code> 的值取决于以下两种可能中较大的那个：</p>
<ol>
<li>不考虑 <code>text1[i-1]</code>，即 <code>text1[0...i-2]</code> 和 <code>text2[0...j-1]</code> 的最长公共子序列长度，也就是 <code>dp[i-1][j]</code>。</li>
<li>不考虑 <code>text2[j-1]</code>，即 <code>text1[0...i-1]</code> 和 <code>text2[0...j-2]</code> 的最长公共子序列长度，也就是 <code>dp[i][j-1]</code>。<br>
所以，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>.</li>
</ol>
</li>
</ul>
<p><strong>3. 初始化 DP 数组（边界条件）</strong></p>
<ul>
<li><code>dp[0][j]</code>：表示 <code>text1</code> 为空字符串（长度为 0）与 <code>text2</code> 的前 <code>j</code> 个字符的最长公共子序列。空字符串与任何字符串的公共子序列长度都是 0。所以 <code>dp[0][j] = 0</code> 对所有 <code>j</code> 成立。</li>
<li><code>dp[i][0]</code>：表示 <code>text1</code> 的前 <code>i</code> 个字符与 <code>text2</code> 为空字符串（长度为 0）的最长公共子序列。同理，长度也是 0。所以 <code>dp[i][0] = 0</code> 对所有 <code>i</code> 成立。</li>
<li>因此，<code>dp[0][0]</code> (空串与空串的 LCS) 自然也是 0。<br>
在 Go 语言中，<code>make</code> 创建的 <code>int</code> 类型切片默认值为 0，所以这部分初始化可以省略显式赋值。</li>
</ul>
<p><strong>4. 填表顺序与最终结果</strong></p>
<p>我们从 <code>dp[1][1]</code> 开始，逐行逐列地填充 <code>dp</code> 表，直到 <code>dp[n][m]</code>，其中 <code>n</code> 是 <code>text1</code> 的长度，<code>m</code> 是 <code>text2</code> 的长度。<br>
最终 <code>dp[n][m]</code> 就是我们要求的 <code>text1</code> 和 <code>text2</code> 整个字符串的最长公共子序列的长度。</p>
<p><strong>举例手动推演：</strong></p>
<p>假设 <code>text1 = &quot;ab&quot;</code>，<code>text2 = &quot;axb&quot;</code>。<br>
<code>n = 2</code>, <code>m = 3</code>。<br>
DP 表大小为 <code>(2+1) x (3+1) = 3x4</code>.</p>
<p>初始化：<br>
<code>dp</code> 表所有元素为 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &quot;&quot;  a   x   b   (text2)</span><br><span class="line">&quot;&quot;    0   0   0   0</span><br><span class="line">a     0</span><br><span class="line">b     0</span><br><span class="line">(text1)</span><br></pre></td></tr></table></figure>
<p>开始填充：</p>
<ul>
<li><code>i=1, j=1</code>: <code>text1[0]</code> (‘a’) == <code>text2[0]</code> (‘a’)<br>
<code>dp[1][1] = dp[0][0] + 1 = 0 + 1 = 1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &quot;&quot;  a   x   b</span><br><span class="line">&quot;&quot;    0   0   0   0</span><br><span class="line">a     0   1</span><br><span class="line">b     0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>i=1, j=2</code>: <code>text1[0]</code> (‘a’) != <code>text2[1]</code> (‘x’)<br>
<code>dp[1][2] = max(dp[0][2], dp[1][1]) = max(0, 1) = 1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &quot;&quot;  a   x   b</span><br><span class="line">&quot;&quot;    0   0   0   0</span><br><span class="line">a     0   1   1</span><br><span class="line">b     0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>i=1, j=3</code>: <code>text1[0]</code> (‘a’) != <code>text2[2]</code> (‘b’)<br>
<code>dp[1][3] = max(dp[0][3], dp[1][2]) = max(0, 1) = 1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &quot;&quot;  a   x   b</span><br><span class="line">&quot;&quot;    0   0   0   0</span><br><span class="line">a     0   1   1   1</span><br><span class="line">b     0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>i=2, j=1</code>: <code>text1[1]</code> (‘b’) != <code>text2[0]</code> (‘a’)<br>
<code>dp[2][1] = max(dp[1][1], dp[2][0]) = max(1, 0) = 1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &quot;&quot;  a   x   b</span><br><span class="line">&quot;&quot;    0   0   0   0</span><br><span class="line">a     0   1   1   1</span><br><span class="line">b     0   1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>i=2, j=2</code>: <code>text1[1]</code> (‘b’) != <code>text2[1]</code> (‘x’)<br>
<code>dp[2][2] = max(dp[1][2], dp[2][1]) = max(1, 1) = 1</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &quot;&quot;  a   x   b</span><br><span class="line">&quot;&quot;    0   0   0   0</span><br><span class="line">a     0   1   1   1</span><br><span class="line">b     0   1   1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>i=2, j=3</code>: <code>text1[1]</code> (‘b’) == <code>text2[2]</code> (‘b’)<br>
<code>dp[2][3] = dp[1][2] + 1 = 1 + 1 = 2</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      &quot;&quot;  a   x   b</span><br><span class="line">&quot;&quot;    0   0   0   0</span><br><span class="line">a     0   1   1   1</span><br><span class="line">b     0   1   1   2</span><br></pre></td></tr></table></figure>
<p>最终结果 <code>dp[2][3] = 2</code>。最长公共子序列是 “ab”.</p>
<p>最终的结果是 <code>dp[n][m]</code>，其中 <code>n</code> 是 <code>text1</code> 的长度，<code>m</code> 是 <code>text2</code> 的长度。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filepath: /Users/adrianwang/.leetcode/1143.最长公共子序列.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=1143 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [1143] 最长公共子序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonSubsequence</span><span class="params">(text1 <span class="type">string</span>, text2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n, m := <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dp[i][j] 表示 text1[0...i-1] 和 text2[0...j-1] 的最长公共子序列长度</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// base case: dp[0][...] 和 dp[...][0] 均为 0，Go 语言中默认初始化为 0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= m; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>] &#123;</span><br><span class="line">				<span class="comment">// 当前字符匹配，LCS 长度加 1</span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 当前字符不匹配，取两种情况的最大值</span></span><br><span class="line">				<span class="comment">// 1. text1[0...i-2] 和 text2[0...j-1] 的 LCS</span></span><br><span class="line">				<span class="comment">// 2. text1[0...i-1] 和 text2[0...j-2] 的 LCS</span></span><br><span class="line">				dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n][m]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// max 函数辅助</span></span><br><span class="line"><span class="comment">// func max(a, b int) int &#123;</span></span><br><span class="line"><span class="comment">// 	if a &gt; b &#123;</span></span><br><span class="line"><span class="comment">// 		return a</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// 	return b</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 上述代码中 <code>max</code> 函数在 LeetCode 环境中通常是内置的或可以直接使用，如果本地运行需要自行定义。在 <code>1143.最长公共子序列.go</code> 文件中，<code>max</code> 函数是存在的。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度：</strong> O(n*m)，其中 <code>n</code> 是 <code>text1</code> 的长度，<code>m</code> 是 <code>text2</code> 的长度。我们需要填充一个 <code>n*m</code> 大小的 DP 表。</li>
<li><strong>空间复杂度：</strong> O(n*m)，用于存储 DP 表。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li>动态规划是解决最长公共子序列问题的经典方法。</li>
<li>正确定义 DP 状态 <code>dp[i][j]</code> 的含义至关重要，通常表示考虑子问题 <code>text1[0...i-1]</code> 和 <code>text2[0...j-1]</code>.</li>
<li>仔细推导状态转移方程，考虑字符匹配和不匹配两种情况。</li>
<li>注意 DP 表的初始化和边界条件。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础 - 键值对数据库实现原理</title>
    <url>/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%81%A5%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
    <content><![CDATA[<h2 id="键值对数据库是怎么实现的？">键值对数据库是怎么实现的？</h2>
<p>在介绍具体数据结构之前，需要先了解 Redis 是如何实现键值对（key-value）数据库的基本原理。</p>
<p>Redis 的键值对中的 key 是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong>，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p>
<p>下面是几种 Redis 新增键值对的命令示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SET name &quot;xiaolincoding&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; HSET person name &quot;xiaolincoding&quot; age 18</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">&gt; RPUSH stu &quot;xiaolin&quot; &quot;xiaomei&quot;</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<p>这些命令分别表示：</p>
<ul>
<li>第一条命令：name 是一个<strong>字符串键</strong>，因为键的<strong>值是一个字符串对象</strong>；</li>
<li>第二条命令：person 是一个<strong>哈希表键</strong>，因为键的<strong>值是一个包含两个键值对的哈希表对象</strong>；</li>
<li>第三条命令：stu 是一个<strong>列表键</strong>，因为键的<strong>值是一个包含两个元素的列表对象</strong>；</li>
</ul>
<p>那么这些不同类型的键值对是如何保存在 Redis 中的呢？</p>
<p>Redis 使用「哈希表」来存储所有的键值对。哈希表的一大优势是能够以 O(1) 的时间复杂度快速查找数据——你可以把它想象成一个高效的索引系统。从根本上说，哈希表是一个数组，数组中的每个位置被称为一个「哈希桶」。</p>
<p>每个哈希桶中存储的是指向「哈希表节点」（<code>dictEntry</code>）的指针。这个节点是理解 Redis 如何存储数据的关键。一个 <code>dictEntry</code> 结构并不直接包含键和值的数据本身，而是通过两个特殊的指针 <code>void* key</code> 和 <code>void* value</code>，分别指向实际的键对象和值对象。这种设计使得 Redis 能够灵活地处理各种不同类型的值。</p>
<p>下图展示了 Redis 保存键值对所涉及的核心数据结构：</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%81%A5%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/1747569688715.png" alt="1747569688715"></p>
<p>这些数据结构的内部细节我们稍后在讨论哈希表时会深入探究。现在，我们先来认识一下图中这些结构各自扮演的角色：</p>
<ul>
<li><code>redisDb</code> 结构：可以看作是 Redis 中的一个“数据库实例”。它里面最重要的就是指向 <code>dict</code> 结构的指针，这个 <code>dict</code> 结构是实现我们常说的字典（或哈希表）的核心。</li>
<li><code>dict</code> 结构：这就是字典（或称为关联数组、map）的实现。有趣的是，它内部维护了两个哈希表（即两个 <code>dictht</code> 结构）。通常情况下，数据都存在「哈希表 1」中。「哈希表 2」则是在特殊时期——比如哈希表需要扩容或缩容（这个过程称为 rehash）时才会用到。</li>
<li><code>dictht</code> 结构：代表一个实际的哈希表。它包含一个数组，这个数组就是哈希表的主体，数组的每个元素都是一个指针，指向一个「哈希表节点」（<code>dictEntry</code>）。</li>
<li><code>dictEntry</code> 结构：这就是哈希表中的基本单元——「哈希表节点」。每个节点保存一个键值对。它包含两个至关重要的指针：
<ul>
<li><code>void* key</code>：指向键对象。在 Redis 中，键总是一个字符串对象。</li>
<li><code>void* value</code>：指向值对象。这个值对象既可以是字符串，也可以是更复杂的集合类型，如列表（List）、哈希（Hash）、集合（Set）或有序集合（ZSet）。</li>
</ul>
</li>
</ul>
<p>这里需要特别强调的是，<code>dictEntry</code> 中的 <code>key</code> 和 <code>value</code> 指针，它们指向的并不是原始数据本身，而是指向一种叫做「Redis 对象」（<code>redisObject</code>）的统一封装结构。可以说，在 Redis 的世界里，无论是键还是值，都会被包装成一个 <code>redisObject</code>。这种对象的结构如下图所示：</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%81%A5%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/1747569698413.png" alt="1747569698413"></p>
<p>一个 <code>redisObject</code> 包含了以下几个关键信息：</p>
<ul>
<li><code>type</code>：标记了这个对象是哪种数据类型（例如，字符串、列表、哈希等），明确了它可以执行哪些操作。</li>
<li><code>encoding</code>：指明了该对象内部使用了哪种更底层的具体数据结构来实现（例如，一个列表类型的对象，其底层可能是用压缩列表或双向链表实现的，Redis 会根据情况选择最优的编码方式）。</li>
<li><code>ptr</code>：这是一个核心指针，它指向了真正存储数据的底层数据结构。</li>
</ul>
<p>下图展示了 Redis 键值对数据库的全景图，清晰展示了 Redis 对象和数据结构之间的关系：</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%81%A5%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84/1747569712816.png" alt="1747569712816"></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数据库</tag>
        <tag>REDIS</tag>
        <tag>键值对</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构：SDS 详解</title>
    <url>/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS/</url>
    <content><![CDATA[<h2 id="前言：为什么-Redis-不直接用-C-字符串？">前言：为什么 Redis 不直接用 C 字符串？</h2>
<p>字符串在 Redis 中无处不在，无论是键（Key）还是值（Value），字符串都是核心数据类型之一。</p>
<p>Redis 是用 C 语言编写的，但它并没有直接采用 C 语言传统的 <code>char*</code> 字符数组来表示字符串。相反，Redis 设计并实现了一种名为<strong>简单动态字符串</strong>（Simple Dynamic String，简称 SDS）的数据结构。</p>
<p>你可能会问，既然 C 语言已经有了字符串类型，为什么 Redis 还要“重复造轮子”呢？答案很简单：C 语言的原生字符串在某些方面存在不足，无法完全满足 Redis 对高性能和安全性的要求。</p>
<p>接下来，我们先了解一下 C 语言字符串有哪些“痛点”，然后看看 Redis 的 SDS 是如何巧妙解决这些问题的。</p>
<h2 id="C-语言字符串的“痛点”">C 语言字符串的“痛点”</h2>
<p>C 语言中的字符串本质上是一个以空字符 <code>\0</code> 结尾的字符数组。例如，字符串 “xiaolin” 在内存中的表示如下：</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS/1747750173011.png" alt="1747750173011"></p>
<p>这种设计虽然简单，但也带来了一些问题：</p>
<h3 id="1-获取长度效率低：O-N-复杂度">1. 获取长度效率低：O(N) 复杂度</h3>
<p>C 语言标准库函数（如 <code>strlen</code>）在计算字符串长度时，需要从头开始遍历字符数组，直到遇到 <code>\0</code> 结束符。这意味着获取字符串长度的时间复杂度是 O(N)，其中 N 是字符串的实际长度。对于长字符串，这个操作会比较耗时。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS/1747750179732.png" alt="1747750179732"></p>
<h3 id="2-二进制不安全：无法存储任意数据">2. 二进制不安全：无法存储任意数据</h3>
<p>由于 <code>\0</code> 被用作字符串的结束标志，C 字符串本身不能包含 <code>\0</code> 字符。如果字符串中间出现了 <code>\0</code>，那么字符串操作（如长度计算、拷贝等）会提前终止。</p>
<p>例如，对于字符串 “xiao\0lin”，使用 <code>strlen</code> 计算其长度会得到 4，而不是实际的 7。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS/1747750187410.png" alt="1747750187410"></p>
<p>这个限制使得 C 字符串只能存储纯文本数据，无法安全地存储像图片、音频、视频等可能包含 <code>\0</code> 字符的二进制数据。</p>
<h3 id="3-缓冲区溢出风险：操作不安全">3. 缓冲区溢出风险：操作不安全</h3>
<p>C 语言的字符串操作函数（如 <code>strcat</code> 用于拼接字符串）通常不检查目标缓冲区的剩余空间。它们假定开发者已经分配了足够的内存。如果这个假定不成立，就会发生<strong>缓冲区溢出</strong>，数据会写入到未授权的内存区域，轻则程序崩溃，重则可能导致安全漏洞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 src 字符串拼接到 dest 字符串后面</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span>* src)</span>;</span><br></pre></td></tr></table></figure>
<p>例如，<code>strcat</code> 函数在拼接时，不会检查 <code>dest</code> 是否有足够空间容纳 <code>src</code>。</p>
<h3 id="4-修改效率低：频繁的内存重分配">4. 修改效率低：频繁的内存重分配</h3>
<p>C 字符串本身不记录已分配的内存大小。当需要增长或缩短字符串时（例如，追加内容），程序通常需要：</p>
<ol>
<li>分配一个新的、更大（或更小）的内存块。</li>
<li>将原来的字符串内容拷贝到新内存块。</li>
<li>释放原来的内存块。<br>
这种操作涉及多次内存分配和数据拷贝，效率较低。</li>
</ol>
<p>总结一下 C 语言字符串的主要缺陷：</p>
<ul>
<li>获取字符串长度的时间复杂度为 O(N)。</li>
<li>以 <code>\0</code> 作为结尾，导致二进制不安全，不能存储任意数据。</li>
<li>字符串操作函数（如拼接）容易引发缓冲区溢出。</li>
<li>修改字符串（增长或缩短）时，内存管理复杂且效率不高。</li>
</ul>
<p>为了克服这些限制，Redis 设计了 SDS。</p>
<h2 id="SDS：Redis-的解决方案">SDS：Redis 的解决方案</h2>
<p>SDS (Simple Dynamic String) 是 Redis 自己实现的一种字符串数据结构。它通过在传统字符数组的基础上增加一些元数据，巧妙地解决了 C 字符串的诸多痛点。</p>
<h3 id="SDS-的结构设计">SDS 的结构设计</h3>
<p>下图展示了 Redis 5.0 中 SDS 的基本结构：</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS/1747750286295.png" alt="1747750286295"></p>
<p>一个 SDS 结构通常包含以下几个部分：</p>
<ul>
<li><strong><code>len</code></strong>：一个整数，记录了 <code>buf</code> 数组中已存储字符串的实际长度（不包括末尾的 <code>\0</code>）。</li>
<li><strong><code>alloc</code></strong>：一个整数，记录了 <code>buf</code> 数组总共分配的内存空间大小（不包括末尾的 <code>\0</code>）。</li>
<li><strong><code>flags</code></strong>：一个字节，用于表示 SDS 的类型。Redis 设计了多种 SDS 类型以优化不同长度字符串的存储。</li>
<li><strong><code>buf[]</code></strong>：一个字符数组，实际存储字符串内容。与 C 字符串类似，SDS 也会在字符串末尾添加一个 <code>\0</code> 字符，这样做是为了能够兼容部分 C 语言标准库函数。但这并不会影响 SDS 存储包含 <code>\0</code> 的二进制数据，因为 SDS 依赖 <code>len</code> 属性来判断字符串的实际长度。</li>
</ul>
<p>通过这几个元数据，SDS 带来了诸多优势。</p>
<h3 id="SDS-的核心优势">SDS 的核心优势</h3>
<h4 id="1-O-1-复杂度获取字符串长度">1. O(1) 复杂度获取字符串长度</h4>
<p>由于 SDS 结构中直接存储了字符串的长度（<code>len</code> 属性），获取字符串长度的操作只需要读取这个属性值即可，时间复杂度为 O(1)。这比 C 字符串的 O(N) 遍历高效得多。</p>
<h4 id="2-二进制安全：可以存储任意数据">2. 二进制安全：可以存储任意数据</h4>
<p>SDS 通过 <code>len</code> 属性来判断字符串的结束，而不是依赖 <code>\0</code> 字符。这意味着 <code>buf</code> 数组中可以包含任意二进制数据，包括 <code>\0</code> 字符本身。</p>
<p>虽然 SDS 也会在 <code>buf</code> 的末尾追加一个 <code>\0</code>（为了兼容 C 库函数），但这部分并不计入 <code>len</code> 中，也不会影响 SDS 对二进制数据的处理。因此，SDS 可以安全地存储文本、图片、音频等各种类型的数据。</p>
<h4 id="3-杜绝缓冲区溢出：安全的字符串操作">3. 杜绝缓冲区溢出：安全的字符串操作</h4>
<p>SDS 在进行字符串修改操作（如拼接、拷贝）时，会首先检查 <code>alloc</code> 记录的已分配空间是否足够。</p>
<ul>
<li>如果空间足够，直接进行修改。</li>
<li>如果空间不足，SDS 会自动进行扩容，分配足够大的新内存空间，然后再执行修改操作。</li>
</ul>
<p>这种机制确保了 SDS 在操作过程中不会发生缓冲区溢出，提高了代码的安全性。</p>
<p><strong>智能的内存预分配与惰性空间释放策略：</strong></p>
<p>为了进一步提高效率，SDS 在扩容时采用了“空间预分配”策略：</p>
<ul>
<li>当修改后 SDS 的长度 <code>len</code> 小于 1MB 时，程序分配新空间时，<code>alloc</code> 的大小会是 <code>len</code> 的两倍。也就是说，如果修改后字符串长度是 10 字节，SDS 会分配 20 字节的空间（<code>len=10</code>, <code>alloc=20</code>），其中有 10 字节的未使用空间。</li>
<li>当修改后 SDS 的长度 <code>len</code> 大于等于 1MB 时，程序会额外多分配 1MB 的未使用空间。即 <code>alloc</code> 的大小会是 <code>len + 1MB</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDS 扩容规则的简化逻辑</span></span><br><span class="line">hisds <span class="title function_">hi_sdsMakeRoomFor</span><span class="params">(hisds s, <span class="type">size_t</span> addlen)</span> <span class="comment">// addlen 是需要增加的长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... 省略部分代码 ...</span></span><br><span class="line">    <span class="type">size_t</span> avail = sdsavail(s); <span class="comment">// 获取当前可用空间</span></span><br><span class="line">    <span class="comment">// 如果可用空间足够，则无需扩展</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> len = sdslen(s); <span class="comment">// 获取当前字符串长度</span></span><br><span class="line">    <span class="type">size_t</span> newlen = (len + addlen); <span class="comment">// 修改后至少需要的总长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度决定如何分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; HI_SDS_MAX_PREALLOC) <span class="comment">// HI_SDS_MAX_PREALLOC 通常是 1MB</span></span><br><span class="line">        <span class="comment">// 如果新长度小于 1MB，则分配所需空间的两倍</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果新长度大于等于 1MB，则额外分配 1MB</span></span><br><span class="line">        newlen += HI_SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 执行实际的内存重分配 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种<strong>空间预分配</strong>策略的好处是，当下次再对 SDS 进行增长操作时，如果预分配的空间足够，就不需要再次进行内存重分配，从而减少了内存分配的次数，提高了性能。</p>
<p>相应地，当 SDS 字符串缩短时，SDS 并不会立即回收多出来的空间，而是通过 <code>len</code> 属性更新实际长度，多余的空间就成了未使用的空间，可以供后续的增长操作使用。这被称为<strong>惰性空间释放</strong>。</p>
<h4 id="4-节省内存空间：多种-SDS-类型与紧凑结构">4. 节省内存空间：多种 SDS 类型与紧凑结构</h4>
<p>为了更有效地利用内存，Redis 为 SDS 设计了多种头部结构（通过 <code>flags</code> 字段区分），以适应不同长度的字符串：</p>
<ul>
<li><code>sdshdr5</code> (Redis 3.2 之后不再使用，被 <code>sdshdr8</code> 的 <code>flags</code> 低 3 位表示类型，高 5 位表示长度所取代)</li>
<li><code>sdshdr8</code></li>
<li><code>sdshdr16</code></li>
<li><code>sdshdr32</code></li>
<li><code>sdshdr64</code></li>
</ul>
<p>这些类型的区别主要在于 <code>len</code> 和 <code>alloc</code> 成员变量的数据类型大小不同，从而使得存储短字符串时，头部结构本身占用的内存也更少。</p>
<p>例如：</p>
<ul>
<li><code>sdshdr8</code>: <code>len</code> 和 <code>alloc</code> 通常是 <code>uint8_t</code> 类型，最大长度约 2^8 - 1。</li>
<li><code>sdshdr16</code>: <code>len</code> 和 <code>alloc</code> 是 <code>uint16_t</code> 类型，最大长度约 2^16 - 1。</li>
<li><code>sdshdr32</code>: <code>len</code> 和 <code>alloc</code> 是 <code>uint32_t</code> 类型，最大长度约 2^32 - 1。</li>
<li><code>sdshdr64</code>: <code>len</code> 和 <code>alloc</code> 是 <code>uint64_t</code> 类型，用于超大字符串。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：sdshdr16 和 sdshdr32 的结构 (注意：实际 Redis 源码中 flags 的位置和作用更复杂)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len;          <span class="comment">// 16位无符号整数存储长度</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc;        <span class="comment">// 16位无符号整数存储已分配空间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;   <span class="comment">// 标志位，表示类型等信息</span></span><br><span class="line">    <span class="type">char</span> buf[];            <span class="comment">// 实际字符数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len;          <span class="comment">// 32位无符号整数存储长度</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc;        <span class="comment">// 32位无符号整数存储已分配空间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;   <span class="comment">// 标志位</span></span><br><span class="line">    <span class="type">char</span> buf[];            <span class="comment">// 实际字符数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，Redis 可以根据字符串的实际大小选择最合适的 SDS 头部结构，避免了不必要的内存浪费。</p>
<p>此外，Redis 在定义这些结构体时，使用了 <code>__attribute__ ((__packed__))</code> 编译指令（GCC 特性）。这个指令告诉编译器取消结构体成员变量之间的对齐填充字节，使得结构体按照实际占用的字节数进行内存分配，从而进一步节省内存。</p>
<p><strong><code>__attribute__ ((__packed__))</code> 的作用示例：</strong></p>
<p>考虑一个普通的 C 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a; <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">int</span> b;  <span class="comment">// 4字节</span></span><br><span class="line"> &#125; test1_instance; <span class="comment">// 变量名修正为 instance</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;sizeof(test1_instance) = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(test1_instance)); <span class="comment">// 打印结构体大小</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在大多数编译器和体系结构下，<code>sizeof(test1_instance)</code> 的结果通常是 8 字节。这是因为编译器为了提高内存访问效率，会对结构体成员进行<strong>字节对齐</strong>。<code>char a</code> 占 1 字节，但为了让接下来的 <code>int b</code> (通常是 4 字节对齐) 从一个合适的地址开始，编译器会在 <code>a</code> 和 <code>b</code> 之间填充 3 个字节。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS/1747750306112.png" alt="1747750306112"></p>
<p>而如果使用了 <code>__attribute__ ((__packed__))</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">test2</span>  &#123;</span></span><br><span class="line">    <span class="type">char</span> a; <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">int</span> b;  <span class="comment">// 4字节</span></span><br><span class="line"> &#125; test2_instance; <span class="comment">// 变量名修正为 instance</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;sizeof(test2_instance) = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(test2_instance)); <span class="comment">// 打印结构体大小</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，<code>sizeof(test2_instance)</code> 的结果会是 5 字节 (1 字节 for <code>char a</code> + 4 字节 for <code>int b</code>)。编译器取消了对齐填充，使得结构体更加紧凑。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS/1747750323570.png" alt="1747750323570"></p>
<p>通过这些精心设计，SDS 在保证功能强大和安全的同时，也兼顾了内存使用效率。</p>
<h2 id="总结">总结</h2>
<p>Redis 的 SDS 通过引入 <code>len</code>、<code>alloc</code> 和 <code>flags</code> 等元数据，并结合巧妙的内存管理策略（如空间预分配、惰性释放、多种头部类型和紧凑结构），成功地克服了传统 C 语言字符串在效率、安全性和功能上的诸多限制。这使得 SDS 成为 Redis 高性能和可靠性的重要基石之一。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>REDIS</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 32 - 最长有效括号：动态规划思路错题分析</title>
    <url>/2025/05/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/leetcode-32-longest-valid-parentheses-dp-error-analysis/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses/">LeetCode 32 题 - 最长有效括号</a>要求我们找到给定字符串中由匹配括号组成的最长有效（格式正确且连续）括号子串的长度。</p>
<p>有效括号字符串的定义如下：</p>
<ol>
<li>空字符串是有效括号字符串</li>
<li>如果<code>s</code>是有效括号字符串，那么<code>(s)</code>也是有效括号字符串</li>
<li>如果<code>s</code>和<code>t</code>都是有效括号字符串，那么<code>st</code>（它们的连接）也是有效括号字符串</li>
</ol>
<p><strong>示例输入输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: s = &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串是 &quot;()&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串是 &quot;()()&quot;</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: s = &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 3 * 10^4</code></li>
<li><code>s[i]</code> 只包含 <code>'('</code> 和 <code>')'</code></li>
</ul>
<h2 id="最初的错误解法">最初的错误解法</h2>
<p>我最初尝试使用动态规划解决这个问题。我定义 <code>dp[i]</code> 表示以字符串 <code>s</code> 中第 <code>i-1</code> 个字符结尾的最长有效括号的长度，<code>dp</code> 数组的大小为 <code>n+1</code>（其中 <code>n</code> 是字符串长度），<code>dp[0]</code> 初始化为 0。</p>
<p>以下是我最初的解法（包含错误）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误代码片段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses_buggy</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>) <span class="comment">// dp[i] 表示以 s[i-1] 结尾的最长有效括号长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123; <span class="comment">// 遍历 s[1] 到 s[n-1]</span></span><br><span class="line">        <span class="comment">// 当前考虑的字符是 s[i]，对应 dp[i+1]</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123; <span class="comment">// 情况 1: ...()</span></span><br><span class="line">                <span class="comment">// s[i-2] 结尾的 LVP + &quot;()&quot;</span></span><br><span class="line">                <span class="comment">// 如果 i-2 &lt; 0, dp[i-1] (即 dp[i-2+1]) 会是 dp[-1+1]=dp[0]=0</span></span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;)&#x27;</span> &#123; <span class="comment">// 情况 2: ...))</span></span><br><span class="line">                <span class="comment">// j 指向 s[i-1] 对应 LVP (长度 dp[i]) 前一个字符</span></span><br><span class="line">                <span class="comment">// dp[i] 是以 s[i-1] 结尾的 LVP 长度</span></span><br><span class="line">                j := i - dp[i] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27;(&#x27;</span> &#123; <span class="comment">// 如果 s[j] 是 &#x27;(&#x27;，形成 s[j]...s[i] 的匹配</span></span><br><span class="line">                    <span class="comment">// ❌ 错误点：状态转移逻辑错误</span></span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[j] + <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt;= n; k++ &#123;</span><br><span class="line">        ans = max(ans, dp[k])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法在以下测试用例中失败：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;)()())&quot;</span><br><span class="line">预期输出: 4</span><br><span class="line">实际输出: 2</span><br></pre></td></tr></table></figure>
<h2 id="错误分析">错误分析</h2>
<p>主要的错误出现在处理 <code>s[i] == ')'</code> 并且 <code>s[i-1] == ')'</code> 的情况，即形如 <code>...))</code> 的子串。具体来说，错误发生在状态转移方程的计算中。</p>
<p>让我们通过一个具体的例子来分析这个错误：</p>
<p>对于字符串 <code>&quot;)()())&quot;</code>，我们逐步执行动态规划：</p>
<ol>
<li><code>dp[0] = 0</code>（初始化）</li>
<li>对于 <code>s[0] = ')':</code> 不可能形成有效括号，<code>dp[1] = 0</code></li>
<li>对于 <code>s[1] = '(':</code> 不可能以左括号结尾，<code>dp[2] = 0</code></li>
<li>对于 <code>s[2] = ')':</code> 与前一个字符 <code>s[1] = '('</code> 匹配，<code>dp[3] = dp[1] + 2 = 0 + 2 = 2</code></li>
<li>对于 <code>s[3] = '(':</code> 不可能以左括号结尾，<code>dp[4] = 0</code></li>
<li>对于 <code>s[4] = ')':</code> 与前一个字符 <code>s[3] = '('</code> 匹配，<code>dp[5] = dp[3] + 2 = 2 + 2 = 4</code></li>
<li>对于 <code>s[5] = ')':</code> 需要检查是否可以与某个左括号匹配</li>
</ol>
<p>在第 7 步，也就是处理字符串最后一个字符 <code>)</code> 时，我们需要考虑它能否与某个左括号匹配。这时：</p>
<ul>
<li><code>s[5] = ')'</code></li>
<li><code>s[4] = ')'</code>（前一个字符也是右括号）</li>
<li><code>dp[5] = 4</code>（表示以 <code>s[4]</code> 结尾的最长有效括号长度）</li>
<li><code>j = 5 - 4 - 1 = 0</code>（<code>j</code> 是指向当前有效括号子串前一个位置的索引）</li>
<li><code>s[j] = s[0] = ')'</code>（不是左括号）</li>
</ul>
<p>在这个例子中，由于 <code>s[j]</code> 不是左括号，所以不会形成新的匹配。但这并不是我想要关注的错误。</p>
<p><strong>关键错误分析</strong>：</p>
<p>当 <code>s[i] == ')'</code> 且 <code>s[i-1] == ')'</code> 且 <code>j &gt;= 0</code> 且 <code>s[j] == '('</code> 时，我错误地将状态转移方程写成了 <code>dp[i+1] = dp[j] + 1</code>。</p>
<p>这个错误的状态转移公式有两个问题：</p>
<ol>
<li><code>+1</code> 是错误的，应该是 <code>+2</code>，因为我们需要加上 <code>s[j]</code> 和 <code>s[i]</code> 这两个新匹配的括号。</li>
<li>没有考虑到 <code>s[j+1...i-1]</code> 这部分已经形成的有效括号长度，即 <code>dp[i]</code>。</li>
</ol>
<p>正确的思路是：新形成的有效括号子串长度应该是三部分之和：</p>
<ul>
<li><code>dp[j]</code>：以 <code>s[j-1]</code> 结尾的最长有效括号长度（可能连接到新匹配前面的部分）</li>
<li><code>+ dp[i]</code>：以 <code>s[i-1]</code> 结尾的最长有效括号长度（<code>s[j+1...i-1]</code> 的部分）</li>
<li><code>+ 2</code>：<code>s[j]</code> 和 <code>s[i]</code> 这两个新匹配的括号</li>
</ul>
<h2 id="正确的动态规划思路">正确的动态规划思路</h2>
<p>要解决最长有效括号问题，我们可以使用动态规划来追踪以每个位置结尾的最长有效括号子串长度。下面详细讲解思路：</p>
<h3 id="状态定义">状态定义</h3>
<ul>
<li>定义 <code>dp[i]</code> 表示以字符串 <code>s</code> 中索引 <code>i-1</code> 的字符结尾的最长有效括号的长度</li>
<li>使用 <code>dp</code> 数组大小为 <code>n+1</code>，其中 <code>dp[0]=0</code> 表示空串</li>
</ul>
<h3 id="状态初始化">状态初始化</h3>
<ul>
<li><code>dp[0] = 0</code>（空串）</li>
<li>对于所有的 <code>i ≥ 1</code>，初始时 <code>dp[i] = 0</code></li>
</ul>
<h3 id="状态转移方程">状态转移方程</h3>
<p>由于有效括号子串必须以右括号 <code>')'</code> 结尾，所以我们只需考虑 <code>s[i-1] = ')'</code> 的情况。根据前一个字符，有两种主要情况：</p>
<ol>
<li>
<p><strong>情况一：<code>s[i-1] = ')'</code> 且 <code>s[i-2] = '('</code></strong> (形如 <code>...()</code>)</p>
<ul>
<li>这种情况下，<code>s[i-2]</code> 和 <code>s[i-1]</code> 构成一对匹配的括号 <code>&quot;()&quot;</code></li>
<li>如果 <code>i-3</code> 位置之前也有有效括号子串，需要加上它的长度</li>
<li>状态转移方程：<code>dp[i] = dp[i-2] + 2</code></li>
<li>其中 <code>dp[i-2]</code> 是以 <code>s[i-3]</code> 结尾的最长有效括号长度</li>
<li><code>+2</code> 表示新增了一对匹配的括号</li>
</ul>
</li>
<li>
<p><strong>情况二：<code>s[i-1] = ')'</code> 且 <code>s[i-2] = ')'</code></strong> (形如 <code>...))</code>)</p>
<ul>
<li>这种情况更复杂，我们需要找到与 <code>s[i-1]</code> 匹配的左括号</li>
<li>首先，我们知道以 <code>s[i-2]</code> 结尾的最长有效括号长度为 <code>dp[i-1]</code></li>
<li>这意味着子串 <code>s[(i-1-dp[i-1])...(i-2)]</code> 是有效的</li>
<li>我们需要查看这个子串之前的字符 <code>s[i-1-dp[i-1]-1]</code>，记为 <code>s[j]</code></li>
<li>如果 <code>s[j] = '('</code>，那么它可以与 <code>s[i-1]</code> 匹配</li>
<li>这样会形成一个新的有效括号子串，长度为：
<ul>
<li><code>dp[i-1]</code>：以 <code>s[i-2]</code> 结尾的有效括号长度</li>
<li><code>+2</code>：新增的一对匹配括号 <code>s[j]</code> 和 <code>s[i-1]</code></li>
<li><code>+dp[j]</code>：以 <code>s[j-1]</code> 结尾的有效括号长度（如果存在）</li>
</ul>
</li>
<li>状态转移方程：<code>dp[i] = dp[i-1] + 2 + dp[j]</code>，其中 <code>j = i-1-dp[i-1]-1</code></li>
</ul>
</li>
</ol>
<h3 id="求解过程">求解过程</h3>
<ol>
<li>初始化 <code>dp</code> 数组，所有元素为 0</li>
<li>从左到右遍历字符串，只有当 <code>s[i] = ')'</code> 时才可能更新 <code>dp[i+1]</code></li>
<li>根据不同情况应用状态转移方程</li>
<li>遍历完成后，<code>dp</code> 数组中的最大值即为答案</li>
</ol>
<h3 id="图解状态转移">图解状态转移</h3>
<p>举例说明两种情况的状态转移：</p>
<p><strong>情况一</strong>：当前字符与前一个字符形成 <code>&quot;()&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;......()&quot;</span><br><span class="line">           ^^</span><br><span class="line">        i-2 i-1</span><br><span class="line"></span><br><span class="line">dp[i] = dp[i-2] + 2</span><br></pre></td></tr></table></figure>
<p><strong>情况二</strong>：当前字符与更前面的字符形成匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;...(.......)&quot;</span><br><span class="line">        ^       ^</span><br><span class="line">        j       i-1</span><br><span class="line"></span><br><span class="line">其中 j = i-1-dp[i-1]-1</span><br><span class="line">dp[i] = dp[i-1] + 2 + dp[j]</span><br></pre></td></tr></table></figure>
<p>注意，在情况二中，<code>dp[i-1]</code> 表示以 <code>s[i-2]</code> 结尾的有效括号的长度。这个有效括号子串的起始位置是 <code>i-1-dp[i-1]</code>，因此 <code>j</code> 是该子串前一个位置的索引。</p>
<h2 id="改进的解决方案">改进的解决方案</h2>
<p>根据上述分析，我们需要修正状态转移方程。以下是改进后的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修正后的核心部分</span></span><br><span class="line"><span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">    j := i - dp[i] - <span class="number">1</span> <span class="comment">// dp[i] 是以 s[i-1] 结尾的LVP的长度</span></span><br><span class="line">    <span class="keyword">if</span> j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">        <span class="comment">// 修正点：正确的状态转移逻辑</span></span><br><span class="line">        dp[i+<span class="number">1</span>] = dp[i] + <span class="number">2</span> + dp[j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的修正代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[k] 表示以 s[k-1] 结尾的最长有效括号的长度</span></span><br><span class="line">    <span class="comment">// 为了方便处理边界，dp 数组大小为 n+1，dp[0] 始终为 0</span></span><br><span class="line">    <span class="comment">// 循环中 i 代表当前字符 s[i] 的索引，更新的是 dp[i+1]</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123; <span class="comment">// 遍历 s[1] 到 s[n-1]</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span> &#123; <span class="comment">// 情况 1: 字符串形如 &quot;...()&quot;</span></span><br><span class="line">                <span class="comment">// dp[i-1] 是以 s[i-2] 结尾的LVP长度</span></span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 2: 字符串形如 &quot;...))&quot;</span></span><br><span class="line">                <span class="comment">// s[i-1] 是 &#x27;)&#x27;</span></span><br><span class="line">                <span class="comment">// dp[i] 是以 s[i-1] 结尾的LVP长度</span></span><br><span class="line">                <span class="comment">// j 是 s[i-1] 结尾的LVP前一个字符的索引</span></span><br><span class="line">                j := i - dp[i] - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">                    <span class="comment">// s[j] 是 &#x27;(&#x27;, s[i] 是 &#x27;)&#x27;</span></span><br><span class="line">                    <span class="comment">// 以 s[i] 结尾的LVP = (以 s[i-1] 结尾的LVP) + s[j]...s[i] + (以 s[j-1] 结尾的LVP)</span></span><br><span class="line">                    <span class="comment">// 长度 = dp[i] (s[j+1...i-1]部分) + 2 (s[j]和s[i]) + dp[j] (以s[j-1]结尾的LVP)</span></span><br><span class="line">                    dp[i+<span class="number">1</span>] = dp[i] + <span class="number">2</span> + dp[j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 s[i] == &#x27;(&#x27;，dp[i+1] 保持为 0，因为有效括号子串不可能以 &#x27;(&#x27; 结尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt;= n; k++ &#123;</span><br><span class="line">        <span class="keyword">if</span> dp[k] &gt; ans &#123;</span><br><span class="line">            ans = dp[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这个解法可以工作">为什么这个解法可以工作</h3>
<p>修正后的解法正确考虑了所有情况：</p>
<ol>
<li>
<p>当前字符 <code>s[i] = ')'</code> 且前一个字符 <code>s[i-1] = '('</code> 时：</p>
<ul>
<li>直接形成一对新的有效括号 <code>()</code></li>
<li>加上之前可能已经形成的有效括号子串长度：<code>dp[i+1] = dp[i-1] + 2</code></li>
</ul>
</li>
<li>
<p>当前字符 <code>s[i] = ')'</code> 且前一个字符 <code>s[i-1] = ')'</code> 时：</p>
<ul>
<li>前一个位置已经形成了长度为 <code>dp[i]</code> 的有效括号子串</li>
<li>需要找到这个子串前一个位置 <code>j = i - dp[i] - 1</code></li>
<li>如果 <code>s[j] = '('</code>，则 <code>s[j]</code> 和 <code>s[i]</code> 形成新的匹配，同时连接了三部分：
<ul>
<li>以 <code>s[j-1]</code> 结尾的有效括号子串：<code>dp[j]</code></li>
<li><code>s[j]</code> 和 <code>s[i]</code> 形成的新匹配：<code>+2</code></li>
<li>中间部分 <code>s[j+1...i-1]</code> 的有效括号子串：<code>dp[i]</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这样，我们正确计算了以每个位置结尾的最长有效括号长度，最终结果就是其中的最大值。</p>
<h2 id="另一种解法：使用栈">另一种解法：使用栈</h2>
<p>除了动态规划，我们还可以使用栈来解决这个问题。栈方法的核心思想是：用栈来匹配括号，并计算匹配后形成的有效括号子串的长度。</p>
<h3 id="栈方法的算法思路">栈方法的算法思路</h3>
<ol>
<li>初始化栈，先放入一个哨兵元素 <code>-1</code>（用于处理边界情况）</li>
<li>遍历字符串中的每个字符：
<ul>
<li>如果是左括号 <code>'('</code>，将其索引入栈</li>
<li>如果是右括号 <code>')'</code>：
<ul>
<li>先弹出栈顶元素（可能是左括号的索引或前一个无法匹配的右括号的索引）</li>
<li>如果此时栈为空，将当前右括号的索引入栈（表示这是一个无法匹配的右括号）</li>
<li>如果栈不为空，计算当前位置与栈顶元素的距离，更新最长有效括号长度</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="栈方法代码实现">栈方法代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestValidParenthesesUsingStack</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxLen := <span class="number">0</span></span><br><span class="line">    stack := []<span class="type">int</span>&#123;<span class="number">-1</span>&#125; <span class="comment">// 栈底放一个-1作为哨兵，方便计算长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, i) <span class="comment">// 左括号，索引入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// s[i] == &#x27;)&#x27;</span></span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// 弹出栈顶，可能是左括号或前一个无法匹配的右括号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, i) <span class="comment">// 栈为空，当前右括号无法匹配，入栈作为新的起始点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算当前有效子串的长度：当前位置 - 栈顶元素</span></span><br><span class="line">                <span class="comment">// 栈顶元素是上一个无法匹配的位置（可能是右括号，也可能是初始的-1）</span></span><br><span class="line">                maxLen = max(maxLen, i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈方法的工作原理示例">栈方法的工作原理示例</h3>
<p>以输入 <code>&quot;)()())&quot;</code> 为例，我们跟踪栈的变化：</p>
<ol>
<li>初始化：stack = [-1]</li>
<li>处理 <code>s[0] = ')'</code>:
<ul>
<li>弹出 -1，栈为空</li>
<li>将 0 入栈：stack = [0]</li>
</ul>
</li>
<li>处理 <code>s[1] = '('</code>:
<ul>
<li>将 1 入栈：stack = [0, 1]</li>
</ul>
</li>
<li>处理 <code>s[2] = ')'</code>:
<ul>
<li>弹出 1，栈不为空</li>
<li>计算长度：2 - 0 = 2，更新 maxLen = 2</li>
<li>当前栈：stack = [0]</li>
</ul>
</li>
<li>处理 <code>s[3] = '('</code>:
<ul>
<li>将 3 入栈：stack = [0, 3]</li>
</ul>
</li>
<li>处理 <code>s[4] = ')'</code>:
<ul>
<li>弹出 3，栈不为空</li>
<li>计算长度：4 - 0 = 4，更新 maxLen = 4</li>
<li>当前栈：stack = [0]</li>
</ul>
</li>
<li>处理 <code>s[5] = ')'</code>:
<ul>
<li>弹出 0，栈为空</li>
<li>将 5 入栈：stack = [5]</li>
</ul>
</li>
</ol>
<p>最终 maxLen = 4，这是正确答案。</p>
<h3 id="两种方法的比较">两种方法的比较</h3>
<table>
<thead>
<tr>
<th>方面</th>
<th>动态规划</th>
<th>栈方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>实现难度</td>
<td>中等（状态转移需要仔细推导）</td>
<td>简单（括号匹配的典型应用）</td>
</tr>
<tr>
<td>思路理解</td>
<td>需要理解状态定义和状态转移</td>
<td>直观，基于括号匹配</td>
</tr>
<tr>
<td>代码量</td>
<td>中等</td>
<td>较少</td>
</tr>
<tr>
<td>适用性</td>
<td>类似的子串问题</td>
<td>括号相关问题</td>
</tr>
</tbody>
</table>
<h2 id="学习总结">学习总结</h2>
<p>通过分析这个错误，我学到了以下重要教训：</p>
<ol>
<li>
<p><strong>状态定义的精确理解</strong>：在动态规划中，准确理解状态的定义至关重要。在这个问题中，<code>dp[k]</code> 表示以 <code>s[k-1]</code> 结尾的最长有效括号长度，需要清晰理解这个定义。</p>
</li>
<li>
<p><strong>完整的状态转移分析</strong>：在推导状态转移方程时，必须考虑所有可能的组成部分。对于括号匹配这类问题，新形成的有效括号子串可能由多个部分组成，需要全面分析各部分的贡献。</p>
</li>
<li>
<p><strong>细心处理索引和边界条件</strong>：动态规划中的索引处理尤为重要，特别是当状态数组和原始数据的索引有偏移时。在这个问题中，<code>dp[i+1]</code> 对应 <code>s[i]</code>，这种对应关系需要时刻牢记。</p>
</li>
<li>
<p><strong>可视化辅助理解</strong>：对于复杂的状态转移，可以通过画图或具体示例来验证思路。例如，对于 <code>...))</code> 模式，可以画出不同情况下的括号组合和对应的 dp 值是如何累加的。</p>
</li>
<li>
<p><strong>多种解法对比学习</strong>：同一个问题往往有多种解法。动态规划和栈方法各有优缺点，通过对比学习，可以加深对问题的理解，也有助于在实际应用中选择最合适的方法。</p>
</li>
<li>
<p><strong>测试关键用例</strong>：针对特定的状态转移逻辑，构造关键测试用例进行验证非常重要。例如，对于这个问题，应该特别测试包含 <code>...))</code>、<code>...()</code> 等模式的字符串。</p>
</li>
</ol>
<p>这个错误提醒我，在动态规划问题中，即使大方向正确，状态转移方程中的一个小细节偏差也可能导致完全错误的结果。细心推导和验证每一种情况是解决复杂动态规划问题的关键。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>❌错题集</tag>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>字节面试：加了什么锁，导致死锁？</title>
    <url>/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1>字节面试：加了什么锁，导致死锁的？</h1>
<p>这是一个来自字节跳动面试的经典 MySQL 问题。面试官可能会这样提问：“在<strong>可重复读（Repeatable Read）隔离级别</strong>下，以下场景会发生什么情况？”</p>
<p>面试题中涉及一个名为 <code>students</code> 的表，其结构包含 <code>id</code> (主键), <code>no</code>, <code>name</code>, <code>age</code>, <code>score</code> 字段。为了便于实验和分析，我们接下来将使用一个结构相同但表名为 <code>t_student</code> 的表。<br>
<code>students</code> (即我们实验中的 <code>t_student</code>) 表的初始数据大致如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>no</th>
<th>name</th>
<th>age</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>S0001</td>
<td>Bob</td>
<td>25</td>
<td>34</td>
</tr>
<tr>
<td>18</td>
<td>S0002</td>
<td>Alice</td>
<td>24</td>
<td>77</td>
</tr>
<tr>
<td>20</td>
<td>S0003</td>
<td>Jim</td>
<td>24</td>
<td>5</td>
</tr>
<tr>
<td>30</td>
<td>S0004</td>
<td>Eric</td>
<td>23</td>
<td>91</td>
</tr>
<tr>
<td>37</td>
<td>S0005</td>
<td>Tom</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>49</td>
<td>S0006</td>
<td>Tom</td>
<td>25</td>
<td>83</td>
</tr>
<tr>
<td>50</td>
<td>S0007</td>
<td>Rose</td>
<td>23</td>
<td>89</td>
</tr>
</tbody>
</table>
<p>在此场景中，有两个并发事务正在执行：</p>
<ul>
<li><strong>事务 A</strong> 按顺序执行以下操作：
<ol>
<li><code>time1</code>: <code>UPDATE students SET score=100 WHERE id=25;</code></li>
<li><code>time3</code>: <code>INSERT INTO students(id, no, name, age, score) VALUES (25, 's0025', 'sony', 28, 90);</code></li>
</ol>
</li>
<li><strong>事务 B</strong> 按顺序执行以下操作：
<ol>
<li><code>time2</code>: <code>UPDATE students SET score=100 WHERE id=26;</code></li>
<li><code>time4</code>: <code>INSERT INTO students(id, no, name, age, score) VALUES (26, 's0026', 'ace', 28, 90);</code></li>
</ol>
</li>
</ul>
<p>如果对 MySQL 加锁机制比较熟悉，可能一眼就能看出这个场景下<strong>会发生死锁</strong>。但更进一步的问题是：具体是加了什么锁？这些锁之间是如何相互作用最终导致死锁的？</p>
<p>接下来，本文将详细分析上述两个事务在执行 SQL 语句的过程中，分别获取了哪些锁，以及这些锁是如何一步步导致死锁的。</p>
<h2 id="准备工作">准备工作</h2>
<p>先创建一张 t_student 表，假设除了 id 字段，其他字段都是普通字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `t_student` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `<span class="keyword">no</span>` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `score` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>
<p>然后，插入相关的数据后，t_student 表中的记录如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>no</th>
<th>name</th>
<th>age</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>S0001</td>
<td>Bob</td>
<td>25</td>
<td>34</td>
</tr>
<tr>
<td>18</td>
<td>S0002</td>
<td>Alice</td>
<td>24</td>
<td>77</td>
</tr>
<tr>
<td>20</td>
<td>S0003</td>
<td>Jim</td>
<td>24</td>
<td>5</td>
</tr>
<tr>
<td>30</td>
<td>S0004</td>
<td>Eric</td>
<td>23</td>
<td>91</td>
</tr>
<tr>
<td>37</td>
<td>S0005</td>
<td>Tom</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>49</td>
<td>S0006</td>
<td>Tom</td>
<td>25</td>
<td>83</td>
</tr>
<tr>
<td>50</td>
<td>S0007</td>
<td>Rose</td>
<td>23</td>
<td>89</td>
</tr>
</tbody>
</table>
<h2 id="开始实验">开始实验</h2>
<p>在实验开始前，先说明下实验环境：</p>
<ul>
<li>MySQL 版本：8.0.26</li>
<li>隔离级别：可重复读（RR）</li>
</ul>
<p>启动两个事务，按照题目的 SQL 执行顺序，过程如下表格：</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/1747568234814.png" alt="1747568234814"></p>
<p>可以看到，事务 A 和 事务 B 都在执行 insert 语句后，都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。（注意：在 MySQL 默认配置下，死锁检测是开启的。如果开启，其中一个事务（通常是持有锁较少或回滚代价较小的那个）会被选中作为牺牲者并回滚，同时向客户端返回死锁错误，例如 <code>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code>。本文描述两个事务都陷入等待是为了清晰展示死锁形成的完整过程。）</p>
<h2 id="为什么会发生死锁？">为什么会发生死锁？</h2>
<p>我们可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁。</p>
<p>接下来，针对每一条 SQL 语句分析具体加了什么锁。</p>
<h3 id="Time-1-阶段加锁分析">Time 1 阶段加锁分析</h3>
<p>Time 1 阶段，事务 A 执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_student <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后执行 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务 A 此时加了什么锁。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/1747568246886.png" alt="1747568246886"></p>
<p>从上图可以看到，共加了两个锁，分别是：</p>
<ul>
<li>表级锁：一个 X 类型的意向锁 (IX lock)。这是因为事务需要在表中的行上加 X 锁（无论是记录锁还是间隙锁），所以先在表上加 IX 锁。</li>
<li>行级锁：一个 X 类型的间隙锁 (Gap Lock)；</li>
</ul>
<p>这里我们重点关注行锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p>
<ul>
<li>如果 LOCK_MODE 为 <code>X</code>，说明是 next-key 锁；</li>
<li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是记录锁；</li>
<li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是间隙锁；</li>
</ul>
<p><strong>因此，此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加的是 X 型间隙锁，锁范围是<code>(20, 30)</code></strong>。</p>
<blockquote>
<p>间隙锁的范围<code>(20, 30)</code> ，是怎么确定的？</p>
</blockquote>
<p>当 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件（如 <code>id = 25</code>）没有命中任何现有记录时，在可重复读隔离级别下，InnoDB 会为了防止幻读而加上间隙锁。<br>
该间隙锁的范围确定方式如下：</p>
<ul>
<li><code>LOCK_DATA</code> (在此例中为 <code>30</code>) 通常表示该间隙锁范围的右边界（不包含）。这是因为 <code>id=30</code> 是主键索引中大于 <code>25</code> 的第一条记录。</li>
<li>间隙锁范围的左边界（不包含）则是主键索引中小于 <code>25</code> 的最大一条记录的 <code>id</code> 值，即 <code>20</code>。<br>
所以，形成的间隙为 <code>(20, 30)</code>。这个锁确保了在 <code>id</code> 值为 20 和 30 之间的这个区间，没有新的记录可以被插入，从而保证了事务 A 的可重复读。</li>
</ul>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/1748172465154.png" alt="1748172465154"></p>
<p>因此，间隙锁的范围是 <code>(20, 30)</code>。</p>
<h3 id="Time-2-阶段加锁分析">Time 2 阶段加锁分析</h3>
<p>Time 2 阶段，事务 B 执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 B</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_student <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后执行 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务 B 此时加了什么锁。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/1747568314475.png" alt="1747568314475"></p>
<p>从上图可以看到，行锁是 X 类型的间隙锁，间隙锁的范围是<code>(20, 30)</code>。</p>
<blockquote>
<p>事务 A 和 事务 B 的间隙锁范围都是一样的，为什么不会冲突？</p>
</blockquote>
<p>两个事务的间隙锁之间是相互兼容的，不会产生冲突。</p>
<p>在 MySQL 官网上还有一段非常关键的描述：</p>
<p><em>Gap locks in InnoDB are “purely inhibitive”, which means that their only purpose is to prevent other transactions from Inserting to the gap. Gap locks can co-exist. A gap lock taken by one transaction does not prevent another transaction from taking a gap lock on the same gap. There is no difference between shared and exclusive gap locks. They do not conflict with each other, and they perform the same function.</em></p>
<p><strong>间隙锁的意义只在于阻止区间被插入</strong>，因此是可以共存的。<strong>一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁</strong>，共享（S 型）和排他（X 型）的间隙锁是没有区别的，他们相互不冲突，且功能相同。</p>
<h3 id="Time-3-阶段加锁分析">Time 3 阶段加锁分析</h3>
<p>Time 3，事务 A 插入了一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="type">Time</span> <span class="number">3</span> 阶段，事务 A 插入了一条记录</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t_student(id, <span class="keyword">no</span>, name, age,score) <span class="keyword">value</span> (<span class="number">25</span>, <span class="string">&#x27;S0025&#x27;</span>, <span class="string">&#x27;sony&#x27;</span>, <span class="number">28</span>, <span class="number">90</span>);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> 阻塞等待......</span><br></pre></td></tr></table></figure>
<p>此时，事务 A 就陷入了等待状态。</p>
<p>然后执行 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务 A 在获取什么锁而导致被阻塞。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/1747568326650.png" alt="1747568326650"></p>
<p>可以看到，事务 A 的状态为等待状态（LOCK_STATUS: WAITING）。这是因为它试图在 <code>id=25</code> 的位置插入记录，该位置位于事务 B 持有的间隙锁 <code>(20, 30)</code> 范围内。为了执行插入，事务 A 需要获取一个插入意向锁。然而，<strong>插入意向锁与另一个事务持有的间隙锁是冲突的</strong>。因此，事务 A 的插入操作被阻塞，等待事务 B 释放其在 <code>(20, 30)</code> 上的间隙锁。此时，事务 A 自身也持有 <code>(20,30)</code> 的间隙锁。</p>
<blockquote>
<p>插入意向锁是什么？</p>
</blockquote>
<p>注意！插入意向锁名字里虽然有意向锁这三个字，但是它并不是意向锁，它属于行级锁，是一种特殊的间隙锁。</p>
<p>在 MySQL 的官方文档中有以下重要描述：</p>
<p><em>An Insert intention lock is a type of gap lock set by Insert operations prior to row Insertion. This lock signals the intent to Insert in such a way that multiple transactions Inserting into the same index gap need not wait for each other if they are not Inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to Insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with Insert intention locks prior to obtaining the exclusive lock on the Inserted row, but do not block each other because the rows are nonconflicting.</em></p>
<p>这段话表明尽管<strong>插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：<strong>尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的</strong>。</p>
<p>另外，我补充一点，插入意向锁的生成时机：</p>
<ul>
<li>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），现象就是 Insert 语句会被阻塞。</li>
</ul>
<h3 id="Time-4-阶段加锁分析">Time 4 阶段加锁分析</h3>
<p>Time 4，事务 B 插入了一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="type">Time</span> <span class="number">4</span> 阶段，事务 B 插入了一条记录</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t_student(id, <span class="keyword">no</span>, name, age,score) <span class="keyword">value</span> (<span class="number">26</span>, <span class="string">&#x27;S0026&#x27;</span>, <span class="string">&#x27;ace&#x27;</span>, <span class="number">28</span>, <span class="number">90</span>);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> 阻塞等待......</span><br></pre></td></tr></table></figure>
<p>此时，事务 B 就陷入了等待状态。</p>
<p>然后执行 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务 B 在获取什么锁而导致被阻塞。</p>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/1747568340862.png" alt="1747568340862"></p>
<p>可以看到，事务 B 也因尝试获取插入意向锁而被阻塞（LOCK_STATUS: WAITING）。事务 B 试图在 <code>id=26</code> 的位置插入记录，该位置同样位于事务 A 持有的间隙锁 <code>(20, 30)</code> 范围内。与事务 A 的情况类似，事务 B 的插入操作需要获取插入意向锁，而这个锁与事务 A 持有的间隙锁 <code>(20, 30)</code> 冲突。因此，事务 B 等待事务 A 释放其间隙锁。</p>
<blockquote>
<p>最后回答，为什么会发生死锁？</p>
</blockquote>
<p>死锁的发生是因为两个事务形成了循环等待资源。具体分析如下：</p>
<ol>
<li>
<p><strong>初始状态</strong>：</p>
<ul>
<li>事务 A 执行 <code>UPDATE ... WHERE id = 25</code>，未找到记录，获得了间隙锁 G_A 对 <code>(20, 30)</code>。</li>
<li>事务 B 执行 <code>UPDATE ... WHERE id = 26</code>，未找到记录，获得了间隙锁 G_B 对 <code>(20, 30)</code>。</li>
<li>间隙锁之间是兼容的，所以事务 A 和 B 此时都成功持有各自的间隙锁。</li>
</ul>
</li>
<li>
<p><strong>事务 A 尝试插入</strong>：</p>
<ul>
<li>事务 A 执行 <code>INSERT INTO t_student VALUES (25, ...)</code>。</li>
<li>为了插入 <code>id=25</code>，事务 A 需要获取一个插入意向锁 (II_A) 作用于 <code>id=25</code> 所在的位置。</li>
<li>这个位置 <code>id=25</code> 位于事务 B 持有的间隙锁 G_B <code>(20, 30)</code> 范围内。</li>
<li>插入意向锁 II_A 与其他事务持有的间隙锁 G_B 冲突。</li>
<li>因此，事务 A 等待事务 B 释放间隙锁 G_B。</li>
</ul>
</li>
<li>
<p><strong>事务 B 尝试插入</strong>：</p>
<ul>
<li>事务 B 执行 <code>INSERT INTO t_student VALUES (26, ...)</code>。</li>
<li>为了插入 <code>id=26</code>，事务 B 需要获取一个插入意向锁 (II_B) 作用于 <code>id=26</code> 所在的位置。</li>
<li>这个位置 <code>id=26</code> 位于事务 A 持有的间隙锁 G_A <code>(20, 30)</code> 范围内。</li>
<li>插入意向锁 II_B 与其他事务持有的间隙锁 G_A 冲突。</li>
<li>因此，事务 B 等待事务 A 释放间隙锁 G_A。</li>
</ul>
</li>
<li>
<p><strong>循环等待</strong>：</p>
<ul>
<li>事务 A 持有 G_A，等待 G_B。</li>
<li>事务 B 持有 G_B，等待 G_A。</li>
<li>这就构成了循环等待，满足了死锁的条件（互斥、占有并等待、不可抢占、循环等待），因此发生死锁。</li>
</ul>
</li>
</ol>
<p>简而言之，两个事务都先获取了相同范围的间隙锁（这是允许的），然后又都试图在这个被对方锁定的间隙内插入数据，从而需要获取插入意向锁。由于插入意向锁与对方的间隙锁冲突，导致了相互等待。</p>
<h2 id="总结">总结</h2>
<p>两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</p>
<p>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</p>
<p>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</p>
<h2 id="读者问答">读者问答</h2>
<p><img src="/2025/05/18/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95-%E5%8A%A0%E4%BA%86%E4%BB%80%E4%B9%88%E9%94%81%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81/1747568351456.png" alt="1747568351456"></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>死锁</tag>
        <tag>锁</tag>
        <tag>字节跳动</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 416 - 分割等和子集 (Partition Equal Subset Sum)</title>
    <url>/2025/05/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个<strong>只包含正整数</strong>的非空数组 <code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这个问题可以转化为一个经典的组合优化问题：<strong>0/1 背包问题</strong>。</p>
<p>首先，计算整个数组的总和 <code>sum</code>。如果 <code>sum</code> 是奇数，那么不可能将数组分割成两个元素和相等的子集，因为两个子集的和必须都是 <code>sum / 2</code>，而 <code>sum / 2</code> 必须是整数。因此，如果 <code>sum</code> 为奇数，直接返回 <code>false</code>。</p>
<p>如果 <code>sum</code> 是偶数，设目标和 <code>target = sum / 2</code>。问题就转化为：能否从数组 <code>nums</code> 中选取若干个元素，使得这些元素的和恰好等于 <code>target</code>？</p>
<p>这就可以看作是一个 0/1 背包问题：</p>
<ul>
<li><strong>背包的容量 (W)</strong>：<code>target</code></li>
<li><strong>物品的重量 (weight[i])</strong>：数组中的每个元素 <code>nums[i]</code></li>
<li><strong>物品的价值 (value[i])</strong>：同样是数组中的每个元素 <code>nums[i]</code> (因为我们关心的是和，所以重量和价值是相同的)</li>
<li><strong>问题</strong>：能否恰好装满容量为 <code>target</code> 的背包？</li>
</ul>
<p>我们定义一个动态规划数组 <code>dp</code>，其中 <code>dp[j]</code> 表示是否存在一种选取方式，使得选取的元素之和等于 <code>j</code>。<code>dp[j]</code> 是一个布尔值，<code>true</code> 表示存在，<code>false</code> 表示不存在。</p>
<p><strong>状态定义：</strong><br>
<code>dp[j]</code>：表示从数组 <code>nums</code> 中选取元素，是否存在一个子集的和恰好为 <code>j</code>。</p>
<p><strong>状态转移方程：</strong><br>
对于数组中的每个元素 <code>num</code> (即 <code>nums[i]</code>)，我们需要更新 <code>dp</code> 数组。<br>
遍历 <code>dp</code> 数组时，为了确保每个元素只被使用一次（0/1 背包的特性），我们需要从后往前遍历 <code>j</code> (从 <code>target</code> 到 <code>num</code>)。</p>
<p>对于当前的元素 <code>num</code> 和当前的和 <code>j</code>：</p>
<ul>
<li>如果不选取 <code>num</code>，那么 <code>dp[j]</code> 的值保持不变，即 <code>dp[j]</code>。</li>
<li>如果选取 <code>num</code> (前提是 <code>j &gt;= num</code>)，那么我们需要看 <code>dp[j - num]</code> 是否为 <code>true</code>。如果 <code>dp[j - num]</code> 为 <code>true</code>，表示在不包含当前 <code>num</code> 的情况下，已经可以凑成 <code>j - num</code>，那么加上 <code>num</code> 之后就可以凑成 <code>j</code>。</li>
</ul>
<p>所以，状态转移方程为：<br>
<code>dp[j] = dp[j] || dp[j - num]</code> (当 <code>j &gt;= num</code> 时)</p>
<p><strong>初始化：</strong><br>
<code>dp[0] = true</code>，因为不选取任何元素时，和为 0，这是肯定可以达成的。<br>
其余 <code>dp[j]</code> (j &gt; 0) 初始化为 <code>false</code>。</p>
<p><strong>遍历顺序：</strong></p>
<ol>
<li>外层循环遍历数组 <code>nums</code> 中的每个元素 <code>num</code>。</li>
<li>内层循环遍历背包容量 <code>j</code>，从 <code>target</code> 向下到 <code>num</code> (确保每个物品只用一次)。</li>
</ol>
<p><strong>最终结果：</strong><br>
遍历完所有元素后，<code>dp[target]</code> 的值就是最终答案。如果 <code>dp[target]</code> 为 <code>true</code>，则可以分割成两个和相等的子集；否则，不可以。</p>
<h2 id="推导过程">推导过程</h2>
<p>假设 <code>nums = [1, 5, 11, 5]</code></p>
<ol>
<li>计算总和 <code>sum = 1 + 5 + 11 + 5 = 22</code>。</li>
<li><code>sum</code> 是偶数，<code>target = sum / 2 = 11</code>。</li>
<li>初始化 <code>dp</code> 数组，长度为 <code>target + 1 = 12</code>。<br>
<code>dp = [true, false, false, false, false, false, false, false, false, false, false, false]</code><br>
(<code>dp[0] = true</code>)</li>
</ol>
<p><strong>遍历 <code>nums</code>:</strong></p>
<p><strong>1. <code>num = 1</code>:</strong><br>
内层循环 <code>j</code> 从 <code>11</code> 到 <code>1</code>：</p>
<ul>
<li><code>j = 11</code>: <code>dp[11] = dp[11] || dp[11-1] = false || dp[10] = false</code></li>
<li><code>j = 10</code>: <code>dp[10] = dp[10] || dp[10-1] = false || dp[9] = false</code></li>
<li>…</li>
<li><code>j = 1</code>: <code>dp[1] = dp[1] || dp[1-1] = false || dp[0] = false || true = true</code><br>
<code>dp</code> 变为: <code>[true, true, false, false, false, false, false, false, false, false, false, false]</code></li>
</ul>
<p><strong>2. <code>num = 5</code>:</strong><br>
内层循环 <code>j</code> 从 <code>11</code> 到 <code>5</code>：</p>
<ul>
<li><code>j = 11</code>: <code>dp[11] = dp[11] || dp[11-5] = false || dp[6]</code> (此时 <code>dp[6]</code> 还是 <code>false</code>) <code>= false</code></li>
<li><code>j = 10</code>: <code>dp[10] = dp[10] || dp[10-5] = false || dp[5]</code> (此时 <code>dp[5]</code> 还是 <code>false</code>) <code>= false</code></li>
<li>…</li>
<li><code>j = 6</code>: <code>dp[6] = dp[6] || dp[6-5] = false || dp[1] = false || true = true</code></li>
<li><code>j = 5</code>: <code>dp[5] = dp[5] || dp[5-5] = false || dp[0] = false || true = true</code><br>
<code>dp</code> 变为: <code>[true, true, false, false, false, true, true, false, false, false, false, false]</code> (dp[1], dp[5], dp[6] 为 true)</li>
</ul>
<p><strong>3. <code>num = 11</code>:</strong><br>
内层循环 <code>j</code> 从 <code>11</code> 到 <code>11</code>：</p>
<ul>
<li><code>j = 11</code>: <code>dp[11] = dp[11] || dp[11-11] = false || dp[0] = false || true = true</code><br>
<code>dp</code> 变为: <code>[true, true, false, false, false, true, true, false, false, false, false, true]</code> (dp[1], dp[5], dp[6], dp[11] 为 true)</li>
</ul>
<p><strong>4. <code>num = 5</code> (第二个 5):</strong><br>
内层循环 <code>j</code> 从 <code>11</code> 到 <code>5</code>：</p>
<ul>
<li><code>j = 11</code>: <code>dp[11]</code> 已经是 <code>true</code>。<code>dp[11] = dp[11] || dp[11-5] = true || dp[6] = true || true = true</code></li>
<li><code>j = 10</code>: <code>dp[10] = dp[10] || dp[10-5] = false || dp[5] = false || true = true</code></li>
<li><code>j = 9</code>: <code>dp[9] = dp[9] || dp[9-5] = false || dp[4]</code> (此时 <code>dp[4]</code> 为 <code>false</code>) <code>= false</code></li>
<li><code>j = 8</code>: <code>dp[8] = dp[8] || dp[8-5] = false || dp[3]</code> (此时 <code>dp[3]</code> 为 <code>false</code>) <code>= false</code></li>
<li><code>j = 7</code>: <code>dp[7] = dp[7] || dp[7-5] = false || dp[2]</code> (此时 <code>dp[2]</code> 为 <code>false</code>) <code>= false</code></li>
<li><code>j = 6</code>: <code>dp[6]</code> 已经是 <code>true</code>。<code>dp[6] = dp[6] || dp[6-5] = true || dp[1] = true || true = true</code></li>
<li><code>j = 5</code>: <code>dp[5]</code> 已经是 <code>true</code>。<code>dp[5] = dp[5] || dp[5-5] = true || dp[0] = true || true = true</code></li>
</ul>
<p>After this iteration, <code>dp</code> might look like:<br>
<code>dp[0]=true</code> (initial)<br>
<code>dp[1]=true</code> (from num=1)<br>
<code>dp[5]=true</code> (from first num=5)<br>
<code>dp[6]=true</code> (from first num=5 + num=1)<br>
<code>dp[10]=true</code> (from second num=5 + first num=5)<br>
<code>dp[11]=true</code> (from num=11 or from second num=5 + dp[6])</p>
<p>最终 <code>dp[11]</code> 为 <code>true</code>。所以返回 <code>true</code>。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filepath: /Users/adrianwang/.leetcode/416.分割等和子集.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=416 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [416] 分割等和子集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		total += num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果总和是奇数，则不可能分割成两个和相等的子集</span></span><br><span class="line">	<span class="keyword">if</span> total%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	half := total / <span class="number">2</span></span><br><span class="line">	<span class="comment">// dp[i] 表示是否存在和为 i 的子集</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">bool</span>, half+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 和为0的子集总是存在的（即空集）</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0/1 背包问题</span></span><br><span class="line">	<span class="comment">// 外层循环遍历物品（数组中的数字）</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="comment">// 内层循环遍历背包容量（目标和），必须从大到小，保证每个物品只用一次</span></span><br><span class="line">		<span class="keyword">for</span> j := half; j &gt;= num; j-- &#123;</span><br><span class="line">			<span class="comment">// 对于当前数字 num，如果 dp[j-num] 为 true（即存在和为 j-num 的子集）</span></span><br><span class="line">			<span class="comment">// 那么加上 num 之后，就存在和为 j 的子集</span></span><br><span class="line">			<span class="comment">// 或者，如果 dp[j] 本身已经是 true（不包含当前 num 时已经可以凑成 j），则保持 true</span></span><br><span class="line">			dp[j] = dp[j] || dp[j-num]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[half]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>: O(n * target)，其中 <code>n</code> 是数组 <code>nums</code> 的长度，<code>target</code> 是数组总和的一半。我们需要遍历每个数字，并对每个数字更新 <code>dp</code> 数组中最多 <code>target</code> 个状态。</li>
<li><strong>空间复杂度</strong>: O(target)，<code>dp</code> 数组的大小为 <code>target + 1</code>。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li>识别问题是否可以转化为背包问题是解决这类动态规划问题的关键。</li>
<li>0/1 背包问题的核心在于每个物品只能选择一次，这通常通过内层循环逆序遍历容量来实现。</li>
<li>动态规划的状态定义和状态转移方程是解题的核心。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 300: 最长递增子序列 - 动态规划与贪心优化</title>
    <url>/2025/05/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<p>输入：<code>nums = [10,9,2,5,3,7,101,18]</code><br>
输出：<code>4</code><br>
解释：最长递增子序列是 <code>[2,3,7,101]</code>，因此长度为 4 。</p>
<p><strong>示例 2：</strong></p>
<p>输入：<code>nums = [0,1,0,3,2,3]</code><br>
输出：<code>4</code></p>
<p><strong>示例 3：</strong></p>
<p>输入：<code>nums = [7,7,7,7,7,7,7]</code><br>
输出：<code>1</code></p>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="方法一：动态规划-Dynamic-Programming">方法一：动态规划 (Dynamic Programming)</h3>
<p>这是解决 LIS (Longest Increasing Subsequence) 问题的经典方法。</p>
<p><strong>核心思想：</strong></p>
<p>我们定义 <code>dp[i]</code> 为以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度。<br>
为了计算 <code>dp[i]</code>，我们需要遍历 <code>i</code> 之前的所所有元素 <code>nums[j]</code> (其中 <code>0 &lt;= j &lt; i</code>)：</p>
<ul>
<li>如果 <code>nums[i] &gt; nums[j]</code>，说明 <code>nums[i]</code> 可以接在以 <code>nums[j]</code> 结尾的递增子序列之后，形成一个更长的递增子序列。此时，这个新的递增子序列的长度就是 <code>dp[j] + 1</code>。</li>
<li>如果 <code>nums[i] &lt;= nums[j]</code>，则 <code>nums[i]</code> 不能接在 <code>nums[j]</code> 之后形成严格递增子序列。</li>
</ul>
<p>因此，<code>dp[i]</code> 的值应该是所有满足 <code>nums[i] &gt; nums[j]</code> 的 <code>dp[j] + 1</code> 中的最大值。如果没有任何 <code>j</code> 满足条件（例如 <code>nums[i]</code> 是当前所有数字中最小的），那么 <code>dp[i]</code> 就是 1（即 <code>nums[i]</code> 自身构成一个子序列）。</p>
<p><strong>状态转移方程：</strong></p>
<p><code>dp[i] = max(dp[j]) + 1</code>，其中 <code>0 ≤ j &lt; i</code> 且 <code>nums[i] &gt; nums[j]</code>。<br>
如果不存在这样的 <code>j</code>，则 <code>dp[i] = 1</code>。</p>
<p><strong>初始化：</strong></p>
<p><code>dp</code> 数组中所有元素的初始值都为 1，因为每个元素本身至少可以构成一个长度为 1 的递增子序列。</p>
<p><strong>最终结果：</strong></p>
<p>遍历整个 <code>dp</code> 数组，其中的最大值即为整个数组的最长递增子序列的长度。因为 LIS 可能以任何元素结尾。</p>
<h4 id="代码实现-Go">代码实现 (Go)</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// max 返回两个整数中的较大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lengthOfLIS 使用动态规划计算最长递增子序列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS_dp</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="comment">// dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 dp 数组，每个元素自身构成长度为 1 的递增子序列</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充 dp 数组</span></span><br><span class="line">	<span class="comment">// i 从第 1 个元素开始（索引 0 已经初始化为 1）</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 遍历 i 之前的所有元素 j</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="comment">// 如果 nums[i] 大于 nums[j]，说明 nums[i] 可以接在 nums[j] 后面</span></span><br><span class="line">			<span class="keyword">if</span> nums[i] &gt; nums[j] &#123;</span><br><span class="line">				<span class="comment">// 更新 dp[i]，取当前 dp[i] 和 dp[j]+1 中的较大值</span></span><br><span class="line">				dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到 dp 数组中的最大值，即为整个序列的 LIS 长度</span></span><br><span class="line">	maxLength := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		maxLength = max(maxLength, dp[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析">复杂度分析</h4>
<ul>
<li><strong>时间复杂度：</strong> <code>O(n^2)</code>。我们有两个嵌套循环，外层循环 <code>n</code> 次，内层循环平均 <code>n/2</code> 次。</li>
<li><strong>空间复杂度：</strong> <code>O(n)</code>。需要一个 <code>dp</code> 数组来存储中间状态。</li>
</ul>
<h3 id="方法二：贪心-二分查找">方法二：贪心 + 二分查找</h3>
<p>这种方法更为高效，可以将时间复杂度优化到 <code>O(n log n)</code>。</p>
<p><strong>核心思想：</strong></p>
<p>我们维护一个数组 <code>tails</code>（或者叫 <code>min_end_elements_of_lis_with_length_k</code>），其中 <code>tails[k]</code> 存储的是所有长度为 <code>k+1</code> 的递增子序列中，末尾元素的最小值。这个 <code>tails</code> 数组一定是严格递增的。</p>
<p><strong>证明 <code>tails</code> 数组的单调性：</strong><br>
假设 <code>tails[k]</code> (长度为 <code>k+1</code> 的 LIS 的最小末尾) &gt;= <code>tails[k+1]</code> (长度为 <code>k+2</code> 的 LIS 的最小末尾)。<br>
这意味着存在一个长度为 <code>k+2</code> 的 LIS，其末尾元素 <code>tails[k+1]</code> 小于等于 长度为 <code>k+1</code> 的 LIS 的最小末尾元素 <code>tails[k]</code>。<br>
那么这个长度为 <code>k+2</code> 的 LIS 的前 <code>k+1</code> 个元素构成的子序列，其末尾元素一定小于 <code>tails[k+1]</code>，也就小于等于 <code>tails[k]</code>。这与 <code>tails[k]</code> 是长度为 <code>k+1</code> 的 LIS 的最小末尾元素矛盾。<br>
所以 <code>tails</code> 数组必须是严格递增的。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>
<p>初始化一个空数组 <code>tails</code>。这个数组将用来存储我们构建的最长递增子序列（或者更准确地说，是各长度递增子序列的最小末尾元素）。</p>
</li>
<li>
<p>遍历输入数组 <code>nums</code> 中的每个元素 <code>num</code>：</p>
<ul>
<li><strong>情况 1：</strong> 如果 <code>num</code> 大于 <code>tails</code> 数组中的所有元素（即 <code>num &gt; tails[len(tails)-1]</code>，如果 <code>tails</code> 非空），或者 <code>tails</code> 为空，那么 <code>num</code> 可以扩展当前最长的递增子序列。我们将 <code>num</code> 添加到 <code>tails</code> 的末尾。这表示我们找到了一个更长的递增子序列。</li>
<li><strong>情况 2：</strong> 如果 <code>num</code> 不大于 <code>tails</code> 中的所有元素，这意味着 <code>num</code> 不能直接扩展当前已知的最长递增子序列。但是，<code>num</code> 可能可以替换 <code>tails</code> 数组中某个元素，形成一个长度相同但末尾元素更小的递增子序列。<br>
我们使用二分查找，在 <code>tails</code> 数组中找到第一个大于或等于 <code>num</code> 的元素 <code>tails[j]</code>，然后用 <code>num</code> 替换 <code>tails[j]</code>。<br>
这样做的意义是：我们发现了一个可以构成长度为 <code>j+1</code> 的递增子序列，并且其末尾元素是 <code>num</code>（比原来的 <code>tails[j]</code> 更小或相等）。这为后续元素提供了更多可能性（因为末尾元素越小，越容易接上新元素）。</li>
</ul>
</li>
<li>
<p>遍历完成后，<code>tails</code> 数组的长度就是整个序列的最长递增子序列的长度。</p>
</li>
</ol>
<p><strong>为什么这种方法有效？</strong><br>
<code>tails</code> 数组的长度 <code>len</code> 始终代表当前已发现的 LIS 的长度。<br>
当我们用 <code>num</code> 替换 <code>tails[j]</code> 时，我们并没有改变 LIS 的长度，而是优化了构成长度为 <code>j+1</code> 的 LIS 的条件（使其末尾元素更小）。如果 <code>num</code> 大于 <code>tails</code> 的所有元素，我们就增加 LIS 的长度。<br>
这个过程保证了 <code>tails</code> 数组始终存储着在当前遍历进度下，构建不同长度递增子序列的&quot;最优&quot;（即末尾元素最小）选择。</p>
<h4 id="代码实现-Go-2">代码实现 (Go)</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// lengthOfLIS 使用贪心 + 二分查找计算最长递增子序列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS_greedy_binary_search</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tails[i] 表示长度为 i+1 的所有递增子序列中，末尾元素的最小值</span></span><br><span class="line">	tails := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="comment">// 如果 tails 为空，或者 num 大于 tails 中最后一个元素</span></span><br><span class="line">		<span class="comment">// 则 num 可以扩展当前最长的递增子序列</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(tails) == <span class="number">0</span> || num &gt; tails[<span class="built_in">len</span>(tails)<span class="number">-1</span>] &#123;</span><br><span class="line">			tails = <span class="built_in">append</span>(tails, num)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 否则，在 tails 数组中找到第一个大于或等于 num 的元素，并替换它</span></span><br><span class="line">			<span class="comment">// 这意味着我们找到了一个长度相同的递增子序列，但其末尾元素更小</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 二分查找：在 tails 数组中找到 num 的插入位置</span></span><br><span class="line">			<span class="comment">// 目的是找到最小的 j 使得 tails[j] &gt;= num</span></span><br><span class="line">			left, right := <span class="number">0</span>, <span class="built_in">len</span>(tails)<span class="number">-1</span></span><br><span class="line">			pos := right <span class="comment">// 如果 num 比 tails 所有元素都小，则替换 tails[0]</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">				mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">				<span class="keyword">if</span> tails[mid] &gt;= num &#123;</span><br><span class="line">					pos = mid <span class="comment">// 找到了一个可能的替换位置</span></span><br><span class="line">					right = mid - <span class="number">1</span> <span class="comment">// 尝试在左半部分找更小的索引</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					left = mid + <span class="number">1</span> <span class="comment">// num 较大，需要在右半部分找</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tails[pos] = num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// tails 数组的长度即为最长递增子序列的长度</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(tails)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析-2">复杂度分析</h4>
<ul>
<li><strong>时间复杂度：</strong> <code>O(n log n)</code>。外层循环遍历 <code>nums</code> 数组需要 <code>n</code> 次，内层二分查找操作需要 <code>log k</code> 次，其中 <code>k</code> 是 <code>tails</code> 数组的当前长度（<code>k &lt;= n</code>）。</li>
<li><strong>空间复杂度：</strong> <code>O(n)</code>。最坏情况下，<code>tails</code> 数组可能存储所有 <code>n</code> 个元素（例如当 <code>nums</code> 本身就是严格递增的时候）。</li>
</ul>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th style="text-align:left">方面</th>
<th style="text-align:left">动态规划 (DP)</th>
<th style="text-align:left">贪心 + 二分查找</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">时间复杂度</td>
<td style="text-align:left"><code>O(n^2)</code></td>
<td style="text-align:left"><code>O(n log n)</code></td>
</tr>
<tr>
<td style="text-align:left">空间复杂度</td>
<td style="text-align:left"><code>O(n)</code></td>
<td style="text-align:left"><code>O(n)</code></td>
</tr>
<tr>
<td style="text-align:left">实现难度</td>
<td style="text-align:left">相对简单，易于理解</td>
<td style="text-align:left">稍复杂，需要理解贪心思想和二分查找的应用</td>
</tr>
<tr>
<td style="text-align:left">优点</td>
<td style="text-align:left">思路直接</td>
<td style="text-align:left">效率更高</td>
</tr>
<tr>
<td style="text-align:left">缺点</td>
<td style="text-align:left">效率较低，大数据量下可能超时</td>
<td style="text-align:left">理解起来不如DP直观</td>
</tr>
<tr>
<td style="text-align:left">推荐度</td>
<td style="text-align:left">★★★☆☆</td>
<td style="text-align:left">★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ul>
<li><strong>动态规划</strong>是解决 LIS 问题的基础方法，理解 <code>dp[i]</code> 的定义（以 <code>nums[i]</code> 结尾的 LIS 长度）是关键。</li>
<li><strong>贪心 + 二分查找</strong> 提供了一种更优的解决方案。核心在于维护 <code>tails</code> 数组，它存储了不同长度递增子序列的最小末尾元素。这种策略确保我们总是在为未来留下最好的可能性。</li>
<li>对于子序列问题，动态规划是一个常见的思考方向。当 DP 出现平方复杂度时，可以考虑是否有贪心策略或者数据结构（如二分查找、树状数组、线段树）可以优化。</li>
</ul>
<p>这道题是理解动态规划和序列问题优化的一个很好的例子。两种方法都值得掌握。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 139. 单词拆分：小白也能看懂的动态规划解法</title>
    <url>/2025/05/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-139-Word-Break/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个非空字符串 <code>s</code> 和一个包含非空单词列表的字典 <code>wordDict</code>，判定 <code>s</code> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>字典中的单词可以重复使用。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅有小写英文字母组成</li>
<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<h2 id="思路分析：动态规划">思路分析：动态规划</h2>
<p>这道题是典型的可以使用动态规划（Dynamic Programming, DP）解决的问题。当我们判断一个较长的字符串是否能被拆分时，其结果可以依赖于其较短的前缀子串是否能被拆分。这种具有&quot;最优子结构&quot;和&quot;重叠子问题&quot;特征的问题，通常是 DP 的用武之地。</p>
<h3 id="1-定义状态-DP-数组">1. 定义状态 (DP 数组)</h3>
<p>我们定义一个布尔类型的数组 <code>dp</code>，其中 <code>dp[i]</code> 表示字符串 <code>s</code> 的<strong>前 <code>i</code> 个字符</strong>（即子串 <code>s[0...i-1]</code>，注意是长度为 <code>i</code> 的前缀）是否可以被成功拆分成字典中的单词。<br>
数组的长度设为 <code>n+1</code>，其中 <code>n</code> 是字符串 <code>s</code> 的长度。</p>
<ul>
<li><code>dp[0]</code>：代表空字符串。我们定义它为 <code>true</code>，因为空字符串可以被&quot;拆分&quot;（不包含任何单词，或者说，它本身就是一个合法的拆分起点）。这是动态规划非常重要的<strong>初始条件</strong>或<strong>基本情况 (base case)</strong>。</li>
<li><code>dp[1]</code>：代表 <code>s[0...0]</code> (即 <code>s</code> 的第一个字符组成的子串) 是否可以被拆分。</li>
<li>…</li>
<li><code>dp[i]</code>：代表 <code>s[0...i-1]</code> (即 <code>s</code> 的前 <code>i</code> 个字符组成的子串) 是否可以被拆分。</li>
<li><code>dp[n]</code>：代表 <code>s[0...n-1]</code> (即整个字符串 <code>s</code>) 是否可以被拆分。这就是我们最终要求的目标。</li>
</ul>
<h3 id="2-状态转移方程">2. 状态转移方程</h3>
<p>现在，我们来思考如何计算 <code>dp[i]</code> 的值。<br>
要判断 <code>s</code> 的前 <code>i</code> 个字符 <code>s[0...i-1]</code> 能否被拆分，我们可以尝试将其拆分成两部分：<br>
<code>s[0...i-1] = s[0...j-1] + s[j...i-1]</code></p>
<p>其中，<code>j</code> 是一个分割点，<code>0 &lt;= j &lt; i</code>。</p>
<ul>
<li><code>s[0...j-1]</code>：这是字符串 <code>s</code> 的前 <code>j</code> 个字符。它能否被拆分，对应的是 <code>dp[j]</code> 的值。</li>
<li><code>s[j...i-1]</code>：这是从索引 <code>j</code> 开始，到索引 <code>i-1</code> 结束的子串。我们需要判断这个子串本身是否存在于我们的 <code>wordDict</code> 字典中。</li>
</ul>
<p>如果存在一个 <code>j</code> ( <code>0 &lt;= j &lt; i</code> )，使得 <code>dp[j]</code> 为 <code>true</code> (即 <code>s</code> 的前 <code>j</code> 个字符可以被拆分)，<strong>并且</strong>子串 <code>s[j...i-1]</code> 是字典 <code>wordDict</code> 中的一个单词，那么我们就可以断定 <code>s</code> 的前 <code>i</code> 个字符 <code>s[0...i-1]</code> 是可以被成功拆分的。此时，<code>dp[i]</code> 就应该为 <code>true</code>。</p>
<p>所以，状态转移方程可以表示为：<br>
<code>dp[i] = OR (dp[j] &amp;&amp; wordDict.contains(s[j...i-1]))</code> 对于所有 <code>0 &lt;= j &lt; i</code>。</p>
<p>用更易懂的语言来说：<code>dp[i]</code> 为真，当且仅当，存在一个 <code>j</code>（<code>j</code> 在 <code>0</code> 和 <code>i-1</code> 之间），使得 <code>dp[j]</code> 为真，并且从 <code>j</code> 到 <code>i-1</code> 的那段子字符串 <code>s[j:i]</code> 正好是字典里的一个单词。</p>
<p>只要我们能找到<strong>任何一个</strong>这样的 <code>j</code>，<code>dp[i]</code> 就可以被设置为 <code>true</code>，然后我们就可以停止对当前 <code>i</code> 的检查（因为已经找到一种拆分方法了）。</p>
<h3 id="3-初始化">3. 初始化</h3>
<ul>
<li><code>dp[0] = true</code>：如前所述，这是基础情况。</li>
<li><code>dp</code> 数组的其他所有元素（<code>dp[1]</code> 到 <code>dp[n]</code>）在开始计算前，可以默认为 <code>false</code>。</li>
</ul>
<h3 id="4-遍历顺序">4. 遍历顺序</h3>
<ul>
<li>外层循环：我们需要计算 <code>dp[1], dp[2], ..., dp[n]</code>。所以 <code>i</code> 从 <code>1</code> 遍历到 <code>n</code>。</li>
<li>内层循环：对于每一个 <code>dp[i]</code>，我们需要尝试所有可能的分割点 <code>j</code>。所以 <code>j</code> 从 <code>0</code> 遍历到 <code>i-1</code>。</li>
</ul>
<h3 id="举个例子">举个例子</h3>
<p>让我们用 <code>s = &quot;leetcode&quot;</code>, <code>wordDict = [&quot;leet&quot;, &quot;code&quot;]</code> 来模拟一下：</p>
<ul>
<li><code>n = 8</code> (字符串 “leetcode” 的长度)</li>
<li><code>dp</code> 数组大小为 <code>9</code> (<code>dp[0]</code> 到 <code>dp[8]</code>)</li>
<li><code>wordDictSet = &#123;&quot;leet&quot;: true, &quot;code&quot;: true&#125;</code> (为了快速查找，我们通常会把字典转成哈希集合)</li>
</ul>
<p><strong>初始化：</strong><br>
<code>dp[0] = true</code><br>
<code>dp[1...8]</code> 初始化为 <code>false</code></p>
<p><strong>计算 <code>dp[i]</code>:</strong></p>
<ul>
<li>
<p><strong>i = 1</strong> (<code>s[0:1]</code> = “l”):</p>
<ul>
<li><code>j = 0</code>: <code>dp[0]</code> (true) &amp;&amp; <code>wordDictSet[&quot;l&quot;]</code> (false)</li>
<li><code>dp[1]</code> = false</li>
</ul>
</li>
<li>
<p><strong>i = 2</strong> (<code>s[0:2]</code> = “le”):</p>
<ul>
<li><code>j = 0</code>: <code>dp[0]</code> (true) &amp;&amp; <code>wordDictSet[&quot;le&quot;]</code> (false)</li>
<li><code>j = 1</code>: <code>dp[1]</code> (false) &amp;&amp; <code>wordDictSet[&quot;e&quot;]</code> (false)</li>
<li><code>dp[2]</code> = false</li>
</ul>
</li>
<li>
<p><strong>i = 3</strong> (<code>s[0:3]</code> = “lee”):</p>
<ul>
<li>…</li>
<li><code>dp[3]</code> = false</li>
</ul>
</li>
<li>
<p><strong>i = 4</strong> (<code>s[0:4]</code> = “leet”):</p>
<ul>
<li><code>j = 0</code>: <code>dp[0]</code> (true) &amp;&amp; <code>wordDictSet[&quot;leet&quot;]</code> (true)  -&gt; 条件满足！</li>
<li><code>dp[4]</code> = true (跳出内层 j 的循环)</li>
</ul>
</li>
<li>
<p><strong>i = 5</strong> (<code>s[0:5]</code> = “leetc”):</p>
<ul>
<li><code>j = 0</code>: <code>dp[0]</code> (true) &amp;&amp; <code>wordDictSet[&quot;leetc&quot;]</code> (false)</li>
<li><code>j = 1</code>: <code>dp[1]</code> (false) &amp;&amp; <code>wordDictSet[&quot;eetc&quot;]</code> (false)</li>
<li>…</li>
<li><code>j = 4</code>: <code>dp[4]</code> (true) &amp;&amp; <code>wordDictSet[&quot;c&quot;]</code> (false)</li>
<li><code>dp[5]</code> = false</li>
</ul>
</li>
<li>
<p>… (以此类推)</p>
</li>
<li>
<p><strong>i = 8</strong> (<code>s[0:8]</code> = “leetcode”):</p>
<ul>
<li><code>j = 0</code>: <code>dp[0]</code> (true) &amp;&amp; <code>wordDictSet[&quot;leetcode&quot;]</code> (false)</li>
<li><code>j = 1</code>: …</li>
<li>…</li>
<li><code>j = 4</code>: <code>dp[4]</code> (true) &amp;&amp; <code>wordDictSet[s[4:8]]</code> (<code>wordDictSet[&quot;code&quot;]</code>) (true) -&gt; 条件满足！</li>
<li><code>dp[8]</code> = true (跳出内层 j 的循环)</li>
</ul>
</li>
</ul>
<p>最终，我们得到 <code>dp[8] = true</code>，这就是题目的答案。</p>
<h2 id="代码实现-Go">代码实现 (Go)</h2>
<p>下面是使用 Go 语言实现的 <code>wordBreak</code> 函数，其中包含了详细的注释。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc app=leetcode.cn id=139 lang=golang</span></span><br><span class="line"><span class="comment">// [139] 单词拆分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="type">string</span>, wordDict []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 将词典转换为哈希集合，方便快速查找单词是否存在</span></span><br><span class="line">	<span class="comment">// wordDictSet 用于存储词典中的所有单词。</span></span><br><span class="line">	<span class="comment">// 键是单词本身，值是布尔类型的 true，表示该单词在字典中。</span></span><br><span class="line">	<span class="comment">// 使用 map (哈希表) 实现集合，可以使得查找单词的平均时间复杂度为 O(L)，其中 L 是单词长度。</span></span><br><span class="line">	wordDictSet := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123; <span class="comment">// 遍历词典中的每个单词 word</span></span><br><span class="line">		wordDictSet[word] = <span class="literal">true</span> <span class="comment">// 将单词 word 添加到哈希集合中</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := <span class="built_in">len</span>(s) <span class="comment">// 获取输入字符串 s 的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 定义 DP 数组</span></span><br><span class="line">	<span class="comment">// dp[i] 表示字符串 s 的前 i 个字符 (即子串 s[0...i-1]) </span></span><br><span class="line">	<span class="comment">// 是否可以被词典中的单词成功拆分。</span></span><br><span class="line">	<span class="comment">// dp 数组的大小为 n+1，索引从 0 到 n。</span></span><br><span class="line">	<span class="comment">// dp[0] 对应空字符串。</span></span><br><span class="line">	<span class="comment">// dp[n] 对应整个字符串 s。</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">bool</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 初始化 DP 数组</span></span><br><span class="line">	<span class="comment">// dp[0] = true，因为空字符串总是可以被&quot;拆分&quot;的，这是动态规划的基础。</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 状态转移：填充 DP 数组</span></span><br><span class="line">	<span class="comment">// 外层循环 i 从 1 到 n。dp[i] 对应 s 的前 i 个字符 (s[0...i-1])。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		<span class="comment">// 内层循环 j 从 0 到 i-1。j 是一个潜在的分割点。</span></span><br><span class="line">		<span class="comment">// 我们尝试将 s[0...i-1] 分割为 s[0...j-1] 和 s[j...i-1]。</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="comment">// s[j:i] 在 Go 中表示从索引 j (包含) 到索引 i (不包含) 的子串，</span></span><br><span class="line">			<span class="comment">// 也就是我们上面分析的 s[j...i-1]。</span></span><br><span class="line">			<span class="comment">// 检查两个条件：</span></span><br><span class="line">			<span class="comment">// 1. dp[j] is true: 字符串 s 的前 j 个字符 s[0...j-1] 可以被拆分。</span></span><br><span class="line">			<span class="comment">// 2. wordDictSet[s[j:i]] is true: 子串 s[j...i-1] 是字典中的一个单词。</span></span><br><span class="line">			<span class="keyword">if</span> dp[j] &amp;&amp; wordDictSet[s[j:i]] &#123;</span><br><span class="line">				dp[i] = <span class="literal">true</span> <span class="comment">// 如果两个条件都满足，则 s 的前 i 个字符 s[0...i-1] 可以被拆分。</span></span><br><span class="line">				<span class="keyword">break</span>        <span class="comment">// 已经找到了一个有效的拆分方式，无需继续检查其他分割点 j，跳出内层循环。</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 返回结果</span></span><br><span class="line">	<span class="comment">// dp[n] 存储了整个字符串 s (即 s[0...n-1]) 是否可以被拆分的结果。</span></span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度：</strong> <code>O(n^3)</code></p>
<ul>
<li>我们有两层嵌套循环：外层循环 <code>i</code> 从 <code>1</code> 到 <code>n</code>，内层循环 <code>j</code> 从 <code>0</code> 到 <code>i-1</code>。这部分是 <code>O(n^2)</code> 次迭代。</li>
<li>在内层循环中，我们执行了 <code>s[j:i]</code> 来获取子串，并在 <code>wordDictSet</code> 中查找它。</li>
<li>在 Go 中，字符串切片 <code>s[j:i]</code> 的操作本身是 <code>O(1)</code> 的，因为它创建的是一个指向原始字符串数据的视图，并不复制字符数据。</li>
<li>哈希表（<code>map</code>）查找一个字符串 <code>key</code> 的平均时间复杂度是 <code>O(length of key)</code>。在这里，<code>key</code> 是子串 <code>s[j:i]</code>，其长度最大可以达到 <code>i</code>，也就是 <code>O(n)</code>。</li>
<li>因此，内层循环中的操作 <code>wordDictSet[s[j:i]]</code> 最坏情况下是 <code>O(n)</code>。</li>
<li>所以总的时间复杂度是 <code>O(n^2 * n) = O(n^3)</code>。</li>
<li>更精确地写出推导过程：<br>
[ T(n) = \sum_{i=1}^{n} \sum_{j=0}^{i-1} O(i-j) ]<br>
其中 ( O(i-j) ) 是查找长度为 ( i-j ) 的子串的成本。<br>
[ T(n) = \sum_{i=1}^{n} \sum_{k=1}^{i} O(k) = \sum_{i=1}^{n} O(i^2) = O(n^3) ]</li>
</ul>
</li>
<li>
<p><strong>空间复杂度：</strong> <code>O(n + M)</code></p>
<ul>
<li><code>dp</code> 数组：需要 <code>O(n)</code> 的空间，其中 <code>n</code> 是字符串 <code>s</code> 的长度。</li>
<li><code>wordDictSet</code> 哈希集合：需要存储字典中的所有单词。如果字典中有 <code>k</code> 个单词，平均长度为 <code>L</code>，那么空间复杂度是 <code>O(k * L)</code>。在题目约束下，<code>wordDict.length &lt;= 1000</code>, <code>wordDict[i].length &lt;= 20</code>，所以 <code>M</code> 最大约为 <code>1000 * 20</code>。通常我们把这个表示为 <code>O(M)</code>，其中 <code>M</code> 是字典中所有字符的总数。</li>
<li>所以总空间复杂度是 <code>O(n + M)</code>。</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li><strong>动态规划的识别</strong>：当问题可以分解为具有重叠性质的子问题，并且子问题的解可以用来构建原问题的解时，考虑使用动态规划。</li>
<li><strong>DP 状态定义</strong>：清晰地定义 <code>dp[i]</code> 的含义至关重要。在这里，<code>dp[i]</code> 代表&quot;字符串的前 <code>i</code> 个字符是否可分&quot;。</li>
<li><strong>Base Case (初始条件)</strong>：<code>dp[0] = true</code> 是本题 DP 能够正确递推的关键。</li>
<li><strong>状态转移</strong>：仔细思考如何从已知的子问题解（例如 <code>dp[j]</code>）推导出当前问题解（例如 <code>dp[i]</code>）。</li>
<li><strong>数据结构辅助</strong>：将 <code>wordDict</code> 转换为哈希集合 <code>wordDictSet</code> 是一个常见的优化技巧，可以将单词查找时间从 <code>O(num_words_in_dict * word_length)</code>（如果线性扫描列表）降低到平均 <code>O(word_length)</code>。</li>
</ul>
<p>这道&quot;单词拆分&quot;问题是动态规划在字符串处理中的一个经典应用，理解它有助于掌握 DP 的基本思想。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>❌错题集</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 152 - 乘积最大子数组 (Maximum Product Subarray)</title>
    <url>/2025/05/17/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>
<p><strong>约束条件:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 的任何前缀或后缀的乘积都保证是一个 32-位 整数。</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题可以使用动态规划来解决。我们需要维护两个变量：到当前位置为止的最大乘积和最小乘积。</p>
<p>为什么需要维护最小乘积呢？因为当遇到一个负数时，之前的最小乘积乘以这个负数可能会变成最大乘积，同样，之前的最大乘积乘以这个负数可能会变成最小乘积。</p>
<p>我们定义 <code>maxDp[i]</code> 为以 <code>nums[i]</code> 结尾的连续子数组的最大乘积，<code>minDp[i]</code> 为以 <code>nums[i]</code> 结尾的连续子数组的最小乘积。</p>
<p>状态转移方程如下：</p>
<ul>
<li><code>maxDp[i] = max(nums[i], nums[i] * maxDp[i-1], nums[i] * minDp[i-1])</code></li>
<li><code>minDp[i] = min(nums[i], nums[i] * maxDp[i-1], nums[i] * minDp[i-1])</code></li>
</ul>
<p>最终的结果是所有 <code>maxDp[i]</code> 中的最大值。</p>
<p>为了优化空间复杂度，我们可以注意到 <code>maxDp[i]</code> 和 <code>minDp[i]</code> 只依赖于 <code>maxDp[i-1]</code> 和 <code>minDp[i-1]</code>，因此我们可以使用滚动数组的思想，只用两个变量来存储前一个状态的最大和最小乘积。</p>
<h2 id="实现细节">实现细节</h2>
<p>我们初始化 <code>maxProductSoFar</code> 和 <code>minProductSoFar</code> 为 <code>nums[0]</code>，同时初始化 <code>maxAns</code> 为 <code>nums[0]</code>。<br>
然后从数组的第二个元素开始遍历：<br>
对于每个元素 <code>nums[i]</code>：</p>
<ol>
<li>计算当前的 <code>currentMax = max(nums[i], nums[i] * prevMax, nums[i] * prevMin)</code></li>
<li>计算当前的 <code>currentMin = min(nums[i], nums[i] * prevMax, nums[i] * prevMin)</code></li>
<li>更新 <code>maxAns = max(maxAns, currentMax)</code></li>
<li>更新 <code>prevMax = currentMax</code>，<code>prevMin = currentMin</code></li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=152 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [152] 乘积最大子数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxDp := nums[<span class="number">0</span>] <span class="comment">// 以当前元素结尾的最大乘积</span></span><br><span class="line">	minDp := nums[<span class="number">0</span>] <span class="comment">// 以当前元素结尾的最小乘积</span></span><br><span class="line">	maxAns := nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 当 nums[i] &lt; 0 时，最大值和最小值会互换</span></span><br><span class="line">		<span class="comment">// 所以需要一个临时变量存储之前的 maxDp</span></span><br><span class="line">		prevMaxDp := maxDp</span><br><span class="line">		maxDp = maxx(nums[i], nums[i]*maxDp, nums[i]*minDp)</span><br><span class="line">		minDp = minn(nums[i], nums[i]*prevMaxDp, nums[i]*minDp) <span class="comment">// 注意这里用 prevMaxDp</span></span><br><span class="line">		maxAns = max(maxAns, maxDp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxAns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxx</span><span class="params">(a ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	maxAns := a[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; maxAns &#123;</span><br><span class="line">			maxAns = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxAns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minn</span><span class="params">(a ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	minAns := a[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> v &lt; minAns &#123;</span><br><span class="line">			minAns = v</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minAns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一 (动态规划)</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$ (使用滚动变量优化后)</td>
</tr>
<tr>
<td>优点</td>
<td>思路清晰，易于理解和实现</td>
</tr>
<tr>
<td>缺点</td>
<td>需要注意负数带来的影响</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>: $O(n)$，其中 $n$ 是数组 <code>nums</code> 的长度。我们只需要遍历数组一次。</li>
<li><strong>空间复杂度</strong>: $O(1)$。我们只使用了常数个变量来存储中间结果。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li>动态规划问题中，状态的定义至关重要。</li>
<li>处理乘积问题时，需要特别注意负数的影响，负负得正可能使得一个很小的负数变成一个很大的正数。</li>
<li>维护最大值的同时，往往也需要维护最小值，以应对负数的情况。</li>
<li>空间复杂度可以通过滚动数组或只保留前一个状态的方式进行优化。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 死锁了，怎么办？</title>
    <url>/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<h1>MySQL 死锁了，怎么办？</h1>
<p>在数据库的世界里，“死锁&quot;是个时不时会出来捣乱的家伙。简单来说，就是两个或多个操作互相等着对方手里的&quot;东西”（比如数据），结果谁也动不了，像交通堵塞一样卡住了。这篇文章，我们就通过一个订单系统的实际例子，聊聊死锁是怎么发生的，以及怎么尽量避免它。</p>
<p>想象一下，我们的系统里有新增、修改、查询订单这些功能。为了保证每个订单都是独一无二的（比如防止用户手快，重复提交了同一个订单），我们通常会在创建新订单前做个&quot;幂等性校验&quot;。常规操作是：先用 <code>select ... for update</code> 语句查一下这个订单号是不是已经存在了。这个 <code>for update</code> 很关键，它会尝试暂时&quot;锁定&quot;我们要检查的订单号（或者它可能存在的位置），目的是防止在我们检查和插入的短暂间隙，有其他操作也来插同一个订单号。如果查下来发现订单不存在，我们才真正动手插入这条新订单记录。</p>
<p>听起来挺稳妥，对吧？但在业务量一大，并发操作（很多用户同时操作）一多的时候，这种做法有时就会不小心触发死锁。</p>
<p>别担心，下面我们就一步步拆解<strong>死锁是怎么来的，以及有哪些招数可以对付它</strong>。</p>
<h2 id="死锁的发生">死锁的发生</h2>
<p>本次案例我们用的是 MySQL 数据库，存储引擎是 InnoDB（一种常用的数据&quot;仓库管理员&quot;），事务的隔离级别设定为可重复读（Repeatable Read, RR，一种事务处理规则，保证在同一个事务里多次读取同样的数据，结果是一致的）。</p>
<p>接下来，我用实际操作带大家看看死锁是怎么发生的。</p>
<p>我建了一张订单表 <code>t_order</code>，结构如下，其中 <code>id</code> 字段是主键（唯一标识一条记录），<code>order_no</code> 字段建了个普通索引（非唯一索引，可以加快按订单号查询的速度）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `t_order` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `order_no` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  KEY `index_order` (`order_no`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB ;</span><br></pre></td></tr></table></figure>
<p>然后，<code>t_order</code> 表里现在已经有了 6 条记录：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>order_no</th>
<th>create_date</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1001</td>
<td>2021-12-28 13:59:07</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>2021-12-28 13:59:14</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>2021-12-28 13:59:21</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>2021-12-28 13:59:30</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>2021-12-28 13:59:36</td>
</tr>
<tr>
<td>6</td>
<td>1006</td>
<td>2021-12-28 14:24:33</td>
</tr>
</tbody>
</table>
<p>假设这时有两个事务（可以理解为两个独立的业务操作流程），一个事务（我们叫它事务A）要插入订单号为 1007 的订单，另一个事务（事务B）要插入订单号为 1008 的订单。因为需要对订单做幂等性校验，所以两个事务都会先查询对应的订单是否存在，如果不存在才插入记录。过程如下：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747411836905.png" alt="1747411836905"></p>
<p>上图的操作中，如果数据库没有开启死锁检测机制（或者检测需要时间），你就会看到，两个事务都卡住了，陷入了相互等待对方释放锁的状态，这就是死锁。</p>
<p>这里在查询订单是否存在时，我们特意用了 <code>select ... for update</code> 语句。它的主要目的是&quot;占位&quot;，即在当前事务检查和插入订单的这个过程中，防止其他事务也来插入相同的订单号，或者影响到我们正在判断的这个&quot;空位&quot;。如果不用它，就可能出现&quot;幻读&quot;（Phantom Read）的问题——比如我们刚查完发现订单1007不存在，正准备插入，结果另一个事务抢先一步插了1007，导致我们后续操作出错，或者最终系统里有了两条订单1007。如下图所示：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747411844244.png" alt="1747411844244"></p>
<h2 id="为什么会产生死锁？">为什么会产生死锁？</h2>
<p>前面提到，<code>select ... for update</code> 是为了防止幻读。在MySQL的InnoDB存储引擎和&quot;可重复读&quot;（RR）这个事务隔离级别下，为了从根本上解决幻读问题（即在一个事务中，前后两次执行同样的查询，结果集却不一致，像出现了&quot;幽灵&quot;数据一样），引入了一种特殊的锁机制，叫做 <strong>next-key 锁</strong>。你可以把它理解成一种组合锁，它包含了两种锁的功能：</p>
<ul>
<li>Record Lock（记录锁）：顾名思义，就是直接锁住某条具体的记录本身。</li>
<li>Gap Lock（间隙锁）：它锁的不是某条具体的记录，而是记录与记录之间的&quot;空档&quot;或&quot;缝隙&quot;。比如，如果你的表里有订单号1005和1009，间隙锁就能锁住1005和1009之间的这个范围，防止其他事务在这中间插入新的订单号（比如1007）。这样就避免了你在这个事务里前后两次查询，发现中间突然多出来一条记录的幻读情况。</li>
</ul>
<p>通常，我们执行普通的 <code>select</code> 语句是不会加锁的（它通过一种叫做MVCC的机制来实现&quot;快照读&quot;，保证可重复读）。如果想在查询时就给记录加上行锁（一种针对数据行的锁），可以用下面这两种方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>; <span class="comment">-- 开始事务</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 对读取的记录加共享锁 (S锁)</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 提交事务，锁被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>; <span class="comment">-- 开始事务</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 对读取的记录加排他锁 (X锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>; <span class="comment">-- 提交事务，锁被释放</span></span><br></pre></td></tr></table></figure>
<p>要注意，行锁通常是在整个事务提交（commit）或回滚（rollback）后才会被释放，并不是某一条SQL语句执行完就立刻放锁。</p>
<p>举个例子，下面事务A的查询语句会锁住订单号大于2的范围，即 <code>(2, +∞]</code> 这个区间。在事务A提交前，如果有其他事务想在这个锁住的范围里插入数据，就会被阻塞。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747411854584.png" alt="1747411854584"></p>
<p>next-key 锁的加锁规则其实挺复杂的，在某些特定场景下它可能会&quot;退化&quot;成单纯的记录锁或间隙锁。我之前也写过一篇专门讲加锁规则的文章，想深入了解的同学可以看看：<a href="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/">MySQL 是怎么加锁的？</a></p>
<p>这里有个非常重要提醒：如果你的 <code>update</code> 语句的 <code>where</code> 条件没有用到索引列，MySQL就不得不做全表扫描。在扫描过程中，它不仅会给每一行记录都加上行锁，还会给记录两边的空隙都加上间隙锁。这相当于把整张表都锁了！直到事务结束这些锁才会被释放。所以，<strong>在线上系统千万别执行没有带索引条件的 <code>update</code> 语句</strong>，否则可能导致业务大面积停顿。我有个读者就因为这么干了，结果被老板狠狠地&quot;教育&quot;了一番，详情可以看这篇：<a href="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8/">update 没加索引会锁全表？</a></p>
<p>好了，让我们回到前面那个死锁的例子。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747411865196.png" alt="1747411865196"></p>
<p>当事务A执行这条语句时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t_order <span class="keyword">where</span> order_no <span class="operator">=</span> <span class="number">1007</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行SQL过程中具体加了哪些锁。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747411875923.png" alt="1747411875923"></p>
<p>从上图可以看到，事务A主要加了两种锁：</p>
<ul>
<li>表锁：一个X类型的意向锁（IX锁，表示事务准备在表里的某些行上加X锁）。</li>
<li>行锁：一个X类型的next-key锁。</li>
</ul>
<p>我们重点关注行锁。图中 <code>LOCK_TYPE</code> 的 <code>RECORD</code> 表示这是一个行级锁（不是特指记录锁）。具体是next-key锁、间隙锁还是记录锁，需要看 <code>LOCK_MODE</code>：</p>
<ul>
<li><code>X</code>：表示X型的next-key锁。</li>
<li><code>X, REC_NOT_GAP</code>：表示X型的记录锁。</li>
<li><code>X, GAP</code>：表示X型的间隙锁。</li>
</ul>
<p><strong>因此，此时事务A在 <code>order_no</code> 这个二级索引（<code>INDEX_NAME : index_order</code>）上加的是X型的next-key锁，锁定的范围是 <code>(1006, +∞]</code></strong>。这里的1006是执行这条查询时，<code>t_order</code> 表中 <code>order_no</code> 列上小于1007且最接近1007的值（如果表里有小于1007的，就是那个最大的；如果没有，可能会是更小的一个范围起点）。由于1006是当时表里最大的订单号，所以 <code>(1006, +∞]</code> 锁住了从1006订单号之后的所有可能间隙，一直到表尾。</p>
<blockquote>
<p>next-key 锁的范围 (1006, +∞]，是怎么确定的？</p>
<p>根据我的经验，如果 <code>LOCK_MODE</code> 显示是next-key锁或者间隙锁，那么 <code>LOCK_DATA</code> 通常表示这个锁范围的最右边的那个值。在事务A的例子里，<code>LOCK_DATA</code> 是 <code>supremum pseudo-record</code>，这代表的是正无穷大（<code>+∞</code>）。而锁范围的最左边的值，则是 <code>t_order</code> 表中，在 <code>order_no</code> 索引上，小于我们查询值（1007）的那个最大值，也就是1006。因此，事务A的next-key锁锁定的就是 <code>(1006, +∞]</code> 这个开区间。</p>
</blockquote>
<div class="note warning">
            <p>有的读者可能会问，我在<a href="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/">MySQL 是怎么加锁的？</a>这篇文章里讲到，当在非唯一索引上进行等值查询，并且查询的记录不存在时，next-key lock会退化成间隙锁。那为什么上面事务A的next-key lock没有退化呢？</p><p>这里的关键在于查询的值（1007）与索引中已存在的值的相对位置。</p><ul><li>如果表中 <code>order_no</code> 索引的最大值是1006（如此案例），然后我们查询 <code>order_no = 1007</code>（一个不存在且大于所有现有值的记录），此时加的是next-key lock，范围是 <code>(1006, +∞]</code>，它不会退化。</li><li>但如果表中 <code>order_no</code> 索引的最大值是1010，我们查询 <code>order_no = 1007</code>（一个不存在但在现有值之间的记录），此时next-key lock会锁定 <code>(1006, 1010]</code> 这个区间（假设1006是小于1007的最大值），然后它会退化成一个间隙锁，锁住 <code>(1006, 1010)</code> 这个间隙。如下图所示：</li></ul><p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747411917531.png" alt="1747411917531"></p>
          </div>
<p>当事务B想要在事务A的next-key锁范围 <code>(1006, +∞]</code> 里插入订单号为1008的记录时，它就会被卡住：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Insert into</span> t_order (order_no, create_date) <span class="keyword">values</span> (<span class="number">1008</span>, now()); <span class="comment">-- 事务B的操作</span></span><br></pre></td></tr></table></figure>
<p>这是因为，当一个事务（比如事务B）尝试向一个间隙中插入数据时，它需要先获得一种叫做<strong>插入意向锁</strong>（Insert Intention Lock）的&quot;许可&quot;。</p>
<p>关键点来了：</p>
<ol>
<li><strong>插入意向锁 与 (其他事务持有的)间隙锁 是冲突的</strong>：如果事务A的next-key锁（它包含了一个间隙锁）已经锁住了事务B想插入的那个&quot;缝隙&quot;，那么事务B就必须等待事务A把这个间隙锁放掉，才能拿到自己的插入意向锁。</li>
<li><strong>间隙锁 与 (其他事务持有的)间隙锁 是兼容的</strong>：这就是为什么一开始两个事务都能成功执行 <code>select ... for update</code> 语句。它们各自获取的next-key锁虽然都覆盖了 <code>(1006, +∞]</code> 这个范围，但它们所包含的间隙锁部分并不会互相&quot;打架&quot;。多个事务可以同时拥有覆盖相同间隙的间隙锁。</li>
</ol>
<p>所以，死锁的剧本是这样的：</p>
<ul>
<li>事务A执行 <code>select ... for update where order_no = 1007;</code>，成功获得了覆盖 <code>(1006, +∞]</code> 范围的next-key锁（这个锁里包含了间隙锁成分）。</li>
<li>事务B执行 <code>select ... for update where order_no = 1008;</code>，也成功获得了覆盖 <code>(1006, +∞]</code> 范围的next-key锁（同样包含间隙锁，并且与事务A的间隙锁兼容）。</li>
<li>现在，事务A想插入订单1007。它需要获取插入意向锁。但这个位置（或者说这个意图）与事务B持有的 <code>(1006, +∞]</code> 间隙锁冲突了，所以事务A开始等待事务B释放锁。</li>
<li>同时，事务B想插入订单1008。它也需要获取插入意向锁。同样，这个意图与事务A持有的 <code>(1006, +∞]</code> 间隙锁冲突了，所以事务B也开始等待事务A释放锁。</li>
</ul>
<p>看，它们互相等待对方手里的&quot;钥匙&quot;，谁也动不了，死锁就这么华丽丽地发生了。</p>
<blockquote>
<p>为什么间隙锁与间隙锁之间是兼容的？</p>
<p>MySQL官方文档有这么一段描述（我翻译并提炼一下）：</p>
<p><em>“InnoDB中的间隙锁是&quot;纯粹抑制性&quot;的，意思是它们唯一的作用就是阻止其他事务往这个间隙里插入数据。间隙锁可以共存。一个事务持有的间隙锁并不会阻止另一个事务在同一个间隙上持有间隙锁。共享间隙锁和排他间隙锁之间没有区别，它们互不冲突，并且功能相同。”</em></p>
<p>简单说，<strong>间隙锁的核心任务就是&quot;守住这块空地，不准别人进来盖房子（插入数据）&quot;</strong>。既然大家的目的都是守地，那就可以一起守，互不干扰。</p>
</blockquote>
<p>但是，这里要特别注意一点：<strong>next-key锁 = 记录锁 + 间隙锁</strong>。虽然间隙锁部分是兼容的，但如果两个next-key锁试图锁定的是同一个 <em>实际存在的记录</em>，那记录锁部分就可能会冲突了。比如，一个事务获取了某条记录的X型记录锁（包含在next-key锁里），另一个事务也想获取这条记录的X型记录锁，那就会被阻塞。</p>
<p>不过，在我们这个死锁案例中，两个事务的next-key锁 <code>(1006, +∞]</code> 都指向了一个&quot;无穷远&quot;的虚拟边界，并没有锁定同一个实际存在的记录。<code>+∞</code> 并不是一条真实的数据记录，所以它们在记录锁层面不会直接冲突。冲突主要来自于后续插入操作时，插入意向锁与对方间隙锁的矛盾。</p>
<blockquote>
<p>插入意向锁是什么？</p>
<p>注意！“插入意向锁&quot;虽然名字里带&quot;意向锁”，但它和我们常说的表级意向锁（如IX, IS）不是一回事。它其实是一种<strong>特殊类型的间隙锁</strong>。</p>
<p>MySQL官方文档是这么说的（同样，我来概括下）：</p>
<p><em>“插入意向锁是一种在行插入操作之前设置的间隙锁。这种锁表明了插入的&quot;意图”，使得多个事务如果不是在间隙中的完全相同位置插入数据，它们就不必互相等待。比如，有索引记录4和7。两个不同的事务分别尝试插入5和6，在真正获得插入行的排他锁之前，它们都会用插入意向锁来锁定4和7之间的间隙，但它们不会互相阻塞，因为插入的行是不冲突的。&quot;</em></p>
<p>这段话告诉我们：</p>
<ul>
<li>插入意向锁也是一种间隙锁，但它非常特殊，<strong>主要用于处理并发插入操作</strong>。</li>
<li>如果说普通的间隙锁锁住的是一个&quot;区间&quot;，那么<strong>插入意向锁更像是锁住一个&quot;点&quot;</strong>（即你打算插入的具体位置）。这可能是我能想到的最形象的比喻了。</li>
<li>插入意向锁和普通间隙锁的一个重要区别是：虽然它们都沾点&quot;间隙&quot;的边，但<strong>一个事务不能在持有普通间隙锁的同时，让另一个事务在该间隙内持有插入意向锁</strong>（除非插入意向锁的位置不在这个普通间隙锁的保护范围内）。这就是它们冲突的根源。</li>
</ul>
</blockquote>
<p>另外，我补充一点插入意向锁的生成时机：当一个事务准备插入一条新记录时，它会检查这条新记录紧邻的下一条索引记录上是否已经被其他事务加了间隙锁。如果加了，当前事务的插入操作就会生成一个插入意向锁，并且这个锁会进入等待状态（MySQL加锁时，是先创建锁结构，再设置锁的状态。等待状态意味着锁还没拿到手，事务会被阻塞），直到那个间隙锁被释放。</p>
<h2 id="Insert-语句是怎么加行级锁的？">Insert 语句是怎么加行级锁的？</h2>
<p>你可能会想，是不是每次<code>INSERT</code>一条记录，数据库都会马上给它上一堆锁呢？其实不一定。InnoDB有个聪明的机制叫做<strong>隐式锁</strong>。</p>
<blockquote>
<p>什么是隐式锁？</p>
<p>简单说，就是&quot;能不加锁就不加锁，除非万不得已&quot;。当插入一条新记录时，InnoDB并不会立刻给这条记录分配一个明确的锁结构（比如我们前面看到的那些记录锁、next-key锁）。它依赖记录本身的一些内部信息（比如一个隐藏的事务ID列 <code>trx_id</code>）来间接实现保护。只有在某些特殊情况，比如这条记录可能要和别的事务发生冲突了，这个&quot;隐形&quot;的锁才会转换成我们之前讨论的那些&quot;实体&quot;锁。这样做的好处是减少了不必要的锁开销，提高了并发性能。</p>
<p>那么，什么情况下隐式锁会&quot;现身&quot;变成显式锁呢？主要有两种场景：</p>
<ol>
<li><strong>要插入的地方已经被间隙锁&quot;封路&quot;了</strong>：如果其他事务用间隙锁锁住了你要插入记录的那个&quot;缝隙&quot;，那你这条<code>INSERT</code>语句就得等着，并且会尝试获取一个插入意向锁（此时隐式锁机制可能就不够用了，需要显式的锁介入）。</li>
<li><strong>插入的记录和已有记录的唯一键冲突了</strong>：比如你要插入一个主键已经存在的记录，或者一个唯一索引列已经有相同值的记录。这时，插入会失败，并且InnoDB会对那条已经存在的、造成冲突的记录加上一个S型的锁。</li>
</ol>
</blockquote>
<h3 id="1、记录之间加有间隙锁">1、记录之间加有间隙锁</h3>
<p>我们来看个例子。现在<code>t_order</code>表中只有以下数据，并且<code>order_no</code>是二级索引（非唯一）。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>order_no</th>
<th>create_date</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1001</td>
<td>(NULL)</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>(NULL)</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>(NULL)</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>(NULL)</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>(NULL)</td>
</tr>
</tbody>
</table>
<p>现在，事务A执行了下面这条语句，试图查询一个不存在的订单号1006并锁定它：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> order_no <span class="operator">=</span> <span class="number">1006</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec) <span class="comment">-- 查询结果为空，因为1006不存在</span></span><br></pre></td></tr></table></figure>
<p>我们用 <code>select * from performance_schema.data_locks\G;</code> 查一下事务A加了什么锁（只关注记录上的锁）：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412272712.png" alt="1747412272712"></p>
<p>可以看到，事务A在<code>order_no</code>索引上加了一个next-key锁，锁定的范围是 <code>(1005, +∞]</code>（因为1005是小于1006的最大值）。</p>
<p>然后，事务B尝试在这个被锁定的间隙中插入一条记录（订单号1010）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 B 插入一条记录</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t_order(order_no, create_date) <span class="keyword">values</span>(<span class="number">1010</span>,now());</span><br><span class="line">### 阻塞状态。。。。</span><br></pre></td></tr></table></figure>
<p>事务B的<code>INSERT</code>语句被阻塞了。我们再查一下事务B的锁信息：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412280944.png" alt="1747412280944"></p>
<p>事务B的状态是 <code>WAITING</code>（等待）。它试图获取一个 <code>X,INSERT_INTENTION</code>（X型插入意向锁），但由于它想插入的位置（1010）落在了事务A持有的next-key锁范围 <code>(1005, +∞]</code> 内，所以它必须等待。</p>
<h3 id="2、遇到唯一键冲突">2、遇到唯一键冲突</h3>
<p>如果在插入新记录时，发现新纪录的某个唯一键（主键或唯一二级索引）的值与已存在的记录重复了，插入操作会失败。并且，InnoDB还会对那条已经存在的、导致冲突的记录加上一个<strong>S型（共享型）的锁</strong>。</p>
<p>具体加的是S型记录锁还是S型next-key锁，会根据冲突的是主键还是唯一二级索引，以及当前的事务隔离级别有所不同：</p>
<ul>
<li>
<p><strong>如果主键值重复</strong>：</p>
<ul>
<li>在**读已提交（Read Committed, RC）**隔离级别下，插入事务会给已存在的主键重复的聚簇索引记录（即数据行本身）添加 <strong>S型记录锁</strong>。</li>
<li>在**可重复读（Repeatable Read, RR）**隔离级别下（MySQL默认），同样是添加 <strong>S型记录锁</strong>。</li>
</ul>
</li>
<li>
<p><strong>如果唯一二级索引列的值重复</strong>：</p>
<ul>
<li><strong>无论是在RC还是RR隔离级别下</strong>，插入事务都会给已存在的、二级索引值重复的二级索引记录添加 <strong>S型next-key锁</strong>。是的，你没看错，即使是读已提交隔离级别，这里也会加next-key锁（包含间隙锁成分）。这算是RC隔离级别下一个比较特殊的、会使用间隙锁的场景。至于为什么这么设计，我暂时还没找到官方的明确解释。</li>
</ul>
</li>
</ul>
<h4 id="主键索引冲突">主键索引冲突</h4>
<p>我们来看个主键冲突的例子。MySQL 8.0版本，事务隔离级别为可重复读（RR）。<br>
<code>t_order</code> 表的 <code>id</code> 字段是主键。假设表里已经有一条 <code>id</code> 为 5 的记录。现在一个事务尝试插入一条新的 <code>id</code> 为 5 的记录，这必然会失败，并报告主键冲突错误。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412292466.png" alt="1747412292466"></p>
<p>除了报错，数据库还做了一件重要的事情：它给原来那条 <code>id</code> 为 5 的记录加上了一个<strong>S型的记录锁</strong>。<br>
我们可以通过 <code>select * from performance_schema.data_locks\G;</code> 确认这一点：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412298840.png" alt="1747412298840"></p>
<p>看到没？<code>LOCK_DATA</code> 是 5（表示主键值为5的记录），<code>LOCK_MODE</code> 是 <code>S, REC_NOT_GAP</code>（S型记录锁）。</p>
<p>所以，在RR隔离级别下，如果插入数据时发生主键冲突，插入事务会给那条已经存在的、主键值相同的记录上一个S型记录锁。</p>
<h4 id="唯一二级索引冲突">唯一二级索引冲突</h4>
<p>再来看唯一二级索引冲突的例子。同样是MySQL 8.0，RR隔离级别。<br>
假设 <code>t_order</code> 表的 <code>order_no</code> 字段现在是一个唯一二级索引，并且表里已经有一条 <code>order_no</code> 为 1001 的记录。事务A尝试插入一条新的 <code>order_no</code> 也为 1001 的记录，同样会报错。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412314882.png" alt="1747412314882"></p>
<p>除了报错，数据库这时会对 <code>order_no</code> 值为 1001 的那条二级索引记录加上一个<strong>S型的next-key锁</strong>。<br>
查看锁信息：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412321985.png" alt="1747412321985"></p>
<p>可以看到，在 <code>index_order</code> 这个二级索引上，<code>LOCK_MODE</code> 是 <code>S</code>（表示S型next-key锁），它锁定的范围大致是 <code>(-∞, 1001]</code> （具体范围取决于1001之前的值）。</p>
<p>如果这时，另一个事务B想对 <code>order_no = 1001</code> 的记录执行 <code>select ... for update</code>（即想给它加X型锁），事务B就会被阻塞，因为X型锁和S型锁是冲突的。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412342011.png" alt="1747412342011"></p>
<p>查看事务B的锁状态，会发现它在等待一个X型的记录锁 (<code>LOCK_MODE: X,REC_NOT_GAP</code>)，状态是 <code>WAITING</code>。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412349198.png" alt="1747412349198"></p>
<h4 id="两个事务插入相同的唯一二级索引记录">两个事务插入相同的唯一二级索引记录</h4>
<p>接下来，我们分析一个更有意思的场景：两个事务先后尝试插入具有相同唯一二级索引值的记录。<br>
假设 <code>t_order</code> 表中目前的数据如下，并且 <code>order_no</code> 是唯一二级索引。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>order_no</th>
<th>create_date</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1001</td>
<td>(NULL)</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>(NULL)</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>(NULL)</td>
</tr>
<tr>
<td>4</td>
<td>1004</td>
<td>(NULL)</td>
</tr>
<tr>
<td>5</td>
<td>1005</td>
<td>(NULL)</td>
</tr>
</tbody>
</table>
<p>在RR隔离级别下，事务A先执行插入，然后事务B也执行相同的插入语句。这时，<strong>事务B的INSERT语句会被阻塞</strong>。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412382887.png" alt="1747412382887"></p>
<p>这两个事务的加锁过程是这样的：</p>
<ol>
<li><strong>事务A</strong>插入 <code>order_no</code> 为 1006 的记录。由于这是个新记录，并且没有违反唯一性约束（假设此时还没有1006），插入成功。这条新插入的记录的唯一二级索引（<code>order_no = 1006</code>）此时受到&quot;隐式锁&quot;的保护。在这个阶段，如果去查 <code>performance_schema.data_locks</code>，通常看不到这条记录有显式的锁结构。</li>
<li><strong>事务B</strong>也尝试插入 <code>order_no</code> 为 1006 的记录。当它检查唯一二级索引时，发现事务A（虽然还未提交）已经&quot;占用&quot;了1006这个值。于是，事务B的插入操作因唯一键冲突而受阻。它会尝试为这个冲突的二级索引记录（即 <code>order_no = 1006</code>）获取一个S型的next-key锁。</li>
<li>但与此同时，由于事务B的操作与事务A插入的记录发生了潜在冲突，事务A在这条 <code>order_no = 1006</code> 的记录上的&quot;隐式锁&quot;会<strong>升级为显式的X型记录锁</strong>。</li>
<li>结果就是，事务B想获取S型next-key锁，但事务A已经持有了X型记录锁（在同一个索引记录上）。X型锁和S型锁是冲突的，所以事务B被迫进入等待状态，直到事务A提交或回滚。</li>
</ol>
<p>我们可以通过 <code>performance_schema.data_locks</code> 来验证这个过程。<br>
先看事务A在 <code>order_no = 1006</code> 的记录上最终持有什么锁（这是在事务B尝试插入后产生的）：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412390597.png" alt="1747412390597"><br>
可以看到，事务A在 <code>index_order</code> 索引的 <code>order_no = 1006</code> 这条记录上，持有了一个X型的记录锁 (<code>LOCK_MODE: X,REC_NOT_GAP</code>)。</p>
<p>再看事务B想获取什么锁，以及它的状态：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412395893.png" alt="1747412395893"><br>
事务B想在 <code>index_order</code> 索引的 <code>order_no = 1006</code> 记录上获取一个S型的next-key锁 (<code>LOCK_MODE: S</code>)，但因为与事务A的X型记录锁冲突，所以它的状态是 <code>WAITING</code>。</p>
<p>这个实验告诉我们：当多个事务并发插入具有唯一二级索引的记录时，第一个成功插入的事务（即使未提交）的记录会受到隐式锁保护。当后续事务尝试插入相同唯一键的记录时，第一个事务的隐式锁会强化为显式的X型记录锁，而后续事务则因请求S型next-key锁与之冲突而被阻塞。</p>
<p><strong>形成对比的是</strong>：如果 <code>order_no</code> 字段只是一个普通的非唯一索引，那么两个事务先后执行相同的INSERT语句，通常是不会互相阻塞的（除非有其他锁机制介入，比如间隙锁导致的阻塞，就像我们最初的死锁案例那样）。它们都能成功插入各自的记录，表里就会出现两条 <code>order_no</code> 相同的记录。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1747412403318.png" alt="1747412403318"></p>
<h2 id="如何避免死锁？">如何避免死锁？</h2>
<p>死锁的发生需要满足四个必要条件：<strong>互斥</strong>（资源不能共享）、<strong>占有且等待</strong>（拿着自己的，还想要别人的）、<strong>不可强占用</strong>（不能抢别人的）、<strong>循环等待</strong>（形成一个等待链）。只要破坏其中任意一个条件，理论上就可以避免死锁。</p>
<p>在数据库层面，通常有两种策略来处理已经发生的死锁，它们主要是通过&quot;打破循环等待条件&quot;来实现的：</p>
<ol>
<li>
<p><strong>设置事务等待锁的超时时间</strong>：可以给事务设置一个最长等待锁的时间。如果一个事务等待超过了这个设定的阈值，数据库就会自动回滚这个超时的事务，从而释放它占有的锁，让其他事务得以继续执行。在InnoDB中，这个参数是 <code>innodb_lock_wait_timeout</code>，默认值通常是50秒。<br>
当发生超时后，你可能会看到类似这样的错误提示：<br>
<img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1748172386672.png" alt="1748172386672"></p>
</li>
<li>
<p><strong>开启主动死锁检测</strong>：InnoDB引擎有一个内置的死锁检测机制。当它发现死锁时，会主动选择一个&quot;牺牲者&quot;（通常是回滚代价最小的那个事务），将它回滚掉，从而解开死锁链条，让其他事务继续。这个功能通过参数 <code>innodb_deadlock_detect</code> 控制，默认就是开启的。<br>
当检测到死锁并回滚了某个事务后，你可能会看到这样的提示：<br>
<img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL-%E6%AD%BB%E9%94%81%E4%BA%86-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/1748172399956.png" alt="1748172399956"></p>
</li>
</ol>
<p>上面这两种策略更像是&quot;死锁发生后的应对措施&quot;，而不是完全的&quot;预防&quot;。</p>
<p>那么，从业务逻辑的角度，我们能不能主动做些什么来预防类似我们案例中的死锁呢？<br>
回顾一下，我们最初使用 <code>select ... for update</code> 做幂等性校验，是为了防止出现重复订单。其实，我们可以利用数据库本身的约束机制来达到这个目的：<strong>直接将 <code>order_no</code> 字段设置为唯一索引列</strong>。这样一来，当尝试插入一个已经存在的 <code>order_no</code> 时，数据库层面就会直接报错（唯一性冲突），从根本上阻止了重复订单的产生。这种方式简单直接，虽然在插入重复订单时会抛出异常（应用层面需要妥善处理这种异常），但它通常能有效避免因复杂的锁竞争而导致的死锁问题。</p>
<p>当然，具体的解决方案还需要根据业务场景和并发情况来综合评估。理解锁机制，合理设计表结构和事务逻辑，是减少死锁的关键。</p>
<p>参考资料：</p>
<ul>
<li>《MySQL 是怎样运行的？》</li>
<li><a href="http://mysql.taobao.org/monthly/2020/09/06/">http://mysql.taobao.org/monthly/2020/09/06/</a></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>锁机制</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的记录锁与间隙锁：能否抵挡删除操作引发的幻读？</title>
    <url>/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<h1>MySQL 记录锁 + 间隙锁能挡住删除操作的幻读吗？</h1>
<p>有位候选人分享了他在美团二面时遇到的一个关于 MySQL 幻读的场景。面试中，他提到在可重复读（REPEATABLE READ）隔离级别下，当前读通过记录锁和间隙锁来解决幻读，并说明间隙锁的目的是防止数据的插入。面试官随即反问：“如果此时执行删除（DELETE）指令，是否会导致幻读？” 这位候选人当时回答“会”，但事后对此答案感到不确定，因此希望能明确这个问题。</p>
<p>这个问题的核心可以归纳为：<strong>MySQL 记录锁 + 间隙锁可以防止删除操作而导致的幻读吗？</strong></p>
<p>答案是：<strong>能！</strong></p>
<p>别急，我们通过几个小实验来一步步揭开这个谜底，顺便也温习一下记录锁和间隙锁这两个重要的概念。</p>
<h2 id="什么是幻读？">什么是幻读？</h2>
<p>咱们先看看 MySQL 官方文档是怎么解释&quot;幻读&quot;（Phantom Read）的：</p>
<blockquote>
<p><strong><em>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.</em></strong></p>
</blockquote>
<p>简单来说，幻读就是<strong>在一个事务（可以理解为一系列操作的集合）里，同样的查询命令，在不同时间执行后，得到的结果集不一样了。</strong> 比如，你第一次查询，返回了5条数据；过了一会儿，在同一个事务里，你再次执行同样的查询，结果却返回了6条数据（多了一条&quot;幽灵&quot;般的数据），或者只返回了4条数据（少了一条数据）。这种情况，我们就说发生了幻读。</p>
<p>举个例子，假设一个事务在 T1 和 T2 两个时间点都执行了下面这条查询语句，并且中间没有做任何其他操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>如果 T1 时刻查询到 5 条记录，而 T2 时刻查询到了 6 条记录，这就是幻读。<br>
反过来，如果 T1 时刻查询到 5 条记录，而 T2 时刻查询到了 4 条记录，这也算是幻读。</p>
<blockquote>
<p>MySQL 是怎么解决幻读的？</p>
</blockquote>
<p>MySQL 的 InnoDB 存储引擎，在它默认的&quot;可重复读&quot;隔离级别下，很大程度上避免了幻读问题（虽然不是100%完美解决，有些极端情况还是可能发生，想深入了解可以看看这篇<a href="/2025/05/07/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-07-MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%BB%E8%AF%BB/">文章</a>。它主要用了两种方法：</p>
<ul>
<li>对于<strong>快照读</strong>（就是我们平时用的普通 <code>SELECT</code> 语句），MySQL 通过一种叫做 <strong>MVCC（多版本并发控制）</strong> 的机制来解决幻读。简单说，就是事务在执行过程中看到的数据，始终和它刚启动时看到的一样，就算其他事务在这期间插入了新数据，当前事务也&quot;看不见&quot;，自然就避免了幻读。</li>
<li>对于<strong>当前读</strong>（比如 <code>SELECT ... FOR UPDATE</code> 这种会加锁的查询），MySQL 则通过 <strong>next-key lock（它其实是记录锁和间隙锁的组合）</strong> 来解决幻读。当执行这类查询时，MySQL 会在相关的数据范围上加上 next-key lock。这时，如果其他事务想在这个锁定的范围内插入新数据，就会被阻塞，插不进去，也就避免了幻读。</li>
</ul>
<h2 id="实验验证">实验验证</h2>
<p>接下来，我们就来验证一下前面的结论：“MySQL 的记录锁 + 间隙锁<strong>确实可以防止</strong>因删除数据而引发的幻读问题”。</p>
<p>实验环境：MySQL 8.0 版本，隔离级别为可重复读。</p>
<p>我们先准备一张用户表 <code>t_user</code>，这张表结构很简单，<strong>只有一个主键索引 <code>id</code></strong>。表里已经有一些数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>reward</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>路飞</td>
<td>19</td>
<td>3000000000</td>
</tr>
<tr>
<td>2</td>
<td>索隆</td>
<td>21</td>
<td>11100000000</td>
</tr>
<tr>
<td>3</td>
<td>山治</td>
<td>21</td>
<td>1000000000</td>
</tr>
<tr>
<td>4</td>
<td>乌索普</td>
<td>19</td>
<td>500000000</td>
</tr>
<tr>
<td>5</td>
<td>香克斯</td>
<td>39</td>
<td>4000000000</td>
</tr>
<tr>
<td>6</td>
<td>鹰眼</td>
<td>43</td>
<td>3500000000</td>
</tr>
<tr>
<td>7</td>
<td>罗</td>
<td>23</td>
<td>3000000000</td>
</tr>
<tr>
<td>8</td>
<td>基德</td>
<td>23</td>
<td>3000000000</td>
</tr>
<tr>
<td>9</td>
<td>乔巴</td>
<td>17</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>现在，我们开启一个事务 A，执行一条查询语句，查找年龄大于 20 岁的用户，发现有 6 条记录。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747398796814.png" alt="1747398796814"></p>
<p>紧接着，我们开启另一个事务 B，尝试删除 <code>id = 2</code> 的这条记录：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747398946132.png" alt="1747398946132"></p>
<p>你会发现，事务 B 的删除操作会一直卡在那里，显示<strong>等待状态</strong>，根本删不掉。</p>
<p>这就证明了：MySQL 的记录锁 + 间隙锁<strong>确实可以防止</strong>因为删除数据而引发的幻读问题。</p>
<h3 id="加锁分析">加锁分析</h3>
<p>那么问题来了，事务 A 在执行 <code>SELECT ... FOR UPDATE</code> 语句时，到底给数据加了哪些锁呢？</p>
<p>我们可以通过执行 <code>select * from performance_schema.data_locks\G;</code> 这条命令来查看事务在执行 SQL 时都加了哪些锁。</p>
<p>这条命令输出的信息通常比较多，这里我们只看关键部分（总共有11行，我做了一些删减）：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747398955476.png" alt="1747398955476"></p>
<p>从上面的输出可以看到，主要加了两种类型的锁：</p>
<ul>
<li><strong>表锁</strong> (<code>LOCK_TYPE: TABLE</code>)：这里是一个 X 类型的意向锁（简单理解为，我要对表里某些行加锁了，先在表级别打个招呼）。</li>
<li><strong>行锁</strong> (<code>LOCK_TYPE: RECORD</code>)：这里是多个 X 类型的 next-key 锁。</li>
</ul>
<p>我们重点关注的是&quot;行锁&quot;。注意，图中的 <code>LOCK_TYPE</code> 显示为 <code>RECORD</code>，但这指的是行级锁的总称，具体是哪种行锁，还需要看 <code>LOCK_MODE</code>：</p>
<ul>
<li>如果 <code>LOCK_MODE</code> 是 <code>X</code>，那么它就是一个 next-key 锁（记录锁 + 间隙锁的组合）。</li>
<li>如果 <code>LOCK_MODE</code> 是 <code>X, REC_NOT_GAP</code>，那它就是一个记录锁（只锁住某条记录，不锁间隙）。</li>
<li>如果 <code>LOCK_MODE</code> 是 <code>X, GAP</code>，那它就是一个间隙锁（只锁住记录之间的间隙，不锁记录本身）。</li>
</ul>
<p>接着，我们可以通过 <code>LOCK_DATA</code> 来确定 next-key 锁的具体范围。怎么看呢？</p>
<ul>
<li>根据经验，如果 <code>LOCK_MODE</code> 是 next-key 锁或间隙锁，那么 <strong><code>LOCK_DATA</code> 通常表示这个锁管辖范围的&quot;右边界&quot;</strong>。而这个锁的&quot;左边界&quot;，就是 <code>LOCK_DATA</code> 对应值的前一条记录的值。</li>
</ul>
<p>所以，在这个例子中，事务 A 在主键索引（<code>INDEX_NAME : PRIMARY</code>）上加了 10 个 next-key 锁，它们的范围分别是：</p>
<ul>
<li>X 型的 next-key 锁，范围：(-∞, 1] (表示小于等于1的范围)</li>
<li>X 型的 next-key 锁，范围：(1, 2]  (表示大于1且小于等于2的范围)</li>
<li>X 型的 next-key 锁，范围：(2, 3]</li>
<li>X 型的 next-key 锁，范围：(3, 4]</li>
<li>X 型的 next-key 锁，范围：(4, 5]</li>
<li>X 型的 next-key 锁，范围：(5, 6]</li>
<li>X 型的 next-key 锁，范围：(6, 7]</li>
<li>X 型的 next-key 锁，范围：(7, 8]</li>
<li>X 型的 next-key 锁，范围：(8, 9]</li>
<li>X 型的 next-key 锁，范围：(9, +∞] (表示大于9的范围)</li>
</ul>
<p><strong>简单来说，这相当于把整张表从头到尾都给锁上了！</strong> 任何其他事务想要在这张表上进行增加、删除、修改操作，都会被阻塞。</p>
<p>只有当事务 A 完成（提交或回滚）后，它加的这些锁才会被释放。</p>
<blockquote>
<p>为什么只是查询年龄大于 20 岁的记录，却把整张表都锁了呢？</p>
</blockquote>
<p>这是因为事务 A 的这条查询语句 (<code>SELECT * FROM t_user WHERE age &gt; 20 FOR UPDATE;</code>) 实际上进行的是<strong>全表扫描</strong>。MySQL 在加锁时，并不是只针对最后查询出来的结果加锁，而是在遍历索引（这里因为没有 <code>age</code> 索引，所以是遍历主键索引，即全表扫描）的过程中，逐个给扫描到的索引项加上锁。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747398970013.png" alt="1747398970013"></p>
<p>因此，<strong>敲黑板划重点：在线上环境执行 <code>UPDATE</code>、<code>DELETE</code> 或者 <code>SELECT ... FOR UPDATE</code>这类会加锁的语句时，一定要确保查询条件能用上索引。如果走了全表扫描，MySQL 就会给扫描到的每一个索引项都加上 next-key 锁，结果就是整张表都被锁住，这可是个大麻烦，会严重影响并发性能！</strong></p>
<blockquote>
<p>如果给 <code>age</code> 字段加上索引，事务 A 这条查询又会加哪些锁呢？</p>
</blockquote>
<p>好问题！接下来，我们<strong>给 <code>age</code> 字段创建一个索引</strong>，然后再来执行同样的查询语句：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747398980779.png" alt="1747398980779"></p>
<p>再次使用 <code>select * from performance_schema.data_locks\G;</code> 来查看加锁情况。</p>
<p>这次的输出我就不全贴出来了，直接说结论：</p>
<p><strong>因为现在表里有两个索引了：主键索引 <code>id</code> 和我们刚加的 <code>age</code> 索引。所以，MySQL 会分别在这两个索引上加锁。</strong></p>
<p>在<strong>主键索引</strong>上，会加以下锁：</p>
<ul>
<li>X 型的记录锁，锁住 <code>id = 2</code> 这条记录。</li>
<li>X 型的记录锁，锁住 <code>id = 3</code> 这条记录。</li>
<li>X 型的记录锁，锁住 <code>id = 5</code> 这条记录。</li>
<li>X 型的记录锁，锁住 <code>id = 6</code> 这条记录。</li>
<li>X 型的记录锁，锁住 <code>id = 7</code> 这条记录。</li>
<li>X 型的记录锁，锁住 <code>id = 8</code> 这条记录。<br>
(这些都是 <code>age &gt; 20</code> 对应的主键id)</li>
</ul>
<p>在分析 <strong><code>age</code> 索引</strong>上的加锁情况时，我们要先在脑海里把 <code>age</code> 字段的值排个序（因为B+树索引本身就是有序的）。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1748172446598.png" alt="1748172446598"></p>
<p><code>age</code> 索引上会加这些锁：</p>
<ul>
<li>X 型的 next-key lock，锁住 <code>age</code> 索引上 <code>(19, 21]</code> 这个范围。</li>
<li>X 型的 next-key lock，锁住 <code>age</code> 索引上 <code>(21, 21]</code> 这个范围 (这里虽然左右边界相同，但因为是next-key，它会锁住值为21的记录以及其后的间隙)。</li>
<li>X 型的 next-key lock，锁住 <code>age</code> 索引上 <code>(21, 23]</code> 这个范围。</li>
<li>X 型的 next-key lock，锁住 <code>age</code> 索引上 <code>(23, 23]</code> 这个范围。</li>
<li>X 型的 next-key lock，锁住 <code>age</code> 索引上 <code>(23, 39]</code> 这个范围。</li>
<li>X 型的 next-key lock，锁住 <code>age</code> 索引上 <code>(39, 43]</code> 这个范围。</li>
<li>X 型的 next-key lock，锁住 <code>age</code> 索引上 <code>(43, +∞]</code> 这个范围 (锁住大于等于43的记录以及之后无穷大的间隙)。</li>
</ul>
<p>简单概括一下，<strong>在 <code>age</code> 索引上，next-key 锁覆盖的范围是 <code>(19, +∞]</code>，也就是所有 <code>age &gt; 19</code> 的记录以及它们之间的间隙，一直到正无穷。</strong></p>
<p>可以看到，给 <code>age</code> 字段加上索引后，查询语句就从全表扫描变成了索引查询，因此<strong>不会再锁住整张表了</strong>，锁的范围精准了很多。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747399030724.png" alt="1747399030724"></p>
<p>总结一下，在给 <code>age</code> 字段创建索引后，当事务 A 执行 <code>SELECT * FROM t_user WHERE age &gt; 20 FOR UPDATE;</code> 这条查询时，主键索引和 <code>age</code> 索引上会加上如下图所示的锁：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747399042109.png" alt="1747399042109"></p>
<p>当事务 A 加上这些锁之后，其他的事务（比如 B、C、D、E）如果想执行以下操作，都会被阻塞：</p>
<ul>
<li><strong>事务 B (删除):</strong> <code>DELETE FROM t_user WHERE id = 2;</code> (因为 <code>id=2</code> 的主键记录被锁了，且 <code>age=21</code> 也在 <code>age</code> 索引的锁定范围内)</li>
<li><strong>事务 C (更新):</strong> <code>UPDATE t_user SET name = '娜美' WHERE id = 3;</code> (因为 <code>id=3</code> 的主键记录被锁了)</li>
<li><strong>事务 D (插入):</strong> <code>INSERT INTO t_user (id, name, age, reward) VALUES (10, '罗宾', 30, 130000000);</code> (因为 <code>age=30</code> 落在了 <code>age</code> 索引的 <code>(23, 39]</code> 这个 next-key 锁的间隙内)</li>
<li><strong>事务 E (更新):</strong> <code>UPDATE t_user SET age = 22 WHERE id = 1;</code> (虽然 <code>id=1</code> 的主键记录没被锁，但是要更新的 <code>age=22</code> 落在了 <code>age</code> 索引的 <code>(21, 23]</code> 这个 next-key 锁的间隙内)</li>
</ul>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-16-MySQL%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8E%E9%97%B4%E9%9A%99%E9%94%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB/1747399048011.png" alt="1747399048011"></p>
<h2 id="总结">总结</h2>
<p>在 MySQL 的&quot;可重复读&quot;隔离级别下，当我们执行会加锁的查询语句（比如 <code>SELECT ... FOR UPDATE</code>）时，MySQL 会在相关的<strong>索引</strong>上加上记录锁和间隙锁（也就是 next-key 锁）。这套组合拳非常有效，可以防止其他事务通过插入、删除或修改数据来捣乱，从而避免了幻读问题。</p>
<p>最重要的一点再次强调：在执行 <code>UPDATE</code>、<code>DELETE</code>、<code>SELECT ... FOR UPDATE</code> 这类语句时，<strong>一定要检查它们是否能有效利用索引</strong>。如果走了全表扫描，MySQL 会给扫描到的每一个索引项（通常是主键索引的每一条记录）都加上 next-key 锁，结果就是整张表都被锁得死死的，这对系统的并发处理能力是个巨大的打击。</p>
<p>搞定！希望这次的解释能让你彻底明白。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>幻读</tag>
        <tag>InnoDB</tag>
        <tag>事务</tag>
        <tag>记录锁</tag>
        <tag>间隙锁</tag>
        <tag>Next-Key锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中update不带索引的危险：全表锁定详解</title>
    <url>/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8/</url>
    <content><![CDATA[<h1>update 没加索引会锁全表？ 别再让你的数据库&quot;罢工&quot;了！</h1>
<p>想象一下这个场景：一个平平无奇的工作日，你熟练地在生产数据库上敲下了一行看似人畜无害的 <code>UPDATE</code> 语句。几分钟后，监控系统警报声此起彼伏，用户抱怨雪片般飞来，网站卡得像在播放慢动作，整个业务几乎陷入停顿。然后，你的老板“亲切”地请你去办公室“聊聊人生”……</p>
<p>这可不是危言耸听，而是不少开发者都曾踩过的“天坑”。而引发这场“灾难”的，往往就是一条再普通不过的 <code>UPDATE</code> 语句——仅仅因为它的 <code>WHERE</code> 条件里忘了带索引，或者索引没生效。</p>
<p>这篇文章会用大白话给你讲清楚：</p>
<ul>
<li>为啥一条没用对索引的 <code>UPDATE</code> 语句能把整个系统搞垮？</li>
<li>作为“打工人”，我们该如何避免这种“飞来横祸”？</li>
</ul>
<p>接下来的内容，咱们都以 MySQL 最常用的 InnoDB 存储引擎和它默认的“可重复读”（Repeatable Read）隔离级别为背景。一起来揭开这个数据库“定时炸弹”的神秘面纱吧！</p>
<h2 id="为什么会发生这种“惨案”？">为什么会发生这种“惨案”？</h2>
<p>简单来说，InnoDB 为了解决在“可重复读”这个隔离级别下可能出现的“幻读”问题（就是同一个事务里，两次相同的查询看到了不一样的结果），引入了一种叫做 <code>next-key</code> 锁的机制。这个锁很霸道，它不仅会锁住你要操作的那行数据（这叫记录锁），还会把这行数据前后的“空隙”也给锁上（这叫间隙锁），防止其他事务在这些空隙里搞小动作（比如插入新数据）。</p>
<p>当我们执行 <code>UPDATE</code> 语句时，InnoDB 会给符合条件的记录加上独占锁（X 锁）。这个锁一旦加上，其他想修改这些记录的事务就得乖乖排队等着。而且，这个锁不是 <code>UPDATE</code> 语句执行完就立马释放的，它会一直等到整个事务结束（比如 <code>COMMIT</code> 或 <code>ROLLBACK</code>）才会被放开。</p>
<p>关键点来了：<strong>InnoDB 加锁的基本单位是 <code>next-key</code> 锁，而且这个锁是加在索引上的，而不是直接加在数据行上的。</strong></p>
<ul>
<li>
<p><strong>如果你的 <code>UPDATE</code> 语句 <code>WHERE</code> 条件用的是唯一索引（比如主键），并且是等值查询</strong>：那太棒了！<code>next-key</code> 锁会“降级”成记录锁，只锁住精准匹配的那一行数据。其他事务该干嘛干嘛，互不影响。</p>
<p>举个栗子，假设我们有张 <code>users</code> 表，<code>id</code> 是主键：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8/1747386813184.png" alt="1747386813184"></p>
<p>现在有两个事务，它们的执行顺序是这样的：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8/1747386818980.png" alt="1747386818980"></p>
<p>事务 A 的 <code>UPDATE</code> 语句因为用了主键 <code>id</code> 进行等值查询，所以只锁住了 <code>id = 1</code> 这一行。事务 B 想更新 <code>id = 2</code> 的数据，完全没问题，不会被阻塞。</p>
</li>
<li>
<p><strong>但是，如果你的 <code>UPDATE</code> 语句 <code>WHERE</code> 条件没有使用索引，或者索引失效了</strong>：灾难就要降临了！InnoDB 找不到合适的索引，就只能进行全表扫描。在全表扫描的过程中，它会对表里的每一条记录（以及它们之间的间隙）都加上 <code>next-key</code> 锁。这就相当于把整张表都给锁死了！</p>
<p>再来看一个例子：</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8/1747386826920.png" alt="1747386826920"></p>
<p>这次事务 B 的 <code>UPDATE</code> 语句就被卡住了，动弹不得。</p>
<p>为啥呢？因为事务 A 的 <code>UPDATE</code> 语句 <code>WHERE</code> 条件 <code>name = 'xiaolin'</code> 中的 <code>name</code> 字段没有索引（或者索引没被优化器选中），导致了全表扫描。在扫描过程中，InnoDB 给表里的所有记录（比如 4 条记录）和它们之间的所有间隙（比如 5 个间隙）都加上了 <code>next-key</code> 锁。结果就是，整张表都被锁定了，其他事务想对这张表做任何写操作（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）都会被阻塞。</p>
<p><img src="/2025/05/16/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/update%E6%B2%A1%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%BC%9A%E9%94%81%E5%85%A8%E8%A1%A8/1747386839204.png" alt="1747386839204"></p>
<p>可以想象，如果这张表的数据量巨大（比如几百万、几千万行），这个全表锁一旦加上，可能会持续很长时间，直到事务 A 结束。在这期间，除了只读的 <code>SELECT ... FROM ...</code> 查询，其他所有对这张表的操作都会被阻塞。业务自然也就跟着停摆，然后你就要准备好接受老板的“灵魂拷问”了。</p>
</li>
</ul>
<p>那么，是不是只要 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件带上索引，就一定能避免全表锁呢？</p>
<p>答案是：<strong>不一定！</strong></p>
<p><strong>最关键的还是要看 MySQL 的优化器最终选择了什么执行计划。如果优化器觉得走索引的成本比全表扫描还高（比如表数据量很小，或者索引选择性不高），它还是可能会选择全表扫描。一旦走了全表扫描，那全表记录加锁的命运就难以避免了。</strong></p>
<div class="note info">
            <p>很多网上的文章会说 <code>UPDATE</code> 没加索引会导致“表锁”。严格来说，这个说法不完全准确。</p><p>InnoDB 的源码里，加锁的基本单位是索引项（<code>index entry</code>）。当 <code>UPDATE</code> 因为没有有效索引而进行全表扫描时，它实际上是把表里所有记录对应的索引项都加上了锁。从效果上看，这确实和锁住了整张表差不多，所以大家习惯性地称之为“表锁”。但理解其本质是行锁（准确地说是 <code>next-key</code> 锁）的累加，有助于我们更深入地分析问题。</p>
          </div>
<h2 id="如何避免这种“飞来横祸”？">如何避免这种“飞来横祸”？</h2>
<p>知道了原因，我们就可以对症下药了。以下是一些避免 <code>UPDATE</code> 没加索引导致全表锁的实用方法：</p>
<ol>
<li>
<p><strong>开启安全更新模式 (<code>sql_safe_updates</code>)</strong></p>
<p>我们可以把 MySQL 的 <code>sql_safe_updates</code> 参数设置为 <code>1</code>。这样一来，MySQL 就会变得“敏感”起来。</p>
<blockquote>
<p>官方解释是这么说的：<br>
If set to 1, MySQL aborts UPDATE or DELETE statements that do not use a key in the WHERE clause or a LIMIT clause. (Specifically, UPDATE statements must have a WHERE clause that uses a key or a LIMIT clause, or both. DELETE statements must have both.) This makes it possible to catch UPDATE or DELETE statements where keys are not used properly and that would probably change or delete a large number of rows. The default value is 0.</p>
</blockquote>
<p>简单翻译一下，当 <code>sql_safe_updates</code> 设置为 <code>1</code> 时：</p>
<ul>
<li><code>UPDATE</code> 语句必须满足以下任一条件才能成功执行：
<ul>
<li><code>WHERE</code> 条件中必须包含索引列。</li>
<li>使用了 <code>LIMIT</code> 子句。</li>
<li>同时使用了 <code>WHERE</code> 和 <code>LIMIT</code>（此时 <code>WHERE</code> 条件中可以没有索引列，但不推荐）。</li>
</ul>
</li>
<li><code>DELETE</code> 语句则更严格，必须同时满足：
<ul>
<li><code>WHERE</code> 条件中包含索引列。</li>
<li>并且使用了 <code>LIMIT</code> 子句。</li>
</ul>
</li>
</ul>
<p>开启这个参数，就像给你的数据库上了一道保险，能有效阻止那些可能因为忘加索引或索引使用不当而导致大范围数据修改或删除的危险操作。</p>
</li>
<li>
<p><strong>强制使用索引 (<code>FORCE INDEX</code>)</strong></p>
<p>即使你的 <code>WHERE</code> 条件里包含了索引列，但如果 MySQL 优化器“自作聪明”地选择了全表扫描，你还是有办法“纠正”它的。</p>
<p>可以使用 <code>FORCE INDEX([index_name])</code> 语法来明确告诉优化器：“嘿，老兄，听我的，就用这个名叫 <code>[index_name]</code> 的索引！” 这样就能强制查询走指定的索引，从而避免因优化器选择失误导致的全表扫描和潜在的全表锁风险。</p>
<p>例如：<code>UPDATE my_table FORCE INDEX(idx_name) SET column1 = 'new_value' WHERE name = 'some_value';</code></p>
</li>
<li>
<p><strong>上线前充分测试和 <code>EXPLAIN</code></strong></p>
<p>对于所有重要的 <code>UPDATE</code> 和 <code>DELETE</code> 语句，在上线前务必在测试环境进行充分测试。更重要的是，要使用 <code>EXPLAIN</code> 命令分析这些语句的执行计划，确保它们确实走了预期的索引，并且扫描的行数在合理范围内。</p>
<p>如果 <code>EXPLAIN</code> 结果显示 <code>type</code> 是 <code>ALL</code>（全表扫描），或者 <code>rows</code> 数量异常大，那就要高度警惕了，赶紧检查索引和查询条件。</p>
</li>
</ol>
<h2 id="总结：小心驶得万年船">总结：小心驶得万年船</h2>
<p>别小看一条小小的 <code>UPDATE</code> 语句，在生产环境，如果使用不当，它真有可能变成压垮骆驼的最后一根稻草，导致业务停滞甚至系统崩溃。</p>
<p>为了避免成为那个“背锅侠”，请牢记以下几点：</p>
<ul>
<li>执行 <code>UPDATE</code> 或 <code>DELETE</code> 语句时，<strong>务必确保 <code>WHERE</code> 条件中使用了合适的索引列</strong>。</li>
<li>在测试环境，<strong>使用 <code>EXPLAIN</code> 仔细检查语句的执行计划</strong>，确认它真的走了索引，而不是全表扫描。</li>
<li>考虑<strong>开启 MySQL 的 <code>sql_safe_updates</code> 参数</strong>，作为一道额外的安全防线。</li>
<li>如果发现即使 <code>WHERE</code> 条件带了索引，优化器依然“固执”地选择全表扫描，别犹豫，果断使用 <code>FORCE INDEX([index_name])</code> 来“指引”它走上正途。</li>
</ul>
<p>希望这篇文章能帮你避开这个常见的“坑”。下次操作数据库时，一定要多加小心，别再因为一条 <code>UPDATE</code> 语句而被老板请去“喝茶”啦！</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>锁</tag>
        <tag>事故分析</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 322 - 零钱兑换</title>
    <url>/2025/05/16/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3</span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>1 &lt;= coins.length &lt;= 12</li>
<li>1 &lt;= coins[i] &lt;= 2^31 - 1</li>
<li>0 &lt;= amount &lt;= 10^4</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我的初始解法是尝试使用动态规划，但实现方式有误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">		dp[i] = math.MaxInt32</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= amount; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> k := <span class="number">0</span>; k*coin &lt;= j; k++ &#123;</span><br><span class="line">				dp[j] = min(dp[j], dp[j-k*coin]+<span class="number">1</span>) <span class="comment">// ❌ 错误点：这里应该是 +k</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> dp[amount] == math.MaxInt32 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>这个解法存在几个问题：</p>
<ol>
<li>
<p><strong>状态转移方程错误</strong>：在使用 k 个当前面值的硬币时，应该是 <code>dp[j-k*coin]+k</code>，而不是 <code>dp[j-k*coin]+1</code>。这是因为我们使用了 k 个硬币，所以应该加上 k。</p>
</li>
<li>
<p><strong>不必要的三重循环</strong>：即使修正了状态转移方程，这种实现方式也有严重的效率问题。三重循环导致时间复杂度高达 O(amount^2 * n)，其中 n 是硬币数量。最内层循环（枚举使用硬币的个数）是不必要的。</p>
</li>
<li>
<p><strong>理解完全背包问题的本质</strong>：这是一个典型的完全背包问题，每种物品（硬币）可以重复选择，目标是使用最少的物品达到特定容量（金额）。对于完全背包问题，有更高效的解法。</p>
</li>
</ol>
<h2 id="正确解法一：标准动态规划（自底向上）">正确解法一：标准动态规划（自底向上）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>) <span class="comment">// dp[i] 表示凑成金额i所需的最少硬币数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化dp数组</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">		dp[i] = math.MaxInt32 <span class="comment">// 初始化为一个很大的数</span></span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 凑成金额0需要0个硬币</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于每种硬币</span></span><br><span class="line">	<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">		<span class="comment">// 从coin面值开始遍历，确保可以使用当前硬币</span></span><br><span class="line">		<span class="keyword">for</span> j := coin; j &lt;= amount; j++ &#123;</span><br><span class="line">			<span class="comment">// 状态转移：不使用当前硬币 vs 使用当前硬币</span></span><br><span class="line">			dp[j] = min(dp[j], dp[j-coin]+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果dp[amount]仍然是初始值，说明无法凑成amount</span></span><br><span class="line">	<span class="keyword">if</span> dp[amount] == math.MaxInt32 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法一分析">解法一分析</h3>
<p>这是完全背包问题的标准解法，时间复杂度为 O(amount * n)，其中 n 是硬币数量。</p>
<p><strong>状态定义</strong>：</p>
<ul>
<li><code>dp[i]</code> 表示凑成金额 i 所需的最少硬币数</li>
</ul>
<p><strong>状态转移方程</strong>：</p>
<ul>
<li><code>dp[i] = min(dp[i], dp[i-coin]+1)</code>，其中 i ≥ coin</li>
</ul>
<p><strong>解题步骤</strong>：</p>
<ol>
<li>初始化 dp 数组，除了 dp[0] = 0 外，其他位置设为一个很大的数（表示暂时无法达到）</li>
<li>对每种硬币，遍历从该面值到 amount 的所有金额</li>
<li>对于金额 j，考虑使用当前硬币后的最少硬币数：当前状态 dp[j] 与 dp[j-coin]+1 取较小值</li>
<li>最后，如果 dp[amount] 仍为初始大值，返回 -1；否则返回 dp[amount]</li>
</ol>
<h2 id="正确解法二：记忆化搜索（自顶向下）">正确解法二：记忆化搜索（自顶向下）</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="type">int</span>, amount <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 创建记忆化数组，初始值为 -1，表示状态尚未计算</span></span><br><span class="line">	memo := <span class="built_in">make</span>([]<span class="type">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> memo &#123;</span><br><span class="line">		memo[i] = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	memo[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 金额为0时需要0个硬币</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自顶向下的递归函数</span></span><br><span class="line">	<span class="keyword">var</span> dp <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">	dp = <span class="function"><span class="keyword">func</span><span class="params">(remaining <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="comment">// 剩余金额为负，无法凑成</span></span><br><span class="line">		<span class="keyword">if</span> remaining &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 已经计算过的状态，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> memo[remaining] != <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> memo[remaining]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		minCoins := math.MaxInt32</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 尝试使用每种硬币</span></span><br><span class="line">		<span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">			<span class="comment">// 递归计算使用当前硬币后所需的最少硬币数</span></span><br><span class="line">			subProblem := dp(remaining - coin)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果子问题有解，并且比当前最小值更小，更新最小值</span></span><br><span class="line">			<span class="keyword">if</span> subProblem &gt;= <span class="number">0</span> &amp;&amp; subProblem &lt; minCoins &#123;</span><br><span class="line">				minCoins = subProblem + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没有找到有效解，设置为-1</span></span><br><span class="line">		<span class="keyword">if</span> minCoins == math.MaxInt32 &#123;</span><br><span class="line">			memo[remaining] = <span class="number">-1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memo[remaining] = minCoins</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> memo[remaining]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp(amount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二分析">解法二分析</h3>
<p>这种方法使用记忆化搜索（自顶向下的动态规划）来解决问题，时间复杂度同样为 O(amount * n)。</p>
<p><strong>递归函数定义</strong>：</p>
<ul>
<li><code>dp(remaining)</code> 返回凑成金额 remaining 所需的最少硬币数</li>
</ul>
<p><strong>递归转移关系</strong>：</p>
<ul>
<li><code>dp(remaining) = min(dp(remaining - coin) + 1) for coin in coins</code>，前提是 remaining ≥ coin</li>
</ul>
<p><strong>解题步骤</strong>：</p>
<ol>
<li>创建记忆化数组，初始值为 -1，表示状态尚未计算</li>
<li>定义递归函数，对于每个金额，尝试使用每种硬币</li>
<li>对于每种硬币，计算使用后剩余金额所需的最少硬币数</li>
<li>取所有可能中的最小值</li>
<li>使用记忆化数组避免重复计算</li>
</ol>
<h2 id="两种方法的比较与思考">两种方法的比较与思考</h2>
<h3 id="方法对比表">方法对比表</h3>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>解法一：自底向上 DP</th>
<th>解法二：自顶向下记忆化搜索</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现方式</td>
<td>迭代</td>
<td>递归</td>
</tr>
<tr>
<td>思考顺序</td>
<td>从小问题构建大问题</td>
<td>从大问题分解为小问题</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(amount * n)</td>
<td>O(amount * n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(amount)</td>
<td>O(amount) + 递归栈空间</td>
</tr>
<tr>
<td>实际效率</td>
<td>通常更快（无递归开销）</td>
<td>可能稍慢（有递归调用开销）</td>
</tr>
<tr>
<td>代码简洁度</td>
<td>较为简洁</td>
<td>较为直观，符合思考过程</td>
</tr>
<tr>
<td>适用场景</td>
<td>状态转移清晰的问题</td>
<td>递归思路更容易理解的问题</td>
</tr>
<tr>
<td>易理解性</td>
<td>对初学者可能较难理解</td>
<td>更符合直觉的思考方式</td>
</tr>
<tr>
<td>调试难度</td>
<td>相对容易追踪状态</td>
<td>递归调用栈可能较难追踪</td>
</tr>
</tbody>
</table>
<h3 id="详细比较">详细比较</h3>
<ol>
<li>
<p><strong>自底向上 vs 自顶向下</strong>：</p>
<ul>
<li>自底向上的方法（解法一）从小问题开始解决，逐步构建大问题的解</li>
<li>自顶向下的方法（解法二）从大问题开始，分解成小问题，并使用记忆化避免重复计算</li>
<li>两种方法的时间复杂度相同，但实际运行效率可能因具体问题而异</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：</p>
<ul>
<li>两种方法的空间复杂度均为 O(amount)，用于存储 dp 数组或记忆化数组</li>
<li>自顶向下方法有额外的递归调用栈开销，最坏情况为 O(amount)</li>
</ul>
</li>
<li>
<p><strong>错误原因深入思考</strong>：</p>
<ul>
<li>我的错误代码试图通过三重循环来枚举所有可能性，但这种方法效率低下且更容易出错</li>
<li>标准的完全背包问题解法通过巧妙的动态规划转移关系，避免了显式枚举的需要</li>
<li>在动态规划中，状态转移方程的正确设计是关键，需要深入理解问题的本质</li>
</ul>
</li>
</ol>
<h2 id="学习总结">学习总结</h2>
<p>通过这个错题，我学到了：</p>
<ol>
<li>对于完全背包问题，标准的解法是两层循环，外层遍历物品，内层正序遍历金额</li>
<li>动态规划问题中，状态定义和转移方程的正确性至关重要</li>
<li>优化算法时，不仅要考虑正确性，还要考虑时间和空间复杂度</li>
<li>记忆化搜索是解决动态规划问题的另一种思路，有时更直观</li>
<li>在解决问题时，理解问题本质比死记硬背算法模板更重要</li>
</ol>
<p>这个题目是动态规划中的经典问题，理解了它的解法，可以帮助解决许多类似的完全背包问题。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>❌错题集</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 763 - 划分字母区间（Partition Labels）</title>
    <url>/2025/05/16/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个字符串 <code>s</code>，要求将这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<h3 id="示例-1">示例 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2">示例 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br><span class="line">解释：整个字符串只能构成一个片段。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件:</h3>
<ul>
<li>1 &lt;= s.length &lt;= 500</li>
<li>s 仅由小写英文字母组成</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题目的关键是理解&quot;同一字母最多出现在一个片段中&quot;的约束条件。这意味着，如果一个片段包含了某个字母，那么这个字符串中所有相同的字母都必须包含在这个片段中。</p>
<p>基于这个要求，我们可以使用贪心算法：</p>
<ol>
<li>首先，我们需要知道每个字符在字符串中最后出现的位置</li>
<li>然后，我们从头遍历字符串，对于每个字符，其最后出现的位置就是当前片段的潜在结束位置</li>
<li>随着遍历过程，我们不断更新当前片段的结束位置（取最远的那个）</li>
<li>当我们遍历到当前片段的结束位置时，就找到了一个符合条件的片段</li>
</ol>
<p>这个算法的核心思想是：要让同一字母都在一个片段中，那么片段的结束位置必须至少延伸到这个字母最后出现的位置。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionLabels</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 记录每个字母最后出现的位置</span></span><br><span class="line">	lastPosition := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">	<span class="keyword">for</span> i, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">		lastPosition[char-<span class="string">&#x27;a&#x27;</span>] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">	start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历字符串，不断更新当前区间的结束位置</span></span><br><span class="line">	<span class="keyword">for</span> i, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// 更新当前区间的结束位置（取最远的位置）</span></span><br><span class="line">		charLastPos := lastPosition[char-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">		<span class="keyword">if</span> charLastPos &gt; end &#123;</span><br><span class="line">			end = charLastPos</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果当前位置达到了区间的结束位置，说明找到了一个分区</span></span><br><span class="line">		<span class="keyword">if</span> i == end &#123;</span><br><span class="line">			<span class="comment">// 添加区间长度</span></span><br><span class="line">			result = <span class="built_in">append</span>(result, end-start+<span class="number">1</span>)</span><br><span class="line">			<span class="comment">// 更新下一个区间的开始位置</span></span><br><span class="line">			start = end + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现细节">实现细节</h2>
<p>代码实现可以分为两个主要部分：</p>
<h3 id="1-预处理：记录每个字母最后出现的位置">1. 预处理：记录每个字母最后出现的位置</h3>
<p>首先，我们创建一个长度为 26 的数组（假设字符串只包含小写字母），用于记录每个字母在字符串中最后出现的位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lastPosition := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line"><span class="keyword">for</span> i, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">    lastPosition[char-<span class="string">&#x27;a&#x27;</span>] = i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-贪心划分：找到符合条件的片段">2. 贪心划分：找到符合条件的片段</h3>
<p>然后，我们再次遍历字符串，维护当前片段的开始位置 <code>start</code> 和结束位置 <code>end</code>。</p>
<p>对于每个字符，我们查看它最后出现的位置，如果这个位置比当前的 <code>end</code> 更远，就需要更新 <code>end</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">charLastPos := lastPosition[char-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> charLastPos &gt; end &#123;</span><br><span class="line">    end = charLastPos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们遍历到位置 <code>i</code> 等于当前维护的 <code>end</code> 时，意味着从 <code>start</code> 到 <code>end</code> 的这个片段满足条件（所有字母都只出现在这个片段中）。此时，我们将这个片段的长度添加到结果中，并更新下一个片段的开始位置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i == end &#123;</span><br><span class="line">    result = <span class="built_in">append</span>(result, end-start+<span class="number">1</span>)</span><br><span class="line">    start = end + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>贪心算法</th>
<th>其他可能的方法（如分治）</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n²) 或更高</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1) (只需固定大小数组)</td>
<td>可能需要更多空间</td>
</tr>
<tr>
<td>优点</td>
<td>简单直观，效率高</td>
<td>适应性可能更强</td>
</tr>
<tr>
<td>缺点</td>
<td>针对特定问题</td>
<td>实现复杂，效率较低</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★☆☆☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，其中 n 是字符串的长度。我们需要两次遍历字符串，第一次记录每个字母最后出现的位置，第二次进行分区。</li>
<li><strong>空间复杂度</strong>：$O(1)$，因为我们只需要一个固定大小的数组来记录字母的最后出现位置（最多 26 个字母）。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>贪心算法思想</strong>：这道题是贪心算法的典型应用，通过每次选择局部最优解（尽可能小的满足条件的片段），最终达到全局最优（最多的片段数量）。</p>
</li>
<li>
<p><strong>预处理技巧</strong>：提前记录每个字母最后出现的位置，避免了重复查找，提高了算法效率。</p>
</li>
<li>
<p><strong>双指针</strong>：利用 <code>start</code> 和 <code>end</code> 两个指针来维护当前片段的范围，是一种常见且有效的技巧。</p>
</li>
<li>
<p><strong>问题转化</strong>：将&quot;同一字母最多出现在一个片段中&quot;转化为&quot;找到一个最小的包含所有出现字母的区间&quot;，是解决此类问题的关键。</p>
</li>
</ol>
<p>这道题目体现了贪心算法的精髓：通过每次做出局部最优的选择，最终得到全局最优解。理解这种思想对解决其他类似的区间划分问题也有很大帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>双指针</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 45 - 跳跃游戏 II (Jump Game II)</title>
    <url>/2025/05/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>
<ul>
<li>0 &lt;= j &lt;= nums[i]</li>
<li>i + j &lt; n</li>
</ul>
<p>返回到达 nums[n - 1] 的最小跳跃次数。</p>
<h3 id="示例">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>1 &lt;= nums.length &lt;= 10^4</li>
<li>0 &lt;= nums[i] &lt;= 1000</li>
<li>题目保证可以到达 nums[n-1]</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题要求计算到达数组最后位置的最小跳跃次数。有多种方法可以解决这个问题，下面我们将介绍三种主要的解法：贪心算法、动态规划和 BFS。</p>
<h3 id="方法一：贪心算法（最优解）">方法一：贪心算法（最优解）</h3>
<p><strong>核心思想</strong>：在每一步中，我们都贪心地选择能跳得最远的位置，将跳跃过程划分为多个区间。</p>
<p>具体思路：</p>
<ol>
<li>维护当前能够到达的最远位置 <code>maxReach</code></li>
<li>维护当前跳跃区间的边界 <code>end</code></li>
<li>当到达当前区间边界时，更新边界并增加跳跃步数</li>
</ol>
<p>这个贪心策略之所以有效，是因为在每个区间内，我们总是选择能使下一步跳得最远的位置，这样可以最小化跳跃次数。</p>
<h3 id="方法二：动态规划">方法二：动态规划</h3>
<p><strong>核心思想</strong>：使用数组 dp[i] 表示到达位置 i 的最小跳跃次数。</p>
<p>具体思路：</p>
<ol>
<li>创建一个长度为 n 的数组 dp，初始值设为 infinity（表示无法到达）</li>
<li>设置 dp[0] = 0（起始位置不需要跳跃）</li>
<li>对于每个位置 i，尝试更新 dp[i+1] 到 dp[i+nums[i]]</li>
</ol>
<h3 id="方法三：广度优先搜索（BFS）">方法三：广度优先搜索（BFS）</h3>
<p><strong>核心思想</strong>：将数组视为一个图，每次可以从当前位置跳到可达的范围内的任意位置。</p>
<p>具体思路：</p>
<ol>
<li>使用队列存储当前层级（相同跳跃次数）能到达的位置</li>
<li>每层代表一次跳跃，直到找到最后一个位置</li>
<li>层数即为最小跳跃次数</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="贪心算法实现">贪心算法实现</h3>
<p>贪心算法维护三个关键变量：</p>
<ul>
<li><code>steps</code>：记录跳跃次数</li>
<li><code>end</code>：当前跳跃能到达的边界</li>
<li><code>maxReach</code>：下一步能够到达的最远位置</li>
</ul>
<p>算法的关键在于区间的划分：</p>
<ol>
<li>我们将问题分解为若干个区间</li>
<li>在当前区间 [i, end] 内，计算能够到达的最远位置 maxReach</li>
<li>当遍历到当前区间的边界 end 时，我们知道必须进行一次跳跃</li>
<li>此时，将 end 更新为 maxReach，表示新的区间边界</li>
<li>steps 自增，表示进行了一次跳跃</li>
</ol>
<p><strong>注意点</strong>：循环条件是 <code>i &lt; len(nums)-1</code> 而不是 <code>i &lt; len(nums)</code>，这是因为：</p>
<ol>
<li>我们只需要能够到达最后一个位置，而不需要从最后一个位置再跳</li>
<li>当到达最后一个位置时，不需要再计算可以跳到的最远距离</li>
</ol>
<h3 id="关键代码解析">关键代码解析</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	steps := <span class="number">0</span>  <span class="comment">// 跳跃次数</span></span><br><span class="line">	end := <span class="number">0</span>    <span class="comment">// 当前区间的终点</span></span><br><span class="line">	maxReach := <span class="number">0</span>  <span class="comment">// 当前能到达的最远位置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 更新最远可达位置</span></span><br><span class="line">		<span class="keyword">if</span> i+nums[i] &gt; maxReach &#123;</span><br><span class="line">			maxReach = i + nums[i]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 到达当前区间的终点，必须跳跃一次</span></span><br><span class="line">		<span class="keyword">if</span> i == end &#123;</span><br><span class="line">			steps++   <span class="comment">// 增加跳跃次数</span></span><br><span class="line">			end = maxReach  <span class="comment">// 更新区间终点为能到达的最远位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程分析：以 <code>[2,3,1,1,4]</code> 为例</p>
<ol>
<li>初始状态：steps=0, end=0, maxReach=0</li>
<li>i=0: nums[0]=2，更新 maxReach=0+2=2，i==end，所以 steps=1，end=2</li>
<li>i=1: nums[1]=3，更新 maxReach=1+3=4，i!=end，所以 steps 不变</li>
<li>i=2: nums[2]=1，maxReach 已经是 4，不更新，i==end，所以 steps=2，end=4</li>
<li>i=3: nums[3]=1，maxReach 已经是 4，不更新，i!=end，所以 steps 不变</li>
<li>循环结束，返回 steps=2</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<h3 id="方法一：贪心算法">方法一：贪心算法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	steps := <span class="number">0</span></span><br><span class="line">	end := <span class="number">0</span></span><br><span class="line">	maxReach := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i+nums[i] &gt; maxReach &#123;</span><br><span class="line">			maxReach = i + nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i == end &#123;</span><br><span class="line">			steps++</span><br><span class="line">			end = maxReach</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：动态规划-2">方法二：动态规划</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jumpDP</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化dp数组，设置为最大值</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		dp[i] = n <span class="comment">// 使用n作为&quot;无穷大&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 起始位置不需要跳跃</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 动态规划填表</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="comment">// 从位置i能跳到的所有位置</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i+j &lt; n; j++ &#123;</span><br><span class="line">			dp[i+j] = min(dp[i+j], dp[i]+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：广度优先搜索（BFS）-2">方法三：广度优先搜索（BFS）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jumpBFS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已访问的位置</span></span><br><span class="line">	visited := <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	visited[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 队列记录当前层级的位置</span></span><br><span class="line">	queue := []<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">	steps := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		size := <span class="built_in">len</span>(queue)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">			curr := queue[<span class="number">0</span>]</span><br><span class="line">			queue = queue[<span class="number">1</span>:] <span class="comment">// 出队</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 从当前位置能跳到的所有位置</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= nums[curr] &amp;&amp; curr+j &lt; n; j++ &#123;</span><br><span class="line">				next := curr + j</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 如果到达终点，直接返回步数+1</span></span><br><span class="line">				<span class="keyword">if</span> next == n<span class="number">-1</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> steps + <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 如果该位置未访问过，加入队列</span></span><br><span class="line">				<span class="keyword">if</span> !visited[next] &#123;</span><br><span class="line">					visited[next] = <span class="literal">true</span></span><br><span class="line">					queue = <span class="built_in">append</span>(queue, next)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		steps++ <span class="comment">// 增加层级</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 不会执行到这里，因为题目保证可以到达</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>贪心算法</th>
<th>动态规划</th>
<th>BFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>最高效，空间占用小</td>
<td>思路清晰，容易理解</td>
<td>适用于最短路径问题</td>
</tr>
<tr>
<td>缺点</td>
<td>实现技巧性较高</td>
<td>时间复杂度较高</td>
<td>需要额外空间</td>
</tr>
<tr>
<td>适用场景</td>
<td>需要最优性能</td>
<td>需要求解更复杂的变种</td>
<td>图的最短路径问题</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
<td>★★★★☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="贪心算法">贪心算法</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n)，只需要遍历数组一次</li>
<li><strong>空间复杂度</strong>：O(1)，只使用了几个变量，没有额外的数据结构</li>
</ul>
<h3 id="动态规划">动态规划</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n²)，最坏情况下，对于每个位置 i，我们需要尝试 nums[i] 种跳跃方式</li>
<li><strong>空间复杂度</strong>：O(n)，需要一个长度为 n 的 dp 数组</li>
</ul>
<h3 id="BFS">BFS</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n)，每个位置最多入队一次</li>
<li><strong>空间复杂度</strong>：O(n)，需要队列和访问标记数组</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>贪心算法的巧妙应用</strong>：</p>
<ul>
<li>在这个问题中，贪心算法不是直接选择能跳得最远的位置，而是在能跳到的范围内选择能使下一步跳得最远的位置</li>
<li>使用区间划分的思想来优化解法</li>
</ul>
</li>
<li>
<p><strong>边界处理的重要性</strong>：</p>
<ul>
<li>循环条件 <code>i &lt; len(nums)-1</code> 而不是 <code>i &lt; len(nums)</code>，避免了不必要的计算</li>
<li>这个细节很容易被忽略，但对正确性至关重要</li>
</ul>
</li>
<li>
<p><strong>算法选择的权衡</strong>：</p>
<ul>
<li>贪心算法在这个问题上效率最高，但实现较为技巧性</li>
<li>动态规划思路清晰但效率较低</li>
<li>BFS 适用于求解最短路径问题，但需要额外空间</li>
</ul>
</li>
<li>
<p><strong>变量命名的含义</strong>：</p>
<ul>
<li><code>end</code> 表示当前跳跃区间的边界，是一个关键的概念</li>
<li><code>maxReach</code> 记录当前能到达的最远位置</li>
<li>清晰的变量命名使算法更易理解</li>
</ul>
</li>
</ol>
<h2 id="相关题目">相关题目</h2>
<ul>
<li>LeetCode 55: 跳跃游戏（判断是否能到达最后一个位置）</li>
<li>LeetCode 1306: 跳跃游戏 III（能否到达值为 0 的元素）</li>
<li>LeetCode 1340: 跳跃游戏 V（从更高的柱子向两边跳跃）</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>广度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis BitMap及其他高级数据类型详解</title>
    <url>/2025/05/14/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Other/</url>
    <content><![CDATA[<h2 id="BitMap">BitMap</h2>
<h3 id="介绍">介绍</h3>
<p>Bitmap，你可以把它想象成一个<strong>超级迷你的小本本</strong>，这个本本上只记录两种状态：要么是&quot;√&quot;（表示 1），要么是&quot;×&quot;（表示 0）。我们通过一个&quot;页码&quot;（也就是偏移量 offset）就能快速找到对应位置的状态是&quot;√&quot;还是&quot;×&quot;。</p>
<p>这种小本本最大的好处就是<strong>超级节省空间</strong>。因为计算机里最小的信息单位就是 bit（比特），一个 bit 就能表示一个&quot;√&quot;或一个&quot;×&quot;。所以，当我们有很多很多只需要记录两种状态的事情时（比如用户今天签到了没？某个功能打开了没？），用 Bitmap 就特别合适，能省下好多地方。我们把这种只需要记录两种状态的场景，叫做&quot;<strong>二值统计</strong>&quot;。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/bitmap.png" alt></p>
<h3 id="内部实现">内部实现</h3>
<p>你可能会好奇这个 Bitmap 小本本在 Redis 里是怎么存放的。其实，它巧妙地利用了 Redis 中我们已经认识的 <code>String</code> 类型。</p>
<p>我们知道 <code>String</code> 类型在 Redis 内部其实是以一串二进制数字（0和1）的形式存储的。Bitmap 就借用了这一点，把 <code>String</code> 里的每一个 bit 位都当成小本本上的一页，用来记录一个&quot;√&quot;或&quot;×&quot;。所以，你可以简单地理解为：<strong>Bitmap 就是一个由 bit 组成的大数组，而这个大数组被藏在了 String 类型里面</strong>。</p>
<h3 id="常用命令">常用命令</h3>
<p>bitmap 基本操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置值，其中value只能是 0 和 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取值</span></span><br><span class="line">GETBIT key offset</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定范围内值为 1 的个数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start 和 end 以字节为单位</span></span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure>
<p>bitmap 运算操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BitMap间的运算</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">operations 位移操作符，枚举值</span></span><br><span class="line">  AND 与运算 &amp;</span><br><span class="line">  OR 或运算 |</span><br><span class="line">  XOR 异或 ^</span><br><span class="line">  NOT 取反 ~</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">result 计算的结果，会存储在该key中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span></span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回指定key中第一次出现指定value(0/1)的位置</span></span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure>
<h3 id="应用场景">应用场景</h3>
<p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。</p>
<h4 id="签到统计">签到统计</h4>
<p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p>
<p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p>
<p>假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。</p>
<p>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETBIT uid:sign:100:202206 2 1</span><br></pre></td></tr></table></figure>
<p>第二步，检查该用户 6 月 3 日是否签到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GETBIT uid:sign:100:202206 2</span><br></pre></td></tr></table></figure>
<p>第三步，统计该用户在 6 月份的签到次数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITCOUNT uid:sign:100:202206</span><br></pre></td></tr></table></figure>
<p>这样，我们就知道该用户在 6 月份的签到情况了。</p>
<blockquote>
<p>如何统计这个月首次打卡时间呢？</p>
</blockquote>
<p>Redis 提供了 <code>BITPOS key bitValue [start] [end]</code>指令，返回数据表示 Bitmap 中第一个值为 <code>bitValue</code> 的 offset 位置。</p>
<p>在默认情况下，命令将检测整个位图，用户可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。所以我们可以通过执行这条命令来获取 userID = 100 在 2022 年 6 月份<strong>首次打卡</strong>日期：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">BITPOS</span> uid:sign:<span class="number">100</span>:<span class="number">202206</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1。</p>
<h4 id="判断用户登录态">判断用户登录态</h4>
<p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p>
<p>只需要一个 key = login_status 表示存储用户登录状态集合数据，将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。50000 万 用户只需要 6 MB 的空间。</p>
<p>假如我们要判断 ID = 10086 的用户的登录情况：</p>
<p>第一步，执行以下指令，表示用户已登录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETBIT login_status 10086 1</span><br></pre></td></tr></table></figure>
<p>第二步，检查该用户是否登录，返回值 1 表示已登录。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">GETBIT</span> login_status <span class="number">10086</span></span><br></pre></td></tr></table></figure>
<p>第三步，登出，将 offset 对应的 value 设置成 0。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETBIT login_status 10086 0</span><br></pre></td></tr></table></figure>
<h4 id="连续签到用户总数">连续签到用户总数</h4>
<p>如何统计连续 7 天都签到的用户总数？这里我们可以巧妙地使用 Bitmap 和位运算来实现。</p>
<p><strong>基本思路</strong>：</p>
<ol>
<li>
<p>为每天创建一个 Bitmap，其中：</p>
<ul>
<li>Bitmap 的 key 是日期（例如：<code>sign:20250508</code>）</li>
<li>用户 ID 作为 offset 位置</li>
<li>用户签到则将对应位置设为 1，未签到则为 0</li>
</ul>
</li>
<li>
<p>当我们需要统计连续 7 天都签到的用户时：</p>
<ul>
<li>对这 7 天的 Bitmap 执行&quot;按位与&quot;（AND）操作</li>
<li>结果中，只有 7 天都签到（即 7 个 Bitmap 对应位置都是 1）的用户，在最终结果中才会是 1</li>
</ul>
</li>
<li>
<p>统计结果 Bitmap 中值为 1 的位数，就得到了连续签到 7 天的用户总数</p>
</li>
</ol>
<p>Redis 提供了 <code>BITOP</code>命令来实现这种位操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>operation</code>可以是 <code>AND</code>（与）、<code>OR</code>（或）、<code>XOR</code>（异或）、<code>NOT</code>（非）</li>
<li><code>destkey</code>是存储结果的键名</li>
<li>后面跟着参与运算的键名列表</li>
</ul>
<p>当使用 <code>AND</code>操作时，只有在所有输入 Bitmap 的相同位置都为 1 时，结果才为 1，这正好符合我们&quot;连续签到&quot;的逻辑。</p>
<p><strong>实例说明</strong>：</p>
<p>假设要统计最近 3 天（5 月 12 日、13 日和 14 日）连续签到的用户数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行AND位操作，将结果存入destmap</span></span><br><span class="line">BITOP AND destmap sign:20250512 sign:20250513 sign:20250514</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计结果中位值为1的数量（即连续签到用户数）</span></span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，<code>BITCOUNT destmap</code>返回的结果就是连续 3 天都签到的用户总数。</p>
<p><strong>内存占用分析</strong>：</p>
<ul>
<li>即使用户数量达到 1 亿，一个 Bitmap 的内存占用也只有约 12 MB<br>
(计算方式：10^8 位 ÷ 8 位/字节 ÷ 1024 字节/KB ÷ 1024KB/MB ≈ 12 MB)</li>
<li>存储 7 天的签到数据约需 84 MB 内存</li>
</ul>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>为 Bitmap 设置合理的过期时间，自动清理历史签到数据</li>
<li>对于大型应用，可以按月或按周设计键名，便于管理和清理</li>
<li>可结合 Redis 的计划任务，定期合并计算连续签到的统计结果</li>
</ul>
<h2 id="HyperLogLog">HyperLogLog</h2>
<h3 id="介绍-2">介绍</h3>
<p>想象一下，你想知道一个超级大的网站，比如微博或者知乎，一天有多少<strong>不同的人</strong>访问了它。直接去数的话，如果每个人都记录下来，那得用掉多少存储空间啊！</p>
<p>Redis 的 HyperLogLog 就是来解决这个问题的&quot;神器&quot;。它是一种专门用来做&quot;<strong>去重计数</strong>&quot;（专业点叫「统计基数」）的工具。简单来说，就是帮你估算出一大堆数据里，到底有多少个不重复的元素。</p>
<p>最厉害的是，HyperLogLog <strong>超级节省内存</strong>！不管你要统计的数据有多少（几百万、几亿甚至更多），它基本上都只用固定的、非常非常小的内存（在 Redis 里大约是 12KB）。就能给你一个八九不离十的估计值。当然，它也不是百分百精确的，会有一点点小误差（标准错误率大约是 0.81%），但对于很多场景来说，这点误差完全可以接受。</p>
<p><strong>举个例子让你感受下它有多省内存</strong>：</p>
<p>如果我们不用 HyperLogLog，而是用传统方法（比如 Java 里的 <code>long</code> 类型数字）来记录每一个独立访客的 ID。假设有几百亿个访客，每个访客 ID 都需要占用一定的存储空间（比如 8 个字节）。那总共需要的内存就会是一个天文数字，可能比你电脑的硬盘还要大得多！而 HyperLogLog 只需要大约 12KB 就能搞定这个估算任务，是不是很神奇？</p>
<p>所以，简单来说，当你需要<strong>大概知道有多少不重复的东西，而且这些东西数量巨大，又不想太占内存</strong>时，HyperLogLog 就是你的好帮手。</p>
<h3 id="内部实现-2">内部实现</h3>
<p>HyperLogLog 的实现涉及到很多数学问题，太费脑子了，我也没有搞懂，如果你想了解一下，课下可以看看这个：<a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>。</p>
<h3 id="常见命令">常见命令</h3>
<p>HyperLogLog 命令很少，就三个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-2">应用场景</h3>
<h4 id="百万级网页-UA-User-Agent-计数">百万级网页 UA (User Agent) 计数</h4>
<p>Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p>
<p>所以，非常适合统计百万级以上的网页 UA 的场景。</p>
<p>在统计 UA 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFADD page1:ua user1 user2 user3 user4 user5</span><br></pre></td></tr></table></figure>
<p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UA 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFCOUNT page1:ua</span><br></pre></td></tr></table></figure>
<p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p>
<p>这也就意味着，你使用 HyperLogLog 统计的 UA 是 100 万，但实际的 UA 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p>
<h2 id="GEO">GEO</h2>
<p>Redis GEO 是 Redis 3.2 版本引入的一个新功能，专门用来帮你<strong>存储和查询地理位置信息</strong>。</p>
<p>想象一下我们平时用的地图软件，比如你要找&quot;我附近的餐馆&quot;，或者打车软件帮你匹配最近的司机，这些都离不开地理位置服务（我们常说的 LBS - Location-Based Service）。GEO 类型就是为了方便实现这类功能而生的。它可以帮你存储很多地点（比如餐馆、车辆、用户）的经度和纬度，并且能快速找出某个地点附近的其他地点。</p>
<h3 id="内部实现-3">内部实现</h3>
<p>你可能会想，Redis 是怎么做到这么神奇的地理位置存储和查询的呢？它是不是又发明了一种全新的、复杂的数据结构？</p>
<p>答案是：并没有！GEO 类型非常聪明，它<strong>巧妙地借用了我们之前学过的 <code>Sorted Set</code>（有序集合）</strong>.</p>
<p>它是这样工作的：</p>
<ol>
<li><strong>GeoHash 编码</strong>：首先，对于每一个地理位置（经度和纬度），GEO 会用一种叫做 “GeoHash” 的方法，把这个二维的经纬度信息转换成一个<strong>一维的数字</strong>（你可以把它想象成给地图上的每个小区域编了一个号）。这个数字就代表了这个位置所在的区域。</li>
<li><strong>存入 Sorted Set</strong>：然后，GEO 把这个转换后的一维数字作为 <code>Sorted Set</code> 中每个元素的&quot;分数&quot;（score），而地点本身的名字（比如餐馆名、车辆ID）就是元素的值。</li>
</ol>
<p>这样一来，所有的地理位置信息就被转换成了 <code>Sorted Set</code> 里带着分数的元素。因为 <code>Sorted Set</code> 本身就是有序的，而且支持按照分数范围来查找，所以我们就能很方便地利用这个特性来找到某个分数（也就是某个地理区域）附近的其他元素了，从而实现&quot;搜索附近&quot;的功能。</p>
<p>简单来说，<strong>GEO 就是用 GeoHash 把地图上的点&quot;拍扁&quot;成一维的数字，然后用 Sorted Set 来管理这些数字，从而实现高效的地理位置查询</strong>。</p>
<h3 id="常用命令-2">常用命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span></span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回两个给定位置之间的距离。</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>
<h3 id="应用场景-3">应用场景</h3>
<h4 id="滴滴叫车">滴滴叫车</h4>
<p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p>
<p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p>
<p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure>
<p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p>
<p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure>
<h2 id="Stream">Stream</h2>
<h3 id="介绍-3">介绍</h3>
<p>Redis Stream 是 Redis 5.0 版本专门为&quot;<strong>消息队列</strong>&quot;量身打造的一种新数据类型。</p>
<p><strong>什么是消息队列呢？</strong></p>
<p>你可以把它想象成一个<strong>智能的公告板或者任务清单</strong>。有人（生产者）往上面贴条子（发布消息），另外一些人（消费者）则从公告板上取条子去处理（消费消息）。</p>
<p><strong>为什么需要 Stream？</strong></p>
<p>在 Stream 出现之前，大家也尝试用 Redis 的其他功能（比如 <code>List</code> 或者发布订阅模式）来模拟消息队列，但它们都有一些天生的&quot;小毛病&quot;：</p>
<ul>
<li><strong>发布订阅模式</strong>：这种模式像个&quot;广播&quot;，消息发出去了就没了，<strong>不能保存</strong>。如果某个消费者当时不在线，它就错过了这些消息，之后也找不回来。</li>
<li><strong><code>List</code> 类型</strong>：用 <code>List</code> 来做消息队列，消息倒是能存下来。但是，一条消息被一个消费者取走后，别的消费者就看不到了（<strong>不能重复消费</strong>）。而且，谁先发消息谁后发消息，这个顺序的管理也比较麻烦，生产者需要自己想办法给每条消息编个号。</li>
</ul>
<p>为了解决这些问题，Stream 横空出世！它就像一个<strong>超级增强版的消息队列</strong>，拥有很多高级功能：</p>
<ul>
<li><strong>消息持久化</strong>：消息会被稳稳地存起来，不用担心丢了。</li>
<li><strong>自动生成唯一ID</strong>：每条消息都会自动获得一个独一无二的编号，管理起来很方便。</li>
<li><strong>消息确认机制（ACK）</strong>：消费者拿到消息处理完后，可以告诉 Stream “我搞定了！”，这样 Stream 才知道这条消息被成功处理了。</li>
<li><strong>消费组模式</strong>：这是 Stream 的一大亮点！允许多个消费者组成一个&quot;小组&quot;，共同来处理消息。一个小组里的消息只会被其中一个成员领走，避免了重复劳动。而且，不同的小组可以独立消费同样的消息，互不影响。</li>
</ul>
<p>有了这些特性，用 Stream 来做消息队列就变得非常<strong>稳定和可靠</strong>了。</p>
<h3 id="常见命令-2">常见命令</h3>
<p>Stream 消息队列操作命令：</p>
<ul>
<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li>
<li>XLEN：查询消息长度；</li>
<li>XREAD：用于读取消息，可以按 ID 读取数据；</li>
<li>XDEL：根据消息 ID 删除消息；</li>
<li>DEL：删除整个 Stream；</li>
<li>XRANGE：读取区间消息</li>
<li>XREADGROUP：按消费组形式读取消息；</li>
<li>XPENDING 和 XACK：
<ul>
<li>XPENDING 命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</li>
<li>XACK 命令用于向消息队列确认消息处理已完成；</li>
</ul>
</li>
</ul>
<h3 id="应用场景-4">应用场景</h3>
<h4 id="消息队列">消息队列</h4>
<p>生产者（发消息的人）用 <code>XADD</code> 命令把一条消息放进队列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里的 * 号表示让 Redis 自动给这条消息生成一个全局唯一的 ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">意思是：往一个叫做 mymq 的消息队列里，放一条内容是 name=xiaolin 的消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XADD mymq * name xiaolin</span></span><br><span class="line">&quot;1654254953808-0&quot; # 这是 Redis 返回的消息 ID</span><br></pre></td></tr></table></figure>
<p>这个返回的 ID 很特别，它由两部分组成：</p>
<ul>
<li>第一部分（例如 <code>1654254953808</code>）：是消息被存入时，服务器的时间戳（精确到毫秒）。</li>
<li>第二部分（例如 <code>0</code>）：表示在同一毫秒内，这条消息是第几条（从0开始数）。</li>
</ul>
<p>消费者（处理消息的人）用 <code>XREAD</code> 命令来读消息。你可以告诉它从哪个 ID 开始读，它就会把那个 ID 之后的新消息都给你。这样设计的好处是，消费者只需要记住上次读到哪里，下次就能接着读，非常方便。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 ID 号为 1654254953807-0 的消息之后开始读取，返回所有更新的消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREAD STREAMS mymq 1654254953807-0</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot; # 消息ID</span><br><span class="line">         2) 1) &quot;name&quot;      # 消息内容</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure>
<p>如果希望<strong>没有新消息时，让 <code>XREAD</code> 命令先别急着返回，而是等一会儿</strong>（比如等几秒钟），看看有没有新消息进来，可以加上 <code>BLOCK</code> 参数。这就像你去窗口办事，如果暂时没人，你会等一下而不是立刻离开。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令最后的<span class="string">&quot;$&quot;</span>符号表示我想读取最新的消息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BLOCK 10000 表示如果没有新消息，就阻塞等待10000毫秒（10秒）</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREAD BLOCK 10000 STREAMS mymq $</span></span><br><span class="line">(nil) # 10秒内没有新消息，就返回空</span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure>
<p>用 <code>XADD</code> 发消息，用 <code>XREAD</code> 收消息，这样最基本的消息队列就搭起来了。流程就像下面这张图：</p>
<p><img src="/2025/05/14/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Other/1747324335058.png" alt="1747324335058"></p>
<blockquote>
<p>前面这些基本操作，用 <code>List</code> 其实也能勉强做到。Stream 真正的厉害之处在于它的&quot;消费组&quot;功能。</p>
</blockquote>
<p>Stream 可以用 <strong><code>XGROUP CREATE</code> 创建消费组</strong>。创建了消费组之后，就可以用 <code>XREADGROUP</code> 命令让组里的消费者来读消息了。</p>
<p>比如，我们创建一个名叫 <code>group1</code> 的消费组，让它从消息队列 <code>mymq</code> 的第一条消息（用 <code>0-0</code> 表示）开始读：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XGROUP CREATE mymq group1 0-0</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样，再创建一个 group2</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XGROUP CREATE mymq group2 0-0</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>然后，<code>group1</code> 里的一个消费者 <code>consumer1</code> 可以这样来读消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令最后的参数<span class="string">&quot;&gt;&quot;</span>，表示我想从第一条<span class="string">&quot;还没有被组里其他消费者拿走&quot;</span>的消息开始读。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure>
<p><strong>重点来了：同一个消费组里的消息，一旦被一个消费者取走了，组里的其他消费者就拿不到了。</strong> 这确保了同一条消息不会被同一个小组的人重复处理。</p>
<p>比如，<code>consumer1</code> 刚读了一条消息，如果它再用同样的命令去读，就会发现没新消息了（除非队列里又来了别的未被读取的消息）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>但是，<strong>不同消费组之间是独立的</strong>。如果它们都设置了从同一个地方开始读消息，那么它们都可以读到相同的消息。</p>
<p>比如，刚才 <code>group1</code> 的 <code>consumer1</code> 读了 <code>1654254953808-0</code> 这条消息。现在我们让 <code>group2</code> 里的 <code>consumer1</code> (注意，这是另一个组的同名消费者，或者不同名的消费者都行) 去读，它也能读到这条消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure>
<p>消费组的主要目的就是让组里的多个消费者<strong>分工合作，共同处理消息</strong>，提高效率。通常我们会让每个消费者领一部分消息。</p>
<p>比如，我们可以让 <code>group2</code> 里的三个消费者 <code>consumer1</code>、<code>consumer2</code>、<code>consumer3</code> 各自去领一条消息来处理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让 group2 的 consumer1 领一条消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer1 COUNT 1 STREAMS mymq &gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (consumer1 领到的消息)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让 group2 的 consumer2 领一条消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer2 COUNT 1 STREAMS mymq &gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (consumer2 领到的消息)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让 group2 的 consumer3 领一条消息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer3 COUNT 1 STREAMS mymq &gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">... (consumer3 领到的消息)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么问题来了：如果一个消费者领了条消息，但它自己处理的时候出错了（比如程序崩了），那这条消息不就丢了吗？Stream 是怎么保证消息被可靠处理的呢？</p>
</blockquote>
<p>这就是 Stream 的<strong>消息确认机制</strong>和 <strong>Pending List（待处理列表）</strong> 的作用了。</p>
<p>当一个消费者通过 <code>XREADGROUP</code> 拿到消息后，Stream 会默默地把这些&quot;已被认领但还没说处理完&quot;的消息记录在一个内部的&quot;<strong>待处理列表</strong>&quot;（Pending List）里。只有当消费者处理完消息，并且明确地用 <code>XACK</code> 命令告诉 Stream &quot;这条消息我处理好了！&quot;之后，Stream 才会认为这条消息被成功消费了，然后从 Pending List 里移除它。</p>
<p>这个过程就像这样：</p>
<p><img src="/2025/05/14/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Other/1747324344772.png" alt="1747324344772"></p>
<p>如果消费者拿了消息但一直没发 <code>XACK</code>（比如因为它自己出故障了），那么这条消息就会一直待在 Pending List 里。当这个消费者恢复后（或者其他备用消费者介入时），可以用 <code>XPENDING</code> 命令来查看哪些消息是&quot;之前领了但还没确认处理完的&quot;。</p>
<p>例如，查看 <code>group2</code> 里，所有消费者加起来总共有多少条&quot;待处理&quot;的消息，以及这些消息的 ID 范围：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XPENDING mymq group2</span><br><span class="line">1) (integer) 3 # 总共有3条待处理消息</span><br><span class="line">2) &quot;1654254953808-0&quot;  # 这些待处理消息中，ID最小的那个</span><br><span class="line">3) &quot;1654256271337-0&quot;  # 这些待处理消息中，ID最大的那个</span><br><span class="line">4) 1) 1) &quot;consumer1&quot;   # consumer1 有几条待处理的</span><br><span class="line">      1) &quot;1&quot;</span><br><span class="line">   1) 1) &quot;consumer2&quot;   # consumer2 有几条待处理的</span><br><span class="line">      1) &quot;1&quot;</span><br><span class="line">   2) 1) &quot;consumer3&quot;   # consumer3 有几条待处理的</span><br><span class="line">      1) &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>如果想看某个消费者（比如 <code>consumer2</code>）具体有哪些待处理的消息，可以这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 group2 里的 consumer2 有哪些待处理的消息（最多看10条，从最早的开始）</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XPENDING mymq group2 - + 10 consumer2</span></span><br><span class="line">1) 1) &quot;1654256265584-0&quot;   # 消息ID</span><br><span class="line">   2) &quot;consumer2&quot;       # 哪个消费者领的</span><br><span class="line">   3) (integer) 410700  # 这条消息被认领后，空闲了多久（毫秒）</span><br><span class="line">   4) (integer) 1         # 这条消息被传递了几次（如果发生过重新认领）</span><br></pre></td></tr></table></figure>
<p>一旦 <code>consumer2</code> 把消息 <code>1654256265584-0</code> 处理完了，它就应该用 <code>XACK</code> 命令告诉 Stream：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XACK mymq group2 1654256265584-0</span></span><br><span class="line">(integer) 1 # 表示成功确认了1条消息</span><br></pre></td></tr></table></figure>
<p>之后再用 <code>XPENDING</code> 去查 <code>consumer2</code>，就会发现它没有待处理的消息了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XPENDING mymq group2 - + 10 consumer2</span></span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>
<p>好了，关于 Stream 实现消息队列的关键点小结一下：</p>
<ul>
<li><strong>保证消息顺序</strong>：用 <code>XADD</code> 添加，ID 本身就带有时间戳和序号。</li>
<li><strong>可以阻塞等待新消息</strong>：<code>XREAD</code> 或 <code>XREADGROUP</code> 加上 <code>BLOCK</code> 参数。</li>
<li><strong>避免重复消息</strong>：<code>XADD</code> 自动生成全局唯一 ID。</li>
<li><strong>保证消息可靠性</strong>：通过消费组、Pending List 和 <code>XACK</code> 确认机制，确保消息至少被成功处理一次。</li>
<li><strong>支持消费组协同工作</strong>：多个消费者可以一起干活，提高效率。</li>
</ul>
<blockquote>
<p>Redis Stream 这么厉害，那它和那些专业的&quot;消息队列中间件&quot;（比如 Kafka、RabbitMQ）比起来怎么样呢？</p>
</blockquote>
<p>一个专业的消息队列，通常要重点解决两个问题：</p>
<ol>
<li><strong>消息不能丢</strong>。</li>
<li><strong>消息能大量堆积</strong>（比如生产者发得很快，消费者处理得慢，消息不能因为堆太多而丢了）。</li>
</ol>
<p><em>1、Redis Stream 的消息会丢失吗？</em></p>
<p>一个完整的消息传递过程包括三个环节：<strong>生产者发消息 -&gt; 消息队列中间件存消息 -&gt; 消费者收消息</strong>。</p>
<p><img src="/2025/05/14/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Other/1747324361948.png" alt="1747324361948"></p>
<p>我们来看看 Redis Stream 在这三个环节的表现：</p>
<ul>
<li><strong>生产者发消息会不会丢？</strong> 这个主要看生产者程序写得好不好。如果生产者发完消息后，能正确检查 Stream 返回的确认（表示 Stream 已经收到），并且在出错时能重新发送，那么这个环节一般不会丢消息。</li>
<li><strong>消费者收消息会不会丢？</strong> 一般也不会。因为 Stream 有 Pending List 和 <code>XACK</code> 确认机制。消费者处理完消息才发确认，如果中途挂了，消息还在 Pending List 里，重启后可以继续处理。</li>
<li><strong>消息在 Stream（也就是 Redis 自己作为中间件）里会不会丢？</strong> <strong>这个是有可能的！</strong> 主要在两种情况下：
<ul>
<li>如果 Redis 的持久化策略（比如 AOF）配置成每秒写一次硬盘，那么在两次写盘间隔内如果 Redis 突然挂了，这一秒内收到的消息就可能丢了。</li>
<li>如果 Redis 做了主从复制，但复制是异步的，那么在主节点挂了、从节点还没同步完数据的时候切换，也可能丢一部分数据。</li>
</ul>
</li>
</ul>
<p>所以，<strong>在&quot;中间件&quot;这个环节，Redis Stream 本身并不能像专业消息队列那样做到绝对不丢消息</strong>。专业的消息队列（如 Kafka）通常会把消息写到集群里的多个节点（多个副本），一个节点挂了也不影响数据。</p>
<p><em>2、Redis Stream 消息能大量堆积吗？</em></p>
<p>Redis 的数据主要是存在内存里的。如果消息产生得非常快，消费却很慢，导致大量消息堆积在 Stream 里，就会不断消耗 Redis 的内存。如果内存耗尽，Redis 就可能崩溃（OOM）。</p>
<p>为了避免这种情况，Stream 允许你设置一个队列的最大长度。超过这个长度后，老的消息就会被自动删除，只保留最新的消息。这样虽然能防止内存爆炸，但也意味着<strong>在消息严重堆积时，Stream 可能会主动丢弃老消息</strong>。</p>
<p>而专业的 Kafka、RabbitMQ 通常把消息存在磁盘上，磁盘空间一般比内存大得多，所以它们更能抗住大量的消息堆积。</p>
<p>因此，总结一下，用 Redis Stream 做消息队列时要注意：</p>
<ul>
<li><strong>Redis 自身的原因（持久化、主从切换）可能导致少量数据丢失。</strong></li>
<li><strong>消息大量堆积时，内存可能成为瓶颈，并可能导致老消息被丢弃。</strong></li>
</ul>
<p>那么，到底能不能用 Redis Stream 做消息队列呢？关键看你的业务场景：</p>
<ul>
<li>如果你的业务<strong>对偶尔丢失几条消息不那么敏感</strong>，并且<strong>消息积压的风险不高</strong>，那么用 Redis Stream 是个简单方便的选择。</li>
<li>但如果你的业务要求<strong>消息绝对不能丢</strong>，或者<strong>可能产生海量消息并长时间堆积</strong>，那还是选择 Kafka、RabbitMQ 这类更专业的消息队列中间件更稳妥。</li>
</ul>
<blockquote>
<p>补充：为什么不直接用 Redis 的&quot;发布/订阅&quot;机制做消息队列？</p>
</blockquote>
<p>虽然发布/订阅听起来也像消息传递，但它有几个硬伤，不适合做正经的消息队列：</p>
<ol>
<li><strong>不存消息</strong>：发布/订阅是纯粹的&quot;阅后即焚&quot;，消息发出去就没了，Redis 不会为它做持久化（写 RDB 或 AOF）。Redis 重启后，啥都没了。</li>
<li><strong>离线消费者收不到</strong>：如果一个订阅者当时不在线，它就永远错过了那些消息，之后也补不回来。</li>
<li><strong>消费者慢了会被踢掉</strong>：如果生产者发太快，某个消费者处理不过来，导致它那边的消息缓冲区满了（默认超过32MB，或者60秒内持续占着8MB以上），Redis 会把这个&quot;拖后腿&quot;的消费者直接踢下线。</li>
</ol>
<p>所以，发布/订阅机制更适合做一些<strong>即时性的通知</strong>，比如 Redis 哨兵集群内部的通信，而不是需要可靠传递和存储的消息队列。</p>
<h2 id="总结">总结</h2>
<p>Redis 常见的五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)</strong>。</p>
<p>这五种数据类型都由多种数据结构实现的，主要是出于时间和空间的考虑，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。</p>
<p>这五种数据类型与底层数据结构对应关系图如下，左边是 Redis 3.0 版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Github 最新的 Redis 代码的。</p>
<p><img src="/2025/05/14/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Other/1747324379560.png" alt="1747324379560"></p>
<p>可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如：</p>
<ul>
<li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li>
<li>在最新的 Redis 代码中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li>
</ul>
<p>Redis 五种数据类型的应用场景：</p>
<ul>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>
<li>List 类型的应用场景：消息队列（有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
</ul>
<p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p>
<ul>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登录状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。</li>
</ul>
<p>针对 Redis 是否适合做消息队列，关键看你的业务场景：</p>
<ul>
<li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li>
<li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li>
</ul>
<hr>
<p>参考资料：</p>
<ul>
<li>《Redis 核心技术与实战》</li>
<li><a href="https://www.cnblogs.com/hunternet/p/12742390.html">https://www.cnblogs.com/hunternet/p/12742390.html</a></li>
<li><a href="https://www.cnblogs.com/qdhxhz/p/15669348.html">https://www.cnblogs.com/qdhxhz/p/15669348.html</a></li>
<li><a href="https://www.cnblogs.com/bbgs-xc/p/14376109.html">https://www.cnblogs.com/bbgs-xc/p/14376109.html</a></li>
<li><a href="http://kaito-kidd.com/2021/04/19/can-redis-be-used-as-a-queue/">http://kaito-kidd.com/2021/04/19/can-redis-be-used-as-a-queue/</a></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>REDIS</tag>
        <tag>数据类型</tag>
        <tag>Bitmap</tag>
        <tag>HyperLogLog</tag>
        <tag>GEO</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 295 - 数据流的中位数（Find Median from Data Stream）</title>
    <url>/2025/05/14/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<p>例如：</p>
<ul>
<li>arr = [2,3,4] 的中位数是 3</li>
<li>arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5</li>
</ul>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li><code>void addNum(int num)</code> - 将整数 num 添加到数据结构中</li>
<li><code>double findMedian()</code> - 返回所有元素的中位数</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出：[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr = [1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // 返回 2.0</span><br></pre></td></tr></table></figure>
<p>约束条件：</p>
<ul>
<li>-10^5 &lt;= num &lt;= 10^5</li>
<li>在调用 findMedian 之前，数据结构中至少有一个元素</li>
<li>最多 5 * 10^4 次调用 addNum 和 findMedian</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<h3 id="分析问题">分析问题</h3>
<p>这个问题要求我们设计一个数据结构，能够在数据流中快速获取中位数。关键挑战在于：</p>
<ol>
<li>数据是连续添加的，而不是一次性给出</li>
<li>每次添加后可能需要重新计算中位数</li>
<li>需要高效处理大量的添加操作和查找操作</li>
</ol>
<p>对于中位数的查找，如果我们维护一个有序的数组，那么中位数的位置是确定的。但每次插入新元素时，为了保持有序，我们需要 O(n) 的时间复杂度进行插入，这在数据量大时效率很低。</p>
<h3 id="核心思想：双堆法">核心思想：双堆法</h3>
<p><strong>关键洞见</strong>：我们可以将数据分成两部分，左半部分用最大堆维护，右半部分用最小堆维护。</p>
<p>这样设计的好处是：</p>
<ul>
<li>左边最大堆的堆顶是左半部分的最大值</li>
<li>右边最小堆的堆顶是右半部分的最小值</li>
<li>当两个堆平衡时，这两个值就是我们需要的中间值</li>
</ul>
<p>具体来说：</p>
<ol>
<li>如果元素总数是奇数，我们可以让左边的最大堆多一个元素，此时最大堆的堆顶就是中位数</li>
<li>如果元素总数是偶数，中位数是最大堆堆顶和最小堆堆顶的平均值</li>
</ol>
<h3 id="算法流程">算法流程</h3>
<ol>
<li>创建两个堆：最大堆 <code>maxHeap</code> 和最小堆 <code>minHeap</code></li>
<li><code>maxHeap</code> 存储较小的一半数字，<code>minHeap</code> 存储较大的一半数字</li>
<li>确保两个堆大小平衡：两堆大小要么相等，要么 <code>maxHeap</code> 比 <code>minHeap</code> 多一个元素</li>
<li>每次添加元素时，通过交换堆顶元素来维护两个堆的数据平衡</li>
</ol>
<p>添加元素的具体步骤：</p>
<ol>
<li>如果两个堆都为空，直接将元素添加到 <code>maxHeap</code></li>
<li>否则，根据两个堆的大小关系选择合适的堆进行元素添加</li>
<li>添加时，先弹出一个堆的顶部元素，与新元素比较，较大的进入 <code>minHeap</code>，较小的进入 <code>maxHeap</code></li>
<li>这样确保了 <code>maxHeap</code> 中所有元素都小于等于 <code>minHeap</code> 中的所有元素</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>Go 语言的标准库 <code>container/heap</code> 提供了堆的接口，但需要我们自己实现特定的方法。</p>
<h3 id="实现堆接口">实现堆接口</h3>
<p>首先，我们需要为最大堆和最小堆分别实现 <code>heap.Interface</code> 接口：</p>
<ol>
<li>最小堆实现：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> minHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;  <span class="comment">// 最小堆：父节点小于子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span></span> Push(x any) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span></span> Pop() any &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>最大堆实现：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> maxHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125;  <span class="comment">// 最大堆：父节点大于子节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *maxHeap)</span></span> Push(x any) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *maxHeap)</span></span> Pop() any &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键实现细节">关键实现细节</h3>
<p>在 <code>AddNum</code> 方法中，我们需要确保两个堆的平衡并且数据分布正确：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MedianFinder)</span></span> AddNum(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 特殊处理第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mf.maxh) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(mf.minh) == <span class="number">0</span> &#123;</span><br><span class="line">        heap.Push(&amp;mf.maxh, num)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个堆的大小，调整元素分布</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mf.maxh) &lt;= <span class="built_in">len</span>(mf.minh) &#123;</span><br><span class="line">        <span class="comment">// 从最小堆弹出一个元素，与新元素比较</span></span><br><span class="line">        num2 := heap.Pop(&amp;mf.minh).(<span class="type">int</span>)</span><br><span class="line">        <span class="comment">// 较大的进入最小堆</span></span><br><span class="line">        heap.Push(&amp;mf.minh, max(num, num2))</span><br><span class="line">        <span class="comment">// 较小的进入最大堆</span></span><br><span class="line">        heap.Push(&amp;mf.maxh, min(num2, num))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从最大堆弹出一个元素，与新元素比较</span></span><br><span class="line">        num2 := heap.Pop(&amp;mf.maxh).(<span class="type">int</span>)</span><br><span class="line">        <span class="comment">// 较大的进入最小堆</span></span><br><span class="line">        heap.Push(&amp;mf.minh, max(num, num2))</span><br><span class="line">        <span class="comment">// 较小的进入最大堆</span></span><br><span class="line">        heap.Push(&amp;mf.maxh, min(num2, num))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>FindMedian</code> 方法中，根据两个堆的大小关系快速计算中位数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MedianFinder)</span></span> FindMedian() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mf.maxh) != <span class="built_in">len</span>(mf.minh) &#123;</span><br><span class="line">        <span class="comment">// 奇数情况：最大堆的堆顶就是中位数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(mf.maxh[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偶数情况：两个堆顶的平均值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(mf.maxh[<span class="number">0</span>] + mf.minh[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<p>完整的 Go 语言实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">    minh minHeap  <span class="comment">// 存储较大的一半数字</span></span><br><span class="line">    maxh maxHeap  <span class="comment">// 存储较小的一半数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MedianFinder &#123;</span><br><span class="line">    <span class="keyword">return</span> MedianFinder&#123;</span><br><span class="line">        minh: minHeap&#123;&#125;,</span><br><span class="line">        maxh: maxHeap&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MedianFinder)</span></span> AddNum(num <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mf.maxh) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(mf.minh) == <span class="number">0</span> &#123;</span><br><span class="line">        heap.Push(&amp;mf.maxh, num)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mf.maxh) &lt;= <span class="built_in">len</span>(mf.minh) &#123;</span><br><span class="line">        num2 := heap.Pop(&amp;mf.minh).(<span class="type">int</span>)</span><br><span class="line">        heap.Push(&amp;mf.minh, max(num, num2))</span><br><span class="line">        heap.Push(&amp;mf.maxh, min(num2, num))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num2 := heap.Pop(&amp;mf.maxh).(<span class="type">int</span>)</span><br><span class="line">        heap.Push(&amp;mf.minh, max(num, num2))</span><br><span class="line">        heap.Push(&amp;mf.maxh, min(num2, num))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mf *MedianFinder)</span></span> FindMedian() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mf.maxh) != <span class="built_in">len</span>(mf.minh) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(mf.maxh[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(mf.maxh[<span class="number">0</span>] + mf.minh[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义最小堆</span></span><br><span class="line"><span class="keyword">type</span> minHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span></span> Push(x any) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span></span> Pop() any &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义最大堆</span></span><br><span class="line"><span class="keyword">type</span> maxHeap []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *maxHeap)</span></span> Push(x any) &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *maxHeap)</span></span> Pop() any &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[:n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>
<p><code>AddNum</code> 操作：O(log n)</p>
<ul>
<li>堆的插入和删除操作都是 O(log n)，其中 n 是堆的大小</li>
<li>每次 AddNum 进行了固定次数（常数次）的堆操作</li>
</ul>
</li>
<li>
<p><code>FindMedian</code> 操作：O(1)</p>
<ul>
<li>直接返回堆顶或两个堆顶的平均值，是常数时间操作</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li>O(n)，其中 n 是添加到数据结构中的元素数量
<ul>
<li>所有元素都存储在两个堆中</li>
</ul>
</li>
</ul>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>双堆法</th>
<th>排序数组法</th>
<th>AVL 树/红黑树法</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加元素时间复杂度</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>查找中位数时间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>中等</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>适用场景</td>
<td>高频添加和查询</td>
<td>高频查询，低频添加</td>
<td>数据量大且波动大</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>数据结构的选择至关重要</strong>：使用两个堆能让我们高效地获取中位数</li>
<li><strong>数据平衡的维护</strong>：确保两个堆的大小差不超过 1，是算法正确性的关键</li>
<li><strong>元素交换的技巧</strong>：通过比较新元素和堆顶元素来保证数据分布正确</li>
<li><strong>数据流算法设计</strong>：处理数据流问题时，我们通常无法一次处理所有数据，需要能够动态调整的数据结构</li>
<li><strong>堆的接口实现</strong>：Go 语言 <code>container/heap</code> 包提供了灵活的堆接口，通过实现接口可以快速构建自定义堆</li>
</ol>
<p>这道题目是堆和优先队列在实际问题中的一个典型应用，也展示了如何在不排序整个数组的情况下高效地维护数据的中位数。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>堆</tag>
        <tag>优先队列</tag>
        <tag>数据结构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 215 - 数组中的第K个最大元素 (超时分析与优化)</title>
    <url>/2025/05/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-%E8%B6%85%E6%97%B6%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>约束条件:</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我最初使用快速选择（Quick Select）算法来解决这个问题，但在某些情况下遇到了超时问题。</p>
<h3 id="最初的错误代码">最初的错误代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  n := <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> || k &gt; n &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">    pivot := left + rand.Intn(right-left+<span class="number">1</span>)</span><br><span class="line">    nums[left], nums[pivot] = nums[pivot], nums[left]</span><br><span class="line">    tmpLeft, tmpRight := left, right</span><br><span class="line">    tmp := nums[left]</span><br><span class="line">    <span class="keyword">for</span> tmpLeft &lt; tmpRight &#123;</span><br><span class="line">      <span class="keyword">for</span> tmpLeft &lt; tmpRight &amp;&amp; nums[tmpRight] &lt; tmp &#123;</span><br><span class="line">        tmpRight--</span><br><span class="line">      &#125;</span><br><span class="line">      nums[tmpLeft] = nums[tmpRight]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 错误的分区条件</span></span><br><span class="line">      <span class="keyword">for</span> tmpLeft &lt; tmpRight &amp;&amp; nums[tmpLeft] &gt; tmp &#123;</span><br><span class="line">        tmpLeft++</span><br><span class="line">      &#125;</span><br><span class="line">      nums[tmpRight] = nums[tmpLeft]</span><br><span class="line">    &#125;</span><br><span class="line">    nums[tmpLeft] = tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tmpLeft == k<span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tmpLeft &lt; k<span class="number">-1</span> &#123;</span><br><span class="line">      left = tmpLeft + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = tmpLeft - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<ul>
<li><strong>分区判断不严谨</strong>：错误代码中左侧分区使用 <code>for tmpLeft &lt; tmpRight &amp;&amp; nums[tmpLeft] &gt; tmp</code>，跳过了等于基准值的元素，导致分区不均衡，在存在大量重复或极端分布时，退化为 O(n²) 耗时。</li>
<li><strong>随机枢轴未充分利用</strong>：在重复元素较多或近似有序的数组上，未能有效打乱数据顺序，分区效率低下。</li>
</ul>
<p>通过将左侧分区条件修改为 <code>nums[tmpLeft] &gt;= tmp</code>、在达到目标位置后及时退出循环，并结合合理的随机枢轴抽取，可保证平均 O(n) 性能。</p>
<h2 id="正确解法">正确解法</h2>
<p>快速选择（Quick Select）算法是解决&quot;第 k 大/小元素&quot;问题的经典方法，它是快速排序的变种，平均时间复杂度为 O(n)，远优于完全排序的 O(n log n)。</p>
<h3 id="解题原理">解题原理</h3>
<h4 id="快速选择的本质原理">快速选择的本质原理</h4>
<p>快速选择算法的核心思想非常直接：<strong>我们不需要知道整个数组的排序情况，只需要确定第 k 大元素在哪里</strong>。这就像在一群人中找到身高排第 k 高的人，我们不需要把所有人按身高排好队，只需要找到那个特定位置的人。</p>
<p>想象你手里有一堆扑克牌，要找到大小排第 k 的牌：</p>
<ol>
<li>你随机抽一张牌作为&quot;参考牌&quot;</li>
<li>把比参考牌大的放左边，比参考牌小的放右边</li>
<li>看看参考牌现在是第几位：
<ul>
<li>如果正好是第 k 位，恭喜你找到了答案！</li>
<li>如果参考牌排在第 j 位且 j&lt;k，说明目标在右边那堆牌里</li>
<li>如果 j&gt;k，说明目标在左边那堆牌里</li>
</ul>
</li>
<li>只在可能包含目标的那一堆牌中重复上述过程</li>
</ol>
<p><strong>这种&quot;排除法&quot;的精妙之处</strong>在于：每次操作后，我们可以确定一个元素的最终位置，并排除掉一大半不可能包含答案的元素。我们不断缩小搜索范围，直到找到答案。</p>
<h4 id="为什么会超时？重复元素的陷阱">为什么会超时？重复元素的陷阱</h4>
<p>在有大量重复元素的情况下，如果我们把&quot;等于参考牌&quot;的牌全都放在一边（比如都放在大于参考牌的一组），会导致分区极度不平衡。最坏情况下，每次只能排除一个元素，算法就退化为 O(n²)。</p>
<p>这就像在找第 k 高的人时，如果有很多人身高相同，而我们将所有相同身高的人都放在同一组，可能导致每次只能排除很少的人，效率大大降低。</p>
<h4 id="随机选择的威力">随机选择的威力</h4>
<p>随机选择参考元素是另一个关键点。如果总是选第一个元素作为参考，遇到已排序或特殊构造的数组时会陷入最坏情况。随机选择就像是在扑克牌中闭眼随机抽一张作为参考，这样不管牌是否有序，都能以较高概率获得平衡的分区。</p>
<p><strong>随机化使算法具有&quot;概率意义上的稳健性&quot;</strong>—算法的期望运行时间是 O(n)，即使在最坏数据分布下也很难触发最坏情况。</p>
<h4 id="时空复杂度解析">时空复杂度解析</h4>
<p>从数学角度看，快速选择的平均时间复杂度是 O(n)，这是因为：</p>
<ul>
<li>第一次分区需要比较 n 个元素</li>
<li>第二次大约需要比较 n/2 个元素</li>
<li>第三次约 n/4 个元素</li>
<li>以此类推…</li>
</ul>
<p>最终得到：n + n/2 + n/4 + … ≈ 2n，所以复杂度是 O(n)。</p>
<p>相比之下，如果用排序算法，必须把所有元素都排好序，至少需要 O(n log n)的时间复杂度。快速选择巧妙地避开了&quot;完全排序&quot;这一昂贵操作，直接定位到我们关心的那个位置。</p>
<h3 id="代码实现与讲解">代码实现与讲解</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  n := <span class="built_in">len</span>(nums)</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> || k &gt; n &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  <span class="comment">// 边界检查，确保k有效</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">    <span class="comment">// 随机选择基准值，避免最坏情况</span></span><br><span class="line">    pivot := left + rand.Intn(right-left+<span class="number">1</span>)</span><br><span class="line">    nums[left], nums[pivot] = nums[pivot], nums[left]  <span class="comment">// 将基准值交换到左侧</span></span><br><span class="line"></span><br><span class="line">    tmpLeft, tmpRight := left, right</span><br><span class="line">    tmp := nums[left]  <span class="comment">// 保存基准值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序的分区过程</span></span><br><span class="line">    <span class="keyword">for</span> tmpLeft &lt; tmpRight &#123;</span><br><span class="line">      <span class="comment">// 从右向左找到第一个大于等于基准值的元素</span></span><br><span class="line">      <span class="keyword">for</span> tmpLeft &lt; tmpRight &amp;&amp; nums[tmpRight] &lt; tmp &#123;</span><br><span class="line">        tmpRight--</span><br><span class="line">      &#125;</span><br><span class="line">      nums[tmpLeft] = nums[tmpRight]  <span class="comment">// 将该元素放到左侧</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 修正分区条件：包含等于基准值的元素，避免倾斜分区</span></span><br><span class="line">      <span class="comment">// 在存在大量重复元素时，这个修正至关重要</span></span><br><span class="line">      <span class="keyword">for</span> tmpLeft &lt; tmpRight &amp;&amp; nums[tmpLeft] &gt;= tmp &#123;</span><br><span class="line">        tmpLeft++</span><br><span class="line">      &#125;</span><br><span class="line">      nums[tmpRight] = nums[tmpLeft]  <span class="comment">// 将该元素放到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准值放到最终位置</span></span><br><span class="line">    nums[tmpLeft] = tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据基准值位置调整搜索区间</span></span><br><span class="line">    <span class="keyword">if</span> tmpLeft == k<span class="number">-1</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>  <span class="comment">// 达到目标位置后及时退出，找到第k大元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tmpLeft &lt; k<span class="number">-1</span> &#123;</span><br><span class="line">      left = tmpLeft + <span class="number">1</span>  <span class="comment">// 在右侧区间继续寻找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = tmpLeft - <span class="number">1</span>  <span class="comment">// 在左侧区间继续寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时第k大的元素已经位于正确的位置</span></span><br><span class="line">  <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析与优化总结">复杂度分析与优化总结</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li><strong>平均情况</strong>：O(n)
<ul>
<li>每次分区操作能够排除约一半的元素</li>
<li>总体递归深度为 O(log n)，每层处理 O(n)个元素</li>
<li>数学表达：T(n) = T(n/2) + O(n) = O(n)</li>
</ul>
</li>
<li><strong>最坏情况</strong>：O(n²)
<ul>
<li>如果每次选择的基准值都是最大或最小元素</li>
<li>但随机选择基准值使最坏情况的概率变得极低</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li><strong>O(1)</strong> - 原地操作，只使用常数额外空间</li>
<li>没有使用递归，避免了递归栈的空间消耗</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>快速选择</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 347 - 前 K 个高频元素 (Top K Frequent Elements)</title>
    <url>/2025/05/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p><strong>示例 1:</strong></p>
<p>输入: nums = <code>[1,1,1,2,2,3]</code>, k = 2<br>
输出: <code>[1,2]</code></p>
<p><strong>示例 2:</strong></p>
<p>输入: nums = <code>[1]</code>, k = 1<br>
输出: <code>[1]</code></p>
<p><strong>提示：</strong></p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度必须优于 O(<em>n</em> log <em>n</em>) , <em>n</em> 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>解决这个问题的核心思路分为两步：</p>
<ol>
<li><strong>统计频率</strong>：遍历整个数组，使用哈希表（在 Go 中是 <code>map</code>）来统计每个元素出现的频率。</li>
<li><strong>找出前 K 个高频元素</strong>：利用堆（优先队列）这种数据结构，来高效地找出频率最高的前 K 个元素。</li>
</ol>
<p>具体步骤如下：</p>
<ol>
<li>创建一个哈希表 <code>freqMap</code>，用于存储每个数字及其出现的频率。</li>
<li>遍历输入数组 <code>nums</code>，对于每个数字：
<ul>
<li>如果数字已存在于 <code>freqMap</code> 中，则将其频率加 1。</li>
<li>如果数字不存在于 <code>freqMap</code> 中，则将其添加到 <code>freqMap</code> 并设置频率为 1。</li>
</ul>
</li>
<li>创建一个小顶堆（min-heap）。堆中存储的是一个包含数字和其频率的结构体或数组。堆的大小维持在 K。</li>
<li>遍历 <code>freqMap</code> 中的每个键值对（数字和频率）：
<ul>
<li>如果堆的大小小于 K，直接将当前元素（数字和频率）加入堆中。</li>
<li>如果堆的大小等于 K，比较当前元素的频率与堆顶元素的频率：
<ul>
<li>如果当前元素的频率大于堆顶元素的频率，则将堆顶元素移除，并将当前元素加入堆中。这样可以保证堆中始终存储的是当前已遍历元素中频率最高的 K 个。</li>
</ul>
</li>
</ul>
</li>
<li>遍历结束后，堆中的 K 个元素即为频率最高的前 K 个元素。将这些元素的数字部分提取出来即可。</li>
</ol>
<h2 id="Go-中-container-heap-的使用方法">Go 中 <code>container/heap</code> 的使用方法</h2>
<p>Go 语言标准库 <code>container/heap</code> 提供了一个实现堆（优先队列）的接口。要使用它，我们需要定义一个类型，并为该类型实现 <code>heap.Interface</code> 接口，该接口包含以下五个方法：</p>
<ul>
<li><code>Len() int</code>：返回集合中的元素个数。</li>
<li><code>Less(i, j int) bool</code>：比较索引为 <code>i</code> 和 <code>j</code> 的两个元素，如果 <code>heap[i]</code> 应该排在 <code>heap[j]</code> 前面，则返回 <code>true</code>。对于小顶堆，如果 <code>heap[i] &lt; heap[j]</code> 则返回 <code>true</code>；对于大顶堆，如果 <code>heap[i] &gt; heap[j]</code> 则返回 <code>true</code>。</li>
<li><code>Swap(i, j int)</code>：交换索引为 <code>i</code> 和 <code>j</code> 的两个元素。</li>
<li><code>Push(x interface&#123;&#125;)</code>：向堆中添加一个元素 <code>x</code>。注意 <code>x</code> 的类型是 <code>interface&#123;&#125;</code>，通常我们会将其断言为我们定义的元素类型。这个方法通常是追加元素到内部的 slice 末尾。</li>
<li><code>Pop() interface&#123;&#125;</code>：移除并返回堆顶元素（对于小顶堆是最小元素，对于大顶堆是最大元素）。这个方法通常是移除内部 slice 的末尾元素。</li>
</ul>
<h3 id="针对本题的堆实现">针对本题的堆实现</h3>
<p>为了解决“前 K 个高频元素”的问题，我们需要一个<strong>小顶堆</strong>，堆中元素的比较基准是它们的<strong>频率</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义堆中元素的结构</span></span><br><span class="line"><span class="keyword">type</span> FreqElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span> <span class="comment">// 元素值</span></span><br><span class="line">	Count <span class="type">int</span> <span class="comment">// 元素出现的频率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类型，它实现了 heap.Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []FreqElement</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回堆中元素的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less 比较两个元素的频率，用于构建小顶堆</span></span><br><span class="line"><span class="comment">// 如果 h[i] 的频率小于 h[j] 的频率，则 h[i] 应该排在 h[j] 前面</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Count &lt; h[j].Count &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap 交换堆中两个元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push 向堆中添加一个元素</span></span><br><span class="line"><span class="comment">// 注意：Push 方法的参数是 interface&#123;&#125;，需要类型断言</span></span><br><span class="line"><span class="comment">// heap.Push 会调用这个 Push 方法，并将元素追加到 slice 的末尾</span></span><br><span class="line"><span class="comment">// 然后通过 up 调整堆结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(FreqElement))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 从堆中移除并返回最小频率的元素（堆顶元素）</span></span><br><span class="line"><span class="comment">// 注意：Pop 方法返回的是 interface&#123;&#125;，需要类型断言</span></span><br><span class="line"><span class="comment">// heap.Pop 会先将堆顶元素与末尾元素交换，然后移除末尾元素</span></span><br><span class="line"><span class="comment">// 再通过 down 调整堆结构，最后返回移除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FreqElement 定义堆中元素的结构</span></span><br><span class="line"><span class="keyword">type</span> FreqElement <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span> <span class="comment">// 元素值</span></span><br><span class="line">	Count <span class="type">int</span> <span class="comment">// 元素出现的频率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MinHeap 定义一个类型，它实现了 heap.Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []FreqElement</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i].Count &lt; h[j].Count &#125; <span class="comment">// 小顶堆，按频率比较</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(FreqElement))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 统计元素频率</span></span><br><span class="line">	freqMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		freqMap[num]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 构建小顶堆</span></span><br><span class="line">	h := &amp;MinHeap&#123;&#125;</span><br><span class="line">	heap.Init(h) <span class="comment">// 初始化堆</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 遍历频率映射，维护大小为 k 的小顶堆</span></span><br><span class="line">	<span class="keyword">for</span> val, count := <span class="keyword">range</span> freqMap &#123;</span><br><span class="line">		<span class="keyword">if</span> h.Len() &lt; k &#123;</span><br><span class="line">			heap.Push(h, FreqElement&#123;Val: val, Count: count&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果当前元素的频率大于堆顶元素的频率（堆顶是当前k个元素中频率最小的）</span></span><br><span class="line">			<span class="comment">// 则弹出堆顶，并将当前元素压入堆</span></span><br><span class="line">			<span class="keyword">if</span> count &gt; (*h)[<span class="number">0</span>].Count &#123; <span class="comment">// (*h)[0] 是堆顶元素</span></span><br><span class="line">				heap.Pop(h)</span><br><span class="line">				heap.Push(h, FreqElement&#123;Val: val, Count: count&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 提取结果</span></span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		<span class="comment">// Pop出来的是频率最小的，但因为我们维护的是大小为k的堆，</span></span><br><span class="line">		<span class="comment">// 并且不断用更高频率的元素替换低频率的，所以最后堆里剩下的就是前k个高频元素。</span></span><br><span class="line">		<span class="comment">// 题目对顺序没有要求，所以直接Pop即可。</span></span><br><span class="line">		<span class="comment">// 如果需要按频率从高到低输出，则需要先将所有元素压入大顶堆，然后Pop k次。</span></span><br><span class="line">		<span class="comment">// 或者，将小顶堆的元素取出后反转。</span></span><br><span class="line">		<span class="comment">// 这里我们直接按Pop的顺序（频率从小到大，但都是前k个高频的）放入结果数组，然后反转。</span></span><br><span class="line">		<span class="comment">// 或者，更简单地，因为题目不要求顺序，可以直接从堆中取出。</span></span><br><span class="line">		result[i] = heap.Pop(h).(FreqElement).Val</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 如果需要按频率从高到低输出，可以对result进行一次反转</span></span><br><span class="line">    <span class="comment">// for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 &#123;</span></span><br><span class="line">	<span class="comment">// 	result[i], result[j] = result[j], result[i]</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>哈希表 + 排序</th>
<th>哈希表 + 小顶堆 (本解法)</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(N + M log M)，其中 N 是数组长度，M 是不同元素的个数</td>
<td>O(N + M log K)，其中 N 是数组长度，M 是不同元素的个数，K 是要找的元素个数</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(M)</td>
<td>O(M + K)</td>
</tr>
<tr>
<td>优点</td>
<td>实现相对简单</td>
<td>时间复杂度更优，特别是当 M 远大于 K 时</td>
</tr>
<tr>
<td>缺点</td>
<td>当不同元素很多时，排序开销大</td>
<td>实现略复杂，需要自定义堆结构</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<p><strong>说明：</strong></p>
<ul>
<li><strong>哈希表 + 排序</strong>：先用哈希表统计频率 (O(N))，然后将哈希表中的元素（值和频率）存入一个列表并按频率排序 (O(M log M))，最后取前 K 个。</li>
<li><strong>哈希表 + 小顶堆</strong>：先用哈希表统计频率 (O(N))，然后遍历哈希表中的 M 个元素，每个元素进行堆操作 (Push/Pop)，堆操作的时间复杂度是 O(log K)。所以这部分是 O(M log K)。</li>
</ul>
<p>由于题目要求时间复杂度优于 O(<em>n</em> log <em>n</em>)，当 M 接近 N 时，O(N + M log M) 约等于 O(N log N)，可能不满足要求。而 O(N + M log K) 通常会更好。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>统计频率：O(N)，其中 N 是数组 <code>nums</code> 的长度。</li>
<li>构建和维护堆：我们遍历 <code>freqMap</code>，其大小最多为 N (当所有元素都不同时，记为 M，M &lt;= N)。对于 <code>freqMap</code> 中的每个元素，我们执行一次堆操作（<code>Push</code> 或 <code>Pop</code> 后 <code>Push</code>）。堆的大小最多为 K。因此，堆操作的时间复杂度为 O(log K)。总共是 O(M log K)。</li>
<li>所以，总的时间复杂度是 O(N + M log K)。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：
<ul>
<li>哈希表 <code>freqMap</code>：最坏情况下存储 M 个不同元素，空间复杂度为 O(M)。</li>
<li>堆 <code>h</code>：存储 K 个元素，空间复杂度为 O(K)。</li>
<li>所以，总的空间复杂度是 O(M + K)。</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li>理解哈希表在统计频率问题中的高效应用。</li>
<li>掌握 Go 语言中 <code>container/heap</code> 包的使用方法，包括如何定义自定义类型并实现 <code>heap.Interface</code> 接口。</li>
<li>学会使用小顶堆来解决“前 K 大/高”这类问题，通过维护一个固定大小的堆，不断将更优的元素替换堆顶元素。</li>
<li>对于需要自定义比较逻辑的优先队列，<code>container/heap</code> 提供了灵活的解决方案。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 84 - 柱状图中最大的矩形</title>
    <url>/2025/05/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="/2025/05/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/1747066251581.png" alt="1747066251581"></p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形是从第三个柱子开始，到第四个柱子结束，高度为 5，宽度为 2，面积为 10</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2>
<p>这道题看似简单，实则暗藏玄机。我们需要在柱状图中找出面积最大的矩形。直观上看，这个矩形必须以某个柱子的高度为高，然后向两边尽可能延伸。</p>
<p>想象你在一排高矮不一的楼房中寻找能放置一个最大长方形广告牌的位置，你需要考虑：</p>
<ol>
<li>每个楼的高度（决定了广告牌的高度）</li>
<li>能在多少个相邻楼上放（决定了广告牌的宽度）</li>
</ol>
<p>我们将介绍三种方法来解决这个问题：从最直观但效率较低的暴力法，到高效精巧的单调栈解法。</p>
<h3 id="方法一：暴力法-最直观的解法">方法一：暴力法 - 最直观的解法</h3>
<p>暴力法就像是我们一个个尝试所有可能的矩形，就像小孩子一样挨个试一试。</p>
<p>思路非常直白：</p>
<ol>
<li>我们先选定一个柱子，把它的高度作为矩形的高</li>
<li>然后像橡皮筋一样，尽可能地向左右两边拉伸，直到碰到比这个柱子矮的为止</li>
<li>计算此时的面积，记录下最大值</li>
</ol>
<p>比如对于柱子高度 <code>[2,1,5,6,2,3]</code>：</p>
<ul>
<li>如果选择高度 5 的柱子，我们不能向左拉伸（因为左边的 1 比 5 矮），但可以向右拉伸一格（因为右边的 6 比 5 高）</li>
<li>此时得到的矩形宽度是 2，高度是 5，面积为 10</li>
</ul>
<p>这是最容易想到的方法，也最符合我们的直觉思维：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line">    maxArea := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        height := heights[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向左扩展</span></span><br><span class="line">        left := i</span><br><span class="line">        <span class="keyword">for</span> left &gt; <span class="number">0</span> &amp;&amp; heights[left<span class="number">-1</span>] &gt;= height &#123;</span><br><span class="line">            left--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向右扩展</span></span><br><span class="line">        right := i</span><br><span class="line">        <span class="keyword">for</span> right &lt; n<span class="number">-1</span> &amp;&amp; heights[right+<span class="number">1</span>] &gt;= height &#123;</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算面积</span></span><br><span class="line">        width := right - left + <span class="number">1</span></span><br><span class="line">        area := height * width</span><br><span class="line">        maxArea = max(maxArea, area)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n²)$，其中 n 是输入数组的长度。<br>
空间复杂度：$O(1)$。</p>
<p>这种方法在 LeetCode 上会超时，因此我们需要更高效的算法。</p>
<h3 id="方法二：分治法-巧妙地分割问题">方法二：分治法 - 巧妙地分割问题</h3>
<p>分治法的思想就像&quot;兵分两路&quot;战术：</p>
<ol>
<li>首先找到整个柱状图中<strong>最矮的那个柱子</strong>（就像找到一个军事分界线）</li>
<li>用这个最矮柱子的高度乘以整个图的宽度，得到一个可能的面积</li>
<li>然后将问题分成两半：最矮柱子左边的部分和右边的部分</li>
<li>分别在这两部分中继续寻找最大面积</li>
<li>最后从这三个面积（横跨整个区域的、只在左半部分的、只在右半部分的）中取最大值</li>
</ol>
<p>这种方法的妙处在于：对于横跨的矩形，高度受限于最矮的柱子；对于不包含最矮柱子的矩形，我们可以在子区域中重复此过程。</p>
<p>看一个生动例子：假设我们有柱子 <code>[3,1,4,2]</code>：</p>
<ul>
<li>最矮的柱子是第二个，高度为 1</li>
<li>用它计算一个面积：1×4 = 4</li>
<li>分割成左半部分 <code>[3]</code> 和右半部分 <code>[4,2]</code></li>
<li>在左半部分中，最大面积是 3×1 = 3</li>
<li>在右半部分中，最大面积是 2×2 = 4</li>
<li>最终的最大面积是 4</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> calculateArea(heights, <span class="number">0</span>, <span class="built_in">len</span>(heights)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateArea</span><span class="params">(heights []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> start &gt; end &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start == end &#123;</span><br><span class="line">        <span class="keyword">return</span> heights[start]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最小高度的索引</span></span><br><span class="line">    minIdx := start</span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> heights[i] &lt; heights[minIdx] &#123;</span><br><span class="line">            minIdx = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算三种可能的情况下的最大面积</span></span><br><span class="line">    useMin := heights[minIdx] * (end - start + <span class="number">1</span>)</span><br><span class="line">    leftArea := calculateArea(heights, start, minIdx<span class="number">-1</span>)</span><br><span class="line">    rightArea := calculateArea(heights, minIdx+<span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(useMin, max(leftArea, rightArea))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：平均情况下为 $O(n \log n)$，最坏情况下为 $O(n²)$。<br>
空间复杂度：$O(\log n)$，递归调用栈的空间。</p>
<h3 id="方法三：单调栈（最优解）-聪明的一趟扫描法">方法三：单调栈（最优解）- 聪明的一趟扫描法</h3>
<p>单调栈就像是一个聪明的&quot;侦察兵&quot;，能够高效地找出每个柱子的&quot;左右邻居&quot;（左右两边第一个比它矮的柱子）。</p>
<h4 id="单调栈的原理通俗解释">单调栈的原理通俗解释</h4>
<p>想象你站在平原上看一排高低不同的楼房，但你只能看到那些没被前面更高楼房挡住的楼：</p>
<ol>
<li>我们从左到右走，用一个栈记录&quot;能看到的楼房&quot;</li>
<li>当遇到一个比栈顶更矮的楼时，意味着栈顶楼的&quot;右边界&quot;已经确定</li>
<li>此时，我们计算以栈顶楼高为高的矩形面积，然后将它从栈中移除</li>
<li>重复这个过程，直到栈顶楼不再比当前楼高</li>
<li>最后，我们把当前楼也加入到栈中</li>
</ol>
<p><strong>关键洞见</strong>：通过这种方式，对于每个柱子，我们能够找到：</p>
<ul>
<li>它左边第一个比它矮的柱子（栈中它下面的元素）</li>
<li>它右边第一个比它矮的柱子（导致它被弹出栈的元素）</li>
</ul>
<p>有了这两个边界，我们就能计算以这个柱子高度为高的最大矩形面积。</p>
<p>这种方法只需要遍历数组一次，时间复杂度是 $O(n)$，是最高效的解法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;<span class="number">-1</span>&#125;  <span class="comment">// 辅助栈，初始放入-1作为边界</span></span><br><span class="line">    maxArea := <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(heights)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每个柱子</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> heights &#123;</span><br><span class="line">        <span class="comment">// 当栈顶元素对应的柱子高度大于当前柱子高度时</span></span><br><span class="line">        <span class="keyword">for</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="number">-1</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素，计算以该柱子高度为高的矩形面积</span></span><br><span class="line">            height := heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算宽度：当前位置 - 新栈顶位置 - 1</span></span><br><span class="line">            width := i - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最大面积</span></span><br><span class="line">            maxArea = max(maxArea, height * width)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前柱子的索引入栈</span></span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理栈中剩余的柱子</span></span><br><span class="line">    <span class="keyword">for</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="number">-1</span> &#123;</span><br><span class="line">        height := heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        width := n - stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">        maxArea = max(maxArea, height * width)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$O(n)$，每个元素最多被入栈出栈各一次。<br>
空间复杂度：$O(n)$，栈的空间。</p>
<h2 id="代码错误分析-我犯的错误">代码错误分析 - 我犯的错误</h2>
<p>在最初的实现中，我犯了一个非常常见但很容易被忽视的错误：<strong>没有处理栈中剩余的元素</strong>。这就像是书写一篇文章时忘记了写结尾，故事戛然而止，显得不完整。</p>
<h3 id="❌-错误的代码">❌ 错误的代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestRectangleArea</span><span class="params">(heights []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    stack := []<span class="type">int</span>&#123;<span class="number">-1</span>&#125;</span><br><span class="line">    maxArea := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> heights &#123;</span><br><span class="line">        <span class="keyword">for</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="number">-1</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            mid := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            left := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            maxArea = max(maxArea, heights[mid]*(i-left<span class="number">-1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea  <span class="comment">// ❌ 错误：没有处理栈中剩余的元素！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因-通俗解释">错误原因 - 通俗解释</h3>
<p>想象你是一个摄影师，要为一排站着的人拍照。你的规则是：</p>
<ol>
<li>从左到右看，当看到一个比前面矮的人时，就给前面的人拍照</li>
<li>拍照时需要确定这个人的&quot;左右边界&quot;（左右两边第一个比他矮的人）</li>
</ol>
<p><strong>问题出在哪里？</strong> 当你走完整排人后，还有些人没拍照！这些人右边没有比他们矮的人了，但他们仍然需要被拍照。</p>
<p>在我的原始代码中，这些&quot;剩下的人&quot;（栈中剩余的元素）被完全忽略了，它们代表的潜在最大矩形没有被计算。</p>
<p>例如，对于输入 <code>[2,1,5,6,2,3]</code>，遍历结束后栈中还会剩余：</p>
<ul>
<li>索引 <code>-1</code>（哨兵值，不是实际柱子）</li>
<li>索引 <code>1</code>（高度为 1 的柱子）</li>
<li>索引 <code>4</code>（高度为 2 的柱子）</li>
<li>索引 <code>5</code>（高度为 3 的柱子）</li>
</ul>
<p>这三个实际柱子<strong>可能形成的矩形都没有被考虑</strong>！</p>
<h3 id="✅-修正的解法">✅ 修正的解法</h3>
<p>正确的做法是，遍历结束后，还需要&quot;清空栈&quot;，处理所有剩余的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理栈中剩余的柱子</span></span><br><span class="line"><span class="keyword">for</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="number">-1</span> &#123;</span><br><span class="line">    mid := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">    stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">    left := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">// 这些柱子的右边界就是数组的末尾</span></span><br><span class="line">    maxArea = max(maxArea, heights[mid]*(n-left<span class="number">-1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就像是确保给所有人都拍了照，不落下任何一个。对于这些剩下的柱子，它们的右边界就是整个数组的末尾（因为右边没有更矮的柱子了）。</p>
<h2 id="单调栈解法图解-一步一步看懂">单调栈解法图解 - 一步一步看懂</h2>
<p>为了让单调栈的工作原理更加容易理解，我们来通过一个图解示例，就像讲故事一样展示解题过程。以 <code>[2,1,5,6,2,3]</code> 为例：</p>
<h3 id="图解流程">图解流程</h3>
<p><img src="/2025/05/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/1747067025071.png" alt="1747067025071"></p>
<ol>
<li>
<p><strong>初始准备</strong>：</p>
<ul>
<li>栈 = [-1] （-1 是一个哨兵值，表示边界）</li>
<li>maxArea = 0</li>
</ul>
</li>
<li>
<p><strong>处理第 1 个柱子（高度=2）</strong>：</p>
<ul>
<li>因为栈为空，直接入栈</li>
<li>栈 = [-1, 0] （0 是柱子的索引）</li>
</ul>
</li>
<li>
<p><strong>处理第 2 个柱子（高度=1）</strong>：</p>
<ul>
<li>发现 1 &lt; 2，也就是当前柱子比栈顶柱子矮</li>
<li>这意味着我们找到了栈顶柱子的右边界！</li>
<li>弹出栈顶索引 0，计算面积：2 × (1-(-1)-1) = 2</li>
<li>把当前柱子入栈，栈 = [-1, 1]</li>
</ul>
</li>
<li>
<p><strong>处理第 3 个柱子（高度=5）</strong>：</p>
<ul>
<li>5 &gt; 1，当前柱子比栈顶高</li>
<li>直接入栈，栈 = [-1, 1, 2]</li>
</ul>
</li>
<li>
<p><strong>处理第 4 个柱子（高度=6）</strong>：</p>
<ul>
<li>6 &gt; 5，当前柱子比栈顶高</li>
<li>直接入栈，栈 = [-1, 1, 2, 3]</li>
</ul>
</li>
<li>
<p><strong>处理第 5 个柱子（高度=2）</strong>：</p>
<ul>
<li>2 &lt; 6，当前柱子比栈顶矮</li>
<li>弹出栈顶索引 3，计算面积：6 × (4-2-1) = 6</li>
<li>2 &lt; 5，继续弹出栈顶索引 2，计算面积：5 × (4-1-1) = 10 ← 目前最大</li>
<li>2 &gt; 1，停止弹出</li>
<li>把当前柱子入栈，栈 = [-1, 1, 4]</li>
</ul>
</li>
<li>
<p><strong>处理第 6 个柱子（高度=3）</strong>：</p>
<ul>
<li>3 &gt; 2，当前柱子比栈顶高</li>
<li>直接入栈，栈 = [-1, 1, 4, 5]</li>
</ul>
</li>
<li>
<p><strong>处理剩余栈中元素</strong>（这一步是我之前忽略的）：</p>
<ul>
<li>弹出索引 5，计算面积：3 × (6-4-1) = 3</li>
<li>弹出索引 4，计算面积：2 × (6-1-1) = 8</li>
<li>弹出索引 1，计算面积：1 × (6-(-1)-1) = 6</li>
</ul>
</li>
</ol>
<p>经过完整计算，最大面积是 <strong>10</strong>，对应的是高度为 5，宽度为 2 的矩形（从索引 2 到索引 3）。</p>
<h3 id="关键理解点">关键理解点</h3>
<p>单调栈的巧妙之处在于：</p>
<ul>
<li>入栈：当前柱子比栈顶高，表示&quot;还不知道右边界在哪&quot;</li>
<li>出栈：当前柱子比栈顶矮，表示&quot;找到了栈顶柱子的右边界&quot;</li>
<li>剩余处理：遍历结束后栈中剩余的柱子，它们的右边界是数组的末尾</li>
</ul>
<p>这个过程就像是在处理一排人的视线问题，每个人只能看到右边第一个比自己矮的人，单调栈帮我们在 O(n)时间内找到了所有这样的关系。</p>
<h2 id="总结与反思">总结与反思</h2>
<h3 id="三种方法的对比">三种方法的对比</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
<th>时间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>暴力法</td>
<td>最直观易懂</td>
<td>效率低</td>
<td>$O(n²)$</td>
<td>数据量小，面试初步思路</td>
</tr>
<tr>
<td>分治法</td>
<td>思路优雅</td>
<td>实现复杂</td>
<td>$O(n \log n)$，最坏 $O(n²)$</td>
<td>处理递归问题，分而治之</td>
</tr>
<tr>
<td>单调栈</td>
<td>效率最高，一次遍历</td>
<td>需理解栈原理</td>
<td>$O(n)$</td>
<td>大数据量，最优解法</td>
</tr>
</tbody>
</table>
<h3 id="我的错误与教训">我的错误与教训</h3>
<p>这道题我犯的错误（忘记处理栈中剩余元素）其实非常常见，但它给我们两个重要启示：</p>
<ol>
<li>
<p><strong>算法的完整性很重要</strong>：不要只关注主循环，还要考虑循环结束后的&quot;收尾工作&quot;。就像写故事不能忘记结尾一样。</p>
</li>
<li>
<p><strong>特殊情况的处理</strong>：在这个问题中，特殊情况是&quot;那些右边没有更矮柱子的元素&quot;，它们也需要被正确处理。</p>
</li>
</ol>
<h3 id="单调栈的应用场景">单调栈的应用场景</h3>
<p>单调栈不仅仅用于这道题，它是解决&quot;下一个更大/更小元素&quot;类问题的利器。其应用场景包括：</p>
<ul>
<li>寻找数组中每个元素的下一个更大元素</li>
<li>寻找温度升高需要等待的天数（LeetCode 739）</li>
<li>计算矩形面积类问题</li>
</ul>
<p><strong>记住</strong>：单调栈的核心思想是维持栈内元素的单调性（递增或递减），这样可以在 $O(n)$时间内找到每个元素左右两侧第一个比它大/小的元素。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>❌错题集</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 739 - 每日温度 (Daily Temperatures)</title>
    <url>/2025/05/12/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个整数数组 <code>temperatures</code>，表示每天的温度。你需要返回一个数组 <code>answer</code>，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>示例：</strong></p>
<p>输入: <code>temperatures = [73,74,75,71,69,72,76,73]</code><br>
输出: <code>[1,1,4,2,1,1,0,0]</code></p>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 10^5</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题要求我们找到每天之后第一个比它温度高的日子，并计算相差的天数。</p>
<h3 id="暴力解法（朴素想法）">暴力解法（朴素想法）</h3>
<p>最直接的想法是，对于每一天 <code>i</code>，我们都向后遍历，找到第一个温度比 <code>temperatures[i]</code> 高的日子 <code>j</code>，那么 <code>answer[i] = j - i</code>。如果找不到，则 <code>answer[i] = 0</code>。这种方法的时间复杂度是 O(N^2)，在 N 达到 10^5 时，会超时。</p>
<h3 id="单调栈解法">单调栈解法</h3>
<p>为了优化时间复杂度，我们可以使用「单调栈」。单调栈是一种特殊的栈，它在任何时候栈内元素都保持单调递增或单调递减的性质。对于这道题，我们希望找到每个元素的「下一个更大元素」，这正是单调栈的经典应用场景。</p>
<p>我们可以维护一个<strong>单调递减栈</strong>，栈中存储的是温度值的<strong>索引</strong>。为什么是单调递减呢？</p>
<ul>
<li>当我们遍历到当天的温度 <code>temperatures[i]</code> 时：
<ul>
<li>如果栈为空，或者当前温度小于等于栈顶索引对应的温度，说明当前温度没有打破栈的单调递减性（或者说，对于栈顶元素而言，当前温度还不是它右边第一个更高的温度），直接将当前温度的索引 <code>i</code> 入栈。</li>
<li>如果当前温度 <code>temperatures[i]</code> <strong>大于</strong>栈顶索引 <code>topIdx</code> 对应的温度 <code>temperatures[topIdx]</code>，这说明我们找到了 <code>temperatures[topIdx]</code> 右边第一个比它大的元素，这个元素就是 <code>temperatures[i]</code>。此时，栈顶元素 <code>topIdx</code> 的等待天数就是 <code>i - topIdx</code>。我们将 <code>topIdx</code> 出栈，并记录结果。然后继续比较新的栈顶元素和当前温度 <code>temperatures[i]</code>，直到栈为空或者当前温度不再大于栈顶温度。处理完毕后，将当前温度的索引 <code>i</code> 入栈，以维持后续的判断。</li>
</ul>
</li>
</ul>
<p>通过这种方式，每个元素的索引最多入栈一次、出栈一次，所以总的时间复杂度是 O(N)。</p>
<h2 id="代码实现-Go">代码实现 (Go)</h2>
<p>这是你提供的 Go 语言解法，它正确地使用了单调栈：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=739 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [739] 每日温度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="type">int</span>)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 存储索引的单调递减栈</span></span><br><span class="line">	res = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(temperatures)) <span class="comment">// 结果数组，默认值为0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> temperatures &#123;</span><br><span class="line">		<span class="comment">// 【待优化部分】</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当栈不为空，且当前温度大于栈顶索引对应的温度时</span></span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; temperatures[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &lt; temperatures[i] &#123;</span><br><span class="line">			top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// 取出栈顶索引</span></span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// 弹出栈顶</span></span><br><span class="line"></span><br><span class="line">			res[top] = i - top <span class="comment">// 计算等待天数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		stack = <span class="built_in">append</span>(stack, i) <span class="comment">// 当前索引入栈</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h2 id="代码优化">代码优化</h2>
<p>我们来看看上面代码中标记的【待优化部分】：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的意图是：如果栈为空，就直接把当前索引 <code>i</code> 加进去，然后跳过后续的 <code>for</code> 循环，开始下一次迭代。</p>
<p><strong>为什么可以优化呢？</strong></p>
<p>我们分析一下后续的逻辑：</p>
<ol>
<li><code>for len(stack) &gt; 0 &amp;&amp; temperatures[stack[len(stack)-1]] &lt; temperatures[i]</code>：这个循环处理的是当栈<strong>不为空</strong>且当前温度<strong>大于</strong>栈顶温度的情况。如果栈为空，<code>len(stack) &gt; 0</code> 这个条件自然不满足，循环体不会执行。</li>
<li><code>stack = append(stack, i)</code>：在 <code>for</code> 循环之后，无论之前栈是否为空，或者 <code>for</code> 循环是否执行，当前索引 <code>i</code> 都会被加入栈中。</li>
</ol>
<p>考虑如果我们将【待优化部分】去掉：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> temperatures &#123;</span><br><span class="line">    <span class="comment">// 【待优化部分】被移除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当栈不为空，且当前温度大于栈顶索引对应的温度时</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; temperatures[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &lt; temperatures[i] &#123;</span><br><span class="line">        top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        res[top] = i - top</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack = <span class="built_in">append</span>(stack, i) <span class="comment">// 当前索引入栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>现在，如果遍历到 <code>i</code> 时栈是空的：</p>
<ul>
<li>内部的 <code>for</code> 循环因为 <code>len(stack) &gt; 0</code> 不满足，所以不会执行。</li>
<li>然后，<code>stack = append(stack, i)</code> 会将 <code>i</code> 加入到空栈中。</li>
</ul>
<p>这与原始代码中【待优化部分】的行为结果是一致的！原始代码中，如果栈为空，会执行 <code>stack = append(stack, i)</code> 然后 <code>continue</code>。优化后，如果栈为空，内部 <code>for</code> 循环不执行，然后 <code>stack = append(stack, i)</code> 执行。两者最终都使得 <code>i</code> 被加入栈中，且没有错误地执行内部 <code>for</code> 循环的逻辑。</p>
<p>因此，那段显式的空栈检查和 <code>continue</code> 语句其实是<strong>不必要</strong>的。移除它可以让代码更简洁，因为后续的逻辑已经隐式地正确处理了栈为空的情况。</p>
<h2 id="优化后的代码实现-Go">优化后的代码实现 (Go)</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dailyTemperatures</span><span class="params">(temperatures []<span class="type">int</span>)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">	stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	res = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(temperatures))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> temperatures &#123;</span><br><span class="line">		<span class="comment">// 优化：移除了显式的空栈检查</span></span><br><span class="line">		<span class="comment">// if len(stack) == 0 &#123;</span></span><br><span class="line">		<span class="comment">//  stack = append(stack, i)</span></span><br><span class="line">		<span class="comment">//  continue</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; temperatures[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &lt; temperatures[i] &#123;</span><br><span class="line">			top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">			res[top] = i - top</span><br><span class="line">		&#125;</span><br><span class="line">		stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<p>这段优化后的代码功能完全相同，但更加精炼。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>: O(N)，其中 N 是 <code>temperatures</code> 数组的长度。每个元素的索引最多被压入和弹出栈一次。</li>
<li><strong>空间复杂度</strong>: O(N)，在最坏的情况下（例如温度持续递减 <code>[70,60,50,40]</code>），栈中会存储所有元素的索引。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li>单调栈是解决“下一个更大/更小元素”问题的有效工具。</li>
<li>在编写循环和条件判断时，仔细思考边界条件和已有逻辑的覆盖范围，有时可以发现冗余代码，使代码更简洁。</li>
<li>对于这道题，维护一个存储索引的单调递减栈是核心。</li>
</ul>
<p>希望这篇题解能帮助你更好地理解这道题目和单调栈的应用！</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 394 - 字符串解码 (String Decode)</title>
    <url>/2025/05/11/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为：<code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 30</code></li>
<li><code>s</code> 由小写英文字母、数字和方括号 <code>'[]'</code> 组成</li>
<li><code>s</code> 保证是一个有效的输入。</li>
<li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的特点是存在嵌套的括号和重复次数，这种具有递归结构或者需要处理嵌套关系的问题，通常可以考虑使用栈来解决。</p>
<p>我们可以维护两个栈：</p>
<ol>
<li><code>numStack</code>：用于存储重复次数 <code>k</code>。</li>
<li><code>strStack</code>：用于存储待解码的字符串片段。</li>
</ol>
<p>遍历输入的字符串 <code>s</code>，根据遇到的不同字符进行相应的操作：</p>
<ul>
<li><strong>遇到数字</strong>：
<ul>
<li>解析出完整的数字（可能不止一位）。</li>
<li>将解析得到的数字压入 <code>numStack</code>。</li>
</ul>
</li>
<li><strong>遇到字母</strong>：
<ul>
<li>解析出连续的字母串。</li>
<li>将这个字母串压入 <code>strStack</code>。</li>
</ul>
</li>
<li><strong>遇到 <code>[</code></strong>：
<ul>
<li>这是一个新的解码单元的开始，我们将一个特殊标记（例如 <code>[</code> 本身）压入 <code>strStack</code>，用于后续识别解码单元的边界。</li>
</ul>
</li>
<li><strong>遇到 <code>]</code></strong>：
<ul>
<li>这是当前解码单元的结束。我们需要从 <code>strStack</code> 中弹出字符串，直到遇到 <code>[</code>。这些弹出的字符串拼接起来就是当前 <code>encoded_string</code>。</li>
<li>从 <code>numStack</code> 中弹出一个数字，这是当前 <code>encoded_string</code> 需要重复的次数 <code>k</code>。</li>
<li>将 <code>encoded_string</code> 重复 <code>k</code> 次得到解码后的子串。</li>
<li>将这个解码后的子串压回 <code>strStack</code>。</li>
</ul>
</li>
</ul>
<p>遍历完成后，<code>strStack</code> 中剩下的所有字符串按顺序拼接起来就是最终的解码结果。</p>
<h2 id="代码实现-优化前">代码实现 (优化前)</h2>
<p>这是你提供的原始 Go 代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=394 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [394] 字符串解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  numStack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">  strStack := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    c := s[i]</span><br><span class="line">    <span class="comment">// fmt.Println(c) // 调试语句</span></span><br><span class="line">    <span class="keyword">if</span> isNum(c) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> i &gt;= <span class="number">1</span> &amp;&amp; isNum(s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        top := <span class="built_in">len</span>(numStack) - <span class="number">1</span></span><br><span class="line">        numStack[top] = numStack[top]*<span class="number">10</span> + <span class="type">int</span>(c-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        numStack = <span class="built_in">append</span>(numStack, <span class="type">int</span>(c-<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="string">&#x27;]&#x27;</span> &#123;</span><br><span class="line">      str := <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> strStack[<span class="built_in">len</span>(strStack)<span class="number">-1</span>] != <span class="string">&quot;[&quot;</span> &#123;</span><br><span class="line">        str = strStack[<span class="built_in">len</span>(strStack)<span class="number">-1</span>] + str</span><br><span class="line">        strStack = strStack[:<span class="built_in">len</span>(strStack)<span class="number">-1</span>]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      strStack = strStack[:<span class="built_in">len</span>(strStack)<span class="number">-1</span>] <span class="comment">// 弹出 &#x27;[&#x27;</span></span><br><span class="line">      topNum := numStack[<span class="built_in">len</span>(numStack)<span class="number">-1</span>]</span><br><span class="line">      numStack = numStack[:<span class="built_in">len</span>(numStack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">      str = strings.Repeat(str, topNum)</span><br><span class="line">      strStack = <span class="built_in">append</span>(strStack, str)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">      strStack = <span class="built_in">append</span>(strStack, <span class="type">string</span>(c))</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理字母</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">1</span> &amp;&amp; isChar(s[i<span class="number">-1</span>]) &amp;&amp; <span class="built_in">len</span>(strStack) &gt; <span class="number">0</span> &amp;&amp; strStack[<span class="built_in">len</span>(strStack)<span class="number">-1</span>] != <span class="string">&quot;[&quot;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果前一个也是字符，并且栈顶不是&#x27;[&#x27;，则追加到栈顶字符串</span></span><br><span class="line">      strStack[<span class="built_in">len</span>(strStack)<span class="number">-1</span>] = strStack[<span class="built_in">len</span>(strStack)<span class="number">-1</span>] + <span class="type">string</span>(c)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，作为新的字符串入栈</span></span><br><span class="line">      strStack = <span class="built_in">append</span>(strStack, <span class="type">string</span>(c))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res := <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strStack); i++ &#123;</span><br><span class="line">    res += strStack[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNum</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isChar</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h2 id="代码分析与可优化点">代码分析与可优化点</h2>
<p>原始代码的思路是正确的，使用了两个栈来分别存储数字和字符串。但在处理连续数字和连续字母时，逻辑稍微有些复杂：</p>
<ol>
<li><strong>连续数字处理</strong>：通过 <code>if i &gt;= 1 &amp;&amp; isNum(s[i-1])</code> 来判断是否是多位数的一部分，然后更新栈顶数字。</li>
<li><strong>连续字母处理</strong>：通过 <code>if i &gt;= 1 &amp;&amp; isChar(s[i-1]) &amp;&amp; len(strStack) &gt; 0 &amp;&amp; strStack[len(strStack)-1] != &quot;[&quot;</code> 来判断是否追加到栈顶的字符串。这种方式使得栈 <code>strStack</code> 中存储的元素类型不统一，有时是单个字符，有时是 <code>[</code>，有时是已经拼接好的字符串。这增加了处理的复杂度。</li>
<li><strong>字符串拼接</strong>：在遇到 <code>]</code> 时，从 <code>strStack</code> 弹出字符串并进行反向拼接 (<code>str = strStack[len(strStack)-1] + str</code>)，效率较低。</li>
<li><strong>栈元素统一性</strong>：<code>strStack</code> 中混合了单个字符、<code>[</code> 标记和解码后的字符串片段。如果能让栈中元素类型更统一，或者处理逻辑更清晰，会更好。</li>
</ol>
<p><strong>优化思路：</strong></p>
<ul>
<li><strong>简化解析</strong>：我们可以引入一个指针 <code>ptr</code> 来遍历字符串 <code>s</code>。</li>
<li><strong>数字解析</strong>：当遇到数字时，连续读取所有数字位，组成一个完整的数字。</li>
<li><strong>字母解析</strong>：当遇到字母时，连续读取所有字母，组成一个完整的字符串。</li>
<li><strong>栈内元素</strong>：<code>strStack</code> 可以设计为只存储解码过程中的字符串片段。当遇到 <code>[</code> 时，可以将当前数字和 <code>[</code> 之前累积的字符串（如果有的话）一起入栈。</li>
<li><strong>更通用的栈处理</strong>：可以考虑使用一个栈来同时存储数字和字符串，或者使用更结构化的方式。一个常见的优化是，当遇到 <code>[</code> 时，将当前的数字和 <code>[</code> 前的字符串结果入栈；遇到 <code>]</code> 时，出栈得到数字和之前的字符串，然后进行拼接。</li>
</ul>
<h2 id="优化后的代码实现">优化后的代码实现</h2>
<p>下面是一个优化后的 Go 版本。这个版本尝试简化解析逻辑，并使栈的操作更清晰。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeStringOptimized</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    numStack := []<span class="type">int</span>&#123;&#125;      <span class="comment">// 存储重复次数</span></span><br><span class="line">    strStack := []<span class="type">string</span>&#123;&#125;   <span class="comment">// 存储遇到&#x27;[&#x27;前的字符串结果</span></span><br><span class="line">    currentNum := <span class="number">0</span></span><br><span class="line">    currentStr := strings.Builder&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> char &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; char &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">            currentNum = currentNum*<span class="number">10</span> + <span class="type">int</span>(char-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 将当前的数字和字符串入栈</span></span><br><span class="line">            numStack = <span class="built_in">append</span>(numStack, currentNum)</span><br><span class="line">            strStack = <span class="built_in">append</span>(strStack, currentStr.String())</span><br><span class="line">            <span class="comment">// 重置当前数字和字符串</span></span><br><span class="line">            currentNum = <span class="number">0</span></span><br><span class="line">            currentStr.Reset()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;]&#x27;</span> &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶的数字和字符串</span></span><br><span class="line">            repeatTimes := numStack[<span class="built_in">len</span>(numStack)<span class="number">-1</span>]</span><br><span class="line">            numStack = numStack[:<span class="built_in">len</span>(numStack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            prevStr := strStack[<span class="built_in">len</span>(strStack)<span class="number">-1</span>]</span><br><span class="line">            strStack = strStack[:<span class="built_in">len</span>(strStack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建重复后的字符串</span></span><br><span class="line">            decodedPart := strings.Repeat(currentStr.String(), repeatTimes)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 currentStr 为 prevStr + decodedPart</span></span><br><span class="line">            currentStr.Reset()</span><br><span class="line">            currentStr.WriteString(prevStr)</span><br><span class="line">            currentStr.WriteString(decodedPart)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字母</span></span><br><span class="line">            currentStr.WriteRune(char)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentStr.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数 (如果需要在 main 包外使用，则不需要)</span></span><br><span class="line"><span class="comment">// func isNum(c byte) bool &#123;</span></span><br><span class="line"><span class="comment">//  return c &lt;= &#x27;9&#x27; &amp;&amp; c &gt;= &#x27;0&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func isChar(c byte) bool &#123;</span></span><br><span class="line"><span class="comment">//  return (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>优化点说明：</strong></p>
<ol>
<li><strong><code>strings.Builder</code></strong>：使用 <code>strings.Builder</code> 进行字符串拼接，比直接使用 <code>+</code> 更高效。</li>
<li><strong>栈的职责更清晰</strong>：
<ul>
<li><code>numStack</code> 只存储 <code>[</code> 对应的重复次数。</li>
<li><code>strStack</code> 只存储遇到 <code>[</code> 时，它前面的那部分已经解码（或本身就是）的字符串。</li>
</ul>
</li>
<li><strong>变量作用</strong>：
<ul>
<li><code>currentNum</code>：用于累积当前遇到的数字，形成完整的重复次数。</li>
<li><code>currentStr</code>：用于累积当前解码单元内的字符串（在 <code>[</code> 和 <code>]</code> 之间，或者在最外层）。</li>
</ul>
</li>
<li><strong>逻辑流程</strong>：
<ul>
<li><strong>数字</strong>：累加到 <code>currentNum</code>。</li>
<li><strong><code>[</code></strong>：将 <code>currentNum</code> 和 <code>currentStr</code>（<code>[</code>之前的部分）入栈，然后重置 <code>currentNum</code> 和 <code>currentStr</code> 以开始处理括号内的新内容。</li>
<li><strong><code>]</code></strong>：
<ul>
<li>从 <code>numStack</code> 弹出重复次数 <code>repeatTimes</code>。</li>
<li>从 <code>strStack</code> 弹出 <code>[</code> 之前的那部分字符串 <code>prevStr</code>。</li>
<li><code>currentStr</code> 此时是 <code>]</code> 和与之配对的 <code>[</code> 之间的内容解码结果（如果内部还有嵌套，也已处理完）。</li>
<li>将 <code>currentStr</code> 重复 <code>repeatTimes</code> 次，然后与 <code>prevStr</code> 拼接，形成新的 <code>currentStr</code>。</li>
</ul>
</li>
<li><strong>字母</strong>：追加到 <code>currentStr</code>。</li>
</ul>
</li>
</ol>
<p>最终，遍历结束后，<code>currentStr</code> 中就是完全解码后的字符串。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<p>假设 <code>N</code> 是输入字符串 <code>s</code> 的长度。</p>
<ul>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li>我们遍历字符串 <code>s</code> 一次。</li>
<li>栈操作（入栈、出栈）的平均时间复杂度是 O(1)。</li>
<li>字符串的重复操作 <code>strings.Repeat(str, k)</code> 的时间复杂度是 O(len(str) * k)。在最坏情况下，解码后的字符串长度可能非常大。例如 <code>100[a100[b]]</code>。</li>
<li>如果最终解码后的字符串长度为 <code>L</code>，那么总的时间复杂度可以认为是 O(L)。因为每个字符最终都会被构建出来。在某些情况下，<code>L</code> 可能远大于 <code>N</code>。如果仅考虑遍历和栈操作，不考虑字符串生成，则是 O(N)。但实际瓶颈在于字符串生成。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：</p>
<ul>
<li>栈 <code>numStack</code> 和 <code>strStack</code> 的深度取决于嵌套的层数。最坏情况下，嵌套层数可以是 O(N)（例如 <code>[[[...]]]</code>）。</li>
<li><code>strStack</code> 中存储的字符串片段的总长度也可能很大。</li>
<li><code>currentStr</code> (strings.Builder) 存储中间结果。</li>
<li>综合来看，空间复杂度也与解码后字符串的中间片段长度和嵌套深度有关，最坏情况下可能是 O(L) 或 O(N)（取决于哪个是主导因素）。</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>栈的应用</strong>：对于处理具有嵌套结构或需要“后进先出”逻辑的问题（如括号匹配、表达式求值、字符串解码），栈是非常有效的数据结构。</li>
<li><strong>状态管理</strong>：在遍历过程中，清晰地管理当前状态（如当前数字 <code>currentNum</code>、当前构建的字符串 <code>currentStr</code>）至关重要。</li>
<li><strong>字符串构建效率</strong>：在 Go 中，频繁进行字符串拼接时，使用 <code>strings.Builder</code> 通常比直接用 <code>+</code> 或 <code>fmt.Sprintf</code> 更高效，因为它避免了每次拼接都创建新字符串对象的开销。</li>
<li><strong>问题分解</strong>：将复杂问题分解为对不同类型字符（数字、<code>[</code>、<code>]</code>、字母）的独立处理逻辑，可以使代码更模块化、更易于理解和调试。</li>
<li><strong>栈内元素设计</strong>：精心设计栈中存储的内容，可以简化出栈和入栈时的处理逻辑。在优化后的版本中，<code>strStack</code> 存储的是 <code>[</code> 符号出现之前的累积字符串，这使得 <code>]</code> 出栈逻辑更直接。</li>
</ol>
<p>这道题是一个很好的练习，可以帮助理解栈在字符串处理中的应用，以及如何通过优化数据结构和算法流程来提高代码的清晰度和效率。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 155 - 最小栈 (Min Stack)</title>
    <url>/2025/05/11/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素 val 推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
<p><strong>约束条件:</strong></p>
<ul>
<li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>
<li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 10^4</code> 次</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心要求是在常数时间内检索到栈中的最小元素，同时要支持常规的栈操作（push, pop, top）。</p>
<p>一个常见的解法是使用 <strong>辅助栈</strong>。我们维护两个栈：</p>
<ol>
<li><code>stack</code>: 普通的数据栈，用于存储所有推入的元素。</li>
<li><code>minStack</code>: 辅助栈，用于存储当前 <code>stack</code> 中对应状态下的最小值。</li>
</ol>
<p><strong>具体操作如下：</strong></p>
<ul>
<li>
<p><strong><code>push(val)</code></strong>:</p>
<ul>
<li>将 <code>val</code> 正常推入 <code>stack</code>。</li>
<li>对于 <code>minStack</code>：
<ul>
<li>如果 <code>minStack</code> 为空，则将 <code>val</code> 推入 <code>minStack</code>。</li>
<li>否则，比较 <code>val</code> 和 <code>minStack</code> 的栈顶元素 <code>currentMin</code>。将 <code>min(val, currentMin)</code> 推入 <code>minStack</code>。这样 <code>minStack</code> 的栈顶始终是当前 <code>stack</code> 中的最小值。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>pop()</code></strong>:</p>
<ul>
<li>同时从 <code>stack</code> 和 <code>minStack</code> 中弹出栈顶元素。</li>
</ul>
</li>
<li>
<p><strong><code>top()</code></strong>:</p>
<ul>
<li>返回 <code>stack</code> 的栈顶元素。</li>
</ul>
</li>
<li>
<p><strong><code>getMin()</code></strong>:</p>
<ul>
<li>返回 <code>minStack</code> 的栈顶元素。</li>
</ul>
</li>
</ul>
<p>这种方法可以保证所有操作的时间复杂度都是 O(1)。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filepath: /Users/adrianwang/.leetcode/155.最小栈.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack    []<span class="type">int</span></span><br><span class="line">	minStack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">	<span class="keyword">return</span> MinStack&#123;</span><br><span class="line">		stack:    <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		minStack: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(val <span class="type">int</span>) &#123;</span><br><span class="line">	this.stack = <span class="built_in">append</span>(this.stack, val)</span><br><span class="line">	<span class="keyword">var</span> minVal <span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.minStack) == <span class="number">0</span> &#123;</span><br><span class="line">		minVal = val</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		minVal = this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Go 语言没有内置的 min 函数，需要自己实现或者直接比较</span></span><br><span class="line">	<span class="keyword">if</span> val &lt; minVal &#123;</span><br><span class="line">		this.minStack = <span class="built_in">append</span>(this.minStack, val)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		this.minStack = <span class="built_in">append</span>(this.minStack, minVal)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line">	this.minStack = this.minStack[:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">	this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(val);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数 min (Go语言标准库没有，需要自行实现)</span></span><br><span class="line"><span class="comment">// func min(a, b int) int &#123;</span></span><br><span class="line"><span class="comment">// 	if a &lt; b &#123;</span></span><br><span class="line"><span class="comment">// 		return a</span></span><br><span class="line"><span class="comment">// 	&#125;</span></span><br><span class="line"><span class="comment">// 	return b</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 上述 Go 代码中的 <code>Push</code> 方法有一个小调整，因为 Go 标准库中没有直接的 <code>min</code> 函数。在实际 LeetCode 提交时，如果 <code>min</code> 函数未提供，你需要自己实现一个，或者像代码中那样直接进行比较。在提供的代码片段中，<code>min(val, minVal)</code> 这一行会报错，我已经将其修改为直接比较。</p>
<h3 id="空间优化思路">空间优化思路</h3>
<p>上述辅助栈的方法虽然简单，但 <code>minStack</code> 的大小始终与 <code>stack</code> 相同。我们可以对 <code>minStack</code> 的使用进行优化，使其仅在必要时存储元素，从而可能节省空间。</p>
<p><strong>优化逻辑：</strong></p>
<ul>
<li>
<p><strong><code>Push(val)</code></strong>:</p>
<ul>
<li>元素 <code>val</code> 正常推入 <code>stack</code>。</li>
<li>对于 <code>minStack</code>：
<ul>
<li>如果 <code>minStack</code> 为空，或者 <code>val</code> 小于或等于 <code>minStack</code> 的栈顶元素，则将 <code>val</code> 推入 <code>minStack</code>。我们使用 <code>&lt;=</code> 是为了正确处理栈中存在多个相同最小值的情况。</li>
<li>否则 (<code>val</code> 大于 <code>minStack</code> 的栈顶元素)，<code>minStack</code> 不做任何操作，因为当前的最小值仍然有效。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>Pop()</code></strong>:</p>
<ul>
<li>从 <code>stack</code> 弹出栈顶元素 <code>poppedVal</code>。</li>
<li>检查 <code>poppedVal</code> 是否等于 <code>minStack</code> 的栈顶元素。
<ul>
<li>如果相等，说明被弹出的元素是（或之一是）当前的最小值，因此也需要从 <code>minStack</code> 弹出栈顶元素，以更新最小值记录。</li>
<li>如果不相等，<code>minStack</code> 不做任何操作。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>Top()</code> 和 <code>GetMin()</code></strong>:</p>
<ul>
<li><code>Top()</code> 逻辑不变，返回 <code>stack</code> 的栈顶。</li>
<li><code>GetMin()</code> 逻辑不变，返回 <code>minStack</code> 的栈顶。</li>
</ul>
</li>
</ul>
<p><strong>优化后的代码实现示例：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Push (空间优化版)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(val <span class="type">int</span>) &#123;</span><br><span class="line">    this.stack = <span class="built_in">append</span>(this.stack, val)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.minStack) == <span class="number">0</span> || val &lt;= this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>] &#123;</span><br><span class="line">        this.minStack = <span class="built_in">append</span>(this.minStack, val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop (空间优化版)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line">    <span class="comment">// 假设栈非空 (根据题目约束)</span></span><br><span class="line">    poppedVal := this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.minStack) &gt; <span class="number">0</span> &amp;&amp; poppedVal == this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>] &#123;</span><br><span class="line">        this.minStack = this.minStack[:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <code>Constructor</code>, <code>Top</code>, <code>GetMin</code> 方法与原版相同。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>辅助栈法 (同步栈)</th>
<th>辅助栈法 (空间优化)</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>Push: O(1), Pop: O(1), Top: O(1), GetMin: O(1)</td>
<td>Push: O(1), Pop: O(1), Top: O(1), GetMin: O(1)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n) - 辅助栈与数据栈等长</td>
<td>O(n) - 最坏情况 O(n) (如单调递减序列), 平均情况可能优于同步栈 (如单调递增序列)</td>
</tr>
<tr>
<td><code>Push</code> 实现</td>
<td>总是向<code>minStack</code>推入当前比较后的最小值</td>
<td>仅当新元素 <code>&lt;= minStack</code>栈顶时推入</td>
</tr>
<tr>
<td><code>Pop</code> 实现</td>
<td>总是从<code>minStack</code>同步弹出</td>
<td>仅当弹出元素 <code>== minStack</code>栈顶时从<code>minStack</code>弹出</td>
</tr>
<tr>
<td>优点</td>
<td>实现非常简单，<code>Pop</code>逻辑直接</td>
<td>在某些数据模式下可能节省空间</td>
</tr>
<tr>
<td>缺点</td>
<td><code>minStack</code>空间占用相对固定</td>
<td><code>Pop</code>逻辑稍复杂，空间节省效果依赖输入数据序列</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★ (因其简洁性和稳定性)</td>
<td>★★★★☆ (适用于对空间有极致要求的场景，或作为理解栈设计的进阶)</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<p>对于上述两种辅助栈实现方法：</p>
<ul>
<li>
<p><strong>时间复杂度</strong>:</p>
<ul>
<li><code>push()</code>: O(1)。</li>
<li><code>pop()</code>: O(1)。</li>
<li><code>top()</code>: O(1)。</li>
<li><code>getMin()</code>: O(1)。<br>
所有操作均为常数时间。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>: O(n)，其中 n 是栈中元素的数量。</p>
<ul>
<li>对于同步栈方法，<code>minStack</code> 的大小与 <code>stack</code> 始终相同。</li>
<li>对于空间优化方法，<code>minStack</code> 的大小在最坏情况下（例如，输入序列单调递减）也是 O(n)，但平均情况下可能小于 O(n)（例如，输入序列单调递增时，<code>minStack</code> 只存一个元素）。</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li><strong>辅助数据结构</strong>: 解决这类需要在特定约束下（如常数时间）获取额外信息的问题时，辅助数据结构是一个非常有效的思路。</li>
<li><strong>同步操作</strong>: 辅助栈 <code>minStack</code> 的操作必须与主数据栈 <code>stack</code> 的操作同步，以确保 <code>minStack</code> 栈顶始终对应 <code>stack</code> 当前状态的最小值。</li>
<li><strong>空间换时间</strong>: 辅助栈的使用是以额外的空间开销为代价，来换取 <code>getMin</code> 操作的常数时间复杂度。</li>
<li><strong>空间优化</strong>: 在某些场景下，通过优化辅助栈的使用，可以进一步减少空间占用。</li>
</ul>
<p>这道题是栈相关问题中的经典题目，理解辅助栈的思想以及空间优化的策略对于解决类似问题很有帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>栈</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 是怎么加锁的？—— 深入解析MySQL锁机制</title>
    <url>/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/</url>
    <content><![CDATA[<h1>MySQL 是怎么加锁的？</h1>
<h2 id="什么-SQL-语句会加行级锁？">什么 SQL 语句会加行级锁？</h2>
<p>InnoDB 存储引擎支持行级锁，而 MyISAM 存储引擎则不支持。因此，后续内容均基于 InnoDB 引擎进行讨论。</p>
<p>所以，当我们探讨 MySQL 如何添加行级锁时，实际上是在讨论 InnoDB 引擎是如何实现行级锁的。</p>
<p>普通的 <code>select</code> 语句通常不会对记录加锁，因为它属于&quot;快照读&quot;（Snapshot Read），是通过 MVCC（多版本并发控制）机制实现的，目的是提供一致性的非阻塞读。</p>
<p>如果希望在查询时对记录施加行级锁，可以使用以下两种方式，这类会加锁的查询被称为&quot;锁定读&quot;（Locking Read）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 对读取的记录加共享锁 (S型锁)</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 对读取的记录加独占锁 (X型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>上述这两条语句必须在事务中执行，<strong>因为锁的生命周期与事务绑定，事务一旦提交，所有锁便会释放</strong>。因此，在使用这些语句时，务必先通过 <code>begin</code> 或 <code>start transaction</code> 开启一个事务。</p>
<p><strong>除了上述的锁定读语句会添加行级锁之外，<code>update</code> 和 <code>delete</code> 操作同样会添加行级锁，并且它们添加的都是独占锁 (X 型锁)</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 对操作的记录加独占锁 (X型锁)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> .... <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 对操作的记录加独占锁 (X型锁)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>共享锁（S 锁）的特性是&quot;读读共享，读写互斥&quot;，即多个事务可以同时持有同一记录的 S 锁进行读取，但任何持有 S 锁的事务都不能写入，任何尝试写入的事务也不能获取 S 锁。</p>
<p>独占锁（X 锁）的特性是&quot;写写互斥，读写互斥&quot;，即一旦一个事务持有了记录的 X 锁，其他任何事务都不能再对该记录施加 S 锁或 X 锁。</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970217982.png" alt="1746970217982"></p>
<h2 id="行级锁有哪些种类？">行级锁有哪些种类？</h2>
<p>在不同的事务隔离级别下，行级锁的种类也有所不同。</p>
<p>在&quot;读已提交&quot;（Read Committed）隔离级别下，行级锁主要表现为记录锁（Record Lock），即仅仅锁定某一条记录。</p>
<p>在&quot;可重复读&quot;（Repeatable Read）隔离级别下，为了避免&quot;幻读&quot;（Phantom Read）问题，除了记录锁之外，还引入了间隙锁（Gap Lock）。因此，在该隔离级别下，行级锁主要有以下三类：</p>
<ul>
<li><strong>Record Lock (记录锁)</strong>：仅仅锁定一条记录。</li>
<li><strong>Gap Lock (间隙锁)</strong>：锁定一个范围，但不包括记录本身。</li>
<li><strong>Next-Key Lock (临键锁)</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<p>接下来，我们分别详细介绍这三种行级锁。</p>
<h3 id="Record-Lock">Record Lock</h3>
<p>Record Lock，即记录锁，用于锁定单条记录。记录锁分为 S 型记录锁和 X 型记录锁：</p>
<ul>
<li>当一个事务为某条记录添加了 S 型记录锁后，其他事务仍然可以继续为该记录添加 S 型记录锁（S 锁之间兼容），但不能添加 X 型记录锁（S 锁与 X 锁互斥）。</li>
<li>当一个事务为某条记录添加了 X 型记录锁后，其他事务既不能为该记录添加 S 型记录锁（S 锁与 X 锁互斥），也不能添加 X 型记录锁（X 锁之间也互斥）。</li>
</ul>
<p>例如，当一个事务执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>该事务会为表中主键 <code>id = 1</code> 的记录添加一个 X 型的记录锁。此时，如果其他事务尝试对这条记录进行删除或更新操作，这些操作将会被阻塞。值得注意的是，如果其他事务尝试插入一条 <code>id = 1</code> 的新记录，该操作不会被这个记录锁阻塞，但会因为主键的唯一性约束而报错。</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970230632.png" alt="1746970230632"></p>
<p>当事务执行 <code>commit</code> 后，其在事务过程中产生的所有锁都将被释放。</p>
<h3 id="Gap-Lock">Gap Lock</h3>
<p>Gap Lock，即间隙锁，仅存在于可重复读隔离级别中，其主要目的是为了解决该隔离级别下的幻读问题。</p>
<p>例如，若表中存在一个覆盖 <code>id</code> 范围 <code>(3, 5)</code> 的间隙锁，那么其他事务将无法插入 <code>id = 4</code> 这条记录，从而有效地防止了幻读现象的发生。</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970239002.png" alt="1746970239002"></p>
<p>间隙锁虽然也区分 X 型和 S 型，但实际上它们之间并没有功能上的差异。<strong>间隙锁之间是相互兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，它们之间不存在互斥关系。这是因为间隙锁的核心目标是阻止新的记录插入到间隙中，以防止幻读。</strong></p>
<h3 id="Next-Key-Lock">Next-Key Lock</h3>
<p>Next-Key Lock，即临键锁，是 Record Lock 和 Gap Lock 的结合体。它锁定一个范围，并且同时锁定范围右边界上的那条记录本身。通常我们说的 Next-Key Lock 的区间是一个左开右闭的区间。</p>
<p>例如，若表中存在一个覆盖 <code>id</code> 范围 <code>(3, 5]</code> 的 next-key lock，那么其他事务既不能插入 <code>id = 4</code> 的记录（被 Gap 部分覆盖），也不能修改或删除 <code>id = 5</code> 这条记录（被 Record 部分覆盖）。</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970246308.png" alt="1746970246308"></p>
<p>因此，next-key lock 既能保护目标记录不被修改或删除，又能阻止其他事务在被保护记录之前的间隙中插入新记录。</p>
<p><strong>由于 next-key lock 包含了记录锁和间隙锁，如果一个事务获取了 X 型的 next-key lock，那么其他事务试图获取相同范围的 X 型 next-key lock 时将会被阻塞。</strong></p>
<p>例如，一个事务持有了范围为 <code>(1, 10]</code> 的 X 型 next-key lock，那么其他事务在尝试获取相同范围的 X 型 next-key lock 时就会发生阻塞。</p>
<p>虽然覆盖相同范围的间隙锁是相互兼容的，但对于 next-key lock 中的记录锁部分，我们仍需考虑 X 型与 S 型锁之间的兼容关系：X 型的记录锁与 X 型的记录锁是冲突的，X 型记录锁与 S 型记录锁也是冲突的。</p>
<h2 id="MySQL-是怎么加行级锁的？">MySQL 是怎么加行级锁的？</h2>
<p>行级锁的加锁规则相当复杂，不同的查询场景下，其加锁形式也会有所不同。</p>
<p><strong>MySQL 加锁的对象是索引，而加锁的基本单位是 next-key lock</strong>。next-key lock 由记录锁和间隙锁组合而成，其锁定范围通常是一个<strong>前开后闭</strong>的区间（例如 <code>(a, b]</code>）。相对地，单纯的间隙锁锁定的是一个<strong>前开后开</strong>的区间（例如 <code>(a, b)</code>）。</p>
<p>然而，在特定场景下，next-key lock 可能会&quot;退化&quot;为记录锁或间隙锁。总结其退化原则就是：<strong>在仅通过记录锁或间隙锁就能有效避免幻读问题的场景下，next-key lock 就会进行相应的退化。</strong></p>
<p>接下来，我们将使用以下表结构进行实验说明：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  KEY `index_age` (`age`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
<p>其中，<code>id</code> 是主键索引（唯一索引），<code>age</code> 是普通索引（非唯一索引），<code>name</code> 是一个没有索引的普通列。</p>
<p>表中的初始记录如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>路飞</td>
<td>19</td>
</tr>
<tr>
<td>5</td>
<td>索隆</td>
<td>21</td>
</tr>
<tr>
<td>10</td>
<td>山治</td>
<td>22</td>
</tr>
<tr>
<td>15</td>
<td>乌索普</td>
<td>20</td>
</tr>
<tr>
<td>20</td>
<td>香克斯</td>
<td>39</td>
</tr>
</tbody>
</table>
<p>本次实验环境的 <strong>MySQL 版本为 8.0.26，事务隔离级别为「可重复读」</strong>。</p>
<p>请注意，不同 MySQL 版本的加锁规则可能存在细微差异，但总体逻辑是相似的。</p>
<h3 id="唯一索引等值查询">唯一索引等值查询</h3>
<p>当使用唯一索引进行等值查询时，根据查询的记录是否存在，加锁规则有所不同：</p>
<ul>
<li>当查询的记录 <strong>「存在」</strong> 时，在索引树上定位到该记录后，施加在该记录索引项上的 next-key lock 会<strong>退化为「记录锁」</strong>。</li>
<li>当查询的记录 <strong>「不存在」</strong> 时，在索引树上找到第一条大于该查询记录值的记录后，施加在该记录索引项上的 next-key lock 会<strong>退化为「间隙锁」</strong>，该间隙锁覆盖的范围是查不到的那条记录到这条大于它的记录之间的间隙。</li>
</ul>
<p>接下来通过两个案例进行说明。</p>
<h4 id="1、记录存在的情况">1、记录存在的情况</h4>
<p>假设事务 A 执行以下等值查询语句，且查询的记录 <code>id = 1</code> <strong>存在</strong>于表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 路飞   <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<p>此时，事务 A 会为 <code>id = 1</code> 的这条记录添加一个 <strong>X 型的记录锁</strong>。</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970299852.png" alt="1746970299852"></p>
<p>若此时有其他事务尝试对 <code>id = 1</code> 的记录进行更新或删除操作，这些操作都将被阻塞。这是因为更新或删除操作也会尝试对该记录添加 X 型的记录锁，而 X 锁与 X 锁之间是互斥的。</p>
<p>例如：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970306340.png" alt="1746970306340"></p>
<p>由于事务 A 对 <code>id = 1</code> 的记录持有了 X 型记录锁，事务 B 修改 <code>id=1</code> 记录的操作和事务 C 删除 <code>id=1</code> 记录的操作都会被阻塞。</p>
<blockquote>
<p>有什么命令可以分析加了什么锁？</p>
</blockquote>
<p>我们可以通过执行 <code>select * from performance_schema.data_locks\G;</code> 这条语句，来查看当前事务在执行 SQL 过程中具体添加了哪些锁。</p>
<p>以上述事务 A 为例，分析其加锁情况：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970318268.png" alt="1746970318268"></p>
<p>从上图的输出可以看到，事务 A 共添加了两种锁：</p>
<ul>
<li><strong>表锁 (Table Lock)</strong>：类型为 <code>IX</code> (Intent Exclusive，意向排他锁)。这是 InnoDB 在对行加锁前，为了协调表级锁和行级锁的关系而自动加的表级锁。</li>
<li><strong>行锁 (Row Lock)</strong>：<code>LOCK_TYPE</code> 显示为 <code>RECORD</code>，表示这是一个行级锁。</li>
</ul>
<p>我们重点关注行级锁。通过 <code>LOCK_MODE</code> 字段可以进一步区分是 next-key 锁、间隙锁还是记录锁：</p>
<ul>
<li>如果 <code>LOCK_MODE</code> 为 <code>X</code>，通常表示 next-key 锁。</li>
<li>如果 <code>LOCK_MODE</code> 为 <code>X, REC_NOT_GAP</code>，明确表示是记录锁。</li>
<li>如果 <code>LOCK_MODE</code> 为 <code>X, GAP</code>，明确表示是间隙锁。</li>
</ul>
<p>因此，在这个例子中，<strong>事务 A 在 <code>id = 1</code> 这条记录的主键索引上添加的是 X 型记录锁</strong>，锁定的就是 <code>id = 1</code> 这一行数据。这使得其他事务无法对该记录进行更新和删除。</p>
<p>从这里也可以看出，<strong>加锁是针对索引进行的</strong>。由于此查询语句通过聚簇索引（即主键索引）进行扫描，因此锁是施加在主键索引上的。对相应记录的主键索引项添加记录锁后，其他事务就不能更新或删除这条记录了。</p>
<blockquote>
<p>为什么唯一索引等值查询且记录存在的场景下，next-key lock 会退化成记录锁？</p>
</blockquote>
<p>核心原因在于，在这种特定场景下，<strong>仅依靠记录锁就足以避免幻读问题</strong>。</p>
<p>幻读的定义是：在一个事务内，前后两次执行相同的查询，结果集却不一致（例如，多出或少了一些行）。要避免幻读，就需要防止在两次查询之间，结果集中的某条记录被其他事务删除，或者有其他事务插入了新的符合查询条件的记录。</p>
<ul>
<li><strong>防止新记录插入</strong>：由于主键具有唯一性约束，任何其他事务尝试插入一条 <code>id = 1</code> 的新记录时，都会因为主键冲突而失败。这就保证了事务 A 在多次查询 <code>id = 1</code> 的记录时，不会凭空多出一条 <code>id = 1</code> 的记录。</li>
<li><strong>防止记录被删除/修改</strong>：由于事务 A 对 <code>id = 1</code> 的记录添加了记录锁，其他事务无法删除或修改这条记录。这就保证了事务 A 在多次查询 <code>id = 1</code> 的记录时，该记录不会消失或被改变。</li>
</ul>
<p>综上，一个记录锁已经能确保查询 <code>id=1</code> 的结果一致性，因此 next-key lock 退化为更轻量级的记录锁是合理的优化。</p>
<h4 id="2、记录不存在的情况">2、记录不存在的情况</h4>
<p>假设事务 A 执行以下等值查询语句，但查询的记录 <code>id = 2</code> <strong>不存在</strong>于表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p>接下来，通过 <code>select * from performance_schema.data_locks\G;</code> 查看加锁情况：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970329203.png" alt="1746970329203"></p>
<p>从上图可以看到，行锁的 <code>LOCK_MODE</code> 为 <code>X, GAP</code>，表示添加了 X 型的间隙锁。</p>
<p>具体分析：<br>
MySQL 在主键索引上查找 <code>id = 2</code> 的记录。由于 <code>id = 2</code> 不存在，它会找到第一个大于 2 的记录，即 <code>id = 5</code>。然后，在 <code>id = 5</code> 这条记录对应的主键索引项上添加一个间隙锁。这个间隙锁覆盖的范围是表中 <code>id = 5</code> 之前的记录 <code>id = 1</code> 到 <code>id = 5</code> 之间的间隙，即 <code>(1, 5)</code>。</p>
<p>因此，<strong>事务 A 在主键索引上添加了一个覆盖范围 <code>(1, 5)</code> 的 X 型间隙锁。</strong></p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970337602.png" alt="1746970337602"></p>
<p>这个间隙锁意味着，其他事务将无法插入 <code>id</code> 值为 2、3、4 的新记录，因为这些值都落在了 <code>(1, 5)</code> 这个间隙内。</p>
<p>注意：如果其他事务尝试插入 <code>id = 1</code> 或 <code>id = 5</code> 的记录，它们不会被这个间隙锁阻塞，而是会因为主键冲突（表中已存在这些记录）而报错。</p>
<p>例如：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970344320.png" alt="1746970344320"></p>
<p>由于事务 A 持有范围为 <code>(1, 5)</code> 的 X 型间隙锁，事务 B 尝试插入 <code>id = 3</code> 的记录时，其操作会被阻塞。</p>
<blockquote>
<p>这个间隙锁的范围 <code>(1, 5)</code> 是如何确定的？</p>
</blockquote>
<p>根据 <code>performance_schema.data_locks</code> 的输出，如果 <code>LOCK_MODE</code> 是 next-key 锁或间隙锁，<code>LOCK_DATA</code> 字段通常表示锁范围的&quot;右边界&quot;。在此次事务 A 的例子中，<code>LOCK_DATA</code> 是 5。<br>
然后，锁范围的&quot;左边界&quot;是表中 <code>id</code> 为 5 的记录的前一条记录的 <code>id</code> 值，即 1。<br>
因此，间隙锁的范围确定为 <code>(1, 5)</code>。</p>
<blockquote>
<p>为什么唯一索引等值查询且记录「不存在」的场景下，next-key lock 会退化成「间隙锁」？</p>
</blockquote>
<p>原因同样是为了在避免幻读的前提下，使用尽可能小的锁范围。</p>
<ul>
<li><strong>为什么不是 next-key lock？</strong> 如果对 <code>id = 5</code> 的索引项加 next-key lock <code>(1, 5]</code>，这意味着其他事务无法删除或修改 <code>id = 5</code> 这条记录。但我们查询的是 <code>id = 2</code>，只要保证前后两次查询 <code>id = 2</code> 的结果集相同（即没有新的 <code>id = 2</code> 插入），就能避免幻读。<code>id = 5</code> 是否被删除对查询 <code>id = 2</code> 的结果没有影响。因此，没有必要锁定 <code>id = 5</code> 本身，一个覆盖 <code>(1, 5)</code> 的间隙锁足以阻止 <code>id = 2, 3, 4</code> 的插入。</li>
<li><strong>为什么不是记录锁？</strong> 锁是施加在索引项上的。由于查询的记录 <code>id = 2</code> 本身并不存在于索引中，自然无法对一个不存在的记录施加记录锁。</li>
</ul>
<p>因此，退化为间隙锁 <code>(1, 5)</code> 是最合适的选择。</p>
<h3 id="唯一索引范围查询">唯一索引范围查询</h3>
<p>唯一索引的范围查询与等值查询的加锁规则有所不同。</p>
<p>当使用唯一索引进行范围查询时，<strong>MySQL 会对扫描到的每一个索引项（满足条件的记录以及扫描过程中遇到的用于界定范围的记录）尝试添加 next-key 锁。然后，根据具体情况，这些 next-key 锁可能会退化成记录锁或间隙锁</strong>：</p>
<ul>
<li>情况一：对于 <strong>「大于等于 (&gt;=)」</strong> 的范围查询，由于其中包含了等值查询的条件，如果等值部分（例如 <code>id = X</code> in <code>id &gt;= X</code>）的记录<strong>存在</strong>于表中，那么施加在该记录索引项上的 next-key 锁会<strong>退化成记录锁</strong>。对于范围覆盖的其他记录，则仍可能是 next-key 锁。</li>
<li>情况二：对于 <strong>「小于 (&lt;) 或小于等于 (&lt;=)」</strong> 的范围查询，处理方式取决于条件值的记录是否存在于表中：
<ul>
<li>当条件值的记录<strong>不存在</strong>于表中时（例如 <code>id &lt; 6</code> 或 <code>id &lt;= 6</code>，而表中没有 <code>id = 6</code> 的记录），无论是「小于」还是「小于等于」的查询，当扫描到第一个不满足范围条件（即大于或等于条件值）的记录时（作为范围的终止点），施加在该终止记录索引项上的 next-key 锁会<strong>退化成间隙锁</strong>。其他被扫描到的满足条件的记录，其索引项上通常加的是 next-key 锁。</li>
<li>当条件值的记录<strong>存在</strong>于表中时（例如 <code>id &lt; 5</code> 或 <code>id &lt;= 5</code>，且表中有 <code>id = 5</code> 的记录）：
<ul>
<li>如果是「小于 (&lt;)」条件的范围查询（如 <code>id &lt; 5</code>），当扫描到条件值的记录（即 <code>id = 5</code>，它是第一个不满足 <code>id &lt; 5</code> 的记录）时，施加在该记录索引项上的 next-key 锁会<strong>退化成间隙锁</strong>。其他被扫描到的满足条件的记录，其索引项上通常加的是 next-key 锁。</li>
<li>如果是「小于等于 (&lt;=)」条件的范围查询（如 <code>id &lt;= 5</code>），当扫描到条件值的记录（即 <code>id = 5</code>，它是满足条件的最后一条记录）时，施加在该记录索引项上的 next-key 锁通常<strong>不会退化</strong>。其他被扫描到的满足条件的记录，其索引项上通常加的也是 next-key 锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>接下来，通过几个实验来验证上述结论。</p>
<h4 id="1、针对「大于或者大于等于」的范围查询">1、针对「大于或者大于等于」的范围查询</h4>
<blockquote>
<p>实验一：针对「大于 (&gt;)」的范围查询。</p>
</blockquote>
<p>假设事务 A 执行以下范围查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name      <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 香克斯    <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ol>
<li>扫描到的第一条满足 <code>id &gt; 15</code> 的记录是 <code>id = 20</code>。由于这是一个严格大于的查询，不是等值查询，因此在 <code>id = 20</code> 这条记录的主键索引项上添加的是一个 next-key 锁，其覆盖范围是 <code>(15, 20]</code>（左边界是表中 <code>id=20</code> 之前的记录 <code>id=15</code>）。</li>
<li>由于是范围查询，MySQL 会继续向后扫描，以确定范围的上限。即使 <code>id = 20</code> 是表中的最后一条用户记录，InnoDB 内部还有一个特殊的&quot;supremum pseudo-record&quot;来标识索引的末尾。当扫描到这个 supremum 记录时，会为它添加一个 next-key 锁，覆盖范围是 <code>(20, +∞]</code>。</li>
<li>扫描结束。</li>
</ol>
<p>因此，事务 A 在主键索引上添加了两个 X 型的 next-key 锁：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970353980.png" alt="1746970353980"></p>
<ul>
<li>在 <code>id = 20</code> 记录的主键索引项上，施加了范围为 <code>(15, 20]</code> 的 next-key 锁。这意味着其他事务既无法更新或删除 <code>id = 20</code> 的记录，也无法插入 <code>id</code> 值为 16、17、18、19 的新记录。</li>
<li>在 supremum pseudo-record 的主键索引项上，施加了范围为 <code>(20, +∞]</code> 的 next-key 锁。这意味着其他事务无法插入 <code>id</code> 值大于 20 的新记录。</li>
</ul>
<p>通过 <code>select * from performance_schema.data_locks\G;</code> 确认加锁情况（仅截取行级锁部分）：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970365637.png" alt="1746970365637"></p>
<p>从上图分析，<code>LOCK_MODE</code> 均为 <code>X</code>，表示 next-key 锁。</p>
<ul>
<li><code>LOCK_DATA: 20</code> 对应 <code>(15, 20]</code> 的 next-key 锁。</li>
<li><code>LOCK_DATA: supremum pseudo-record</code> 对应 <code>(20, +∞]</code> 的 next-key 锁。<br>
这与我们的分析一致。</li>
</ul>
<blockquote>
<p>实验二：针对「大于等于 (&gt;=)」的范围查询。</p>
</blockquote>
<p>假设事务 A 执行以下范围查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name      <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> 乌索普    <span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 香克斯    <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ol>
<li>首先处理 <code>id = 15</code> 的部分（等值条件）。由于记录 <code>id = 15</code> 存在，施加在该记录主键索引项上的 next-key 锁会<strong>退化为记录锁</strong>，仅锁定 <code>id = 15</code> 这一行。</li>
<li>继续范围查找，扫描到下一条记录 <code>id = 20</code>。在 <code>id = 20</code> 的主键索引项上添加 next-key 锁，范围是 <code>(15, 20]</code>。</li>
<li>继续向后扫描到 supremum pseudo-record，为其添加 next-key 锁，范围是 <code>(20, +∞]</code>。</li>
<li>扫描结束。</li>
</ol>
<p>事务 A 在主键索引上添加了三个 X 型的锁：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970396194.png" alt="1746970396194"></p>
<ul>
<li>在 <code>id = 15</code> 记录的主键索引项上，施加了记录锁，锁定 <code>id = 15</code>。</li>
<li>在 <code>id = 20</code> 记录的主键索引项上，施加了范围为 <code>(15, 20]</code> 的 next-key 锁。</li>
<li>在 supremum pseudo-record 的主键索引项上，施加了范围为 <code>(20, +∞]</code> 的 next-key 锁。</li>
</ul>
<p>通过 <code>select * from performance_schema.data_locks\G;</code> 确认加锁情况：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970403063.png" alt="1746970403063"></p>
<p>分析上图：</p>
<ul>
<li><code>LOCK_DATA: 15</code>, <code>LOCK_MODE: X, REC_NOT_GAP</code> 表示对 <code>id = 15</code> 加了记录锁。</li>
<li><code>LOCK_DATA: 20</code>, <code>LOCK_MODE: X</code> 表示对 <code>id = 20</code> 加了 <code>(15, 20]</code> 的 next-key 锁。</li>
<li><code>LOCK_DATA: supremum pseudo-record</code>, <code>LOCK_MODE: X</code> 表示加了 <code>(20, +∞]</code> 的 next-key 锁。<br>
这与我们的分析一致，并验证了：在「大于等于」条件的唯一索引范围查询中，若条件值的记录存在，其索引项上的 next-key 锁会退化为记录锁。</li>
</ul>
<h4 id="2、针对「小于或者小于等于」的范围查询">2、针对「小于或者小于等于」的范围查询</h4>
<blockquote>
<p>实验一：针对「小于 (&lt;)」的范围查询，且查询条件值的记录「不存在」于表中。</p>
</blockquote>
<p>假设事务 A 执行以下范围查询语句，注意条件值 <code>id = 6</code> 的记录并<strong>不存在</strong>于表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 路飞   <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 索隆   <span class="operator">|</span>  <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  <span class="comment">-- 返回的记录是 id=1 和 id=5</span></span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ol>
<li>扫描到的第一条满足 <code>id &lt; 6</code> 的记录是 <code>id = 1</code>。在其主键索引项上添加 next-key 锁，范围是 <code>(-∞, 1]</code> (这里的 <code>-∞</code> 表示索引的起始)。</li>
<li>继续范围查找，扫描到下一条满足 <code>id &lt; 6</code> 的记录是 <code>id = 5</code>。在其主键索引项上添加 next-key 锁，范围是 <code>(1, 5]</code>。</li>
<li>继续扫描，下一条记录是 <code>id = 10</code>。这条记录不满足 <code>id &lt; 6</code> 的条件，它是第一个不满足条件的记录，因此作为扫描的终止点。施加在 <code>id = 10</code> 这条记录主键索引项上的 next-key 锁会<strong>退化成间隙锁</strong>，覆盖的范围是 <code>(5, 10)</code>。</li>
<li>由于找到了不满足条件的记录，扫描停止。</li>
</ol>
<p>事务 A 在主键索引上添加了三个 X 型的锁：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970412678.png" alt="1746970412678"></p>
<ul>
<li>在 <code>id = 1</code> 记录的主键索引项上，施加了范围为 <code>(-∞, 1]</code> 的 next-key 锁。</li>
<li>在 <code>id = 5</code> 记录的主键索引项上，施加了范围为 <code>(1, 5]</code> 的 next-key 锁。</li>
<li>在 <code>id = 10</code> 记录的主键索引项上，施加了范围为 <code>(5, 10)</code> 的间隙锁。这个间隙锁会阻止插入 <code>id</code> 值为 6, 7, 8, 9 的新记录。</li>
</ul>
<p>通过 <code>select * from performance_schema.data_locks\G;</code> 确认加锁情况：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970432932.png" alt="1746970432932"></p>
<p>分析上图：</p>
<ul>
<li><code>LOCK_DATA: 1</code>, <code>LOCK_MODE: X</code> 对应 <code>(-∞, 1]</code> 的 next-key 锁。</li>
<li><code>LOCK_DATA: 5</code>, <code>LOCK_MODE: X</code> 对应 <code>(1, 5]</code> 的 next-key 锁。</li>
<li><code>LOCK_DATA: 10</code>, <code>LOCK_MODE: X, GAP</code> 对应 <code>(5, 10)</code> 的间隙锁。<br>
这与我们的分析一致。</li>
</ul>
<p>值得注意的是，如果此实验中的查询条件改为 <code>id &lt;= 6</code>（而 <code>id=6</code> 仍然不存在），其加锁行为与 <code>id &lt; 6</code> 的情况是相同的，因为扫描的终止点依然是 <code>id=10</code>，并且在其上加间隙锁 <code>(5,10)</code>。</p>
<p>因此，可以得出结论：<strong>针对「小于或小于等于」的唯一索引范围查询，若条件值的记录不存在于表中，当扫描到终止范围查询的记录（即第一个不满足条件的记录）时，施加在该记录索引项上的 next-key 锁会退化成间隙锁。其他被扫描到的满足条件的记录，其索引项上加的是 next-key 锁。</strong></p>
<blockquote>
<p>实验二：针对「小于等于 (&lt;=)」的范围查询，且查询条件值的记录「存在」于表中。</p>
</blockquote>
<p>假设事务 A 执行以下范围查询语句，注意条件值 <code>id = 5</code> 的记录<strong>存在</strong>于表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 路飞   <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 索隆   <span class="operator">|</span>  <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ol>
<li>扫描到的第一条记录是 <code>id = 1</code>。在其主键索引项上添加 next-key 锁，范围为 <code>(-∞, 1]</code>。</li>
<li>继续范围查找，扫描到下一条记录是 <code>id = 5</code>。这条记录满足 <code>id &lt;= 5</code>，并且是条件值的记录。在其主键索引项上添加 next-key 锁，范围为 <code>(1, 5]</code>。由于这是满足条件的最后一条记录（根据主键唯一性），扫描在此基本结束。</li>
<li>扫描停止。</li>
</ol>
<p>事务 A 在主键索引上添加了两个 X 型的 next-key 锁：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970447328.png" alt="1746970447328"></p>
<ul>
<li>在 <code>id = 1</code> 记录的主键索引项上，施加了范围为 <code>(-∞, 1]</code> 的 next-key 锁。</li>
<li>在 <code>id = 5</code> 记录的主键索引项上，施加了范围为 <code>(1, 5]</code> 的 next-key 锁。</li>
</ul>
<p>通过 <code>select * from performance_schema.data_locks\G;</code> 确认加锁情况：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970454035.png" alt="1746970454035"></p>
<p>分析上图，两个锁的 <code>LOCK_MODE</code> 均为 <code>X</code>，与我们的分析一致。这里 <code>id = 5</code> 上的 next-key 锁没有退化。</p>
<blockquote>
<p>实验三：针对「小于 (&lt;)」的范围查询，且查询条件值的记录「存在」于表中。</p>
</blockquote>
<p>假设事务 A 执行以下查询，条件值 <code>id = 5</code> 的记录<strong>存在</strong>于表中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 路飞   <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ol>
<li>扫描到的第一条满足 <code>id &lt; 5</code> 的记录是 <code>id = 1</code>。在其主键索引项上添加 next-key 锁，范围为 <code>(-∞, 1]</code>。</li>
<li>继续范围查找，扫描到下一条记录是 <code>id = 5</code>。这条记录是第一个不满足 <code>id &lt; 5</code> 条件的记录（即它等于条件值）。施加在该记录主键索引项上的 next-key 锁会<strong>退化为间隙锁</strong>，锁范围是 <code>(1, 5)</code>。</li>
<li>由于找到了不满足条件的记录，扫描停止。</li>
</ol>
<p>事务 A 在主键索引上添加了两种 X 型锁：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970462543.png" alt="1746970462543"></p>
<ul>
<li>在 <code>id = 1</code> 记录的主键索引项上，施加了范围为 <code>(-∞, 1]</code> 的 next-key 锁。</li>
<li>在 <code>id = 5</code> 记录的主键索引项上，施加了范围为 <code>(1, 5)</code> 的间隙锁。这个间隙锁会阻止插入 <code>id</code> 值为 2, 3, 4 的新记录。</li>
</ul>
<p>通过 <code>select * from performance_schema.data_locks\G;</code> 确认加锁情况：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970468825.png" alt="1746970468825"></p>
<p>分析上图：</p>
<ul>
<li><code>LOCK_DATA: 1</code>, <code>LOCK_MODE: X</code> 对应 <code>(-∞, 1]</code> 的 next-key 锁。</li>
<li><code>LOCK_DATA: 5</code>, <code>LOCK_MODE: X, GAP</code> 对应 <code>(1, 5)</code> 的间隙锁。<br>
这与我们的分析一致。</li>
</ul>
<p>综合这三个实验，我们可以总结出「小于或小于等于」的唯一索引范围查询的退化规则：</p>
<ul>
<li>当条件值的记录<strong>不存在</strong>于表中时：无论是「小于」还是「小于等于」查询，扫描到终止范围的记录（第一个不满足条件的记录）时，其索引项上的 next-key 锁会<strong>退化成间隙锁</strong>。</li>
<li>当条件值的记录<strong>存在</strong>于表中时：
<ul>
<li>如果是「小于 (&lt;)」查询，扫描到终止范围的记录（即条件值本身）时，其索引项上的 next-key 锁会<strong>退化成间隙锁</strong>。</li>
<li>如果是「小于等于 (&lt;=)」查询，扫描到终止范围的记录（即条件值本身，也是满足条件的最后一条记录）时，其索引项上的 next-key 锁<strong>通常不会退化</strong>。</li>
</ul>
</li>
</ul>
<p>其他被扫描到的、满足查询条件的记录，其索引项上通常施加的是 next-key 锁。</p>
<h3 id="非唯一索引等值查询">非唯一索引等值查询</h3>
<p>当使用非唯一索引（二级索引）进行等值查询时，情况更为复杂，因为这通常涉及到对两个索引的加锁操作：<strong>一个是二级索引本身，另一个是与满足条件的二级索引条目对应的主键索引</strong>。对主键索引加锁时，通常只针对那些满足查询条件的记录的主键。</p>
<p>针对非唯一索引等值查询，根据查询的记录是否存在，加锁规则也有所不同：</p>
<ul>
<li>当查询的记录**「存在」**时：由于是非唯一索引，可能存在多个索引值相同的记录。查询过程会扫描二级索引，直到找到第一个不符合条件的二级索引记录才停止。
<ul>
<li><strong>在二级索引上</strong>：对于扫描到的、满足查询条件的二级索引记录，会添加 <strong>next-key 锁</strong>。对于扫描过程中遇到的第一个不符合查询条件的二级索引记录，其上的 next-key 锁会<strong>退化成间隙锁</strong>。</li>
<li><strong>在主键索引上</strong>：对于那些通过二级索引找到的、符合查询条件的记录，会在它们对应的主键索引项上添加<strong>记录锁</strong>。</li>
</ul>
</li>
<li>当查询的记录**「不存在」**时：
<ul>
<li><strong>在二级索引上</strong>：扫描到第一个不符合条件的（即大于查询值的）二级索引记录，其上的 next-key 锁会<strong>退化成间隙锁</strong>。</li>
<li><strong>在主键索引上</strong>：由于没有找到满足查询条件的记录，所以不会对主键索引加锁。</li>
</ul>
</li>
</ul>
<p>接下来通过两个实验进行说明。</p>
<h4 id="1、记录不存在的情况">1、记录不存在的情况</h4>
<blockquote>
<p>实验一：针对非唯一索引等值查询，查询的值不存在的情况。</p>
</blockquote>
<p>我们先分析非唯一索引等值查询时，记录不存在的情况，这相对简单一些。<br>
假设事务 A 对非唯一索引 <code>age</code> 进行等值查询，且表中不存在 <code>age = 25</code> 的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ul>
<li>在二级索引 <code>index_age</code> 上查找 <code>age = 25</code>。由于不存在，会定位到第一个大于 25 的 <code>age</code> 值，即 <code>age = 39</code>（对应记录 <code>id=20, name='香克斯', age=39</code>）。</li>
<li>施加在 <code>age = 39</code> 这条二级索引记录上的 next-key 锁会<strong>退化成间隙锁</strong>。这个间隙锁的范围是 <code>(22, 39)</code>，其中 22 是 <code>age=39</code> 之前的一个 <code>age</code> 值（来自 <code>id=10, name='山治', age=22</code>）。</li>
<li>查询结束。</li>
</ul>
<p>因此，事务 A 在 <code>age = 39</code> (具体是 <code>id=20, age=39</code> 这条记录) 的二级索引项上，添加了一个 X 型的间隙锁，范围是 <code>(22, 39)</code>。这个锁意味着其他事务无法插入 <code>age</code> 值为 23、24、25、…、38 的新记录。<br>
（关于插入 <code>age = 22</code> 或 <code>age = 39</code> 的情况，会更复杂，稍后讨论。）</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970488972.png" alt="1746970488972"></p>
<p>通过 <code>select * from performance_schema.data_locks\G;</code> 确认加锁情况（仅截取行级锁部分）：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970495945.png" alt="1746970495945"></p>
<p>从上图分析，<code>INDEX_NAME: index_age</code>，<code>LOCK_MODE: X, GAP</code>，<code>LOCK_DATA</code> 显示 <code>39, 20</code>。<br>
这表明在二级索引 <code>index_age</code> 上，针对 <code>age = 39</code> (其主键 <code>id = 20</code>) 的索引项，施加了一个间隙锁。其 <code>age</code> 值的范围是 <code>(22, 39)</code>。</p>
<p>此时，若其他事务尝试插入 <code>age</code> 值为 23 到 38 之间的新记录，这些插入操作都会被阻塞。<br>
但对于插入 <code>age = 22</code> 或 <code>age = 39</code> 的记录，情况会更复杂，取决于插入记录的主键值。</p>
<blockquote>
<p>当一个事务持有二级索引的间隙锁 <code>(22, 39)</code> (基于 age 值) 时，其他事务插入 <code>age = 22</code> 或 <code>age = 39</code> 的记录能否成功？</p>
</blockquote>
<p>要理解这一点，首先要知道：<strong>插入操作在尝试插入一条新记录前，会先在 B+树（此处指二级索引树）中定位其插入位置。如果该插入位置的&quot;下一条&quot;记录的索引项上存在间隙锁（或 next-key 锁的间隙部分）覆盖了这个插入点，则插入会被阻塞。</strong></p>
<p>二级索引树的记录是先按二级索引值（<code>age</code>）排序，如果二级索引值相同，则再按主键值（<code>id</code>）排序。</p>
<p>基于前面的实验，事务 A 在 <code>(id=20, age=39)</code> 这条记录的二级索引项上，施加了 <code>age</code> 范围为 <code>(22, 39)</code> 的间隙锁。</p>
<ul>
<li>
<p><strong>尝试插入 <code>age = 22</code> 的记录</strong>：</p>
<ul>
<li>若其他事务插入 <code>(id=3, age=22)</code>：在二级索引树中，这条记录会排在 <code>(id=10, age=22)</code> 之前。其插入位置的下一条记录是 <code>(id=10, age=22)</code>。由于 <code>(id=10, age=22)</code> 的二级索引项上没有被事务 A 的间隙锁覆盖（事务 A 的间隙锁与 <code>age=22</code> 的记录不直接相关），<strong>此插入通常可以成功</strong>（假设没有其他锁）。</li>
<li>若其他事务插入 <code>(id=12, age=22)</code>：在二级索引树中，这条记录会排在 <code>(id=10, age=22)</code> 之后，但在 <code>(id=20, age=39)</code> 之前。其插入位置的下一条记录是 <code>(id=20, age=39)</code>。由于 <code>(id=20, age=39)</code> 的二级索引项上正好有事务 A 施加的间隙锁 <code>(22, 39)</code>，<strong>此插入会被阻塞</strong>。</li>
</ul>
</li>
<li>
<p><strong>尝试插入 <code>age = 39</code> 的记录</strong>：</p>
<ul>
<li>若其他事务插入 <code>(id=3, age=39)</code>：在二级索引树中，这条记录会排在 <code>(id=20, age=39)</code> 之前。其插入位置的下一条记录是 <code>(id=20, age=39)</code>。由于 <code>(id=20, age=39)</code> 的二级索引项上有间隙锁，<strong>此插入会被阻塞</strong>。</li>
<li>若其他事务插入 <code>(id=21, age=39)</code>：在二级索引树中，这条记录会排在 <code>(id=20, age=39)</code> 之后。其插入位置的下一条记录可能是 supremum pseudo-record（如果 <code>id=21, age=39</code> 是最大的）。如果下一条记录没有被间隙锁覆盖，<strong>此插入可以成功</strong>。</li>
</ul>
</li>
</ul>
<p>所以，<strong>当一个事务持有二级索引的间隙锁 (如 <code>age</code> 范围 <code>(22, 39)</code>) 时，能否成功插入边界值 (<code>age=22</code> 或 <code>age=39</code>) 的新记录，关键在于新记录的主键值如何决定其在二级索引中的精确位置，以及该精确位置的下一条记录是否被间隙锁覆盖。</strong></p>
<p>现在回头看 <code>performance_schema.data_locks</code> 的输出：<code>LOCK_DATA: 39, 20</code><br>
<img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970514906.png" alt="1746970514906"></p>
<ul>
<li><code>LOCK_DATA</code> 的第一个值 <code>39</code> 代表 <code>age</code> 值，它是间隙锁或 next-key 锁范围的右边界（对于二级索引）。</li>
<li><code>LOCK_DATA</code> 的第二个值 <code>20</code> 代表与 <code>age=39</code> 关联的记录的 <code>id</code> 值。</li>
</ul>
<p>这个 <code>LOCK_DATA: 39, 20</code> 结合 <code>LOCK_MODE: X, GAP</code> 更准确地解释了：事务 A 在 <code>(id=20, age=39)</code> 这条记录的二级索引项上，施加了 <code>age</code> 值范围为 <code>(22, 39)</code> 的 X 型间隙锁。并且，<strong>这个 <code>id=20</code> 暗示了：如果其他事务尝试插入 <code>age = 39</code> 的新记录，那么当新记录的 <code>id</code> 值小于 <code>20</code> 时，插入会被阻塞；如果新记录的 <code>id</code> 值大于或等于 <code>20</code>，则可能成功（取决于其精确的下一条记录是否有锁）。</strong></p>
<p>对于插入 <code>age = 22</code> 的情况，<code>performance_schema.data_locks</code> 的输出本身不能直接分析出哪些 <code>id</code> 值可以插入。这需要我们自己根据二级索引的 B+树结构，确定插入位置，然后判断其下一条记录是否有间隙锁。</p>
<h4 id="2、记录存在的情况">2、记录存在的情况</h4>
<blockquote>
<p>实验二：针对非唯一索引等值查询，查询的值存在的情况。</p>
</blockquote>
<p>假设事务 A 对非唯一索引 <code>age</code> 进行等值查询，且表中存在 <code>age = 22</code> 的记录（即 <code>id=10, name='山治', age=22</code>）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 山治   <span class="operator">|</span>  <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ol>
<li><strong>二级索引 <code>index_age</code> 上的操作</strong>：
<ul>
<li>由于是非唯一索引，即使找到 <code>age = 22</code> 的记录，仍需继续扫描以查找其他可能的 <code>age = 22</code> 的记录（按主键 <code>id</code> 排序）。</li>
<li>扫描到 <code>(id=10, age=22)</code>。这是满足条件的记录。在其二级索引项上添加 <strong>next-key 锁</strong>。该锁的范围，根据前一个 <code>age</code> 值 21 (来自 <code>id=5, age=21</code>)，应该是 <code>(21, 22]</code> (基于 age 值，并包含 <code>id=10</code>)。</li>
<li>继续扫描，下一条二级索引记录是 <code>(id=20, age=39)</code>。这条记录不符合 <code>age = 22</code> 的条件，是第一个不符合条件的记录。因此，施加在 <code>(id=20, age=39)</code> 这条二级索引记录上的 next-key 锁会<strong>退化成间隙锁</strong>，<code>age</code> 范围是 <code>(22, 39)</code>。</li>
</ul>
</li>
<li><strong>主键索引上的操作</strong>：
<ul>
<li>对于通过二级索引找到的、符合查询条件的记录 <code>(id=10, age=22)</code>，会在其对应的主键索引项（即 <code>id = 10</code>）上添加 <strong>X 型记录锁</strong>。</li>
</ul>
</li>
<li>扫描结束。</li>
</ol>
<p>总结事务 A 添加的 X 型锁：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970528363.png" alt="1746970528363"></p>
<ul>
<li><strong>主键索引 (<code>PRIMARY</code>)</strong>：
<ul>
<li>在 <code>id = 10</code> 的记录上，添加了记录锁。</li>
</ul>
</li>
<li><strong>二级索引 (<code>index_age</code>)</strong>：
<ul>
<li>在 <code>(id=10, age=22)</code> 的二级索引项上，添加了 <code>age</code> 范围为 <code>(21, 22]</code> 的 next-key 锁。</li>
<li>在 <code>(id=20, age=39)</code> 的二级索引项上，添加了 <code>age</code> 范围为 <code>(22, 39)</code> 的间隙锁。</li>
</ul>
</li>
</ul>
<p>通过 <code>select * from performance_schema.data_locks\G;</code> 确认加锁情况：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970534738.png" alt="1746970534738"></p>
<p>分析上图：</p>
<ul>
<li>
<p><strong>二级索引 (<code>INDEX_NAME: index_age</code>)</strong>：</p>
<ul>
<li><code>LOCK_DATA: 22, 10</code>, <code>LOCK_MODE: X</code>：对应 <code>(id=10, age=22)</code> 上的 next-key 锁，<code>age</code> 范围 <code>(21, 22]</code>。
<ul>
<li>这意味着其他事务不能轻易更新或删除 <code>age=22</code> 且 <code>id=10</code> 的记录。</li>
<li>对于插入新的 <code>age=21</code> 或 <code>age=22</code> 的记录：
<ul>
<li>插入 <code>age=21</code>：若新记录 <code>id &lt; 5</code> (<code>(id=5,age=21)</code>是表中已存在的 age=21 的记录)，可能成功。若新记录 <code>id &gt; 5</code>，其下一条可能是 <code>(id=10,age=22)</code> (被 next-key 锁覆盖) 或 <code>(id=20,age=39)</code> (被间隙锁覆盖)，导致阻塞。</li>
<li>插入 <code>age=22</code>：从 <code>LOCK_DATA: 22, 10</code> 可知，若新记录 <code>id &lt; 10</code>，会被此 next-key 锁阻塞。若新记录 <code>id &gt; 10</code>，其下一条可能是 <code>(id=20,age=39)</code> (被间隙锁覆盖)，也会被阻塞。</li>
</ul>
</li>
</ul>
</li>
<li><code>LOCK_DATA: 39, 20</code>, <code>LOCK_MODE: X, GAP</code>：对应 <code>(id=20, age=39)</code> 上的间隙锁，<code>age</code> 范围 <code>(22, 39)</code>。
<ul>
<li>这意味着其他事务无法插入 <code>age</code> 值为 23 到 38 的记录。</li>
<li>对于插入新的 <code>age=22</code> 或 <code>age=39</code> 的记录：
<ul>
<li>插入 <code>age=22</code>：若新记录 <code>id &lt; 10</code>，会被前一个 next-key 锁阻塞。若新记录 <code>id &gt; 10</code>，其下一条可能是 <code>(id=20,age=39)</code> (被此间隙锁覆盖)，也会被阻塞。因此，实际上很难插入新的 <code>age=22</code> 记录。</li>
<li>插入 <code>age=39</code>：从 <code>LOCK_DATA: 39, 20</code> 可知，若新记录 <code>id &lt; 20</code>，会被此间隙锁阻塞。若 <code>id &gt;= 20</code>，可能成功。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>主键索引 (<code>INDEX_NAME: PRIMARY</code>)</strong>：</p>
<ul>
<li><code>LOCK_DATA: 10</code>, <code>LOCK_MODE: X, REC_NOT_GAP</code>：对 <code>id = 10</code> 添加了记录锁。</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么在这个实验案例中，需要在二级索引上添加 <code>age</code> 范围 <code>(22, 39)</code> 的间隙锁？</p>
</blockquote>
<p>核心原因仍然是为了<strong>避免幻读现象</strong>。</p>
<p>考虑查询语句 <code>select * from user where age = 22 for update;</code></p>
<p>如果事务 A 在二级索引上只对 <code>(id=10, age=22)</code> 添加 <code>age</code> 范围 <code>(21, 22]</code> 的 next-key 锁，而不添加后续的 <code>(22, 39)</code> 间隙锁，那么幻读是有可能发生的。</p>
<p>如前所述，<code>age</code> 范围 <code>(21, 22]</code> 的 next-key 锁（作用于 <code>(id=10, age=22)</code>）并不能完全阻止其他事务插入新的 <code>age = 22</code> 的记录。例如，其他事务理论上可以尝试插入 <code>(id=12, age=22)</code>。如果这个插入成功了，那么事务 A 再次执行 <code>select * from user where age = 22 for update;</code> 时，就会发现多了一条记录，产生了幻读。</p>
<p><strong>当在 <code>(id=20, age=39)</code> 的二级索引项上添加了 <code>age</code> 范围 <code>(22, 39)</code> 的间隙锁后，其他事务尝试插入 <code>(id=12, age=22)</code> 时，其在二级索引树上的插入位置的下一条记录将是 <code>(id=20, age=39)</code>。由于该记录的二级索引项上有这个间隙锁，插入操作就会被阻塞。这样就有效地避免了幻读。</strong></p>
<p>因此，这个额外的间隙锁是防止在 <code>age=22</code> 条件下出现幻读的关键。</p>
<h3 id="非唯一索引范围查询">非唯一索引范围查询</h3>
<p>非唯一索引的范围查询与主键索引（唯一索引）的范围查询在加锁行为上有一个显著区别：<strong>对于非唯一索引的范围查询，其在二级索引上添加的 next-key lock 通常不会发生退化为纯间隙锁或纯记录锁的情况。</strong> 也就是说，扫描到的二级索引记录通常都会被施加 next-key 锁。</p>
<p>我们来分析一个例子，事务 A 执行以下范围查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">22</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name      <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 山治      <span class="operator">|</span>  <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 香克斯    <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>事务 A 的加锁过程分析如下：</p>
<ol>
<li><strong>二级索引 <code>index_age</code> 上的操作</strong>：
<ul>
<li>扫描到的第一条满足 <code>age &gt;= 22</code> 的二级索引记录是 <code>(id=10, age=22)</code>。虽然范围查询包含了等值条件 (<code>age = 22</code>)，但因为这是非唯一索引，所以通常不会发生像唯一索引那样的锁退化。因此，在 <code>(id=10, age=22)</code> 的二级索引项上添加 <strong>next-key 锁</strong>，<code>age</code> 范围是 <code>(21, 22]</code>。</li>
<li>继续范围扫描，下一条满足条件的二级索引记录是 <code>(id=20, age=39)</code>。在其二级索引项上添加 <strong>next-key 锁</strong>，<code>age</code> 范围是 <code>(22, 39]</code>。</li>
<li>继续向后扫描到二级索引的 supremum pseudo-record，为其添加 <strong>next-key 锁</strong>，<code>age</code> 范围是 <code>(39, +∞]</code>。</li>
</ul>
</li>
<li><strong>主键索引上的操作</strong>：
<ul>
<li>对于通过二级索引找到的、符合查询条件的记录 <code>(id=10, age=22)</code>，在其主键索引项 (<code>id=10</code>) 上添加 <strong>X 型记录锁</strong>。</li>
<li>对于记录 <code>(id=20, age=39)</code>，在其主键索引项 (<code>id=20</code>) 上添加 <strong>X 型记录锁</strong>。</li>
</ul>
</li>
<li>扫描结束。</li>
</ol>
<p>总结事务 A 添加的 X 型锁：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970548753.png" alt="1746970548753"></p>
<ul>
<li><strong>主键索引 (<code>id</code> 列)</strong>：
<ul>
<li>在 <code>id = 10</code> 的记录上，添加记录锁。</li>
<li>在 <code>id = 20</code> 的记录上，添加记录锁。</li>
</ul>
</li>
<li><strong>二级索引 (<code>age</code> 列)</strong>：
<ul>
<li>在 <code>(id=10, age=22)</code> 的二级索引项上，添加了 <code>age</code> 范围 <code>(21, 22]</code> 的 next-key 锁。</li>
<li>在 <code>(id=20, age=39)</code> 的二级索引项上，添加了 <code>age</code> 范围 <code>(22, 39]</code> 的 next-key 锁。</li>
<li>在二级索引的 supremum pseudo-record 上，添加了 <code>age</code> 范围 <code>(39, +∞]</code> 的 next-key 锁。</li>
</ul>
</li>
</ul>
<p>这些锁共同确保了在 <code>age &gt;= 22</code> 的范围内不会出现幻读，并且符合条件的记录不能被并发修改。</p>
<blockquote>
<p>在 <code>age &gt;= 22</code> 的范围查询中，<code>age = 22</code> 的记录存在且属于等值部分，为什么不像唯一索引那样，将在 <code>(id=10, age=22)</code> 的二级索引项上的 next-key 锁退化为记录锁？</p>
</blockquote>
<p>这是因为 <code>age</code> 字段是非唯一索引，不具有唯一性。如果仅对 <code>(id=10, age=22)</code> 的二级索引项施加记录锁（记录锁主要防止删除/修改，对防止在&quot;旁边&quot;插入相同 <code>age</code> 值但不同 <code>id</code> 的记录效果有限），那么其他事务仍然可能插入一条新的 <code>age = 22</code> 的记录（例如 <code>(id=12, age=22)</code>）。如果这样的插入成功，事务 A 再次执行查询时就会看到不同的结果集，从而发生幻读。</p>
<p>因此，在非唯一索引的范围查询中，保持 next-key 锁（它包含了间隙锁的功能）对于防止幻读至关重要。</p>
<h3 id="没有加索引的查询">没有加索引的查询</h3>
<p>前面的案例中，我们的查询语句都利用了索引进行扫描和定位记录，然后对扫描到的索引项进行加锁。</p>
<p><strong>如果锁定读查询语句（<code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... LOCK IN SHARE MODE</code>）的 <code>WHERE</code> 条件没有使用索引列，或者查询优化器未能选择使用索引，导致执行全表扫描，那么情况会变得非常严重：InnoDB 会对表中的每一条记录（准确地说是每一个聚簇索引记录）都施加 next-key 锁。这实际上相当于锁定了整张表。</strong></p>
<p>此时，任何其他事务尝试对该表进行增、删、改操作（即使是针对未被查询条件直接命中的行）都会被阻塞，直到持有全表锁的事务提交或回滚。</p>
<p>不仅是锁定读查询语句，<code>UPDATE</code> 和 <code>DELETE</code> 语句如果其 <code>WHERE</code> 条件没有有效利用索引，同样会导致全表扫描，并对每一条记录的聚簇索引项添加 next-key 锁，从而锁住全表。</p>
<p>因此，<strong>在线上环境中执行 <code>UPDATE</code>、<code>DELETE</code>、<code>SELECT ... FOR UPDATE</code> 等具有加锁性质的语句时，务必检查这些语句是否能够有效利用索引。如果发生全表扫描，其对并发性能的影响将是灾难性的。</strong></p>
<h2 id="总结">总结</h2>
<p>本次我们以 <strong>MySQL 8.0.26</strong> 版本，在<strong>可重复读</strong>隔离级别下，通过一系列实验，详细探讨了唯一索引和非唯一索引在不同查询场景下的行级锁加锁规则。</p>
<p>核心的加锁规则可以概括如下：</p>
<p><strong>唯一索引等值查询</strong>：</p>
<ul>
<li>当查询的记录**「存在」<strong>时，施加在该记录索引项上的 next-key lock 会</strong>退化为「记录锁」**。</li>
<li>当查询的记录**「不存在」<strong>时，会找到索引中第一条大于查询值的记录，并施加在该记录索引项上的 next-key lock 会</strong>退化为「间隙锁」**，覆盖查询值与该较大值之间的间隙。</li>
</ul>
<p><strong>非唯一索引等值查询</strong>：</p>
<ul>
<li>当查询的记录**「存在」**时：
<ul>
<li><strong>二级索引</strong>：对扫描到的满足条件的二级索引记录加 <strong>next-key 锁</strong>；对第一个不满足条件的二级索引记录，其 next-key 锁<strong>退化为间隙锁</strong>。</li>
<li><strong>主键索引</strong>：对符合查询条件的记录的主键索引项加<strong>记录锁</strong>。</li>
</ul>
</li>
<li>当查询的记录**「不存在」**时：
<ul>
<li><strong>二级索引</strong>：扫描到第一条不符合条件（大于查询值）的二级索引记录，其 next-key 锁<strong>退化为间隙锁</strong>。</li>
<li><strong>主键索引</strong>：不加锁。</li>
</ul>
</li>
</ul>
<p><strong>范围查询的差异</strong>：</p>
<ul>
<li><strong>唯一索引</strong>的范围查询，在特定条件下（如等值部分、扫描边界等），next-key lock 可能会退化为间隙锁或记录锁。</li>
<li><strong>非唯一索引</strong>的范围查询，其在二级索引上添加的 next-key lock 通常<strong>不会退化</strong>，以更全面地防止幻读。</li>
</ul>
<p>理解 MySQL 为何如此设计加锁机制的关键在于从<strong>避免幻读</strong>的角度去分析。可重复读隔离级别要求防止幻读，而这些复杂的加锁规则（特别是 next-key 锁和间隙锁的运用）正是为了在保证并发性的同时实现这一目标。</p>
<p>最后，再次强调一件至关重要的事情：在线上执行 <code>UPDATE</code>、<code>DELETE</code>、<code>SELECT ... FOR UPDATE</code> 等具有加锁性质的语句时，<strong>务必检查其执行计划，确保它们能够有效利用索引。如果发生全表扫描，将会对每一个索引记录施加 next-key 锁，相当于锁住整个表，这对系统的并发处理能力是极为不利的。</strong></p>
<p>最后附上「@一只小铭」同学总结的流程图，以供参考。</p>
<p>唯一索引加锁的流程图（<strong>请注意：此流程图主要针对「主键索引」。如果是二级唯一索引，除了图中所示的对二级索引的加锁规则外，还会对查询到的记录的主键索引项额外添加「记录锁」。此流程图未明确提示这一点，特此文字补充说明</strong>）：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970564337.png" alt="1746970564337"></p>
<p>非唯一索引加锁的流程图：</p>
<p><img src="/2025/05/11/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84/1746970653139.png" alt="1746970653139"></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>锁机制</tag>
        <tag>行级锁</tag>
        <tag>表级锁</tag>
        <tag>next-key锁</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 4.寻找两个正序数组的中位数 - 深入理解二分思想</title>
    <url>/2025/05/11/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong>。</p>
<p>要求算法的时间复杂度为 <code>O(log (m+n))</code>。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3]，中位数 2</span><br><span class="line"></span><br><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4]，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2>
<p>这道题乍看之下，似乎可以通过合并两个数组后找出中位数来解决，但这样做的时间复杂度是 <code>O(m+n)</code>，而题目要求 <code>O(log(m+n))</code>。一看到对数级的时间复杂度，我们应该想到二分查找。</p>
<h3 id="核心思想">核心思想</h3>
<p>本题的核心思想是<strong>将两个数组进行虚拟切分</strong>，使得：</p>
<ol>
<li>左半部分的元素个数等于右半部分（或者多一个，当总数为奇数时）</li>
<li>左半部分的所有元素都小于或等于右半部分的所有元素</li>
</ol>
<p>找到这样的切分后，中位数就可以轻松计算出来了。</p>
<p>假设有两个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums1: [a1, a2, a3, a4, a5]</span><br><span class="line">nums2: [b1, b2, b3, b4, b5, b6, b7]</span><br></pre></td></tr></table></figure>
<p>我们的目标是在这两个数组中找出一个切分位置，将所有元素分为数量相等（或左侧多一个）的两部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左半部分：[a1, a2, a3 | b1, b2, b3, b4]</span><br><span class="line">右半部分：[a4, a5 | b5, b6, b7]</span><br></pre></td></tr></table></figure>
<p>当左半部分的最大值小于或等于右半部分的最小值时，我们就找到了正确的切分位置。中位数可以根据总元素个数的奇偶性计算：</p>
<ul>
<li>元素总数为奇数：中位数 = 左半部分的最大值</li>
<li>元素总数为偶数：中位数 = (左半部分的最大值 + 右半部分的最小值) / 2</li>
</ul>
<h3 id="实现的关键点解析">实现的关键点解析</h3>
<h4 id="1-切分点的含义">1. 切分点的含义</h4>
<p>重要的是，<strong>mid表示的是元素间的切分位置</strong>，而不是具体的元素。例如：</p>
<p>对于数组 <code>[1, 3, 5, 7, 9]</code>：</p>
<ul>
<li>mid=0 表示在1之前切分：<code>[] | [1, 3, 5, 7, 9]</code></li>
<li>mid=3 表示在7之前切分：<code>[1, 3, 5] | [7, 9]</code></li>
<li>mid=5 表示在所有元素之后切分：<code>[1, 3, 5, 7, 9] | []</code></li>
</ul>
<p>这就是为什么right初始化为len1而不是len1-1，因为我们需要考虑将所有元素都放在左半部分的情况。</p>
<h4 id="2-为什么使用-left-right-而不是-left-right？">2. 为什么使用 <code>left &lt;= right</code> 而不是 <code>left &lt; right</code>？</h4>
<p>在这个二分查找中，使用 <code>left &lt;= right</code> 是必要的。当搜索区间收缩到只有一个元素时（即 <code>left == right</code>），这个元素可能就是正确的切分点。如果使用 <code>left &lt; right</code>，循环会提前退出，可能会错过正确解。</p>
<p>特别是当nums1只有一个元素时，如果使用 <code>left &lt; right</code>，算法可能无法正确处理这种情况。</p>
<h4 id="3-为什么只检查-mid1-len1-和-mid1-0，不检查-mid2-的边界？">3. 为什么只检查 mid1 &lt; len1 和 mid1 &gt; 0，不检查 mid2 的边界？</h4>
<p>这是一个很好的问题！算法中我们检查了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> mid1 &lt; len1 &amp;&amp; nums1[mid1] &lt; nums2[mid2<span class="number">-1</span>] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> mid1 &gt; <span class="number">0</span> &amp;&amp; nums1[mid1<span class="number">-1</span>] &gt; nums2[mid2] &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不需要检查mid2的边界，原因如下：</p>
<ol>
<li>
<p><strong>mid2的计算保证了某些边界条件</strong>：mid2 = halfLen - mid1，其中halfLen = (len1+len2+1)/2</p>
</li>
<li>
<p><strong>mid2的范围是有保证的</strong>：</p>
<ul>
<li>当mid1增大时，mid2减小，反之亦然</li>
<li>我们知道 0 &lt;= mid1 &lt;= len1，因此 (halfLen-len1) &lt;= mid2 &lt;= halfLen</li>
</ul>
</li>
<li>
<p><strong>算法保证了mid2的合理性</strong>：</p>
<ul>
<li>我们总是对较短的数组进行二分（通过交换nums1和nums2确保len1 &lt;= len2）</li>
<li>这确保了halfLen-len1 &gt;= 0，即mid2 &gt;= 0</li>
<li>同样，由于halfLen &lt;= (len1+len2+1)/2 &lt;= (len2+len2+1)/2，可以推导出mid2 &lt;= len2</li>
</ul>
</li>
</ol>
<p>因此，对mid1进行边界检查已经足够，不需要显式检查mid2的边界。这是算法设计的巧妙之处。</p>
<h4 id="4-为什么halfLength计算要加1？">4. 为什么halfLength计算要加1？</h4>
<p>在代码中，我们看到halfLength的计算使用了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">halfLength := (len1+len2+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>  <span class="comment">// 左半部分应该包含的元素个数</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>+1</code>非常关键，它确保了在奇数长度的情况下，左半部分会多包含一个元素。让我们分析不同情况：</p>
<p><strong>情况1：总长度为偶数</strong><br>
假设<code>len1 + len2 = 8</code></p>
<ul>
<li>使用<code>(8) &gt;&gt; 1 = 4</code>，左边和右边各4个元素</li>
<li>使用<code>(8 + 1) &gt;&gt; 1 = 4</code>，结果相同，左右各4个元素</li>
</ul>
<p><strong>情况2：总长度为奇数</strong><br>
假设<code>len1 + len2 = 7</code></p>
<ul>
<li>使用<code>(7) &gt;&gt; 1 = 3</code>，左边3个元素，右边4个元素</li>
<li>使用<code>(7 + 1) &gt;&gt; 1 = 4</code>，左边4个元素，右边3个元素</li>
</ul>
<p>在处理中位数时，我们的代码逻辑是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果两个数组的总长度为奇数，中位数就是左半部分的最大值</span></span><br><span class="line"><span class="keyword">if</span> (len1+len2)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(maxLeft)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总长度为偶数时，中位数是左半部分最大值和右半部分最小值的平均值</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(maxLeft + minRight) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>这里的算法设计假设：</p>
<ul>
<li>奇数长度时，中位数是左半部分的最大值</li>
<li>偶数长度时，需要计算左半部分最大值和右半部分最小值的平均值</li>
</ul>
<p>为了使这个逻辑正确工作，在奇数长度情况下，我们必须确保中位数在左半部分。例如，对于总长度7的数组，中位数是第4个元素，所以左半部分必须包含4个元素。</p>
<p>这就是为什么要使用<code>(len1+len2+1)&gt;&gt;1</code>而不是<code>(len1+len2)&gt;&gt;1</code>的原因：加上这个<code>+1</code>确保了在奇数长度情况下，左半部分会多包含一个元素，从而包含了中位数，使得算法的判断逻辑能够正确工作。</p>
<h2 id="完整代码实现">完整代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找两个正序数组的中位数</span></span><br><span class="line"><span class="comment"> * @param nums1 第一个有序数组</span></span><br><span class="line"><span class="comment"> * @param nums2 第二个有序数组</span></span><br><span class="line"><span class="comment"> * @return 两个数组合并后的中位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 获取两个数组的长度</span></span><br><span class="line">    len1, len2 := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优化：始终对较短的数组进行二分查找，减少搜索空间</span></span><br><span class="line">    <span class="comment">// 如果 nums1 比 nums2 长，则交换两个数组</span></span><br><span class="line">    <span class="keyword">if</span> len1 &gt; len2 &#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二分查找的边界</span></span><br><span class="line">    left := <span class="number">0</span>                   <span class="comment">// 二分查找的左边界，表示nums1可能的最小切分点</span></span><br><span class="line">    right := len1               <span class="comment">// 二分查找的右边界，表示nums1可能的最大切分点</span></span><br><span class="line">    halfLen := (len1+len2+<span class="number">1</span>)/<span class="number">2</span>  <span class="comment">// 左半部分应该包含的元素个数（包括奇数情况）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在nums1上进行二分查找，寻找合适的切分点</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="comment">// 计算当前nums1的切分点（将前mid1个元素放入左半部分）</span></span><br><span class="line">        mid1 := (left + right) &gt;&gt; <span class="number">1</span>  <span class="comment">// 使用位运算提高效率，等价于 (left + right) / 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据mid1计算nums2的切分点，确保左半部分总共有halfLen个元素</span></span><br><span class="line">        mid2 := halfLen - mid1</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一种情况：nums1的切分点太小，左半部分需要更多元素</span></span><br><span class="line">        <span class="comment">// 检查：如果mid1元素小于nums2的mid2-1元素，说明mid1需要右移</span></span><br><span class="line">        <span class="keyword">if</span> mid1 &lt; len1 &amp;&amp; nums1[mid1] &lt; nums2[mid2<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="comment">// mid1太小，需要增加，向右移动left指针</span></span><br><span class="line">            left = mid1 + <span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 第二种情况：nums1的切分点太大，左半部分需要减少元素</span></span><br><span class="line">        <span class="comment">// 检查：如果mid1-1元素大于nums2的mid2元素，说明mid1需要左移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> mid1 &gt; <span class="number">0</span> &amp;&amp; nums1[mid1<span class="number">-1</span>] &gt; nums2[mid2] &#123;</span><br><span class="line">            <span class="comment">// mid1太大，需要减少，向左移动right指针</span></span><br><span class="line">            right = mid1 - <span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 找到了合适的切分点：左半部分的最大值小于等于右半部分的最小值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算左半部分的最大值</span></span><br><span class="line">            <span class="keyword">var</span> maxLeft <span class="type">int</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理边界情况：当mid1=0时，nums1的左半部分为空</span></span><br><span class="line">            <span class="keyword">if</span> mid1 == <span class="number">0</span> &#123;</span><br><span class="line">                maxLeft = nums2[mid2<span class="number">-1</span>]  <span class="comment">// 左半部分最大值来自nums2</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 处理边界情况：当mid2=0时，nums2的左半部分为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> mid2 == <span class="number">0</span> &#123;</span><br><span class="line">                maxLeft = nums1[mid1<span class="number">-1</span>]  <span class="comment">// 左半部分最大值来自nums1</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 一般情况：取nums1和nums2左半部分的最大值</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                maxLeft = max(nums1[mid1<span class="number">-1</span>], nums2[mid2<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果两个数组的总长度为奇数，直接返回左半部分的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (len1+len2) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="type">float64</span>(maxLeft)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算右半部分的最小值（偶数情况下需要）</span></span><br><span class="line">            <span class="keyword">var</span> minRight <span class="type">int</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理边界情况：当mid1=len1时，nums1的右半部分为空</span></span><br><span class="line">            <span class="keyword">if</span> mid1 == len1 &#123;</span><br><span class="line">                minRight = nums2[mid2]  <span class="comment">// 右半部分最小值来自nums2</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 处理边界情况：当mid2=len2时，nums2的右半部分为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> mid2 == len2 &#123;</span><br><span class="line">                minRight = nums1[mid1]  <span class="comment">// 右半部分最小值来自nums1</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 一般情况：取nums1和nums2右半部分的最小值</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                minRight = min(nums1[mid1], nums2[mid2])</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 总长度为偶数时，中位数是左半部分最大值和右半部分最小值的平均值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">float64</span>(maxLeft + minRight) / <span class="number">2.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 理论上不会执行到这里，添加返回值以满足编译要求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回两个整数中的较大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回两个整数中的较小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例分析">实例分析</h2>
<p>让我们通过一个具体例子来说明算法的执行过程：</p>
<p>假设 nums1 = [1, 3, 5]，nums2 = [2, 4, 6]</p>
<ol>
<li>
<p>初始化：len1=3, len2=3, halfLen=(3+3+1)/2=3, left=0, right=3</p>
</li>
<li>
<p>第一次迭代：</p>
<ul>
<li>mid1 = (0+3)/2 = 1，表示在nums1中[1] | [3,5]切分</li>
<li>mid2 = 3-1 = 2，表示在nums2中[2,4] | [6]切分</li>
<li>检查：nums1[mid1-1]=1 &lt;= nums2[mid2]=6 且 nums2[mid2-1]=4 &gt; nums1[mid1]=3</li>
<li>需要增加mid1，所以left = mid1+1 = 2</li>
</ul>
</li>
<li>
<p>第二次迭代：</p>
<ul>
<li>mid1 = (2+3)/2 = 2，表示在nums1中[1,3] | [5]切分</li>
<li>mid2 = 3-2 = 1，表示在nums2中[2] | [4,6]切分</li>
<li>检查：nums1[mid1-1]=3 &lt;= nums2[mid2]=4 且 nums2[mid2-1]=2 &lt;= nums1[mid1]=5</li>
<li>找到了合适的切分点！</li>
<li>左半部分：[1, 3, 2]，最大值是3</li>
<li>右半部分：[5, 4, 6]，最小值是4</li>
<li>总元素个数为偶数，所以中位数 = (3+4)/2 = 3.5</li>
</ul>
</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>时间复杂度：O(log(min(m,n)))，其中m和n分别是两个数组的长度。我们对较短的数组进行二分查找。</li>
<li>空间复杂度：O(1)，只使用了常数额外空间。</li>
</ul>
<h2 id="总结">总结</h2>
<p>这道题的核心在于理解如何在两个有序数组中找到合适的切分点，使得：</p>
<ol>
<li>左半部分和右半部分的元素个数大致相等</li>
<li>左半部分的所有元素小于等于右半部分的所有元素</li>
</ol>
<p>关键点解析：</p>
<ul>
<li>mid表示元素间的切分位置，而不是元素本身</li>
<li>使用<code>left &lt;= right</code>确保能检查所有可能的切分点</li>
<li>right初始化为len1以考虑所有可能的切分情况</li>
<li>只需检查mid1的边界条件，因为算法设计已经保证了mid2的合理性</li>
</ul>
<p>理解了这些关键点，这道Hard难度的题目就变得清晰易懂了。二分查找的应用远不止是在单一有序数组中查找元素，它还可以用来解决更复杂的问题，比如此题中的两个有序数组的中位数查找。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据类型：Zset (有序集合) 深度解析与实战</title>
    <url>/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Zset/</url>
    <content><![CDATA[<h2 id="Zset">Zset</h2>
<h3 id="介绍">介绍</h3>
<p>想象一下，你需要一个能自动排序的列表，比如实时更新的积分排行榜、按时间先后排列的任务队列，或者任何需要根据某个&quot;分数&quot;来决定顺序的场景。Redis 的 Zset (Sorted Set，有序集合) 就是为此而生的！它和普通的 Set 一样，保证了元素的唯一性，但更强大的是，Zset 为每个元素关联了一个&quot;分数&quot;(score)，并能根据这个分数自动对元素进行排序。</p>
<p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Zset/1746890268561.png" alt="1746890268561"></p>
<h3 id="内部实现">内部实现</h3>
<p>Zset 如何做到既能存储唯一元素又能排序呢？Redis 在底层使用了两种精巧的数据结构：<strong>跳表 (Skip List)</strong> 和 <strong>列表打包 (Listpack)</strong>。</p>
<p>简单来说：</p>
<ul>
<li>当你的 Zset 元素不多（默认小于128个），并且每个元素的值也不大（默认小于64字节）时，Redis 会优先使用 <strong>listpack</strong>。它是一种更紧凑的存储方式，非常节省内存。</li>
<li>而当 Zset 元素增多，或者元素值较大，不满足上述条件时，Redis 则会切换到 <strong>跳表</strong>。跳表是一种非常高效的动态排序数据结构，可以快速进行添加、删除和查找操作，其平均时间复杂度接近 O(logN)。</li>
</ul>
<p>你无需关心 Redis 何时以及如何切换，它会自动选择最优的方式。</p>
<p>(值得注意的是，在 Redis 7.0 之前的版本中使用的是压缩列表而非 listpack，但核心思想是类似的——在小数据量时采用内存优化结构。<strong>自 Redis 7.0 起，压缩列表已被 listpack 完全取代。</strong>)</p>
<h3 id="常用命令">常用命令</h3>
<p>理解 Zset 的常用命令是高效使用它的关键。以下是一些核心操作，分为几类以便理解：</p>
<h4 id="添加与修改">添加与修改</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZADD key score member [[score member]...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：向名为 key 的有序集合中添加一个或多个元素 (member)，并为每个元素指定一个分数 (score)。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果元素已存在，则更新其分数；如果元素不存在，则添加新元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回成功添加的新元素数量（不包括仅更新分数的元素）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZADD myzset 10 <span class="string">&quot;apple&quot;</span> 20 <span class="string">&quot;banana&quot;</span></span></span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZINCRBY key increment member</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：为名为 key 的有序集合中指定元素 member 的分数增加 increment。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 member 不存在，则添加它，其初始分数为 increment。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">increment 可以是负数，表示减分。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZINCRBY myzset 5 <span class="string">&quot;apple&quot;</span> (apple 的分数变为 15)</span></span><br><span class="line">ZINCRBY key increment member </span><br></pre></td></tr></table></figure>
<h4 id="删除与查询数量">删除与查询数量</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZREM key member [member...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：从名为 key 的有序集合中删除一个或多个指定的元素 member。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZREM myzset <span class="string">&quot;apple&quot;</span></span></span><br><span class="line">ZREM key member [member...]               </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZCARD key</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：获取名为 key 的有序集合中的元素总数 (Cardinality)。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZCARD myzset</span></span><br><span class="line">ZCARD key </span><br></pre></td></tr></table></figure>
<h4 id="获取分数与排序（按分数）">获取分数与排序（按分数）</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZSCORE key member</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：返回名为 key 的有序集合中指定元素 member 的分数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 member 不存在或 key 不存在，则返回 nil。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZSCORE myzset <span class="string">&quot;banana&quot;</span></span></span><br><span class="line">ZSCORE key member</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：按分数从小到大的顺序（升序），返回名为 key 的有序集合中指定排名范围内的元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">start 和 stop 都是从 0 开始的下标，可以是负数（-1 表示最后一个元素，-2 表示倒数第二个，以此类推）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHSCORES 选项会同时返回元素的分数。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZRANGE myzset 0 -1 WITHSCORES (获取所有元素及其分数)</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZREVRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：按分数从大到小的顺序（降序），返回名为 key 的有序集合中指定排名范围内的元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数含义与 ZRANGE 类似。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZREVRANGE myzset 0 2 WITHSCORES (获取分数最高的3个元素及其分数)</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure>
<h4 id="范围查询（按分数或字典序）">范围查询（按分数或字典序）</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：返回名为 key 的有序集合中，所有分数在 min 和 max 之间（包括 min 和 max）的元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">元素按分数从小到大排序。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">min 和 max 可以是 -inf (负无穷) 和 +inf (正无穷)。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 ( 前缀表示不包含边界值，例如 (100 表示大于100。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">LIMIT 用于分页，offset 是起始位置，count 是数量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZRANGEBYSCORE myzset 10 (30 WITHSCORES LIMIT 0 5 (获取分数大于10小于等于30的前5个元素)</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZRANGEBYLEX key min max [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：当有序集合中所有元素的分数都相同时，此命令按元素的字典序（lexicographical order）返回指定范围内的元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">**重要前提：使用 ZRANGEBYLEX 时，目标 Zset 中的所有元素分数 *必须* 相同，否则结果可能不符合预期！**</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">min 和 max 是字典序范围。使用 - 和 + 表示负无穷和正无穷的字典序边界。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 [ 表示包含边界，使用 ( 表示不包含边界。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZRANGEBYLEX myzset <span class="string">&quot;[apple&quot;</span> <span class="string">&quot;(banana&quot;</span> (获取字典序在 apple (含) 和 banana (不含) 之间的元素)</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZREVRANGEBYLEX key max min [LIMIT offset count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：与 ZRANGEBYLEX 类似，但按字典逆序排列。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">**重要前提：使用 ZREVRANGEBYLEX 时，目标 Zset 中的所有元素分数 *必须* 相同，否则结果可能不符合预期！**</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZREVRANGEBYLEX myzset <span class="string">&quot;+ &quot;</span> <span class="string">&quot;[banana&quot;</span> (获取字典序从最大到 banana (含) 的元素)</span></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br></pre></td></tr></table></figure>
<h4 id="集合运算">集合运算</h4>
<p>Zset 也支持并集和交集运算，但与 Set 不同的是，它可以指定如何处理重复元素的分数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZUNIONSTORE destkey numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算给定的一个或多个有序集合 (key) 的并集，并将结果存储在新的有序集合 destkey 中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">numkeys 指定输入 key 的数量。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WEIGHTS (可选)：为每个输入集合指定一个乘法因子，元素的原始分数在参与运算前会乘以这个因子。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AGGREGATE (可选)：指定如何处理并集中相同元素的分数，默认为 SUM (相加)，也可以是 MIN (取最小值) 或 MAX (取最大值)。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：ZUNIONSTORE outkey 2 zset1 zset2 WEIGHTS 1 2 AGGREGATE MAX</span></span><br><span class="line">ZUNIONSTORE destkey numkeys key [key...] </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZINTERSTORE destkey numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算给定的一个或多个有序集合 (key) 的交集，并将结果存储在新的有序集合 destkey 中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数含义与 ZUNIONSTORE 类似。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：Zset 没有直接的差集运算命令，如果需要，可以通过代码逻辑结合 ZREM 实现。</span></span><br><span class="line">ZINTERSTORE destkey numkeys key [key...] </span><br></pre></td></tr></table></figure>
<h3 id="应用场景">应用场景</h3>
<p>Zset 类型（Sorted Set，有序集合）可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p>
<h4 id="排行榜">排行榜</h4>
<p>有序集合最经典的应用非排行榜莫属了！无论是热门文章榜、游戏玩家积分榜、商品销量榜，还是实时更新的在线用户列表，Zset 都能轻松应对。</p>
<p>我们以博文点赞排名为例，假设用户&quot;小林&quot;发表了五篇博文，它们的赞数（score）和文章ID（member）如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:1 文章获得了200个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 200 arcticle:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:2 文章获得了40个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 40 arcticle:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:3 文章获得了100个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 100 arcticle:3</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:4 文章获得了50个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 50 arcticle:4</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">arcticle:5 文章获得了150个赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD user:xiaolin:ranking 150 arcticle:5</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>如果文章 <code>arcticle:4</code> 新增了一个赞，可以使用 <code>ZINCRBY</code> 命令轻松更新：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZINCRBY user:xiaolin:ranking 1 arcticle:4</span></span><br><span class="line">&quot;51&quot; # 返回新的分数</span><br></pre></td></tr></table></figure>
<p>想查看某篇文章（比如 <code>arcticle:4</code>）的当前赞数，可以使用 <code>ZSCORE</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZSCORE user:xiaolin:ranking arcticle:4</span></span><br><span class="line">&quot;51&quot;</span><br></pre></td></tr></table></figure>
<p>获取小林文章中赞数最高的 3 篇文章（降序排名），可以使用 <code>ZREVRANGE</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WITHSCORES 表示同时显示分数</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span></span><br><span class="line">1) &quot;arcticle:1&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:3&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p>获取小林文章中赞数在 100 到 200 之间的文章（升序排列），可以使用 <code>ZRANGEBYSCORE</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span></span><br><span class="line">1) &quot;arcticle:3&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:1&quot;</span><br><span class="line">6) &quot;200&quot;</span><br></pre></td></tr></table></figure>
<h4 id="电话、姓名排序-按字典序">电话、姓名排序 (按字典序)</h4>
<p>除了按数值分数排序，Zset 还能在所有元素分数都相同的情况下，按照元素的字典顺序（比如字母顺序、数字顺序）进行排序和范围查找。这就要用到 <code>ZRANGEBYLEX</code> (正序) 或 <code>ZREVRANGEBYLEX</code> (逆序) 这样的命令了。</p>
<p><strong>重要前提：使用 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 时，目标 Zset 中的所有元素分数 <em>必须</em> 相同，否则结果可能不符合预期！</strong> 通常我们会将这些元素的分数统一设置为 <code>0</code>。</p>
<p><em>1、电话排序</em></p>
<p>我们可以将电话号码作为 member 存入 Zset，并将它们的分数都设为 0，然后根据需要来获取号段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD phone 0 13100111100 0 13110114300 0 13132110901</span> </span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD phone 0 13200111100 0 13210414300 0 13252110901</span> </span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZADD phone 0 13300111100 0 13310414300 0 13352110901</span> </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>
<p>获取所有号码（按字典序升序）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;-&#x27;</span> 和 <span class="string">&#x27;+&#x27;</span> 表示无穷小的字典序和无穷大的字典序</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX phone - +</span></span><br><span class="line">1) &quot;13100111100&quot;</span><br><span class="line">2) &quot;13110114300&quot;</span><br><span class="line">3) &quot;13132110901&quot;</span><br><span class="line">4) &quot;13200111100&quot;</span><br><span class="line">5) &quot;13210414300&quot;</span><br><span class="line">6) &quot;13252110901&quot;</span><br><span class="line">7) &quot;13300111100&quot;</span><br><span class="line">8) &quot;13310414300&quot;</span><br><span class="line">9) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>
<p>获取 132 号段的号码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;[132&#x27;</span> 表示大于等于 <span class="string">&#x27;132&#x27;</span> 的字典序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;(133&#x27;</span> 表示小于 <span class="string">&#x27;133&#x27;</span> 的字典序</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX phone [132 (133</span></span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br></pre></td></tr></table></figure>
<p>获取 132、133 号段的号码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX phone [132 (134</span></span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br><span class="line">4) &quot;13300111100&quot;</span><br><span class="line">5) &quot;13310414300&quot;</span><br><span class="line">6) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>
<p><em>2、姓名排序</em></p>
<p>同样，将姓名作为 member 存入 Zset，分数统一设为 0：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua</span> </span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>
<p>获取所有人的名字（按字典序升序）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX names - +</span></span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br><span class="line">3) &quot;Bluetuo&quot;</span><br><span class="line">4) &quot;Gaodeng&quot;</span><br><span class="line">5) &quot;Jake&quot;</span><br><span class="line">6) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure>
<p>获取名字中大写字母 A 开头的所有人：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;[A&#x27;</span> 表示以 A 开头（包含A）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;(B&#x27;</span> 表示小于 B （不包含B）</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX names [A (B</span></span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br></pre></td></tr></table></figure>
<p>获取名字中大写字母 C 到 Z 的所有人：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;[C&#x27;</span> 表示以 C 开头（包含C）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;[Z&#x27;</span> 表示以 Z 开头，由于 ZRANGEBYLEX 是前缀匹配，为了包含所有以Z开头的，可以用 <span class="string">&#x27;[Zz&#x27;</span> 或者更通用的方式确保能取到以Z结尾的，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但这里如果只是想取到Z开头的，可以考虑用一个比Z大的字符的上界，或者分段查询。更简单的是确保最后一个字母是Z的最大可能值。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个更精确的做法是如果想包含所有Z开头的，可以用 [Z (Za (假设没有Za开头的)，但这取决于具体场景。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里原示例的 [Z 意图是C到Z，但其匹配行为是<span class="string">&quot;以C开头&quot;</span>到<span class="string">&quot;以Z开头&quot;</span>。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要包含所有以 Z 结尾的，则需要更复杂的模式或多次查询。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里保持原意，获取字母 C 到 Z 开头的名字</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ZRANGEBYLEX names [C [Zz</span></span><br><span class="line">1) &quot;Gaodeng&quot;</span><br><span class="line">2) &quot;Jake&quot;</span><br><span class="line">3) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>总结来说，Redis Zset (有序集合) 以其独特的&quot;元素唯一、自带排序&quot;特性，在需要动态排序、范围查找以及构建各类排行榜的场景中展现出强大的威力。通过灵活运用 <code>ZADD</code>, <code>ZRANGE</code>, <code>ZREVRANGE</code>, <code>ZRANGEBYSCORE</code> 等命令，你可以高效地处理各种有序数据需求。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据类型</tag>
        <tag>Zset</tag>
        <tag>Sorted Set</tag>
        <tag>有序集合</tag>
        <tag>排行榜</tag>
        <tag>跳表</tag>
        <tag>压缩列表</tag>
        <tag>listpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据类型：Set 集合详解与妙用</title>
    <url>/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Set/</url>
    <content><![CDATA[<h2 id="Set">Set</h2>
<h3 id="介绍">介绍</h3>
<p>想象一下，你正在组织一场热门活动，需要统计所有报名用户的ID，并确保每个用户ID只记录一次，不能重复。或者，你想知道两个不同兴趣小组有哪些共同的成员。这时，Redis 的 Set 数据结构就能大显身身手了！Set 是一个无序且唯一的键值集合，就像数学中的集合概念一样，非常适合处理这类去重和关系运算的场景。</p>
<p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Set/1746889590085.png" alt="1746889590085"></p>
<p>Set 类型和 List 类型的区别如下：</p>
<ul>
<li>List 可以存储重复元素，Set 只能存储非重复元素（核心特性！）。</li>
<li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的（插入顺序不重要）。</li>
</ul>
<h3 id="内部实现">内部实现</h3>
<p>Set 看似简单，但 Redis 在背后为它做了精心设计。简单来说，如果你的 Set 里存放的都是整数，并且数量不多（默认512个以内，这个值可以通过 <code>set-maxintset-entries</code> 配置调整），Redis 会选择一种叫做<strong>整数集合 (intset)</strong> 的内存优化方式来存储它们，这样更节省空间。</p>
<p>如果 Set 里的元素不满足上述条件（比如包含字符串，或者数量超过了限制），Redis 就会使用更通用的<strong>哈希表 (hashtable)</strong> 来存储。你不需要关心具体用哪种，Redis 会自动帮你搞定，确保高效运行。</p>
<h3 id="常用命令">常用命令</h3>
<p>掌握 Set 的常用命令，是发挥其威力的关键。下面是一些核心操作：</p>
<h4 id="基础操作">基础操作</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SADD key member [member ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：向名为 key 的集合里添加一个或多个 member。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 member 已经存在，就忽略它，确保唯一性。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 key 这个集合不存在，会自动创建一个新的。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SADD myset <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span></span></span><br><span class="line">SADD key member [member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SREM key member [member ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：从名为 key 的集合中删除一个或多个指定的 member。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SREM myset <span class="string">&quot;world&quot;</span></span></span><br><span class="line">SREM key member [member ...] </span><br></pre></td></tr></table></figure>
<h4 id="查询与判断">查询与判断</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SMEMBERS key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：获取名为 key 的集合中所有元素。注意，因为 Set 是无序的，所以元素的顺序是随机的。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SMEMBERS myset</span></span><br><span class="line">SMEMBERS key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SCARD key</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：获取名为 key 的集合中的元素个数（Cardinality）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SCARD myset</span></span><br><span class="line">SCARD key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SISMEMBER key member</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：判断 member 元素是否存在于名为 key 的集合中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存在返回 1，不存在或者 key 本身不存在则返回 0。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SISMEMBER myset <span class="string">&quot;hello&quot;</span></span></span><br><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure>
<h4 id="随机操作">随机操作</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SRANDMEMBER key [count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：从名为 key 的集合中随机选出 count 个元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 count 是正数，返回的元素不会重复；如果 count 是负数，则可能返回重复元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重要：这个操作只是<span class="string">&quot;查看&quot;</span>，并不会从集合中删除元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例（不重复）：SRANDMEMBER myset 2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例（可能重复）：SRANDMEMBER myset -3</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPOP key [count]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：从名为 key 的集合中随机移除并返回 count 个元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个操作是<span class="string">&quot;取出并删除&quot;</span>，会修改集合内容。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SPOP myset 1</span></span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure>
<h4 id="集合运算-并集、交集、差集">集合运算 (并集、交集、差集)</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SINTER key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算所有给定 key 集合的交集。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如，找出同时存在于 set1 和 set2 中的元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SINTER set1 set2</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SINTERSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算所有给定 key 集合的交集，并将结果存储到名为 destination 的新集合中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SINTERSTORE resultset set1 set2</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SUNION key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算所有给定 key 集合的并集。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如，合并 set1 和 set2 中的所有元素（重复的只保留一个）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SUNION set1 set2</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SUNIONSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算所有给定 key 集合的并集，并将结果存储到名为 destination 的新集合中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SUNIONSTORE resultset set1 set2</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SDIFF key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算第一个 key 集合与后续所有 key 集合的差集。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如，找出存在于 set1 中，但不存在于 set2 和 set3 中的元素。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SDIFF set1 set2 set3</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SDIFFSTORE destination key [key ...]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：计算第一个 key 集合与后续所有 key 集合的差集，并将结果存储到名为 destination 的新集合中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：SDIFFSTORE resultset set1 set2</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>
<h3 id="应用场景">应用场景</h3>
<p>集合的几大特性——无序、唯一、支持并交差运算——使得它在很多场景下都非常有用。</p>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、差集和并集等。当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<p>不过，这里有个小提醒：当你的 Set 里有成千上万甚至数百万个元素时，直接计算它们的交集、并集或差集可能会比较耗时，甚至可能让 Redis 短暂&quot;卡顿&quot;一下。如果你的数据量非常大，可以考虑在从数据库（如果设置了主从复制）上进行这些运算，或者把数据取到你的应用程序里再计算，避免给主数据库带来压力。</p>
<h4 id="利用-Set-元素的唯一性，轻松实现-一人一赞-：">利用 Set 元素的唯一性，轻松实现&quot;一人一赞&quot;：</h4>
<p>Set 类型可以保证一个用户只能点一个赞。假设我们用文章 ID 作为 key，点赞用户的 ID 作为 value。</p>
<p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 <code>article:1</code> 这篇文章点赞了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:1 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:2 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:2</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:3 用户对文章 article:1 点赞</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD article:1 uid:3</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>如果 <code>uid:1</code> 用户想取消点赞：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SREM article:1 uid:1</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>想看看 <code>article:1</code> 这篇文章都有谁点赞了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SMEMBERS article:1</span></span><br><span class="line">1) &quot;uid:3&quot;</span><br><span class="line">2) &quot;uid:2&quot;</span><br></pre></td></tr></table></figure>
<p>想知道 <code>article:1</code> 这篇文章有多少个赞：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SCARD article:1</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<p>判断用户 <code>uid:1</code> 是否对文章 <code>article:1</code> 点过赞：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER article:1 uid:1</span></span><br><span class="line">(integer) 0  # 返回 0 说明没点赞，返回 1 则说明点赞了</span><br></pre></td></tr></table></figure>
<h4 id="利用-Set-的交集运算，发现-我们共同的爱好-：">利用 Set 的交集运算，发现&quot;我们共同的爱好&quot;：</h4>
<p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、共同喜欢的商品、共同订阅的公众号等。</p>
<p>假设 key 是用户 ID，value 则是该用户关注的公众号 ID。</p>
<p>用户 <code>uid:1</code> 关注了公众号 <code>id:5, id:6, id:7, id:8, id:9</code>。<br>
用户 <code>uid:2</code> 关注了公众号 <code>id:7, id:8, id:9, id:10, id:11</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:1 用户关注公众号</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD uid:1 5 6 7 8 9</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uid:2  用户关注公众号</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD uid:2 7 8 9 10 11</span></span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>
<p>想知道 <code>uid:1</code> 和 <code>uid:2</code> 共同关注了哪些公众号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取共同关注</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SINTER uid:1 uid:2</span></span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;9&quot;</span><br></pre></td></tr></table></figure>
<p>想给 <code>uid:2</code> 推荐一些 <code>uid:1</code> 关注过但 <code>uid:2</code> 还没关注的公众号（差集运算）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SDIFF uid:1 uid:2</span></span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure>
<p>验证某个公众号（比如 <code>id:5</code>）是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:1 5</span></span><br><span class="line">(integer) 1 # 返回1，说明 uid:1 关注了</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SISMEMBER uid:2 5</span></span><br><span class="line">(integer) 0 # 返回0，说明 uid:2 没关注</span><br></pre></td></tr></table></figure>
<h4 id="利用-Set-的去重和随机弹出特性，打造公平的-抽奖池-：">利用 Set 的去重和随机弹出特性，打造公平的&quot;抽奖池&quot;：</h4>
<p>在抽奖活动中，我们需要存储所有参与抽奖的用户，并确保每个用户只被记录一次。Set 的去重功能完美契合这个需求。当开奖时，我们又需要从参与者中随机抽取幸运儿。</p>
<p>假设 key 为抽奖活动名 <code>lucky_draw_event</code>，value 为参与抽奖的员工姓名。先把所有员工都加入抽奖池：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SADD lucky_draw_event Tom Jerry John Sean Marry Lindy Sary Mark</span></span><br><span class="line">(integer) 8 # 假设有8名员工参与</span><br></pre></td></tr></table></figure>
<p><strong>如果允许重复中奖（比如阳光普照奖，每个人都可以是候选人，抽多次）</strong>：<br>
可以使用 <code>SRANDMEMBER</code> 命令，它只是随机&quot;看一看&quot;有哪些人，并不会把人从抽奖池里拿走。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随机抽取 1 个一等奖候选人（不从池中移除）：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky_draw_event 1</span></span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随机抽取 2 个二等奖候选人（不从池中移除）：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky_draw_event 2</span></span><br><span class="line">1) &quot;Mark&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随机抽取 3 个三等奖候选人（不从池中移除）：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SRANDMEMBER lucky_draw_event 3</span></span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>
<p><strong>如果不允许重复中奖（比如一、二、三等奖，中过就不能再中了）</strong>：<br>
可以使用 <code>SPOP</code> 命令，它会随机&quot;拿走&quot;一个或多个中奖者，确保他们不会再次中奖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取一等奖1名（从池中移除）：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky_draw_event 1</span></span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时 Sary 已经不在抽奖池里了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取二等奖2名（从池中移除）：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky_draw_event 2</span></span><br><span class="line">1) &quot;Jerry&quot;</span><br><span class="line">2) &quot;Mark&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Jerry 和 Mark 也被移除了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抽取三等奖3名（从池中移除）：</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SPOP lucky_draw_event 3</span></span><br><span class="line">1) &quot;John&quot;</span><br><span class="line">2) &quot;Sean&quot;</span><br><span class="line">3) &quot;Lindy&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">奖项抽取完毕！</span></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>总而言之，Redis 的 Set 类型凭借其无序、唯一以及丰富的集合运算能力，在需要数据去重、关系查找、以及一些特定业务场景（如点赞、共同关注、抽奖）下，都是一个简洁高效的选择。理解了它的特性和适用场景，你就能在开发中更好地利用它来解决实际问题。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据类型</tag>
        <tag>Set</tag>
        <tag>集合</tag>
        <tag>去重</tag>
        <tag>抽奖</tag>
        <tag>点赞</tag>
        <tag>共同关注</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据类型：Hash详解</title>
    <url>/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Hash/</url>
    <content><![CDATA[<h2 id="一、Hash-类型简介">一、Hash 类型简介</h2>
<p>Redis 中的 Hash 类型是一个键值对（key-value pair）集合，其特殊之处在于它的值（value）本身也是一个键值对的集合，形式如：<code>value=[&#123;field1, value1&#125;, &#123;field2, value2&#125;, ..., &#123;fieldN, valueN&#125;]</code>。这种结构使得 Hash 类型非常适合用来存储对象及其属性。</p>
<p>与直接将对象序列化为 JSON 字符串后存入 String 类型相比，Hash 类型允许对对象中的单个字段进行独立的读写操作，而无需读取和反序列化整个对象，这在某些场景下可以提供更高的效率和灵活性。</p>
<p>下图展示了 Hash 与 String 对象在存储对象时的概念性区别：</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Hash/1746889180207.png" alt="Redis Hash vs String 存储对象"><br>
<em>图1: Redis Hash 与 String 存储对象对比</em></p>
<h2 id="二、内部实现">二、内部实现</h2>
<p>Hash 类型的底层数据结构主要依赖于两种实现方式：<strong>压缩列表（ziplist）/ listpack</strong> 和 <strong>哈希表（hashtable）</strong>。Redis 会根据存储的数据规模动态选择：</p>
<ol>
<li>
<p><strong>压缩列表 (ziplist) / listpack</strong>:</p>
<ul>
<li>当哈希对象中包含的键值对数量较少，并且所有键（field）和值（value）的字符串长度都较短时，Redis 会采用压缩列表（ziplist）来存储 Hash。</li>
<li>具体阈值由以下两个配置参数决定：
<ul>
<li><code>hash-max-ziplist-entries</code>：哈希对象包含的键值对数量上限（默认值为 <code>512</code>）。</li>
<li><code>hash-max-ziplist-value</code>：哈希对象中每个值（value）的字节长度上限（默认值为 <code>64</code> 字节）。</li>
</ul>
</li>
<li><strong>重要演进</strong>：在 Redis 7.0 及更高版本中，<code>ziplist</code> 已被更优化的 <code>listpack</code> 数据结构所取代。<code>listpack</code> 解决了 <code>ziplist</code> 在更新操作时可能引发连锁更新（cascade update）的问题，提高了性能和空间效率。因此，在现代 Redis 版本中，当满足上述条件时，底层使用的是 <code>listpack</code>。</li>
</ul>
</li>
<li>
<p><strong>哈希表 (hashtable)</strong>:</p>
<ul>
<li>如果哈希对象中的键值对数量超过 <code>hash-max-ziplist-entries</code>，或者任一键或值的长度超过 <code>hash-max-ziplist-value</code>，Redis 则会自动将底层数据结构转换为哈希表（也称为字典，dict）。</li>
<li>哈希表通过链式哈希解决冲突，并在负载因子达到一定阈值时进行动态扩容（rehash），以保证查询效率。</li>
</ul>
</li>
</ol>
<p>这种动态切换底层数据结构的设计，旨在平衡内存使用和操作效率。对于小型 Hash 对象，<code>listpack</code>（或早期的 <code>ziplist</code>）能有效节省内存；而对于大型 Hash 对象，哈希表则能提供更高效的查找、插入和删除操作。</p>
<h2 id="三、常用命令">三、常用命令</h2>
<p>以下是 Redis Hash 类型的一些常用操作命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置单个 field 的值</span></span><br><span class="line">HSET key field value</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取单个 field 的值</span></span><br><span class="line">HGET key field</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次性设置多个 field 的值</span></span><br><span class="line">HMSET key field1 value1 [field2 value2 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一次性获取多个 field 的值</span></span><br><span class="line">HMGET key field1 [field2 value2 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个或多个 field</span></span><br><span class="line">HDEL key field1 [field2 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表中 field 的数量</span></span><br><span class="line">HLEN key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表中所有的 field 和 value</span></span><br><span class="line">HGETALL key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表中所有的 field</span></span><br><span class="line">HKEYS key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表中所有的 value</span></span><br><span class="line">HVALS key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断哈希表中指定 field 是否存在</span></span><br><span class="line">HEXISTS key field</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为哈希表 key 中指定 field 的整数值加上增量 increment</span></span><br><span class="line">HINCRBY key field increment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为哈希表 key 中指定 field 的浮点数值加上增量 increment</span></span><br><span class="line">HINCRBYFLOAT key field increment</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取哈希表中指定 field 的字符串长度</span></span><br><span class="line">HSTRLEN key field</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>:</p>
<ul>
<li><code>HMSET</code> 在较新版本的 Redis 中已被 <code>HSET</code> 取代（<code>HSET</code> 现在可以一次设置多个字段）。但为了兼容性，<code>HMSET</code> 仍然可用。</li>
<li><code>HGETALL</code> 命令在哈希对象很大时可能会阻塞 Redis 服务器，因为它需要遍历整个哈希表。对于大型哈希，应谨慎使用，或考虑使用 <code>HSCAN</code> 命令进行分批迭代。</li>
</ul>
<h2 id="四、应用场景">四、应用场景</h2>
<p>Hash 类型因其结构特性，在多种场景下都有广泛应用。</p>
<h3 id="1-缓存对象信息">1. 缓存对象信息</h3>
<p>Hash 类型的 <code>(key, field, value)</code> 结构与程序中对象的 <code>(对象标识, 属性名, 属性值)</code> 结构天然对应，因此非常适合用来缓存对象信息。</p>
<p>例如，一个用户信息对象在关系型数据库中的结构可能如下：</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Hash/1746889227698.png" alt="用户信息表结构"><br>
<em>图2: 用户信息表结构示例</em></p>
<p>我们可以使用 Hash 类型来存储这些用户信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储用户ID为1的信息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HSET user:1 name <span class="string">&quot;Tom&quot;</span> age 25 email <span class="string">&quot;tom@example.com&quot;</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储用户ID为2的信息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HSET user:2 name <span class="string">&quot;Jerry&quot;</span> age 22 city <span class="string">&quot;New York&quot;</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取用户ID为1的所有信息</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HGETALL user:1</span></span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">5) &quot;email&quot;</span><br><span class="line">6) &quot;tom@example.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取用户ID为2的姓名和城市</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HMGET user:2 name city</span></span><br><span class="line">1) &quot;Jerry&quot;</span><br><span class="line">2) &quot;New York&quot;</span><br></pre></td></tr></table></figure>
<p>Redis Hash 存储其结构如下图所示：</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Hash/1746889237339.png" alt="Redis Hash 存储对象结构"><br>
<em>图3: Redis Hash 存储对象结构示例</em></p>
<p><strong>与 String + JSON 对比</strong>:</p>
<p>虽然将对象序列化为 JSON 字符串后存储在 String 类型中也是一种常见的缓存对象的方式，但 Hash 类型在以下方面具有优势：</p>
<ul>
<li><strong>部分更新</strong>: 如果只需要修改对象的某个属性，使用 Hash 可以直接通过 <code>HSET</code> 更新该字段，而无需读取、反序列化、修改再序列化、写回整个 JSON 对象。</li>
<li><strong>字段级原子操作</strong>: Hash 提供了如 <code>HINCRBY</code> 这样的原子操作，可以直接对对象属性进行原子增减。</li>
<li><strong>可读性</strong>: 直接存储字段名和值，在 Redis 客户端中查看数据时可能更直观。</li>
</ul>
<p><strong>选择策略</strong>:</p>
<ul>
<li>对于需要频繁更新对象部分属性，或者需要对属性进行原子操作的场景，Hash 类型是更好的选择。</li>
<li>如果对象属性不常变动，或者总是需要整体读写对象，String + JSON 的方式可能更简单，序列化/反序列化的开销在某些情况下也可以接受。</li>
<li>一种混合策略是：将对象的主要、不常变动的属性用 String + JSON 存储，而将频繁变动或需要原子操作的属性（如计数器）单独用 Hash 存储，或者存储在同一个 Hash 的不同字段中。</li>
</ul>
<h3 id="2-购物车实现">2. 购物车实现</h3>
<p>购物车功能是 Hash 类型的另一个经典应用场景。我们可以将用户 ID 作为 key，商品 ID 作为 field，商品数量作为 value。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Hash/1746889245275.png" alt="购物车使用 Hash 存储"><br>
<em>图4: 购物车使用 Hash 存储示例</em></p>
<p>购物车相关操作命令示例：</p>
<ul>
<li><strong>添加商品到购物车/增加商品数量</strong>:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果商品已存在，则数量加1；如果不存在，则添加商品，数量为1</span></span><br><span class="line">HINCRBY cart:user123 product:1001 1</span><br></pre></td></tr></table></figure>
</li>
<li><strong>减少商品数量</strong>:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数量减1。如果减到0或以下，可能需要后续逻辑HDEL删除该商品</span></span><br><span class="line">HINCRBY cart:user123 product:1001 -1</span><br></pre></td></tr></table></figure>
</li>
<li><strong>直接设置商品数量</strong>:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HSET cart:user123 product:1002 5</span><br></pre></td></tr></table></figure>
</li>
<li><strong>获取购物车中商品总数（种类数）</strong>:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HLEN cart:user123</span><br></pre></td></tr></table></figure>
</li>
<li><strong>删除购物车中指定商品</strong>:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HDEL cart:user123 product:1001</span><br></pre></td></tr></table></figure>
</li>
<li><strong>获取购物车中所有商品及其数量</strong>:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HGETALL cart:user123</span><br></pre></td></tr></table></figure>
</li>
<li><strong>清空购物车</strong>:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEL cart:user123</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>:<br>
这种方式只在 Redis 中存储了商品 ID 和数量。在向用户展示购物车时，通常还需要根据商品 ID 从数据库或其他服务查询商品的详细信息（如名称、价格、图片等）。</p>
<h2 id="五、总结">五、总结</h2>
<p>Redis 的 Hash 类型提供了一种高效存储和操作结构化数据的方式，特别适合表示对象。其底层的 <code>listpack</code> (或 <code>ziplist</code>) 和哈希表动态转换机制，使其在不同数据规模下都能保持较好的性能和内存效率。理解其内部实现和常用命令，有助于在实际应用中更好地利用 Hash 类型解决问题，如对象缓存、购物车管理等。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>缓存</tag>
        <tag>Redis</tag>
        <tag>Hash</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 169 - 多数元素（Majority Element）</title>
    <url>/2025/05/10/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个大小为 n 的数组 nums，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5 * 10^4</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li>题目数据保证 <code>nums</code> 中存在多数元素</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>针对多数元素问题，我们有多种解决方案。下面我们将详细介绍四种常用的解法：</p>
<h3 id="方法一：哈希表计数法">方法一：哈希表计数法</h3>
<p><strong>核心思想</strong>：使用哈希表记录每个元素出现的次数，找出出现次数大于 n/2 的元素。</p>
<p>这是一种直观的解法，通过两次遍历实现：</p>
<ol>
<li>第一次遍历：统计每个元素的出现次数</li>
<li>第二次遍历：找出出现次数大于 n/2 的元素</li>
</ol>
<h3 id="方法二：排序法">方法二：排序法</h3>
<p><strong>核心思想</strong>：如果将数组排序，由于多数元素出现次数大于 n/2，所以排序后中间位置的元素一定是多数元素。</p>
<p>这是一种简单但效率不高的解法：</p>
<ol>
<li>对数组进行排序</li>
<li>返回中间位置的元素（下标为 n/2）</li>
</ol>
<h3 id="方法三：分治法">方法三：分治法</h3>
<p><strong>核心思想</strong>：将数组分为左右两部分，分别找出左右两部分的多数元素，然后确定整个数组的多数元素。</p>
<p>分治法的具体步骤：</p>
<ol>
<li>将数组分成左右两部分</li>
<li>递归地找出左半部分和右半部分的多数元素</li>
<li>比较这两个多数元素在整个数组中的出现次数，返回出现次数较多的那个</li>
</ol>
<h3 id="方法四：摩尔投票法">方法四：摩尔投票法</h3>
<p><strong>核心思想</strong>：利用&quot;不同元素相互抵消&quot;的思想，找出最终留下的元素。</p>
<p>想象一下有两支军队在打仗：</p>
<ul>
<li>红军（代表多数元素）</li>
<li>蓝军（代表所有其他元素）</li>
</ul>
<p>由于多数元素出现次数超过总数的一半，所以红军人数必然多于蓝军。即使红蓝双方一对一厮杀（相互抵消），最后战场上剩下的一定是红军！</p>
<p>这就是摩尔投票算法的核心思想：<strong>不同的数字相互抵消，最后剩下的一定是出现次数最多的那个数字</strong>。</p>
<h4 id="算法步骤（超简单版）">算法步骤（超简单版）</h4>
<ol>
<li>找一个&quot;候选人&quot;，先认为第一个数字是候选人</li>
<li>开始计数：遇到和候选人一样的数字就+1，遇到不一样的就-1</li>
<li>如果计数变成0了，就换一个候选人（选当前遇到的那个数字）</li>
<li>继续上面的过程直到结束</li>
<li>最后的候选人就是我们要找的多数元素</li>
</ol>
<h2 id="实现细节与代码">实现细节与代码</h2>
<h3 id="方法一：哈希表计数法-2">方法一：哈希表计数法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表，用于统计每个元素出现的次数</span></span><br><span class="line">    countMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        countMap[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出出现次数大于 n/2 的元素</span></span><br><span class="line">    threshold := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> num, count := <span class="keyword">range</span> countMap &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt; threshold &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为题目保证有多数元素，所以不会走到这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例演示</strong>：以 <code>[2,2,1,1,1,2,2]</code> 为例</p>
<ol>
<li>初始化 <code>countMap = &#123;&#125;</code></li>
<li>遍历数组并统计：
<ul>
<li>遇到 2：<code>countMap[2] = 1</code></li>
<li>遇到 2：<code>countMap[2] = 2</code></li>
<li>遇到 1：<code>countMap[1] = 1</code></li>
<li>遇到 1：<code>countMap[1] = 2</code></li>
<li>遇到 1：<code>countMap[1] = 3</code></li>
<li>遇到 2：<code>countMap[2] = 3</code></li>
<li>遇到 2：<code>countMap[2] = 4</code></li>
</ul>
</li>
<li>最终 <code>countMap = &#123;1: 3, 2: 4&#125;</code>，阈值 <code>threshold = 7/2 = 3</code></li>
<li>检查 <code>countMap</code> 中元素，发现 2 的出现次数为 4，大于阈值 3</li>
<li>返回 2 作为多数元素</li>
</ol>
<h3 id="方法二：排序法-2">方法二：排序法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 对数组进行排序</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回中间位置的元素</span></span><br><span class="line">    <span class="comment">// 由于多数元素出现次数大于 n/2，排序后中间位置一定是多数元素</span></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例演示</strong>：以 <code>[2,2,1,1,1,2,2]</code> 为例</p>
<ol>
<li>排序后数组变为 <code>[1,1,1,2,2,2,2]</code></li>
<li>中间位置是 <code>7/2 = 3</code>，对应的元素是 <code>nums[3] = 2</code></li>
<li>返回 2 作为多数元素</li>
</ol>
<h3 id="方法三：分治法-2">方法三：分治法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> majorityElementRec(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElementRec</span><span class="params">(nums []<span class="type">int</span>, lo, hi <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 基本情况：只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> lo == hi &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[lo]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将数组分成两半</span></span><br><span class="line">    mid := lo + (hi - lo)/<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分别找出左右两部分的多数元素</span></span><br><span class="line">    left := majorityElementRec(nums, lo, mid)</span><br><span class="line">    right := majorityElementRec(nums, mid+<span class="number">1</span>, hi)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左右两部分的多数元素相同，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> left == right &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算左右两部分多数元素在整个区间内的出现次数</span></span><br><span class="line">    leftCount := countInRange(nums, left, lo, hi)</span><br><span class="line">    rightCount := countInRange(nums, right, lo, hi)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回出现次数较多的元素</span></span><br><span class="line">    <span class="keyword">if</span> leftCount &gt; rightCount &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countInRange</span><span class="params">(nums []<span class="type">int</span>, num, lo, hi <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := lo; i &lt;= hi; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == num &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例演示</strong>：对于复杂的分治算法，我们以一个简化的例子 <code>[2,2,1,1,1,2,2]</code> 展示部分步骤：</p>
<ol>
<li>将数组分为两部分：<code>[2,2,1]</code> 和 <code>[1,1,2,2]</code></li>
<li>递归地处理左半部分：进一步分为 <code>[2]</code> 和 <code>[2,1]</code>，最终得到左半部分的多数元素 2</li>
<li>递归地处理右半部分：进一步分为 <code>[1,1]</code> 和 <code>[2,2]</code>，最终得到右半部分的多数元素没有（因为 1 和 2 的出现次数相同）</li>
<li>比较左右两部分的多数元素在整个数组中的出现次数：2 出现了 4 次，1 出现了 3 次</li>
<li>返回 2 作为整个数组的多数元素</li>
</ol>
<h3 id="方法四：摩尔投票法-2">方法四：摩尔投票法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 选第一个数字作为候选人</span></span><br><span class="line">    candidate := nums[<span class="number">0</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 候选人的初始票数为1</span></span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从第二个数字开始统计</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 如果当前票数为0，换新候选人</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            candidate = nums[i]</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] == candidate &#123;</span><br><span class="line">            <span class="comment">// 如果遇到和候选人一样的数字，票数+1</span></span><br><span class="line">            count++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果遇到和候选人不一样的数字，票数-1</span></span><br><span class="line">            count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后剩下的候选人就是多数元素</span></span><br><span class="line">    <span class="keyword">return</span> candidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例演示</strong>：让我们用数组 <code>[2,2,1,1,1,2,2]</code> 来一步步看看上面的算法是怎么工作的：</p>
<ol>
<li>初始状态：
<ul>
<li>候选人 = 2（第一个元素）</li>
<li>票数 = 1</li>
</ul>
</li>
<li>遍历第2个元素（也是2）：
<ul>
<li>发现和候选人相同</li>
<li>票数 +1 = 2</li>
</ul>
</li>
<li>遍历第3个元素（是1）：
<ul>
<li>发现和候选人不同</li>
<li>票数 -1 = 1</li>
</ul>
</li>
<li>遍历第4个元素（是1）：
<ul>
<li>发现和候选人不同</li>
<li>票数 -1 = 0</li>
</ul>
</li>
<li>遍历第5个元素（是1）：
<ul>
<li>票数为0，所以换新候选人</li>
<li>候选人 = 1</li>
<li>票数 = 1</li>
</ul>
</li>
<li>遍历第6个元素（是2）：
<ul>
<li>发现和候选人不同</li>
<li>票数 -1 = 0</li>
</ul>
</li>
<li>遍历第7个元素（是2）：
<ul>
<li>票数为0，所以换新候选人</li>
<li>候选人 = 2</li>
<li>票数 = 1</li>
</ul>
</li>
<li>遍历结束，最终候选人是2，这就是我们要的答案！</li>
</ol>
<p>用表格表示更清晰：</p>
<table>
<thead>
<tr>
<th>当前位置</th>
<th>当前数字</th>
<th>候选人</th>
<th>票数</th>
<th>操作说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>开始</td>
<td>-</td>
<td>2</td>
<td>1</td>
<td>初始状态，选第一个数为候选人</td>
</tr>
<tr>
<td>位置1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>遇到相同数字，票数+1</td>
</tr>
<tr>
<td>位置2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>遇到不同数字，票数-1</td>
</tr>
<tr>
<td>位置3</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>遇到不同数字，票数-1</td>
</tr>
<tr>
<td>位置4</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>票数变为0，换新候选人</td>
</tr>
<tr>
<td>位置5</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>遇到不同数字，票数-1</td>
</tr>
<tr>
<td>位置6</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>票数变为0，换新候选人</td>
</tr>
</tbody>
</table>
<p><strong>为什么这个算法有效？</strong></p>
<p>因为多数元素出现次数超过了数组长度的一半，所以即使它和其他所有元素一一&quot;对抗&quot;（相互抵消），最后剩下的也必定是它。</p>
<p>就像两支军队打仗：</p>
<ul>
<li>红军（多数元素）有100人</li>
<li>蓝军（其他所有元素）合起来最多只有99人</li>
<li>即使红蓝双方一对一厮杀，最终也会剩下至少1个红军</li>
</ul>
<p>无论如何变换候选人，最终留下的一定是出现次数最多的那个元素。这就是摩尔投票算法的巧妙之处！</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>哈希表计数法</th>
<th>排序法</th>
<th>分治法</th>
<th>摩尔投票法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(1) 或 O(n)</td>
<td>O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>直观易懂</td>
<td>实现简单</td>
<td>可以扩展到其他问题</td>
<td>最高效</td>
</tr>
<tr>
<td>缺点</td>
<td>需要额外空间</td>
<td>速度较慢</td>
<td>实现复杂</td>
<td>不直观</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★☆</td>
<td>★★★☆☆</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="哈希表计数法">哈希表计数法</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，需要遍历数组两次</li>
<li><strong>空间复杂度</strong>：$O(n)$，最坏情况下哈希表需要存储 $n/2+1$ 个不同的元素</li>
</ul>
<h3 id="排序法">排序法</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$，主要是排序的时间复杂度</li>
<li><strong>空间复杂度</strong>：$O(1)$ 或 $O(n)$，取决于使用的排序算法（原地排序或非原地排序）</li>
</ul>
<h3 id="分治法">分治法</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$<br>
递归树的深度为 $\log n$，每层的总操作次数为 $O(n)$，因此总时间复杂度为 $O(n \log n)$</li>
<li><strong>空间复杂度</strong>：$O(\log n)$，递归调用栈的深度</li>
</ul>
<h3 id="摩尔投票法">摩尔投票法</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，只需要遍历数组一次</li>
<li><strong>空间复杂度</strong>：$O(1)$，只使用了常数个变量</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>多角度解决问题</strong>：同一个问题可以有多种解法，每种解法都有其优缺点</p>
</li>
<li>
<p><strong>算法效率的权衡</strong>：</p>
<ul>
<li>哈希表方法直观但需要额外空间</li>
<li>排序方法简单但效率不高</li>
<li>分治法思想优雅但实现复杂</li>
<li>摩尔投票法高效但不够直观</li>
</ul>
</li>
<li>
<p><strong>摩尔投票算法的巧妙之处</strong>：</p>
<ul>
<li>利用&quot;不同元素相互抵消&quot;的思想解决问题</li>
<li>不需要额外空间，一次遍历即可得到结果</li>
<li>是解决&quot;多数元素&quot;问题的最佳算法</li>
</ul>
</li>
<li>
<p><strong>问题的扩展思考</strong>：</p>
<ul>
<li>如果不保证存在多数元素，需要增加验证步骤</li>
<li>可以扩展到寻找出现次数大于 n/3 的元素（LeetCode 229）</li>
<li>可以用于解决其他计数相关的问题</li>
</ul>
</li>
</ol>
<h2 id="相关题目">相关题目</h2>
<ul>
<li>LeetCode 229: 求众数 II（找出所有出现次数超过 n/3 的元素）</li>
<li>LeetCode 1150: 检查一个数是否在数组中占绝大多数</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>分治</tag>
        <tag>摩尔投票</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 136 - 只出现一次的数字（Single Number）</title>
    <url>/2025/05/10/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现一次的元素。</p>
<p><strong>说明</strong>：你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h3 id="约束条件：">约束条件：</h3>
<ul>
<li>1 &lt;= nums.length &lt;= 3 * 10^4</li>
<li>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</li>
<li>除了某个元素只出现一次外，其余每个元素均出现两次</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题可以有多种解法，我们将介绍三种不同的解决方案，从简单到高级，最后重点讲解使用异或运算的解法。</p>
<h3 id="方法一：哈希表计数法">方法一：哈希表计数法</h3>
<p><strong>核心思想</strong>：使用哈希表记录每个数字出现的次数，然后找出只出现一次的数字。</p>
<h4 id="实现步骤">实现步骤</h4>
<ol>
<li>创建一个哈希表 <code>map</code>，用于存储数组中每个元素出现的次数</li>
<li>遍历数组，对每个元素进行计数</li>
<li>再次遍历哈希表，找出出现次数为 1 的元素</li>
</ol>
<h3 id="方法二：排序法">方法二：排序法</h3>
<p><strong>核心思想</strong>：先对数组进行排序，然后比较相邻元素，找出只出现一次的数字。</p>
<h4 id="实现步骤-2">实现步骤</h4>
<ol>
<li>对数组进行排序</li>
<li>从头到尾遍历排序后的数组</li>
<li>由于除了一个元素外，其他元素都出现两次，所以相同的元素必然相邻</li>
<li>比较相邻元素，找出不成对的元素</li>
</ol>
<h3 id="方法三：异或运算法（最优解）">方法三：异或运算法（最优解）</h3>
<p><strong>核心思想</strong>：利用异或运算的特性，对数组中所有元素进行异或运算，最终结果就是只出现一次的元素。</p>
<p><strong>异或运算的关键特性</strong>：</p>
<ul>
<li>任何数字与 0 异或等于它自己：<code>a ⊕ 0 = a</code></li>
<li>任何数字与自己异或等于 0：<code>a ⊕ a = 0</code></li>
<li>异或运算满足交换律和结合律：<code>a ⊕ b = b ⊕ a</code> 和 <code>(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)</code></li>
</ul>
<h4 id="实现步骤-3">实现步骤</h4>
<ol>
<li>初始化结果变量 <code>res = 0</code></li>
<li>遍历数组中的每个元素，将其与 <code>res</code> 进行异或运算</li>
<li>最终 <code>res</code> 的值就是只出现一次的元素</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>让我们更详细地解释这三种方法的具体实现：</p>
<h3 id="哈希表计数法详解">哈希表计数法详解</h3>
<p>这是最直观的解法。我们使用一个哈希表来记录每个元素出现的次数：</p>
<ol>
<li>遍历数组，将每个元素作为键，出现次数作为值存入哈希表</li>
<li>再次遍历哈希表，找到值为 1 的键，即为答案</li>
</ol>
<p>这种方法的优点是直观易懂，适合初学者理解。缺点是需要额外的 O(n) 空间复杂度，不满足题目要求的&quot;不使用额外空间&quot;。</p>
<h3 id="排序法详解">排序法详解</h3>
<p>排序后，相同的元素会相邻，我们可以利用这个特性：</p>
<ol>
<li>对数组进行排序</li>
<li>从头到尾遍历排序后的数组，每次跳过两个元素</li>
<li>如果相邻元素不相等，那么这就是我们要找的元素</li>
</ol>
<p>但这种方法的时间复杂度为 O(n log n)，不满足要求的线性时间复杂度。</p>
<h3 id="异或运算法详解（重点）">异或运算法详解（重点）</h3>
<p><strong>为什么异或运算可以解决这个问题？</strong></p>
<p>让我们先简单介绍异或运算：</p>
<p>异或运算（XOR）是一种位运算，用符号 <code>⊕</code> 或 <code>^</code> 表示。它有一个很重要的特性：当两个相同的数进行异或时，结果为 0；而任何数与 0 异或，结果仍为它本身。</p>
<p>用真值表表示：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A ⊕ B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>生活中的例子：可以把异或运算想象成&quot;开关&quot;，每次操作会改变开关状态。如果开关初始为关闭（0），第一次按下会打开（1），第二次再按则会关闭（0）。这就像异或的特性：任何数字出现偶数次会抵消为 0。</p>
<p><strong>重要特性总结</strong>：</p>
<ol>
<li><code>a ⊕ 0 = a</code>：任何数与 0 异或仍为它本身</li>
<li><code>a ⊕ a = 0</code>：任何数与自身异或等于 0</li>
<li><code>a ⊕ b ⊕ a = b</code>：由上面两条推导出的性质</li>
</ol>
<p><strong>为什么这个问题可以用异或解决？</strong></p>
<p>在我们的问题中：</p>
<ul>
<li>数组中有一个元素出现一次，其余元素都出现两次</li>
<li>将所有元素进行异或运算，出现两次的元素会互相抵消（结果为 0）</li>
<li>0 与只出现一次的元素异或，结果就是该元素</li>
</ul>
<p><strong>图解过程</strong>：</p>
<p>以输入 <code>[4,1,2,1,2]</code> 为例：</p>
<ol>
<li>初始 <code>res = 0</code></li>
<li><code>res = 0 ⊕ 4 = 4</code></li>
<li><code>res = 4 ⊕ 1 = 5</code></li>
<li><code>res = 5 ⊕ 2 = 7</code></li>
<li><code>res = 7 ⊕ 1 = 6</code> (因为 <code>1</code> 出现两次，所以 <code>1 ⊕ 1 = 0</code>，这一步相当于 <code>7 ⊕ 0 = 7</code>）</li>
<li><code>res = 6 ⊕ 2 = 4</code> (因为 <code>2</code> 出现两次，所以 <code>2 ⊕ 2 = 0</code>，这一步相当于 <code>6 ⊕ 0 = 6</code>）</li>
</ol>
<p>最终 <code>res = 4</code>，这就是只出现一次的元素。</p>
<p><strong>另一种理解方式</strong>：</p>
<p>将上面的步骤重新组织，利用异或的交换律和结合律：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = 0 ⊕ 4 ⊕ 1 ⊕ 2 ⊕ 1 ⊕ 2</span><br><span class="line">    = 0 ⊕ 4 ⊕ (1 ⊕ 1) ⊕ (2 ⊕ 2)</span><br><span class="line">    = 0 ⊕ 4 ⊕ 0 ⊕ 0</span><br><span class="line">    = 4</span><br></pre></td></tr></table></figure>
<p>这样更直观地看出，相同的元素通过异或运算会抵消为 0，最终只留下出现一次的元素。</p>
<h2 id="代码实现">代码实现</h2>
<p>下面是三种解法的 Go 语言实现：</p>
<h3 id="方法一：哈希表计数法-2">方法一：哈希表计数法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建哈希表</span></span><br><span class="line">    countMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        countMap[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出只出现一次的元素</span></span><br><span class="line">    <span class="keyword">for</span> num, count := <span class="keyword">range</span> countMap &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 这行理论上不会执行，因为题目保证有一个元素仅出现一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：排序法-2">方法二：排序法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 对数组进行排序</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特殊情况处理：如果数组长度为1，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理第一个元素可能是单个的情况</span></span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">0</span>] != nums[<span class="number">1</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理中间元素</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[i+<span class="number">1</span>] &amp;&amp; i+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i+<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理最后一个元素可能是单个的情况</span></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：异或运算法（最优解）-2">方法三：异或运算法（最优解）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        res ^= num</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是题目中展示的解法，简洁而高效。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一：哈希表计数法</th>
<th>方法二：排序法</th>
<th>方法三：异或运算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(1) 或 O(log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>直观易懂</td>
<td>思路简单</td>
<td>最优解，符合题目所有要求</td>
</tr>
<tr>
<td>缺点</td>
<td>需要额外空间</td>
<td>时间复杂度较高</td>
<td>需要理解异或运算原理</td>
</tr>
<tr>
<td>适用场景</td>
<td>通用场景，元素出现任意次</td>
<td>通用场景，元素出现任意次</td>
<td>特定场景，元素出现偶数次</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="方法一：哈希表计数法-3">方法一：哈希表计数法</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n)，需要遍历数组一次，然后遍历哈希表一次</li>
<li><strong>空间复杂度</strong>：O(n)，需要额外的哈希表存储每个元素的出现次数</li>
</ul>
<h3 id="方法二：排序法-3">方法二：排序法</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n log n)，排序的时间复杂度</li>
<li><strong>空间复杂度</strong>：O(1) 或 O(log n)，取决于排序算法的实现</li>
</ul>
<h3 id="方法三：异或运算法">方法三：异或运算法</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n)，只需要遍历数组一次</li>
<li><strong>空间复杂度</strong>：O(1)，只需要一个变量存储结果</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>异或运算的独特作用</strong>：异或运算在处理&quot;出现偶数次&quot;的元素时具有特殊优势，可以实现&quot;自动抵消&quot;的效果。</p>
</li>
<li>
<p><strong>限制条件的重要性</strong>：这种解法之所以有效，是因为题目保证了除了一个元素外，其他元素都出现<strong>两次</strong>（偶数次）。如果元素出现<strong>奇数次</strong>，异或运算就不适用了。</p>
</li>
<li>
<p><strong>空间复杂度优化</strong>：有时候，利用问题的特殊性质可以大幅降低空间复杂度，异或运算法就是一个很好的例子。</p>
</li>
<li>
<p><strong>位运算的强大</strong>：位运算通常可以带来更高效的解法，特别是在处理数字相关问题时。</p>
</li>
<li>
<p><strong>适用场景的拓展</strong>：异或运算法不仅适用于元素出现两次的情况，只要其他元素都出现<strong>偶数次</strong>，这种方法都是有效的。</p>
</li>
<li>
<p><strong>特殊情况的处理</strong>：需要注意的是，这种方法只能找出唯一一个出现奇数次的元素。如果有多个元素出现奇数次，就需要其他方法。</p>
</li>
</ol>
<p><strong>总结</strong>：异或运算法提供了一种巧妙的方式来解决&quot;只出现一次的数字&quot;问题，它利用位操作的特性，实现了线性时间复杂度和常数空间复杂度，是一种非常优雅的解决方案。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>哈希</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis知识点: List列表</title>
    <url>/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/List/</url>
    <content><![CDATA[<h2 id="List">List</h2>
<h3 id="介绍">介绍</h3>
<p>List 列表是 Redis 中的基础数据类型之一，它是一个简单的字符串列表，<strong>按照插入顺序排序</strong>。List 的特点是支持双向操作，可以从头部（左侧）或尾部（右侧）向列表添加或移除元素。</p>
<p>列表的最大长度为 $2^32 - 1$（即 4,294,967,295），也就是每个列表最多可以存储超过 <strong>40 亿</strong>个元素，足以满足绝大多数应用场景的需求。</p>
<p>List 类型具有以下主要特性：</p>
<ul>
<li>有序性：元素按照插入顺序排列</li>
<li>可重复性：同一个元素可以多次出现在列表中</li>
<li>双向操作：支持从两端进行插入和弹出操作</li>
<li>阻塞操作：支持阻塞式的弹出操作，适合实现队列</li>
</ul>
<h3 id="内部实现">内部实现</h3>
<p>List 类型的底层数据结构经历了多次演进：</p>
<ul>
<li>
<p>在 Redis 3.2 版本之前，List 由<strong>双向链表或压缩列表</strong>实现：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用**压缩列表（ziplist）**作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用**双向链表（linkedlist）**作为 List 类型的底层数据结构；</li>
</ul>
</li>
<li>
<p><strong>在 Redis 3.2 版本及之后，List 数据类型底层数据结构统一由 quicklist 实现</strong>，替代了之前的双向链表和压缩列表。</p>
</li>
</ul>
<p><strong>quicklist</strong> 是一个双向链表，但它的每个节点都是一个压缩列表。这种设计结合了双向链表和压缩列表的优点：既保留了链表的灵活性（便于在两端进行操作），又利用了压缩列表的空间效率优势。通过将多个元素存储在一个压缩列表中，quicklist 减少了链表节点的数量和内存碎片。</p>
<h3 id="常用命令">常用命令</h3>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/List/1746872332385.png" alt="1746872332385"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span></span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个或多个值value插入到key列表的表尾(最右边)</span></span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的头元素</span></span><br><span class="line">LPOP key   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除并返回key列表的尾元素</span></span><br><span class="line">RPOP key </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span></span><br><span class="line">LRANGE key start stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表头弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从key列表表尾弹出一个元素，没有就阻塞<span class="built_in">timeout</span>秒，如果<span class="built_in">timeout</span>=0则一直阻塞</span></span><br><span class="line">BRPOP key [key ...] timeout</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回列表的长度</span></span><br><span class="line">LLEN key</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过索引获取列表中的元素</span></span><br><span class="line">LINDEX key index</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在列表的元素前或者后插入元素</span></span><br><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将列表 <span class="built_in">source</span> 中的最后一个元素弹出并返回，然后将该元素插入到列表 destination 的头部</span></span><br><span class="line">RPOPLPUSH source destination</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RPOPLPUSH的阻塞版本</span></span><br><span class="line">BRPOPLPUSH source destination timeout</span><br></pre></td></tr></table></figure>
<h3 id="应用场景">应用场景</h3>
<h4 id="消息队列">消息队列</h4>
<p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p>
<p>Redis 的 List 和 Stream 两种数据类型，都可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法。</p>
<p><em>1、如何满足消息保序需求？</em></p>
<p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p>
<p>List 可以使用 LPUSH + RPOP（或者反过来，RPUSH+LPOP）命令实现消息队列。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/List/1746872357038.png" alt="1746872357038"></p>
<ul>
<li>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</li>
<li>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</li>
</ul>
<p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p>
<p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个 while(1) 循环）。如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令返回空值，再继续循环。</p>
<p>所以，即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p>
<p>为了解决这个问题，Redis 提供了 BRPOP 命令。<strong>BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/List/1746872365846.png" alt="1746872365846"></p>
<p><em>2、如何处理重复的消息？</em></p>
<p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p>
<ul>
<li>每个消息都有一个全局的 ID。</li>
<li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li>
</ul>
<p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一 ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p>
<p>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">LPUSH mq <span class="string">&quot;111000102:stock:99&quot;</span></span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p><em>3、如何保证消息可靠性？</em></p>
<p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p>
<p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p>
<p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<p>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<blockquote>
<p>List 作为消息队列有什么缺陷？</p>
</blockquote>
<p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p>
<p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p>
<p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p>
<h4 id="任务队列">任务队列</h4>
<p>除了作为消息队列，List 还可以用作任务队列。任务队列与消息队列的主要区别在于，任务队列中的每个元素都代表一个需要处理的任务，而不仅仅是一条消息。</p>
<p>任务队列的基本实现方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生产者添加任务</span></span><br><span class="line">LPUSH tasks &quot;task_id:1001:param1:value1:param2:value2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">消费者获取任务</span></span><br><span class="line">BRPOP tasks 0</span><br></pre></td></tr></table></figure>
<h4 id="最近更新列表">最近更新列表</h4>
<p>List 的有序特性使其适合存储最近更新的内容列表，例如社交媒体中的最新动态、博客的最新文章等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加新文章到最新文章列表</span></span><br><span class="line">LPUSH latest_articles &quot;article:1001&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保持列表不超过指定长度</span></span><br><span class="line">LTRIM latest_articles 0 99  # 只保留最新的100篇文章</span><br></pre></td></tr></table></figure>
<h4 id="分页数据缓存">分页数据缓存</h4>
<p>List 可以用于存储分页数据，利用 LRANGE 命令可以很方便地实现分页查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储分页数据</span></span><br><span class="line">RPUSH page_data:user:1001 &quot;item1&quot; &quot;item2&quot; &quot;item3&quot; ... &quot;item100&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取第一页数据（假设每页10条）</span></span><br><span class="line">LRANGE page_data:user:1001 0 9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取第二页数据</span></span><br><span class="line">LRANGE page_data:user:1001 10 19</span><br></pre></td></tr></table></figure>
<h3 id="性能考量">性能考量</h3>
<p>List 数据类型的性能特点：</p>
<ol>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li>LPUSH/RPUSH：O(1)，在列表头部/尾部添加元素是常数时间复杂度</li>
<li>LPOP/RPOP：O(1)，从列表头部/尾部移除元素也是常数时间复杂度</li>
<li>LRANGE：O(N)，N是返回的元素数量</li>
<li>LINDEX：O(N)，N是索引的位置，较大的索引值可能导致性能下降</li>
<li>LINSERT：O(N)，N是查找插入位置前需要遍历的元素数量</li>
</ul>
</li>
<li>
<p><strong>内存占用</strong>：</p>
<ul>
<li>quicklist 的设计平衡了内存效率和访问速度</li>
<li>每个节点包含多个元素，减少了内存碎片</li>
<li>可通过 <code>list-max-ziplist-size</code> 和 <code>list-compress-depth</code> 配置参数调整内存占用</li>
</ul>
</li>
<li>
<p><strong>性能优化建议</strong>：</p>
<ul>
<li>避免在大型列表中间插入或删除元素</li>
<li>尽量在列表两端操作，利用O(1)的时间复杂度</li>
<li>使用 LTRIM 命令定期清理列表，保持合理的长度</li>
<li>对于阻塞操作，设置合理的超时时间，避免无限期阻塞</li>
</ul>
</li>
</ol>
<h3 id="最佳实践">最佳实践</h3>
<ol>
<li>
<p><strong>大小控制</strong></p>
<ul>
<li>使用 LTRIM 命令限制列表大小，防止无限增长</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LPUSH latest_logs &quot;new log entry&quot;</span><br><span class="line">LTRIM latest_logs 0 999  # 只保留最新的1000条日志</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>批量操作</strong></p>
<ul>
<li>使用多值参数形式的命令进行批量操作，减少网络往返</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优于多次调用LPUSH</span></span><br><span class="line">LPUSH mylist value1 value2 value3 value4 value5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>事务使用</strong></p>
<ul>
<li>当需要原子性地执行多个列表操作时，使用事务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MULTI</span><br><span class="line">LPUSH source_list &quot;item&quot;</span><br><span class="line">LPOP dest_list</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>超时处理</strong></p>
<ul>
<li>使用阻塞操作时，添加合理的超时时间，避免客户端永久阻塞</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最多阻塞5秒</span></span><br><span class="line">BRPOP task_queue 5</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>监控指标</strong></p>
<ul>
<li>定期监控列表长度，避免过度增长</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LLEN mylist  # 监控列表长度</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="相关特性">相关特性</h3>
<ol>
<li>
<p><strong>与其他数据类型的对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>List</th>
<th>Stream</th>
<th>Pub/Sub</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息持久化</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>消费组</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>消息ID</td>
<td>需自行实现</td>
<td>内置支持</td>
<td>不支持</td>
</tr>
<tr>
<td>阻塞操作</td>
<td>支持</td>
<td>支持</td>
<td>天然广播</td>
</tr>
<tr>
<td>适用场景</td>
<td>简单队列</td>
<td>复杂消息系统</td>
<td>实时通知</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>与 Stream 的协作</strong></p>
<ul>
<li>对于简单应用可以使用 List</li>
<li>需要消费组或消息持久化等高级特性时，推荐使用 Stream</li>
<li>可以将 List 作为快速缓冲区，再定期批量写入 Stream</li>
</ul>
</li>
<li>
<p><strong>替代方案</strong></p>
<ul>
<li>当需要更强大的消息队列功能时，可以考虑专业的消息队列系统如 RabbitMQ、Kafka 等</li>
<li>对于简单的队列需求，List 提供了轻量级的解决方案</li>
</ul>
</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://redis.io/docs/data-types/lists/">Redis官方文档 - Lists</a></li>
<li><a href="https://redis.io/commands/?group=list">Redis命令参考 - List命令</a></li>
<li><a href="http://zhangtielei.com/posts/blog-redis-quicklist.html">Redis内部数据结构详解之quicklist</a></li>
<li><a href="https://redisbook.readthedocs.io/en/latest/index.html">Redis实战</a></li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>消息队列</tag>
        <tag>数据库</tag>
        <tag>REDIS</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 字符串（String）数据类型详解</title>
    <url>/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>String（字符串）是 Redis 中最基本也是最常用的数据类型，也是唯一一个在 Redis 中默认提供的且不需要特殊编码的数据结构。String 类型在 Redis 中不仅可以存储普通文本，还可以存储序列化后的对象、二进制数据、JSON 甚至是简单的整数计数器。其在缓存、分布式锁、计数器等场景中有广泛应用。</p>
<h2 id="String-基本特性">String 基本特性</h2>
<p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value 其实不仅是字符串，也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/1745926990333.png" alt="1745926990333"></p>
<h2 id="内部实现">内部实现</h2>
<p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<h3 id="SDS（Simple-Dynamic-String）">SDS（Simple Dynamic String）</h3>
<p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串有以下优势：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li><strong>SDS 获取字符串长度的时间复杂度是 O(1)</strong>。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
<li><strong>SDS 使用预分配空间和惰性空间释放策略，减少内存重分配次数</strong>。当 SDS 需要增长时，会分配额外的空间；当 SDS 缩短时，并不立即释放多余空间，而是记录起来以备后用。</li>
</ul>
<p>SDS 的基本结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="编码方式">编码方式</h3>
<p>字符串对象的内部编码（encoding）有 3 种：<strong>int、raw 和 embstr</strong>。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/1746798279486.png" alt="1746798279486"></p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用 <code>long</code>类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code>属性里面（将 <code>void*</code>转换成 long），并将字符串对象的编码设置为 <code>int</code>。</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/1746798287894.png" alt="1746798287894"></p>
<p>如果字符串对象保存的是一个字符串，并且这个字符串的长度小于等于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为 <code>embstr</code>， <code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式：</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/1746798295537.png" alt="1746798295537"></p>
<p>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为 <code>raw</code>：</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/1746798302983.png" alt="1746798302983"></p>
<p>注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：</p>
<ul>
<li>redis 2.+ 是 32 字节</li>
<li>redis 3.0-4.0 是 39 字节</li>
<li>redis 5.0 是 44 字节</li>
<li>redis 6.0+ 保持 44 字节</li>
</ul>
<p>可以看到 <code>embstr</code>和 <code>raw</code>编码都会使用 <code>SDS</code>来保存值，但不同之处在于 <code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存 <code>redisObject</code>和 <code>SDS</code>，而 <code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存 <code>redisObject</code>和 <code>SDS</code>。Redis 这样做会有很多好处：</p>
<ul>
<li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</li>
<li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</li>
<li>因为 <code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li>
</ul>
<p>但是 embstr 也有缺点的：</p>
<ul>
<li>如果字符串的长度增加需要重新分配内存时，整个 redisObject 和 sds 都需要重新分配空间，所以<strong>embstr 编码的字符串对象实际上是只读的</strong>，redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序。当我们对 embstr 编码的字符串对象执行任何修改命令（例如 append）时，程序会先将对象的编码从 embstr 转换成 raw，然后再执行修改命令。</li>
</ul>
<h2 id="常用指令">常用指令</h2>
<h3 id="基本操作指令">基本操作指令</h3>
<p>普通字符串的基本操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET name lin</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 key 获得对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET name</span></span><br><span class="line">&quot;lin&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断某个 key 是否存在</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXISTS name</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回 key 所储存的字符串值的长度</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">STRLEN name</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个 key 对应的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DEL name</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h3 id="批量操作指令">批量操作指令</h3>
<p>批量设置和获取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MSET key1 value1 key2 value2</span> </span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量获取多个 key 对应的 value</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">MGET key1 key2</span> </span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="计数器指令">计数器指令</h3>
<p>计数器（字符串的内容为整数的时候可以使用）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 key-value 类型的值</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET number 0</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 key 中储存的数字值增一</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCR number</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将key中存储的数字值加 10</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCRBY number 10</span></span><br><span class="line">(integer) 11</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 key 中储存的数字值减一</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DECR number</span></span><br><span class="line">(integer) 10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将key中存储的数字值键 10</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">DECRBY number 10</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<h3 id="过期设置指令">过期设置指令</h3>
<p>过期（默认为永不过期）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 key 在 60 秒后过期（该方法是针对已经存在的key设置过期时间）</span></span><br><span class="line">&gt; EXPIRE name  60 </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">&gt; TTL name </span><br><span class="line">(<span class="built_in">integer</span>) 51</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span></span><br><span class="line">&gt; SET key value EX 60</span><br><span class="line">OK</span><br><span class="line">&gt; SETEX key 60 value</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h3 id="条件操作指令">条件操作指令</h3>
<p>不存在就插入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不存在就插入（not exists）</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SETNX key value</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h2 id="应用场景">应用场景</h2>
<h3 id="缓存对象">缓存对象</h3>
<p>使用 String 来缓存对象有两种方式：</p>
<ul>
<li>
<p><strong>JSON序列化方式</strong>：直接缓存整个对象的 JSON，命令例子： <code>SET user:1 '&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;'</code>。</p>
<ul>
<li>优点：简单直观，适合处理复杂对象</li>
<li>缺点：每次修改都需要取出整个对象，修改后再重新存入</li>
</ul>
</li>
<li>
<p><strong>字段拆分方式</strong>：采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</p>
<ul>
<li>优点：可以单独修改某个属性，不需要获取整个对象</li>
<li>缺点：操作相对繁琐，适合简单对象</li>
</ul>
</li>
</ul>
<h3 id="常规计数">常规计数</h3>
<p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p>比如计算文章的阅读量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化文章的阅读量</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">SET article:readcount:1001 0</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阅读量+1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCR article:readcount:1001</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阅读量+1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCR article:readcount:1001</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">阅读量+1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCR article:readcount:1001</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取对应文章的阅读量</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET article:readcount:1001</span></span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>
<p>实际应用中，还可以使用 Redis 的 String 类型实现限流、点赞统计、UV/PV统计等功能。</p>
<h3 id="分布式锁">分布式锁</h3>
<p>SET 命令有个 NX 参数可以实现「key 不存在才插入」，可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure>
<ul>
<li>lock_key 就是 key 键；</li>
<li>unique_value 是客户端生成的唯一的标识；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p>
<p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p>
<p>需要注意的是，上述的简单实现在Redis集群环境下可能存在问题，Redis官方推荐使用Redlock算法来实现更可靠的分布式锁。</p>
<h3 id="共享-Session-信息">共享 Session 信息</h3>
<p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话 (登录) 状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p>分布式系统单独存储 Session 流程图：</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/1746798315817.png" alt="1746798315817"></p>
<p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<p>分布式系统使用同一个 Redis 存储 Session 流程图：</p>
<p><img src="/2025/05/10/%E5%85%AB%E8%82%A1%E6%96%87/REDIS/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/String/1746798322167.png" alt="1746798322167"></p>
<h3 id="限流器实现">限流器实现</h3>
<p>使用Redis String类型可以实现简单的限流功能，比如限制API在一定时间内的调用次数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前计数并递增</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">INCR req:<span class="built_in">limit</span>:api1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置过期时间（如果是第一次）</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">TTL req:<span class="built_in">limit</span>:api1</span></span><br><span class="line">(integer) -1</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EXPIRE req:<span class="built_in">limit</span>:api1 60</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否超过限制</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET req:<span class="built_in">limit</span>:api1</span></span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>在实际应用中，可以结合 INCR 和 EXPIRE 命令来实现更复杂的滑动窗口限流算法。</p>
<h2 id="性能考量">性能考量</h2>
<p>Redis String类型在不同场景下有不同的性能表现：</p>
<ol>
<li>
<p><strong>数据大小</strong>：</p>
<ul>
<li>对于小于44字节(Redis 6.0+)的字符串，使用embstr编码，内存分配只需一次，效率更高</li>
<li>对于大字符串，使用raw编码，需要两次内存分配</li>
<li>超大字符串（接近512MB）可能导致内存碎片和性能下降</li>
</ul>
</li>
<li>
<p><strong>操作类型</strong>：</p>
<ul>
<li>读操作（GET）性能极高，时间复杂度为O(1)</li>
<li>写操作（SET）对于embstr编码的字符串，如需修改会先转换为raw编码，增加了开销</li>
<li>批量操作（MGET/MSET）比多次单独操作更高效，减少了网络往返时间</li>
</ul>
</li>
<li>
<p><strong>内存使用</strong>：</p>
<ul>
<li>String类型相比其他复杂数据结构更节省内存</li>
<li>整数值使用int编码时内存占用最小</li>
<li>预分配策略可能导致一定的内存浪费</li>
</ul>
</li>
</ol>
<h2 id="常见问题与解决方案">常见问题与解决方案</h2>
<ol>
<li>
<p><strong>大key问题</strong>：</p>
<ul>
<li>问题：存储过大的字符串会导致Redis性能下降，尤其在删除大key时</li>
<li>解决：将大对象分片存储，或使用Hash类型替代</li>
</ul>
</li>
<li>
<p><strong>内存占用过大</strong>：</p>
<ul>
<li>问题：String预分配策略可能导致内存浪费</li>
<li>解决：适当设置maxmemory和合理的过期策略</li>
</ul>
</li>
<li>
<p><strong>并发修改问题</strong>：</p>
<ul>
<li>问题：多客户端同时修改同一个key可能导致数据不一致</li>
<li>解决：使用WATCH/MULTI/EXEC事务或Lua脚本确保原子性操作</li>
</ul>
</li>
<li>
<p><strong>过期时间设置</strong>：</p>
<ul>
<li>问题：忘记设置过期时间导致内存持续增长</li>
<li>解决：为所有缓存key设置合理的过期时间，或使用LRU策略</li>
</ul>
</li>
</ol>
<h2 id="与其他数据类型的对比">与其他数据类型的对比</h2>
<p>与Redis的其他数据类型相比，String类型有以下特点：</p>
<ol>
<li>
<p><strong>vs Hash</strong>：</p>
<ul>
<li>String：适合存储单个值或序列化对象，操作简单</li>
<li>Hash：适合存储有多个字段的对象，可单独操作某个字段，节省内存</li>
</ul>
</li>
<li>
<p><strong>vs List</strong>：</p>
<ul>
<li>String：不支持复杂的队列操作</li>
<li>List：适合实现队列、栈等数据结构</li>
</ul>
</li>
<li>
<p><strong>vs Set/Sorted Set</strong>：</p>
<ul>
<li>String：不支持集合操作</li>
<li>Set/Sorted Set：适合需要去重、排序、交集等集合操作的场景</li>
</ul>
</li>
</ol>
<p>选择使用String还是其他数据类型，应根据实际业务需求和性能要求来决定。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>REDIS</category>
        <category>基础知识</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>REDIS</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 153 - 寻找旋转排序数组中的最小值</title>
    <url>/2025/05/10/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个元素值<strong>互不相同</strong>的数组 <code>nums</code>，它原来是一个升序排列的数组，并按照下面的情形进行了多次旋转：</p>
<p><strong>旋转操作</strong>：将数组最前面的元素取出并放到数组的末尾。例如，原数组 <code>[0,1,2,4,5,6,7]</code> 旋转一次后变成 <code>[1,2,4,5,6,7,0]</code>。</p>
<p>若旋转 4 次，则可以得到 <code>[4,5,6,7,0,1,2]</code>，若旋转 7 次（即数组长度），则可以得到原数组 <code>[0,1,2,4,5,6,7]</code>。</p>
<p>请你找出并返回数组中的<strong>最小元素</strong>。</p>
<p><strong>要求</strong>：必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次（整个长度）得到输入数组。</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数<strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>对于这道题，我们首先要理解旋转排序数组的特性：</p>
<ul>
<li>如果数组进行了旋转，那么它会被分成两个升序子数组</li>
<li>最小值是第二个子数组的第一个元素</li>
<li>如果数组旋转了<code>n</code>次（相当于没旋转），则第一个元素就是最小值</li>
</ul>
<p>由于题目要求<code>O(log n)</code>的时间复杂度，<strong>二分查找</strong>是最自然的选择。</p>
<h3 id="解法一：传统二分查找">解法一：传统二分查找</h3>
<h4 id="核心思路">核心思路</h4>
<p>传统二分查找的关键是确定最小值在哪个区间。我们可以通过比较中间元素和右边界元素来判断：</p>
<ul>
<li>如果 <code>nums[mid] &lt; nums[right]</code>：说明 <code>[mid, right]</code> 这一段是有序的，最小值在 <code>mid</code> 或其左侧</li>
<li>如果 <code>nums[mid] &gt; nums[right]</code>：说明最小值在 <code>mid</code> 右侧</li>
</ul>
<h4 id="实现细节">实现细节</h4>
<ol>
<li>初始化左右边界 <code>left = 0, right = n-1</code></li>
<li>当 <code>left &lt; right</code> 时执行循环</li>
<li>计算中间位置 <code>mid = (left + right) / 2</code></li>
<li>比较 <code>nums[mid]</code> 和 <code>nums[right]</code>
<ul>
<li>如果 <code>nums[mid] &lt; nums[right]</code>：更新 <code>right = mid</code></li>
<li>如果 <code>nums[mid] &gt; nums[right]</code>：更新 <code>left = mid + 1</code></li>
</ul>
</li>
<li>循环结束后，<code>left</code> 指向的就是最小值的位置</li>
</ol>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">		mid := (left + right) &gt;&gt; <span class="number">1</span> <span class="comment">// 等价于 mid := (left + right) / 2</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt; nums[right] &#123;</span><br><span class="line">			right = mid</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行过程模拟">执行过程模拟</h4>
<p>以 <code>nums = [4,5,6,7,0,1,2]</code> 为例：</p>
<ol>
<li>初始：<code>left = 0, right = 6</code></li>
<li>第一次迭代：
<ul>
<li><code>mid = 3</code>, <code>nums[mid] = 7</code>, <code>nums[right] = 2</code></li>
<li><code>7 &gt; 2</code>，所以 <code>left = mid + 1 = 4</code></li>
</ul>
</li>
<li>第二次迭代：
<ul>
<li><code>left = 4, right = 6</code></li>
<li><code>mid = 5</code>, <code>nums[mid] = 1</code>, <code>nums[right] = 2</code></li>
<li><code>1 &lt; 2</code>，所以 <code>right = mid = 5</code></li>
</ul>
</li>
<li>第三次迭代：
<ul>
<li><code>left = 4, right = 5</code></li>
<li><code>mid = 4</code>, <code>nums[mid] = 0</code>, <code>nums[right] = 1</code></li>
<li><code>0 &lt; 1</code>，所以 <code>right = mid = 4</code></li>
</ul>
</li>
<li>此时 <code>left = right = 4</code>，循环结束，返回 <code>nums[4] = 0</code>，这是正确的最小值</li>
</ol>
<h3 id="解法二：使用-Go-的-sort-Search">解法二：使用 Go 的 sort.Search</h3>
<h4 id="Go-的-sort-Search-函数实现原理">Go 的 sort.Search 函数实现原理</h4>
<p><code>sort.Search</code> 是 Go 标准库中的二分查找实现，它寻找满足特定条件的最小索引。其实现原理如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 定义搜索区间 [0, n)</span></span><br><span class="line">    lo, hi := <span class="number">0</span>, n</span><br><span class="line">    <span class="comment">// 当搜索区间不为空时继续</span></span><br><span class="line">    <span class="keyword">for</span> lo &lt; hi &#123;</span><br><span class="line">        <span class="comment">// 计算中间点</span></span><br><span class="line">        mid := lo + (hi-lo)/<span class="number">2</span></span><br><span class="line">        <span class="comment">// 如果条件满足，说明结果在左半部分 [lo, mid]</span></span><br><span class="line">        <span class="keyword">if</span> f(mid) &#123;</span><br><span class="line">            hi = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则结果在右半部分 (mid, hi)</span></span><br><span class="line">            lo = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// lo 是第一个满足条件的索引，如果不存在则等于 n</span></span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sort.Search</code> 函数有两个核心特性：</p>
<ol>
<li>它返回第一个使得条件函数 <code>f(i)</code> 返回 <code>true</code> 的索引 <code>i</code></li>
<li>如果所有元素都不满足条件，它会返回 <code>n</code>（搜索范围的上限）</li>
</ol>
<h4 id="核心思路-2">核心思路</h4>
<p>在旋转排序数组中，如果我们寻找第一个小于 <code>nums[0]</code> 的元素，那么：</p>
<ul>
<li>如果数组经过旋转，这个元素就是最小值</li>
<li>如果找不到这样的元素（即 <code>sort.Search</code> 返回数组长度），说明数组没有旋转或旋转了整个长度，此时 <code>nums[0]</code> 就是最小值</li>
</ul>
<h4 id="代码实现-2">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	index := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[i] &lt; nums[<span class="number">0</span>]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nums[index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行过程模拟-2">执行过程模拟</h4>
<p>以 <code>nums = [4,5,6,7,0,1,2]</code> 为例：</p>
<ol>
<li>我们寻找第一个小于 <code>nums[0] = 4</code> 的元素</li>
<li>初始：<code>lo = 0, hi = 7</code></li>
<li>第一次迭代：
<ul>
<li><code>mid = 3</code>, <code>nums[mid] = 7</code></li>
<li><code>7 &lt; 4</code> ? 否，所以 <code>lo = mid + 1 = 4</code></li>
</ul>
</li>
<li>第二次迭代：
<ul>
<li><code>lo = 4, hi = 7</code></li>
<li><code>mid = 5</code>, <code>nums[mid] = 1</code></li>
<li><code>1 &lt; 4</code> ? 是，所以 <code>hi = mid = 5</code></li>
</ul>
</li>
<li>第三次迭代：
<ul>
<li><code>lo = 4, hi = 5</code></li>
<li><code>mid = 4</code>, <code>nums[mid] = 0</code></li>
<li><code>0 &lt; 4</code> ? 是，所以 <code>hi = mid = 4</code></li>
</ul>
</li>
<li>此时 <code>lo = hi = 4</code>，循环结束，返回 <code>lo = 4</code></li>
<li>因为 <code>index = 4 &lt; len(nums) = 7</code>，所以返回 <code>nums[4] = 0</code>，这是正确的最小值</li>
</ol>
<p>对于 <code>nums = [11,13,15,17]</code>（没有旋转）：</p>
<ol>
<li>我们寻找第一个小于 <code>nums[0] = 11</code> 的元素</li>
<li>经过二分查找，发现没有元素小于 11</li>
<li><code>sort.Search</code> 返回 <code>index = 4</code>（数组长度）</li>
<li>因为 <code>index &gt;= len(nums)</code>，所以返回 <code>nums[0] = 11</code>，这是正确的最小值</li>
</ol>
<h2 id="边界情况分析">边界情况分析</h2>
<h3 id="解法一的边界处理">解法一的边界处理</h3>
<p>为什么我们在解法一中比较中间值和右边界值，而不是左边界值？这是因为：</p>
<ol>
<li>
<p>如果比较中间值和左边界值，在某些情况下无法确定最小值在哪一侧</p>
<ul>
<li>例如，在 <code>[3,4,5,1,2]</code> 中
<ul>
<li><code>nums[mid=2] = 5</code>, <code>nums[left=0] = 3</code>，<code>5 &gt; 3</code>，但最小值在右侧</li>
</ul>
</li>
<li>例如，在 <code>[5,1,2,3,4]</code> 中
<ul>
<li><code>nums[mid=2] = 2</code>, <code>nums[left=0] = 5</code>，<code>2 &lt; 5</code>，但最小值在左侧</li>
</ul>
</li>
</ul>
</li>
<li>
<p>而比较中间值和右边界值可以明确判断：</p>
<ul>
<li>如果 <code>nums[mid] &lt; nums[right]</code>：<code>[mid, right]</code> 是有序的，最小值在 <code>mid</code> 或其左侧</li>
<li>如果 <code>nums[mid] &gt; nums[right]</code>：最小值一定在 <code>mid</code> 右侧</li>
</ul>
</li>
</ol>
<p>终止条件 <code>left == right</code> 确保了我们能够找到最小值的确切位置。</p>
<h4 id="二分查找边界条件的精确选择">二分查找边界条件的精确选择</h4>
<p>在这道题的二分查找实现中，边界条件的选择尤为关键：</p>
<ol>
<li>
<p><strong>为什么使用 <code>left &lt; right</code> 而不是 <code>left &lt;= right</code>？</strong></p>
<ul>
<li>使用 <code>left &lt; right</code> 意味着当 <code>left == right</code> 时循环终止</li>
<li>此时搜索区间缩小到只有一个元素，这个元素就是最小值</li>
<li>如果使用 <code>left &lt;= right</code>，当 <code>left == right</code> 时，<code>mid</code> 也等于 <code>left</code> 和 <code>right</code></li>
<li>如果进入 <code>right = mid</code> 的分支，搜索区间不会缩小，导致死循环</li>
</ul>
</li>
<li>
<p><strong>为什么使用 <code>right = mid</code> 而不是 <code>right = mid - 1</code>？</strong></p>
<ul>
<li>当 <code>nums[mid] &lt; nums[right]</code> 时，说明 <code>[mid, right]</code> 这一段是有序的</li>
<li>此时最小值可能是 <code>mid</code>（如果 <code>mid</code> 刚好是最小值的位置）</li>
<li>如果使用 <code>right = mid - 1</code>，当 <code>mid</code> 是最小值时，我们会错过它</li>
<li>例如：在 <code>[4,5,1,2,3]</code> 中，当 <code>left=0, right=4, mid=2</code> 时，<code>nums[mid]=1 &lt; nums[right]=3</code></li>
<li>如果使用 <code>right = mid - 1</code>，会把搜索范围缩小到 <code>[0,1]</code>，从而错过最小值 <code>1</code></li>
</ul>
</li>
<li>
<p><strong>为什么使用 <code>left = mid + 1</code> 而不是 <code>left = mid</code>？</strong></p>
<ul>
<li>当 <code>nums[mid] &gt;= nums[right]</code> 时，说明 <code>mid</code> 不可能是最小值</li>
<li>最小值一定在 <code>mid</code> 的右侧，所以可以安全地使用 <code>left = mid + 1</code></li>
<li>如果使用 <code>left = mid</code>，当 <code>left</code> 和 <code>right</code> 相邻时（例如 <code>left=4, right=5</code>），</li>
<li>计算得到 <code>mid=4</code>，如果进入 <code>left = mid</code> 分支，<code>left</code> 仍然是 <code>4</code>，搜索区间不变</li>
<li>这会导致算法陷入死循环</li>
</ul>
</li>
</ol>
<p>这些边界条件的精确选择，确保了算法既能正确找到最小值，又能高效地收敛而不会陷入死循环。</p>
<h3 id="解法二的边界处理">解法二的边界处理</h3>
<p>解法二的边界处理体现在：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">	<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个判断是为了处理数组没有旋转或旋转了整个长度（等价于没旋转）的情况。在这种情况下，没有元素小于 <code>nums[0]</code>，<code>sort.Search</code> 会返回数组长度 <code>n</code>，此时 <code>nums[0]</code> 就是最小值。</p>
<h4 id="sort-Search-函数的边界设计">sort.Search 函数的边界设计</h4>
<p>Go 语言的 <code>sort.Search</code> 函数有其独特的边界处理机制：</p>
<ol>
<li>
<p><strong>搜索区间是半开区间 <code>[0, n)</code></strong></p>
<ul>
<li>注意右边界是 <code>n</code> 而不是 <code>n-1</code></li>
<li>这样设计的好处是，当所有元素都不满足条件时，返回值为 <code>n</code></li>
<li>我们可以通过检查 <code>index &gt;= len(nums)</code> 来捕获这种情况</li>
</ul>
</li>
<li>
<p><strong>内部循环使用 <code>lo &lt; hi</code></strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sort.Search 的简化实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span> &#123;</span><br><span class="line">    lo, hi := <span class="number">0</span>, n</span><br><span class="line">    <span class="keyword">for</span> lo &lt; hi &#123;</span><br><span class="line">        mid := lo + (hi-lo)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> f(mid) &#123;</span><br><span class="line">            hi = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>lo == hi</code> 时退出循环，确保搜索会收敛到一个确定的位置</li>
<li><code>lo</code> 最终指向第一个满足条件的元素，或者指向 <code>n</code>（如果没有满足条件的元素）</li>
</ul>
</li>
<li>
<p><strong>边界更新规则</strong></p>
<ul>
<li>如果 <code>f(mid)</code> 为 <code>true</code>，则 <code>hi = mid</code>（不是 <code>mid-1</code>）</li>
<li>这确保了找到的是第一个满足条件的元素</li>
<li>如果 <code>f(mid)</code> 为 <code>false</code>，则 <code>lo = mid + 1</code>（不是 <code>mid</code>）</li>
<li>这确保了循环会终止，避免死循环</li>
</ul>
</li>
</ol>
<p>对于我们的问题，条件函数是 <code>nums[i] &lt; nums[0]</code>，表示从数组中找到第一个小于 <code>nums[0]</code> 的元素。这种边界设计使得 <code>sort.Search</code> 非常适合查找第一个满足某条件的元素，在旋转排序数组中找最小值的场景下尤为优雅。</p>
<p>对于边缘情况，如数组只有一个元素：</p>
<ul>
<li>解法一：<code>left = 0, right = 0</code>，循环不会执行，直接返回 <code>nums[0]</code></li>
<li>解法二：没有元素小于 <code>nums[0]</code>，<code>sort.Search</code> 返回 <code>1</code>，执行 <code>if index &gt;= len(nums)</code>，返回 <code>nums[0]</code></li>
</ul>
<h2 id="复杂度分析">复杂度分析</h2>
<p>两种解法的复杂度分析：</p>
<p><strong>时间复杂度</strong>：两种解法都是 $O(\log n)$，因为它们都使用了二分查找，每次将搜索空间减半</p>
<p><strong>空间复杂度</strong>：两种解法都是 $O(1)$，只使用了常数额外空间</p>
<h2 id="解法比较">解法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>解法一（传统二分）</th>
<th>解法二（sort.Search）</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(\log n)$</td>
<td>$O(\log n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>优点</td>
<td>更加直观，不依赖库函数</td>
<td>代码更简洁，利用了Go语言特性</td>
</tr>
<tr>
<td>缺点</td>
<td>需要手动实现二分查找</td>
<td>需要理解sort.Search函数的特性</td>
</tr>
<tr>
<td>适用场景</td>
<td>各种语言环境</td>
<td>Go语言环境</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>二分查找的比较策略很重要</strong>：在旋转排序数组中，选择合适的比较策略（与左边界或右边界比较）会直接影响算法的正确性</li>
<li><strong>利用语言特性可以简化代码</strong>：Go语言的 <code>sort.Search</code> 函数提供了一种简洁的二分查找实现方式</li>
<li><strong>理解问题结构是关键</strong>：理解旋转排序数组的结构特点（两个有序子数组）有助于设计高效算法</li>
<li><strong>边界情况的处理至关重要</strong>：特别注意数组未旋转或只有一个元素的情况</li>
</ol>
<p>这道题展示了如何利用二分查找高效解决旋转排序数组问题，以及如何灵活运用语言特性简化代码实现。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁机制详解：从原理到实践</title>
    <url>/2025/05/08/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-08-MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1>MySQL 锁机制概述</h1>
<p>锁是数据库系统实现并发控制的核心机制，MySQL 通过各种类型的锁保证数据的一致性和完整性。理解 MySQL 的锁机制对于开发高性能、高可靠性的数据库应用至关重要。</p>
<p>在 MySQL 里，根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。这三类锁的粒度逐渐变细，加锁范围逐渐变小，并发性能也逐渐提升。</p>
<h2 id="全局锁">全局锁</h2>
<p><strong>全局锁是 MySQL 中粒度最大的锁，它会锁定整个数据库实例的所有表，使整个数据库处于只读状态。</strong></p>
<h3 id="全局锁的使用方法">全局锁的使用方法</h3>
<p>要使用全局锁，需要执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FLUSH TABLES <span class="keyword">WITH</span> READ LOCK</span><br></pre></td></tr></table></figure>
<p>执行后，<strong>整个数据库就处于只读状态</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 INSERT、DELETE、UPDATE 等语句</li>
<li>对表结构的更改操作，比如 ALTER TABLE、DROP TABLE 等语句</li>
</ul>
<h3 id="全局锁的释放方法">全局锁的释放方法</h3>
<p>如果要释放全局锁，执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>
<p>当然，当会话断开时，全局锁会被自动释放。</p>
<h3 id="全局锁的应用场景">全局锁的应用场景</h3>
<p><strong>全局锁主要应用于全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而导致备份文件数据与实际不一致。</p>
<h4 id="不使用全局锁可能带来的问题">不使用全局锁可能带来的问题</h4>
<p>假设在全库逻辑备份期间不加全局锁，可能会出现以下情况：</p>
<ol>
<li>先备份了用户表的数据</li>
<li>然后有用户发起了购买商品的操作</li>
<li>接着再备份商品表的数据</li>
</ol>
<p>在这种情况下，备份结果会出现：用户表中该用户的余额并没有扣除，而商品表中该商品的库存却被减少了。如果用这个备份文件恢复数据，就会导致用户没花钱就得到了商品。</p>
<h3 id="全局锁的缺点">全局锁的缺点</h3>
<p><strong>加上全局锁会导致整个数据库都是只读状态</strong>，这会带来以下问题：</p>
<ul>
<li>如果数据库有大量数据，备份会花费很长时间</li>
<li>在备份期间，业务只能读数据而不能更新数据，可能导致业务停滞</li>
</ul>
<h3 id="全局锁的替代方案">全局锁的替代方案</h3>
<p>对于支持<strong>可重复读隔离级别</strong>的存储引擎（如 InnoDB），可以采用以下替代方案：</p>
<p>在备份前先开启事务，利用 MVCC 机制，即使其他事务更新了表的数据，也不会影响备份数据时的 Read View。</p>
<p>使用 mysqldump 工具时，可以加上 <code>--single-transaction</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p database &gt; backup.sql</span><br></pre></td></tr></table></figure>
<p>这种方法只适用于支持&quot;可重复读隔离级别&quot;的存储引擎。对于 MyISAM 这种不支持事务的引擎，仍需使用全局锁方式备份。</p>
<h2 id="表级锁">表级锁</h2>
<p>**表级锁是 MySQL 中粒度中等的锁，它锁定整张表，而不是表中的某一行或某些行。**MySQL 中的表级锁主要有以下几种：</p>
<ul>
<li>表锁（Table Lock）</li>
<li>元数据锁（MDL，Metadata Lock）</li>
<li>意向锁（Intention Lock）</li>
<li>AUTO-INC 锁（自增锁）</li>
</ul>
<h3 id="表锁">表锁</h3>
<p><strong>表锁是最基本的锁策略，锁定整张表，分为读锁（共享锁）和写锁（独占锁）。</strong></p>
<h4 id="表锁的使用方法">表锁的使用方法</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表级共享锁（读锁）</span></span><br><span class="line">LOCK TABLES t_student READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级独占锁（写锁）</span></span><br><span class="line">LOCK TABLES t_student WRITE;</span><br></pre></td></tr></table></figure>
<h4 id="表锁的特点">表锁的特点</h4>
<ul>
<li>表锁会限制<strong>其他线程</strong>的读写操作，也会限制<strong>当前线程</strong>接下来的读写操作</li>
<li>如果当前线程对表加了共享锁，那么当前线程后续也无法对该表进行写操作</li>
<li>表锁粒度较大，会影响并发性能</li>
</ul>
<h4 id="释放表锁的方法">释放表锁的方法</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure>
<p>当会话退出后，也会自动释放所有表锁。</p>
<h3 id="元数据锁（MDL）">元数据锁（MDL）</h3>
<p>**元数据锁是 MySQL 5.5 版本引入的表级锁，用于保护表的结构（元数据）。**它在对表执行操作时自动加锁，无需显式调用。</p>
<h4 id="MDL-锁的类型">MDL 锁的类型</h4>
<ul>
<li><strong>MDL 读锁</strong>：对表进行 CRUD 操作时自动加上</li>
<li><strong>MDL 写锁</strong>：对表结构进行变更操作时自动加上</li>
</ul>
<h4 id="MDL-锁的作用">MDL 锁的作用</h4>
<p>MDL 的主要目的是<strong>防止在表结构变更时，有其他线程正在对表进行 CRUD 操作</strong>，避免数据不一致。</p>
<ul>
<li>当有线程在执行 SELECT 语句（MDL 读锁）期间，其他线程要变更表结构（申请 MDL 写锁）会被阻塞</li>
<li>当有线程在变更表结构（MDL 写锁）期间，其他线程执行 CRUD 操作（申请 MDL 读锁）会被阻塞</li>
</ul>
<h4 id="MDL-锁的释放时机">MDL 锁的释放时机</h4>
<p><strong>MDL 锁在事务提交后才会释放</strong>，这意味着事务执行期间，MDL 是一直持有的。</p>
<h4 id="MDL-锁可能引发的问题">MDL 锁可能引发的问题</h4>
<p>如果数据库有长时间未提交的事务（长事务），而此时有表结构变更操作，可能会引发连锁阻塞：</p>
<ol>
<li>线程 A 开启事务执行 SELECT，获取 MDL 读锁</li>
<li>线程 B 也执行 SELECT，也获取 MDL 读锁（读读不冲突）</li>
<li>线程 C 要修改表结构，申请 MDL 写锁，被阻塞（读写冲突）</li>
<li>之后其他线程执行 SELECT 语句，因为 MDL 写锁请求排队在前，新的 MDL 读锁请求也会被阻塞</li>
</ol>
<p>这是因为申请 MDL 锁的操作会形成一个队列，<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有操作。</p>
<h3 id="意向锁">意向锁</h3>
<p><strong>意向锁是 InnoDB 存储引擎在表级别上引入的一种锁，用于表示事务稍后在表中的记录上加锁的意向。</strong></p>
<h4 id="意向锁的分类">意向锁的分类</h4>
<ul>
<li><strong>意向共享锁（IS）</strong>：表示事务意图在表中的某些记录上加共享锁</li>
<li><strong>意向独占锁（IX）</strong>：表示事务意图在表中的某些记录上加独占锁</li>
</ul>
<h4 id="意向锁的作用机制">意向锁的作用机制</h4>
<ul>
<li>在对记录加共享锁前，需要先在表级别加上意向共享锁</li>
<li>在对记录加独占锁前，需要先在表级别加上意向独占锁</li>
</ul>
<p>普通的 SELECT 不会加行级锁，而是利用 MVCC 实现一致性读。但以下语句会加锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先在表上加意向共享锁，然后对读取的记录加共享锁</span></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先在表上加意向独占锁，然后对读取的记录加独占锁</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<h4 id="意向锁的兼容性">意向锁的兼容性</h4>
<p><strong>意向锁之间不会冲突，只会与表锁（共享表锁和独占表锁）冲突。</strong></p>
<p>意向锁的主要目的是<strong>为了快速判断表里是否有记录被加锁</strong>，提高加表锁时的效率。如果没有意向锁，加独占表锁时需要遍历表中所有记录，检查是否有记录被加锁，效率很低。</p>
<h3 id="AUTO-INC-锁">AUTO-INC 锁</h3>
<p><strong>AUTO-INC 锁是一种特殊的表级锁，专门用于处理自增主键的分配。</strong></p>
<h4 id="AUTO-INC-锁的工作机制">AUTO-INC 锁的工作机制</h4>
<p>当表的主键设置了 AUTO_INCREMENT 属性后，插入数据时如果不指定主键值，系统会自动分配一个递增的值。</p>
<p>在插入数据时，MySQL 会先获取 AUTO-INC 锁，然后为 AUTO_INCREMENT 字段赋值，<strong>之后立即释放锁（不需要等到事务提交）</strong>。</p>
<h4 id="AUTO-INC-锁的性能问题及优化">AUTO-INC 锁的性能问题及优化</h4>
<p>AUTO-INC 锁在大量数据插入操作时会影响性能，因为其他插入操作需要等待锁释放。</p>
<p>从 MySQL 5.1.22 版本开始，InnoDB 引入了<strong>轻量级锁</strong>来优化自增锁机制：</p>
<ul>
<li>轻量级锁在获取自增值后立即释放，不等待整个插入语句完成</li>
</ul>
<h4 id="AUTO-INC-锁的控制参数">AUTO-INC 锁的控制参数</h4>
<p>InnoDB 提供了 <code>innodb_autoinc_lock_mode</code>参数来控制自增锁行为：</p>
<ul>
<li><code>innodb_autoinc_lock_mode = 0</code>：使用传统的 AUTO-INC 锁，语句执行完才释放</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用轻量级锁，获取自增值后立即释放</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：混合模式
<ul>
<li>普通 INSERT 语句使用轻量级锁</li>
<li>批量插入语句（如 INSERT…SELECT）使用 AUTO-INC 锁</li>
</ul>
</li>
</ul>
<h4 id="自增锁与主从复制的注意事项">自增锁与主从复制的注意事项</h4>
<p>当 <code>innodb_autoinc_lock_mode = 2</code>并且 <code>binlog_format = statement</code>时，在主从复制场景中可能会导致数据不一致问题。</p>
<h5 id="主从不一致的案例">主从不一致的案例</h5>
<p>当两个会话并发插入数据时：</p>
<ol>
<li>Session B 先插入了记录(1,1,1)、(2,2,2)</li>
<li>然后 Session A 插入记录(3,5,5)</li>
<li>之后 Session B 继续插入记录(4,3,3)、(5,4,4)</li>
</ol>
<p>这导致 Session B 获得的自增 ID 不连续(1,2,4,5)，而中间的 3 被 Session A 获取。</p>
<p>主库发生这种并发插入时，如果 binlog 格式为 statement，主从库执行顺序不同，会导致从库上生成的数据与主库不一致。</p>
<p>正确配置：当 <code>innodb_autoinc_lock_mode = 2</code>时，应使用 <code>binlog_format = row</code>，这样从库会使用与主库相同的自增值。</p>
<h2 id="行级锁">行级锁</h2>
<p>**行级锁是 MySQL 中粒度最细的锁，它只锁定特定的行，而不是整张表，这大大提高了并发处理能力。**行级锁只在存储引擎层实现，InnoDB 支持行级锁，而 MyISAM 不支持。</p>
<h3 id="行级锁的使用方法">行级锁的使用方法</h3>
<p>普通的 SELECT 语句不会对记录加锁。如果需要在查询时加锁，可以使用以下方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对读取的记录加共享锁（S锁）</span></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对读取的记录加独占锁（X锁）</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>这两条语句必须在事务中使用，因为<strong>事务提交后锁会自动释放</strong>。使用时需要加上 BEGIN、START TRANSACTION 或设置 autocommit=0。</p>
<h3 id="行级锁的兼容性">行级锁的兼容性</h3>
<p>行级锁有共享锁（S 锁）和独占锁（X 锁）之分，它们的兼容关系如下：</p>
<ul>
<li>S 锁与 S 锁兼容（读读共享）</li>
<li>S 锁与 X 锁不兼容（读写互斥）</li>
<li>X 锁与 X 锁不兼容（写写互斥）</li>
</ul>
<p><img src="/2025/05/08/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-08-MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/1746795271430.png" alt="1746795271430"></p>
<h3 id="行级锁的类型">行级锁的类型</h3>
<p>InnoDB 实现了以下几种行级锁：</p>
<ul>
<li><strong>Record Lock（记录锁）</strong>：锁定单个行记录</li>
<li><strong>Gap Lock（间隙锁）</strong>：锁定一个范围，但不包含记录本身</li>
<li><strong>Next-Key Lock（临键锁）</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身</li>
<li><strong>插入意向锁</strong>：一种特殊的间隙锁，表示插入意向</li>
</ul>
<h4 id="Record-Lock（记录锁）">Record Lock（记录锁）</h4>
<p><strong>记录锁是最基本的行锁，它锁定的是索引记录，而非记录所在的物理页。</strong></p>
<p>记录锁分为 S 型记录锁和 X 型记录锁：</p>
<ul>
<li>当事务对记录加了 S 型记录锁，其他事务可以继续加 S 锁，但不能加 X 锁</li>
<li>当事务对记录加了 X 型记录锁，其他事务既不能加 S 锁，也不能加 X 锁</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句会对主键 id=1 的记录加上 X 型记录锁，阻止其他事务修改该记录。</p>
<p><img src="/2025/05/08/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-08-MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/1746795281298.png" alt="1746795281298"></p>
<h4 id="Gap-Lock（间隙锁）">Gap Lock（间隙锁）</h4>
<p><strong>间隙锁锁定索引记录之间的间隔，防止其他事务在这个间隔中插入数据，从而避免幻读问题。</strong></p>
<p>间隙锁只在<strong>可重复读隔离级别</strong>下存在，目的是解决幻读问题。</p>
<p>例如，表中有一个范围 id 为(3,5)的间隙锁，其他事务就无法插入 id=4 的记录，有效防止了幻读。</p>
<p><img src="/2025/05/08/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-08-MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/1746795287877.png" alt="1746795287877"></p>
<p><strong>间隙锁的特殊性</strong>：虽然有 S 型和 X 型之分，但间隙锁之间是相互兼容的。两个事务可以同时持有包含共同间隙范围的间隙锁，因为间隙锁的目的只是防止插入操作。</p>
<h4 id="Next-Key-Lock（临键锁）">Next-Key Lock（临键锁）</h4>
<p><strong>Next-Key Lock 是 Record Lock 和 Gap Lock 的组合，既锁定一个范围，又锁定记录本身。</strong></p>
<p>例如，表中有一个范围 id 为(3,5]的 Next-Key Lock，其他事务既不能插入 id=4 的记录，也不能修改 id=5 的记录。</p>
<p><img src="/2025/05/08/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-08-MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/1746795296158.png" alt="1746795296158"></p>
<p>Next-Key Lock 既能保护记录，又能阻止在记录前的间隙中插入新记录，是 InnoDB 默认的行锁算法。</p>
<p><strong>Next-Key Lock 的冲突规则</strong>：由于包含了记录锁，如果一个事务获取了 X 型 Next-Key Lock，其他事务无法获取相同范围的 X 型 Next-Key Lock。</p>
<h4 id="插入意向锁">插入意向锁</h4>
<p><strong>插入意向锁是一种特殊的间隙锁，表示事务想要在某个区间插入记录的意向。</strong></p>
<p>当一个事务要插入一条记录时，需要检查插入位置是否被其他事务加了间隙锁：</p>
<ul>
<li>如果有间隙锁，插入操作会被阻塞</li>
<li>此时会生成一个插入意向锁，状态为等待，直到间隙锁释放</li>
</ul>
<p>例如，事务 A 已经对表加了(3,5)间隙锁：</p>
<p><img src="/2025/05/08/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E9%94%81/2025-05-08-MySQL%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/1746795304573.png" alt="1746795304573"></p>
<p>当事务 B 尝试插入 id=4 的记录时，会被阻塞并生成一个插入意向锁，直到事务 A 提交。</p>
<p><strong>插入意向锁与间隙锁的关系</strong>：</p>
<ul>
<li>插入意向锁是一种特殊的间隙锁，但锁住的是一个点而非区间</li>
<li>插入意向锁与间隙锁不兼容：同一时间内，不能一个事务持有间隙锁，另一个事务持有该间隙内的插入意向锁</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>并发控制</tag>
        <tag>锁机制</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 33 - 搜索旋转排序数组错误分析</title>
    <url>/2025/05/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a> 是一个经典的二分查找变种问题：</p>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code> 上进行了旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我初始的解法思路是：</p>
<ol>
<li>先找到旋转点（数组中值突然下降的位置）</li>
<li>根据旋转点将数组分成两部分</li>
<li>确定 target 在哪个部分，然后在相应部分中使用二分查找</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 找到旋转点</span></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rotateIdx := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[i] &gt; nums[i+<span class="number">1</span>]  <span class="comment">// ❌ 错误点：可能导致数组越界</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rotateIdx == n<span class="number">-1</span> &#123;</span><br><span class="line">		rotateIdx = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rotateIdx == <span class="number">-1</span> || target &lt; nums[<span class="number">0</span>] &#123;</span><br><span class="line">		idx := sort.SearchInts(nums[rotateIdx+<span class="number">1</span>:], target)</span><br><span class="line">		<span class="keyword">if</span> idx+rotateIdx+<span class="number">1</span> &lt; n &amp;&amp; nums[idx+rotateIdx+<span class="number">1</span>] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> idx + rotateIdx + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		idx := sort.SearchInts(nums[:rotateIdx+<span class="number">1</span>], target)</span><br><span class="line">		<span class="keyword">if</span> idx &lt; rotateIdx+<span class="number">1</span> &amp;&amp; nums[idx] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> idx</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>这个解法存在几个严重问题：</p>
<ol>
<li>
<p><strong>数组越界风险</strong>：在使用 <code>sort.Search</code> 查找旋转点时，回调函数 <code>return nums[i] &gt; nums[i+1]</code> 可能导致数组越界。当 <code>i = n-1</code> 时，<code>nums[i+1]</code> 会访问超出数组范围的元素。</p>
</li>
<li>
<p><strong>标准二分搜索不适合查找旋转点</strong>：</p>
<ul>
<li><code>sort.Search</code> 假设数组满足某种单调性，查找第一个使谓词函数为true的索引</li>
<li>但在旋转数组中，<strong>谓词函数 <code>nums[i] &gt; nums[i+1]</code> 不具有预期的单调性</strong></li>
<li>对于完全有序的数组（如 <code>[1,2,3,4]</code>），不存在 <code>nums[i] &gt; nums[i+1]</code> 的情况，此时 <code>sort.Search</code> 会返回 <code>n</code>，超出数组有效范围</li>
</ul>
</li>
<li>
<p><strong>旋转点查找逻辑不完善</strong>：</p>
<ul>
<li>代码通过检查 <code>rotateIdx == n-1</code> 试图解决完全有序的情况，但这个修复不彻底且容易误判</li>
<li>当数组只有一个元素时也可能出现问题</li>
</ul>
</li>
<li>
<p><strong>复杂且不直观</strong>：这种&quot;先找旋转点再搜索&quot;的两步法使代码变得复杂，且容易出错</p>
</li>
</ol>
<h2 id="正确查找旋转点的方法">正确查找旋转点的方法</h2>
<p>如果确实需要先找到旋转点，下面是一个更可靠的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRotateIndex</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果数组完全有序（未旋转）</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] &lt;= nums[right] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// 或返回-1，表示无旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二分查找旋转点</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[right] &#123;</span><br><span class="line">            <span class="comment">// 旋转点在右半部分</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 旋转点在左半部分或就是mid</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left <span class="comment">// 此时left就是旋转点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个查找旋转点的算法基于以下观察：</p>
<ul>
<li>如果 <code>nums[mid] &gt; nums[right]</code>，说明旋转点在 <code>mid</code> 之后</li>
<li>否则，旋转点在 <code>mid</code> 或之前</li>
</ul>
<p>与 <code>sort.Search</code> 不同，这个算法明确利用了旋转数组的特性，不依赖于索引访问的单调性，也不会有数组越界问题。</p>
<h2 id="最优解法：一步到位">最优解法：一步到位</h2>
<p>一个更优雅的解决方案是利用旋转排序数组的一个关键特性：<strong>将数组一分为二，至少有一半是有序的</strong>。我们可以在二分查找的同时确定目标值的位置，无需先找到旋转点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 判断哪一部分是有序的</span></span><br><span class="line">		<span class="keyword">if</span> nums[left] &lt;= nums[mid] &#123; <span class="comment">// 左半部分有序</span></span><br><span class="line">			<span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;</span><br><span class="line">				<span class="comment">// target在左半部分</span></span><br><span class="line">				right = mid - <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// target在右半部分</span></span><br><span class="line">				left = mid + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 右半部分有序</span></span><br><span class="line">			<span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] &#123;</span><br><span class="line">				<span class="comment">// target在右半部分</span></span><br><span class="line">				left = mid + <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// target在左半部分</span></span><br><span class="line">				right = mid - <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这个解法可以工作">为什么这个解法可以工作</h3>
<p>这个解法基于以下观察：</p>
<ol>
<li>
<p>在旋转排序数组中，无论如何切分，总有一部分是有序的</p>
<ul>
<li>如果 <code>nums[left] &lt;= nums[mid]</code>，则左半部分有序</li>
<li>否则，右半部分有序</li>
</ul>
</li>
<li>
<p>知道哪部分有序后，我们可以快速判断 target 是否在有序部分范围内：</p>
<ul>
<li>如果 target 在有序部分范围内，我们只需在该部分继续搜索</li>
<li>否则，target 必然在另一部分中</li>
</ul>
</li>
<li>
<p>每次迭代都会将搜索范围缩小一半，保持了二分查找的 O(log n) 复杂度</p>
</li>
</ol>
<p>这种方法直接在二分查找过程中确定目标位置，无需先找到旋转点，代码更简洁，错误风险更小，从根本上避免了错误地应用标准二分查找来寻找旋转点。</p>
<h2 id="学习总结">学习总结</h2>
<p>从这个错误中，我们可以学到几个重要的算法设计原则：</p>
<ol>
<li>
<p><strong>谨慎使用标准库函数</strong>：</p>
<ul>
<li>像 <code>sort.Search</code> 这样的标准库函数有特定的应用场景和假设条件</li>
<li>在使用前，确保你的问题确实符合这些条件</li>
</ul>
</li>
<li>
<p><strong>防止数组越界</strong>：在编写涉及数组索引的代码时，始终要考虑边界条件，特别是使用 <code>i+1</code> 或 <code>i-1</code> 等操作时</p>
</li>
<li>
<p><strong>简化问题</strong>：有时候，看似需要两步的操作（先找旋转点，再查找目标）可以通过巧妙的算法设计合并为一步，使代码更简洁、更可靠</p>
</li>
<li>
<p><strong>利用问题特性</strong>：旋转排序数组的关键特性是&quot;部分有序&quot;，直接利用这一特性比试图恢复完全有序更高效</p>
</li>
<li>
<p><strong>二分查找的变种</strong>：标准二分查找可以根据具体问题进行调整，关键是每次都将搜索空间减半，同时保持目标值在搜索空间内</p>
</li>
</ol>
<p>这个问题提醒我们，在实现算法时，先思考问题的本质特性，往往能找到更简洁优雅的解法，而不是机械地套用标准算法模板。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 74 - 搜索二维矩阵 - 错误分析</title>
    <url>/2025/05/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p><a href="https://leetcode.cn/problems/search-a-2d-matrix/">LeetCode 74 - 搜索二维矩阵</a>是一个中等难度的二分查找问题。</p>
<p>题目要求在一个满足以下两个条件的 m × n 矩阵中，高效地查找目标值 target：</p>
<ol>
<li>每行中的整数从左到右按非严格递增顺序排列</li>
<li>每行的第一个整数大于前一行的最后一个整数</li>
</ol>
<p>需要判断 target 是否在矩阵中存在，存在返回 true，否则返回 false。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/2025/05/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/1746685273722.png" alt="1746685273722"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/2025/05/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/1746685282110.png" alt="1746685282110"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>$m = matrix.length$</li>
<li>$n = matrix[i].length$</li>
<li>$1 \leq m, n \leq 100$</li>
<li>$-10^4 \leq matrix[i][j], target \leq 10^4$</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>在解决这个问题时，我尝试了几种解法，但其中三个解法都存在错误。下面是对这些错误解法的详细分析。</p>
<h3 id="错误解法-1：错误的边界检查">错误解法 1：错误的边界检查</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	row := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> matrix[i][m<span class="number">-1</span>] &gt;= target</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ❌ 错误点：使用列数(m)而非行数(n)进行边界检查</span></span><br><span class="line">	<span class="keyword">if</span> row &gt;= m &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	col := sort.SearchInts(matrix[row], target)</span><br><span class="line">	<span class="keyword">return</span> matrix[row][col] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误原因分析：</strong></p>
<p>这个解法中的主要错误在于边界检查使用了列数而不是行数。在检查二分查找返回的行索引是否越界时，应该与矩阵的行数 <code>n</code> 进行比较，而不是列数 <code>m</code>。</p>
<p>当 <code>row &gt;= n</code> 时，表示找不到行满足条件（所有行的最后一个元素都小于 target），此时应该返回 false。</p>
<p>但是在错误代码中，使用了 <code>if row &gt;= m</code>，这会导致在特定情况下出现问题：</p>
<ul>
<li>当行数大于列数时（n &gt; m），如果 n &gt; row &gt;= m，会错误地返回 false</li>
<li>当行数小于列数时（n &lt; m），如果 row &gt;= n 但 row &lt; m，会继续执行导致数组索引越界</li>
</ul>
<p>这个错误的严重性取决于矩阵的形状，但在最坏情况下会导致程序崩溃。</p>
<h3 id="错误解法-2：错误的搜索策略和缺少边界检查">错误解法 2：错误的搜索策略和缺少边界检查</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// ❌ 错误点：错误的行选择策略</span></span><br><span class="line">	row := sort.Search(<span class="built_in">len</span>(matrix), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> matrix[i][<span class="number">0</span>] &gt;= target</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ❌ 错误点：缺少边界检查</span></span><br><span class="line">	col := sort.SearchInts(matrix[row], target)</span><br><span class="line">	<span class="keyword">return</span> matrix[row][col] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误原因分析：</strong></p>
<p>这个解法存在两个严重问题：</p>
<ol>
<li>
<p><strong>错误的搜索策略</strong>：这里使用的是找到第一个首元素大于等于 target 的行，这与问题的最优解法不符。由于矩阵的特性，我们应该找到最后一个最大元素小于等于 target 的行（即第一个最大元素大于 target 的行的前一行），或者找到第一个最大元素大于等于 target 的行。</p>
</li>
<li>
<p><strong>缺少边界检查</strong>：没有检查 <code>row</code> 是否越界。如果 target 大于矩阵中的所有元素，<code>sort.Search</code> 可能返回等于 <code>len(matrix)</code> 的值，直接使用这个索引会导致 <code>matrix[row]</code> 数组越界访问。</p>
</li>
</ol>
<p>这个错误解法在以下情况下会失败：</p>
<ul>
<li>当 target 大于矩阵中所有元素时（返回 <code>row = len(matrix)</code>）</li>
<li>当 target 小于矩阵中第一个元素时（可能找错行）</li>
</ul>
<h3 id="错误解法-3：对搜索结果处理不当">错误解法 3：对搜索结果处理不当</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">// ❌ 错误点1：使用了 &gt; 而不是 &gt;= 作为比较条件</span></span><br><span class="line">	row := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> matrix[i][m<span class="number">-1</span>] &gt; target</span><br><span class="line">	&#125;) - <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ❌ 错误点2：调试代码遗留在生产代码中</span></span><br><span class="line">	log.Println(row)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ❌ 错误点3：没有检查 row 是否有效（可能为负数）</span></span><br><span class="line">	col := sort.SearchInts(matrix[row], target)</span><br><span class="line">	<span class="keyword">return</span> matrix[row][col] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误原因分析：</strong></p>
<p>这个解法存在三个问题：</p>
<ol>
<li>
<p><strong>比较条件不当</strong>：使用了 <code>matrix[i][m-1] &gt; target</code> 而不是 <code>matrix[i][m-1] &gt;= target</code>。当我们寻找第一个最大元素大于等于 target 的行时，这可能导致找错行，特别是当 target 恰好等于某行的最后一个元素时。</p>
</li>
<li>
<p><strong>未处理边界情况</strong>：直接对 <code>sort.Search</code> 的结果减 1，但没有检查是否会导致 <code>row</code> 变为负数。如果 target 小于矩阵中的第一个元素，<code>sort.Search</code> 会返回 0，减 1 后变成 -1，这会导致索引越界。</p>
</li>
<li>
<p><strong>调试代码</strong>：保留了 <code>log.Println(row)</code> 调试语句，这在生产代码中是不适当的。</p>
</li>
</ol>
<p>这个错误解法在以下情况下会导致错误或程序崩溃：</p>
<ul>
<li>当 target 小于矩阵中的第一个元素时，会导致 row = -1，引起数组越界</li>
<li>当 target 等于某行的最后一个元素时，可能会找错行</li>
</ul>
<h2 id="正确解法">正确解法</h2>
<p>经过分析，我改进的解法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	n, m := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 查找第一个最后元素大于等于target的行</span></span><br><span class="line">	row := sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> matrix[i][m<span class="number">-1</span>] &gt;= target</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 行索引越界，表示所有行的最后元素都小于target</span></span><br><span class="line">	<span class="keyword">if</span> row &gt;= n &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在找到的行中二分查找target</span></span><br><span class="line">	col := sort.SearchInts(matrix[row], target)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 确保列索引在范围内并且元素等于target</span></span><br><span class="line">	<span class="keyword">return</span> col &lt; m &amp;&amp; matrix[row][col] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这个解法可以工作">为什么这个解法可以工作</h3>
<ol>
<li>
<p><strong>正确的搜索策略</strong>：使用 <code>matrix[i][m-1] &gt;= target</code> 作为条件，找到第一个最大元素大于等于 target 的行。根据矩阵性质，如果 target 存在，它一定在这一行。</p>
</li>
<li>
<p><strong>完整的边界检查</strong>：</p>
<ul>
<li>检查 <code>row &gt;= n</code>，确保找到的行索引在矩阵范围内</li>
<li>隐式检查 <code>col &lt; m</code>，确保找到的列索引在行范围内（虽然在这道题中由于 <code>sort.SearchInts</code> 的特性，这个检查可以省略，但保留它是个好习惯）</li>
</ul>
</li>
<li>
<p><strong>正确的返回条件</strong>：当且仅当 <code>matrix[row][col] == target</code> 时返回 true，确保找到的位置确实包含目标值。</p>
</li>
</ol>
<h2 id="关于-Go-中的-sort-Search-和-sort-SearchInts">关于 Go 中的 sort.Search 和 sort.SearchInts</h2>
<p>这些错误的根源之一是对 Go 标准库中二分查找函数的误用或误解：</p>
<ol>
<li>
<p><strong>sort.Search(n, f)</strong> 返回 <code>[0,n)</code> 范围内第一个使 <code>f(i)=true</code> 的索引 i。如果没有这样的索引，返回 n。</p>
</li>
<li>
<p><strong>sort.SearchInts(a, x)</strong> 返回有序切片 a 中第一个大于等于 x 的元素的索引。如果所有元素都小于 x，则返回 <code>len(a)</code>。</p>
</li>
</ol>
<p>使用这些函数时的关键注意事项：</p>
<ul>
<li><strong>范围检查</strong>：必须检查 <code>sort.Search</code> 和 <code>sort.SearchInts</code> 的返回值是否在有效范围内</li>
<li><strong>边界条件</strong>：理解当目标不在数组中时的行为</li>
<li><strong>调整索引</strong>：有些情况下需要调整返回的索引（如减1），但必须小心处理可能的负值</li>
</ul>
<h2 id="学习总结">学习总结</h2>
<p>从这个问题中，我学到了几个关键教训：</p>
<ol>
<li>
<p><strong>始终检查边界条件</strong>：在使用二分查找或任何索引相关操作时，必须确保索引在有效范围内。</p>
</li>
<li>
<p><strong>理解库函数行为</strong>：深入理解标准库函数的行为，特别是它们在边缘情况下的返回值。</p>
</li>
<li>
<p><strong>选择正确的搜索策略</strong>：根据问题特性选择最合适的搜索方法。在这个问题中，理解矩阵的排序特性是找到高效解法的关键。</p>
</li>
<li>
<p><strong>调整索引时要谨慎</strong>：当需要对搜索结果进行调整（如减1）时，必须考虑这可能导致的边界问题。</p>
</li>
<li>
<p><strong>移除调试代码</strong>：在提交最终解决方案前，确保移除所有调试语句。</p>
</li>
</ol>
<p>这些考虑点不仅适用于这个特定问题，也适用于所有涉及索引操作和二分查找的算法问题。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 35 - 搜索插入位置与Go语言二分搜索全解析</title>
    <url>/2025/05/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 $O(log n)$ 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^4$</li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
<li>nums 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>
<li>$-10^4 &lt;= target &lt;= 10^4$</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题要求我们在排序数组中找到目标值的位置，如果目标值不存在，则返回它应该被插入的位置。由于题目要求算法时间复杂度为 O(log n)，很明显需要使用二分搜索。</p>
<p>对于此类问题，我们需要找到<strong>第一个大于等于目标值</strong>的元素索引，这正是二分搜索的一个常见应用场景。</p>
<h3 id="二分搜索基本原理">二分搜索基本原理</h3>
<p>二分搜索的基本思想是将查找范围逐步缩小为原来的一半，直到找到目标元素或确定目标元素不存在。具体步骤如下：</p>
<ol>
<li>设置左边界 <code>left = 0</code> 和右边界 <code>right = n - 1</code></li>
<li>当 <code>left &lt;= right</code> 时，计算中间位置 <code>mid = left + (right - left) / 2</code></li>
<li>如果 <code>nums[mid] == target</code>，返回 <code>mid</code></li>
<li>如果 <code>nums[mid] &lt; target</code>，说明目标在右半部分，设置 <code>left = mid + 1</code></li>
<li>如果 <code>nums[mid] &gt; target</code>，说明目标在左半部分，设置 <code>right = mid - 1</code></li>
<li>如果循环结束后仍未找到目标，那么 <code>left</code> 就是目标值应该插入的位置</li>
</ol>
<h2 id="Go语言中的二分搜索">Go语言中的二分搜索</h2>
<p>Go语言标准库中的 <code>sort</code> 包提供了一系列的二分搜索函数，非常适合用来解决此类问题。接下来，让我们详细介绍这些函数。</p>
<h3 id="1-sort-Search-通用二分搜索函数">1. sort.Search - 通用二分搜索函数</h3>
<p><code>sort.Search</code> 是Go语言二分搜索的核心函数，其他几个搜索函数都是基于它实现的。其函数签名为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">bool</span>) <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>这个函数在<code>[0, n)</code>范围内搜索，返回使函数 <code>f(i)</code> 首次返回 <code>true</code> 的最小索引 <code>i</code>。如果没有这样的索引，则返回 <code>n</code>。</p>
<p><strong>重要特性：</strong></p>
<ul>
<li>函数 <code>f</code> 必须满足对于某个索引 <code>k</code>，当 <code>i &lt; k</code> 时，<code>f(i) = false</code>；当 <code>i &gt;= k</code> 时，<code>f(i) = true</code></li>
<li>如果对于所有的 <code>i</code> 都有 <code>f(i) = false</code>，则返回 <code>n</code></li>
<li>如果对于所有的 <code>i</code> 都有 <code>f(i) = true</code>，则返回 <code>0</code></li>
</ul>
<p>这个函数非常灵活，可以用来实现各种二分搜索变体。</p>
<h3 id="2-sort-SearchInts-整数切片搜索">2. sort.SearchInts - 整数切片搜索</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="type">int</span>, x <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p><code>SearchInts</code> 在已排序的整数切片 <code>a</code> 中搜索 <code>x</code>，返回 <code>x</code> 应该插入的位置（即第一个大于等于 <code>x</code> 的元素的位置）。如果 <code>a</code> 中所有元素都小于 <code>x</code>，则返回 <code>len(a)</code>。</p>
<h3 id="3-sort-SearchFloat64s-浮点数切片搜索">3. sort.SearchFloat64s - 浮点数切片搜索</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="type">float64</span>, x <span class="type">float64</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p><code>SearchFloat64s</code> 在已排序的浮点数切片 <code>a</code> 中搜索 <code>x</code>，用法与 <code>SearchInts</code> 类似。</p>
<h3 id="4-sort-SearchStrings-字符串切片搜索">4. sort.SearchStrings - 字符串切片搜索</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="type">string</span>, x <span class="type">string</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p><code>SearchStrings</code> 在已排序的字符串切片 <code>a</code> 中搜索 <code>x</code>，用法与 <code>SearchInts</code> 类似。</p>
<h3 id="5-自定义比较函数搜索">5. 自定义比较函数搜索</h3>
<p>对于复杂的数据结构，可以结合 <code>sort.Search</code> 和自定义比较函数来实现二分搜索。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="方法一：使用-sort-Search">方法一：使用 sort.Search</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> sort.Search(n, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现非常简洁，使用 <code>sort.Search</code> 函数查找第一个大于等于 <code>target</code> 的元素索引。判断函数 <code>func(i int) bool &#123; return nums[i] &gt;= target &#125;</code> 用于确定索引 <code>i</code> 处的元素是否大于等于目标值。</p>
<h3 id="方法二：手写二分搜索">方法二：手写二分搜索</h3>
<p>虽然Go标准库的<code>sort.Search</code>非常强大且简洁，但在面试或需要高度自定义的场景中，手写二分搜索仍然是一项必备技能。</p>
<p>下面是针对本题&quot;查找第一个大于等于目标值的元素&quot;的经典实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环终止条件 left &gt; right</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		<span class="comment">// mid := left + (right-left)&gt;&gt;1 可防止left+right溢出</span></span><br><span class="line">		mid := (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果 mid 的值大于等于 target，说明目标在左半部分或就是 mid</span></span><br><span class="line">		<span class="comment">// 我们不能排除 mid，所以尝试在 [left, mid-1] 中继续寻找更靠前的插入点</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &gt;= target &#123;</span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果 mid 的值小于 target，说明目标必定在右半部分</span></span><br><span class="line">			<span class="comment">// mid 以及其左边的元素都可以被排除，所以从 [mid+1, right] 继续寻找</span></span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环结束后，left 就是目标值应该插入的位置</span></span><br><span class="line">	<span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现是经典的二分搜索算法。当循环结束时，<code>left</code> 就是目标值应该插入的位置。</p>
<h3 id="手写二分搜索深度解析">手写二分搜索深度解析</h3>
<p>上面的代码虽然简洁，但包含了很多二分搜索的细节。为了彻底理解它，我们来拆解一下：</p>
<h4 id="1-核心问题转化">1. 核心问题转化</h4>
<p>首先，我们要把原问题&quot;如果找到就返回索引，如果找不到就返回插入位置&quot;转化为一个更清晰的数学表述：<strong>在有序数组中，查找第一个大于或等于 <code>target</code> 的元素的索引</strong>。</p>
<p>不信可以试试：</p>
<ul>
<li>对于 <code>[1,3,5,6]</code> 和 <code>target = 5</code>，第一个大于等于5的元素是5，索引为2。</li>
<li>对于 <code>[1,3,5,6]</code> 和 <code>target = 2</code>，第一个大于等于2的元素是3，索引为1。</li>
<li>对于 <code>[1,3,5,6]</code> 和 <code>target = 7</code>，数组中没有大于等于7的元素，但如果插入，它应该在所有元素之后，也就是索引4的位置。</li>
</ul>
<h4 id="2-定义与维护搜索区间-left-right">2. 定义与维护搜索区间 <code>[left, right]</code></h4>
<ul>
<li><strong>定义</strong>：我们采用闭区间 <code>[left, right]</code> 来定义搜索范围。这意味着在每一轮循环开始时，我们都假设要找的答案位于 <code>nums[left]</code> 到 <code>nums[right]</code>（包含边界）之间。</li>
<li><strong>初始化</strong>：<code>left = 0</code>, <code>right = len(nums) - 1</code>，初始搜索区间覆盖整个数组。</li>
<li><strong>循环条件</strong>：<code>left &lt;= right</code>。只要区间有效（<code>left</code> 不大于 <code>right</code>），搜索就继续。当 <code>left == right</code> 时，区间还有一个元素 <code>nums[left]</code>，也需要被检查。当 <code>left</code> 最终越过 <code>right</code>（即 <code>left = right + 1</code>），循环终止，说明搜索区间为空。</li>
</ul>
<h4 id="3-区间收缩的精髓">3. 区间收缩的精髓</h4>
<p>这是二分查找最核心的逻辑，我们的目标是每一步都安全地排除掉一半的元素。</p>
<ul>
<li><code>mid := (left + right) &gt;&gt; 1</code>: 计算中间点。</li>
<li><code>if nums[mid] &gt;= target</code>:
<ul>
<li><strong>含义</strong>：<code>nums[mid]</code> 这个元素<strong>有可能是我们要找的答案</strong>（比如它就是第一个大于等于<code>target</code>的元素），或者真正的答案在它的<strong>左边</strong>。</li>
<li><strong>操作</strong>：我们不能排除 <code>mid</code>，但可以肯定地说，<code>mid</code> 右边的所有元素都<strong>不是</strong>我们要找的&quot;第一个&quot;大于等于<code>target</code>的元素。因此，我们将搜索范围收缩到左半部分，即 <code>right = mid - 1</code>。我们期待在 <code>[left, mid - 1]</code> 这个新区间里找到一个更靠前的、符合条件的位置。</li>
</ul>
</li>
<li><code>else</code>: (<code>nums[mid] &lt; target</code>)
<ul>
<li><strong>含义</strong>：<code>nums[mid]</code> 比 <code>target</code> 还小，那么 <code>mid</code> 以及 <code>mid</code> 左边的所有元素<strong>都不可能是</strong>我们要找的答案。</li>
<li><strong>操作</strong>：我们必须去右边寻找。将搜索范围收缩到右半部分，即 <code>left = mid + 1</code>。</li>
</ul>
</li>
</ul>
<h4 id="4-深度剖析：为什么最后返回-left？">4. 深度剖析：为什么最后返回 <code>left</code>？</h4>
<p>你问到了最关键的问题。要彻底想明白，我们需要引入一个编程中证明算法正确性的强大思想：<strong>循环不变量 (Loop Invariant)</strong>。</p>
<p>循环不变量是一个在循环开始前为真，并且在每次循环迭代后依然保持为真的性质。如果能找到一个合适的不变量，并证明它在循环结束后能引导我们得到正确答案，那么算法的正确性就得到了保证。</p>
<p>对于我们的二分搜索，我们可以定义这样一组不变量：</p>
<blockquote>
<p>在 <code>for left &lt;= right</code> 循环的<strong>每一次迭代开始前</strong>，<code>left</code> 和 <code>right</code> 指针都满足以下两个条件：</p>
<ol>
<li><code>left</code> 指针左侧的所有元素（即 <code>nums[0...left-1]</code>）都 <strong>严格小于</strong> <code>target</code>。</li>
<li><code>right</code> 指针右侧的所有元素（即 <code>nums[right+1...n-1]</code>）都 <strong>大于等于</strong> <code>target</code>。</li>
</ol>
</blockquote>
<p>我们来验证一下这个不变量是否成立：</p>
<ul>
<li>
<p><strong>初始化</strong>:</p>
<ul>
<li>循环开始前，<code>left = 0</code>, <code>right = n-1</code>。</li>
<li><code>nums[0...-1]</code> 是一个空区间，所以&quot;所有元素都小于 <code>target</code>&quot;的说法天然成立。</li>
<li><code>nums[n...n-1]</code> 也是一个空区间，所以&quot;所有元素都大于等于 <code>target</code>&quot;也天然成立。</li>
<li><strong>结论</strong>：不变量在循环开始前是成立的。</li>
</ul>
</li>
<li>
<p><strong>保持 (Maintenance)</strong>:</p>
<ul>
<li>假设在某一次循环开始时，不变量是成立的。我们来分析循环体内部的两种情况：
<ol>
<li><strong>当 <code>nums[mid] &lt; target</code> 时</strong>:
<ul>
<li>这意味着 <code>nums[mid]</code> 以及它左边的所有元素都小于 <code>target</code>。</li>
<li>我们执行 <code>left = mid + 1</code>。</li>
<li>在下一次循环开始时，新的 <code>left</code> 指针是 <code>mid + 1</code>。<code>left</code> 左边的区间变成了 <code>nums[0...mid]</code>，这个区间内的所有元素确实都小于 <code>target</code>。<code>right</code> 指针没变，所以不变量的第二部分依然成立。</li>
<li><strong>结论</strong>：不变量得以保持。</li>
</ul>
</li>
<li><strong>当 <code>nums[mid] &gt;= target</code> 时</strong>:
<ul>
<li>这意味着 <code>nums[mid]</code> 以及它右边的所有元素都大于等于 <code>target</code>。</li>
<li>我们执行 <code>right = mid - 1</code>。</li>
<li>在下一次循环开始时，新的 <code>right</code> 指针是 <code>mid - 1</code>。<code>right</code> 右边的区间变成了 <code>nums[mid...n-1]</code>，这个区间内的所有元素确实都大于等于 <code>target</code>。<code>left</code> 指针没变，所以不变量的第一部分依然成立。</li>
<li><strong>结论</strong>：不变量得以保持。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>终止 (Termination)</strong>:</p>
<ul>
<li>循环在 <code>left &gt; right</code> 时终止。此时，<code>left = right + 1</code>。</li>
<li>我们再来看一下不变量在这一刻告诉了我们什么：
<ol>
<li><code>left</code> 左侧的元素 <code>nums[0...left-1]</code> 都 <code>&lt; target</code>。</li>
<li><code>right</code> 右侧的元素 <code>nums[right+1...n-1]</code> 都 <code>&gt;= target</code>。</li>
</ol>
</li>
<li>因为 <code>left = right + 1</code>，所以第二条可以改写为：<code>nums[left...n-1]</code> 都 <code>&gt;= target</code>。</li>
<li>把两条合在一起看：
<ul>
<li><code>nums[left-1]</code> (如果存在) 是最后一个 <code>&lt; target</code> 的元素。</li>
<li><code>nums[left]</code> (如果存在) 是第一个 <code>&gt;= target</code> 的元素。</li>
</ul>
</li>
<li>因此，<code>left</code> 正是那个分割点，它指向的位置就是第一个大于或等于 <code>target</code> 的元素应该在的位置，也就是我们苦苦寻找的<strong>插入位置</strong>。</li>
</ul>
</li>
</ul>
<p>这个逻辑可能初看有点绕，但它是理解二分搜索所有变体的基石。通过维护这个清晰的&quot;&lt; target&quot;和&quot;&gt;= target&quot;的区间边界，我们最终就能精确地锁定目标位置。</p>
<h2 id="二分搜索的常见变体及应用场景">二分搜索的常见变体及应用场景</h2>
<p>二分搜索有多种变体，适用于不同的场景：</p>
<h3 id="1-查找值是否存在">1. 查找值是否存在</h3>
<p>这是最基本的二分搜索，用于确定一个值是否在有序数组中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">// 找到目标值，返回索引</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 目标值不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Go中可以使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">idx := sort.SearchInts(nums, target)</span><br><span class="line"><span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[idx] == target &#123;</span><br><span class="line">    <span class="comment">// 找到目标值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 目标值不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-查找第一个大于等于目标值的元素（本题）">2. 查找第一个大于等于目标值的元素（本题）</h3>
<p>查找第一个大于等于目标值的元素，是 <code>sort.Search</code> 和 <code>sort.SearchInts</code> 的默认行为。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用sort.Search</span></span><br><span class="line">idx := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用sort.SearchInts</span></span><br><span class="line">idx := sort.SearchInts(nums, target)</span><br></pre></td></tr></table></figure>
<h3 id="3-查找第一个大于目标值的元素">3. 查找第一个大于目标值的元素</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">idx := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt; target</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="4-查找最后一个小于等于目标值的元素">4. 查找最后一个小于等于目标值的元素</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">idx := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt; target</span><br><span class="line">&#125;) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> idx &gt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 找到了最后一个小于等于目标值的元素</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有小于等于目标值的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-查找最后一个小于目标值的元素">5. 查找最后一个小于目标值的元素</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">idx := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[i] &gt;= target</span><br><span class="line">&#125;) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> idx &gt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 找到了最后一个小于目标值的元素</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有小于目标值的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际应用场景">实际应用场景</h2>
<p>二分搜索在实际编程中有很多应用场景：</p>
<h3 id="1-旋转排序数组中的搜索（LeetCode-33）">1. 旋转排序数组中的搜索（LeetCode 33）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[left] &lt;= nums[mid] &#123;</span><br><span class="line">            <span class="comment">// 左半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右半部分有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] &#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-二分查找答案（二分答案）">2. 二分查找答案（二分答案）</h3>
<p>例如，求平方根（LeetCode 69）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    left, right := <span class="number">1</span>, x/<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid &lt;= x/mid &amp;&amp; (mid+<span class="number">1</span>) &gt; x/(mid+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> mid &gt; x/mid &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-查找峰值元素（LeetCode-162）">3. 查找峰值元素（LeetCode 162）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPeakElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>] &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-在2D矩阵中二分查找（LeetCode-240）">4. 在2D矩阵中二分查找（LeetCode 240）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rows, cols := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    row, col := <span class="number">0</span>, cols<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[row][col] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[row][col] &gt; target &#123;</span><br><span class="line">            col--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项和常见错误">注意事项和常见错误</h2>
<p>使用二分搜索时，有几个常见的注意事项和潜在错误：</p>
<ol>
<li>
<p><strong>整数溢出</strong>：计算中间索引时，应使用 <code>mid := left + (right-left)/2</code> 而不是 <code>mid := (left+right)/2</code>，后者在大数据范围时可能导致整数溢出。</p>
</li>
<li>
<p><strong>循环条件</strong>：根据需要选择 <code>left &lt;= right</code> 或 <code>left &lt; right</code>。前者在循环结束时有 <code>left = right + 1</code>，后者在循环结束时有 <code>left = right</code>。</p>
</li>
<li>
<p><strong>边界更新</strong>：根据不同的搜索需求，边界更新方式也不同。例如，查找第一个满足条件的元素时，可能需要 <code>right = mid</code>，而不是 <code>right = mid - 1</code>。</p>
</li>
<li>
<p><strong>判断函数设计</strong>：使用 <code>sort.Search</code> 时，判断函数必须满足单调性。</p>
</li>
<li>
<p><strong>返回值处理</strong>：当使用 <code>sort.Search</code> 或 <code>sort.SearchInts</code> 等函数时，需要检查返回的索引是否在有效范围内。</p>
</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<p>对于二分搜索：</p>
<ul>
<li>时间复杂度：$O(\log n)$，其中 $n$ 是数组的长度。每次操作都会将搜索范围缩小为原来的一半。</li>
<li>空间复杂度：$O(1)$，只使用了常数额外空间。</li>
</ul>
<h2 id="总结">总结</h2>
<p>二分搜索是一种强大的算法技术，Go语言的标准库提供了多种便捷的二分搜索函数。通过本文的示例和解析，我们不仅解决了LeetCode 35题，还深入学习了Go语言中二分搜索的各种变体和应用场景。</p>
<p><strong>关键收获：</strong></p>
<ol>
<li>掌握 <code>sort.Search</code> 及其变体函数的用法和特性</li>
<li>了解五种常见的二分搜索变体及其适用场景</li>
<li>学会处理二分搜索中的边界条件和常见错误</li>
<li>掌握在实际编程中应用二分搜索的技巧</li>
</ol>
<p>记住，二分搜索不仅限于在数组中查找元素，还可以用于各种需要在有序空间中高效查找的场景，如二分答案、查找边界等。灵活运用这种算法技术，将大大提高我们解决问题的效率。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>Go</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL: 可重复读隔离级别完全解决幻读了吗？</title>
    <url>/2025/05/07/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-07-MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<h1>MySQL 可重复读隔离级别，完全解决幻读了吗？</h1>
<blockquote>
<p><strong>核心结论：</strong> MySQL 的可重复读隔离级别很大程度上避免了幻读，但并没有完全解决。</p>
</blockquote>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB">1. 什么是幻读？</a></li>
<li><a href="#mysql-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB">2. MySQL 如何避免幻读</a>
<ul>
<li><a href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%9A%84">2.1 快照读的解决方案</a></li>
<li><a href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%9A%84">2.2 当前读的解决方案</a></li>
</ul>
</li>
<li><a href="#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">3. 幻读是否被完全解决</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF">3.1 幻读场景一：更新后可见</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF">3.2 幻读场景二：混用读取方式</a></li>
</ul>
</li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">4. 避免幻读的最佳实践</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">5. 总结与关键点</a></li>
</ul>
<p>我在<a href="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">上一篇文章</a>提到，MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但它只是很大程度上避免了幻读现象（并不是完全解决）。InnoDB 提供了两种不同的机制来解决幻读：</p>
<blockquote>
<p><strong>防止幻读的两种机制：</strong></p>
<ul>
<li>针对<strong>快照读</strong>：使用 <strong>MVCC</strong> 机制</li>
<li>针对<strong>当前读</strong>：使用 <strong>next-key lock</strong> (记录锁+间隙锁)</li>
</ul>
</blockquote>
<p>这两个解决方案虽然能处理大多数场景，但仍有特殊情况会出现幻读。本文将深入分析这个问题。</p>
<h2 id="什么是幻读？">什么是幻读？</h2>
<p><strong>幻读定义</strong>：当同一事务内，相同的查询在不同时间点返回不同的结果集时产生的现象。</p>
<blockquote>
<p><strong>MySQL 官方文档解释：</strong><br>
“<em>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.</em>”</p>
<p>翻译：当同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是&quot;幻像&quot;行。</p>
</blockquote>
<h3 id="幻读的简单判断标准">幻读的简单判断标准</h3>
<p>如果一个事务在 T1 和 T2 两个时刻执行完全相同的查询，结果不同就是幻读：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设在T1和T2时刻分别执行相同查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>幻读的表现形式：</p>
<ul>
<li>前一次查询有 5 条记录，后一次变成了 6 条记录 ⟹ 幻读</li>
<li>前一次查询有 5 条记录，后一次变成了 4 条记录 ⟹ 也是幻读</li>
</ul>
<h2 id="MySQL-如何避免幻读">MySQL 如何避免幻读</h2>
<h3 id="快照读是如何避免幻读的？">快照读是如何避免幻读的？</h3>
<p><strong>快照读原理：</strong> InnoDB 通过 MVCC（多版本并发控制）实现可重复读隔离级别。</p>
<p>🔍 <strong>MVCC 工作流程图：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务开始 ➡️ 创建ReadView ➡️ 后续查询使用相同ReadView ➡️ 保证数据一致性</span><br></pre></td></tr></table></figure>
<p>关键机制：</p>
<ol>
<li>事务<strong>启动后第一次查询</strong>创建一个 Read View</li>
<li>后续查询<strong>复用这个 Read View</strong></li>
<li>通过 Read View 在 undo log 版本链中找到<strong>事务开始时的数据版本</strong></li>
<li>即使其他事务插入新数据，也<strong>不会被看到</strong></li>
</ol>
<h4 id="实验演示">实验演示</h4>
<p>表 t_stu 数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小林</td>
<td>50</td>
</tr>
<tr>
<td>2</td>
<td>小明</td>
<td>60</td>
</tr>
<tr>
<td>3</td>
<td>小红</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>小蓝</td>
<td>80</td>
</tr>
</tbody>
</table>
<p>事务执行顺序：</p>
<p><img src="/2025/05/07/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-07-MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%BB%E8%AF%BB/1746620825818.png" alt="1746620825818"></p>
<blockquote>
<p><strong>快照读结论：</strong> 即使事务 B 中途插入了新记录，事务 A 的两次查询结果仍然一致，成功避免了幻读。</p>
</blockquote>
<h3 id="当前读是如何避免幻读的？">当前读是如何避免幻读的？</h3>
<p><strong>当前读的特点</strong>：总是读取数据的最新版本。</p>
<p>属于当前读的操作：</p>
<ul>
<li><code>SELECT ... FOR UPDATE</code></li>
<li><code>UPDATE</code></li>
<li><code>INSERT</code></li>
<li><code>DELETE</code></li>
</ul>
<p>当前读必须读取最新数据的原因：避免数据冲突（如更新已被删除的记录）。</p>
<h4 id="为什么当前读可能导致幻读">为什么当前读可能导致幻读</h4>
<p>如果不加任何限制，当前读会出现这种情况：</p>
<p><img src="/2025/05/07/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-07-MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%BB%E8%AF%BB/1746620834159.png" alt="1746620834159"></p>
<blockquote>
<p><strong>问题：</strong> 事务 A 的两次查询返回不同结果，出现了幻读。</p>
</blockquote>
<h4 id="InnoDB-的解决方案：间隙锁">InnoDB 的解决方案：间隙锁</h4>
<p>为解决当前读的幻读问题，InnoDB 引入了<strong>间隙锁（Gap Lock）</strong>：</p>
<p><img src="/2025/05/07/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-07-MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%BB%E8%AF%BB/1746620841733.png" alt="1746620841733"></p>
<p><strong>next-key lock 工作原理：</strong></p>
<p><img src="/2025/05/07/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-07-MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%BB%E8%AF%BB/1746620850469.png" alt="1746620850469"></p>
<ol>
<li>事务 A 执行 <code>SELECT ... FOR UPDATE</code> 时加上 next-key lock (id 范围: (2, +∞])</li>
<li>事务 B 尝试插入记录时，发现区间被锁</li>
<li>事务 B 生成插入意向锁并等待</li>
<li>直到事务 A 提交，事务 B 才能插入</li>
</ol>
<blockquote>
<p><strong>间隙锁总结:</strong> 通过锁定可能插入记录的间隙，阻止其他事务插入数据，从而避免幻读。</p>
</blockquote>
<h2 id="幻读被完全解决了吗？">幻读被完全解决了吗？</h2>
<div style="background-color: #f8f9fa; padding: 10px; border-left: 4px solid #e7505a; margin: 15px 0;">
<strong>结论：</strong> 可重复读隔离级别很大程度上避免了幻读，但仍有特殊场景会发生幻读。
</div>
<h3 id="第一个发生幻读现象的场景">第一个发生幻读现象的场景</h3>
<p><strong>场景描述：</strong> 快照读 + 更新操作导致的特殊幻读</p>
<p>实验表数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>小林</td>
<td>50</td>
</tr>
<tr>
<td>2</td>
<td>小明</td>
<td>60</td>
</tr>
<tr>
<td>3</td>
<td>小红</td>
<td>70</td>
</tr>
<tr>
<td>4</td>
<td>小蓝</td>
<td>80</td>
</tr>
</tbody>
</table>
<p><strong>步骤 1：</strong> 事务 A 查询不存在的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>步骤 2：</strong> 事务 B 插入该记录并提交</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 B</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert into</span> t_stu <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;小美&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>步骤 3：</strong> 事务 A 更新并查询该记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_stu <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小林 coding&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 小林coding   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>时序图：</strong></p>
<p><img src="/2025/05/07/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-07-MySQL-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%BB%E8%AF%BB/1746620883100.png" alt="1746620883100"></p>
<blockquote>
<p><strong>特殊幻读原因：</strong> 当事务 A 更新 id=5 的记录后，该记录的事务 ID 变成了事务 A 的 ID，因此在事务 A 中也变得可见，导致前后查询结果不一致。</p>
</blockquote>
<h3 id="第二个发生幻读现象的场景">第二个发生幻读现象的场景</h3>
<p><strong>场景描述：</strong> 混合使用快照读和当前读</p>
<p><strong>步骤：</strong></p>
<ol>
<li>T1 时刻：事务 A 执行快照读语句 <code>SELECT * FROM t_test WHERE id &gt; 100</code> 得到 3 条记录</li>
<li>T2 时刻：事务 B 插入一条 id=200 的记录并提交</li>
<li>T3 时刻：事务 A 执行当前读语句 <code>SELECT * FROM t_test WHERE id &gt; 100 FOR UPDATE</code> 得到 4 条记录</li>
</ol>
<blockquote>
<p><strong>混合读取问题：</strong> 同一事务内混用快照读和当前读，会因为读取数据的机制不同而导致幻读。</p>
</blockquote>
<h2 id="避免幻读的最佳实践">避免幻读的最佳实践</h2>
<div style="background-color: #f0f8ff; padding: 10px; border-left: 4px solid #4285f4; margin: 15px 0;">
<strong>推荐做法：</strong> 在事务开始后，立即执行当前读操作，锁定相关记录范围。
</div>
<p>具体建议：</p>
<ol>
<li>使用 <code>SELECT ... FOR UPDATE</code> 锁定目标数据范围</li>
<li>保持事务简短，避免长时间持有锁</li>
<li>避免在同一事务中混用快照读和当前读</li>
<li>如果不需要避免幻读，考虑使用&quot;读已提交&quot;隔离级别提高并发性</li>
</ol>
<h2 id="总结">总结</h2>
<h3 id="幻读问题的解决方案对比">幻读问题的解决方案对比</h3>
<table>
<thead>
<tr>
<th>查询类型</th>
<th>解决机制</th>
<th>是否完全解决</th>
<th>限制条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>快照读</td>
<td>MVCC 机制</td>
<td>否</td>
<td>更新操作会使新记录在事务内可见</td>
</tr>
<tr>
<td>当前读</td>
<td>next-key 锁</td>
<td>否</td>
<td>需要在事务开始时就执行当前读</td>
</tr>
</tbody>
</table>
<h3 id="关键要点">关键要点</h3>
<ol>
<li>
<p>MySQL InnoDB 的可重复读隔离级别采用两种机制避免幻读：</p>
<ul>
<li>快照读：使用 MVCC 机制</li>
<li>当前读：使用 next-key 锁（记录锁+间隙锁）</li>
</ul>
</li>
<li>
<p>幻读仍可能在以下场景出现：</p>
<ul>
<li>事务内对其他事务新插入的记录执行更新操作</li>
<li>同一事务内混用快照读和当前读</li>
</ul>
</li>
<li>
<p>避免幻读的最佳实践：</p>
<ul>
<li>尽量在事务开始后立即使用 <code>SELECT ... FOR UPDATE</code> 锁定相关记录</li>
<li>保持事务简短，减少锁冲突</li>
<li>明确业务需求，选择合适的隔离级别</li>
</ul>
</li>
</ol>
<div style="background-color: #fef9e6; padding: 10px; border-left: 4px solid #f1c40f; margin: 15px 0;">
<strong>记住：</strong> MySQL的可重复读隔离级别并非完全解决了幻读，而是在大多数常见场景下避免了幻读。了解其工作原理和边界情况，才能设计出更可靠的数据库应用。
</div>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>事务隔离级别</tag>
        <tag>幻读</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 52 - N皇后 II（N-Queens II）</title>
    <url>/2025/05/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-52-N%E7%9A%87%E5%90%8E-II/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>N皇后 II 是 <a href="/2025/05/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-51-N%E7%9A%87%E5%90%8E/">N皇后问题</a> 的延伸。不同的是，这道题只需要返回不同解决方案的<strong>数量</strong>，而不需要返回具体的解决方案。</p>
<p>与N皇后问题相同，规则如下：</p>
<ul>
<li>皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子</li>
<li>需要将N个皇后放置在N×N的棋盘上，使皇后彼此不能相互攻击</li>
<li>给你一个整数N，返回所有不同解决方案的数量</li>
</ul>
<h3 id="示例-1">示例 1</h3>
<p><strong>输入</strong>：n = 4<br>
<strong>输出</strong>：2</p>
<p><strong>解释</strong>：如同N皇后问题所示，4皇后问题共有两种解法。</p>
<h3 id="示例-2">示例 2</h3>
<p><strong>输入</strong>：n = 1<br>
<strong>输出</strong>：1</p>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>1 &lt;= n &lt;= 9</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题与<a href="/2025/05/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-51-N%E7%9A%87%E5%90%8E/">N皇后问题</a>的核心算法相同，区别在于：</p>
<ol>
<li>不需要记录棋盘的具体摆放方式</li>
<li>只需要计算解的数量</li>
<li>可以更进一步使用位运算优化空间复杂度</li>
</ol>
<h3 id="基础解法">基础解法</h3>
<p>基础解法与N皇后问题类似，使用回溯算法：</p>
<ol>
<li>使用三个布尔数组记录行、主对角线、副对角线的占用情况</li>
<li>按列递归，对于每一列尝试在各行放置皇后</li>
<li>当成功放置N个皇后时，解的计数器加1</li>
<li>回溯过程中撤销对行和对角线的标记</li>
</ol>
<p>此处我们直接跳过具体的棋盘表示，仅使用计数器记录解的数量。</p>
<h3 id="位运算优化">位运算优化</h3>
<p><strong>核心洞见</strong>：我们可以使用整数的二进制位代替布尔数组，进一步优化空间复杂度。</p>
<p>在位运算解法中：</p>
<ol>
<li>使用一个整数的二进制位表示每一行是否已放置皇后</li>
<li>同样使用整数表示主对角线和副对角线的占用情况</li>
<li>通过位操作高效地检查位置可用性和更新状态</li>
</ol>
<p>位运算的关键操作：</p>
<ul>
<li>检查位置可用性：<code>(~(rows | diags1 | diags2)) &amp; (1 &lt;&lt; i)</code></li>
<li>标记占用：<code>rows |= (1 &lt;&lt; i)</code></li>
<li>撤销标记：<code>rows &amp;= ~(1 &lt;&lt; i)</code></li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="标准回溯实现">标准回溯实现</h3>
<p>与N皇后问题相比，我们不再需要构建棋盘，只需计数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 标记数组，记录已占用的行和对角线</span></span><br><span class="line">    rowUsed := <span class="built_in">make</span>([]<span class="type">bool</span>, n)          <span class="comment">// 标记行是否已被占用</span></span><br><span class="line">    mainDiagUsed := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="number">2</span>*n)   <span class="comment">// 标记主对角线是否已被占用</span></span><br><span class="line">    subDiagUsed := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="number">2</span>*n)    <span class="comment">// 标记副对角线是否已被占用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解的计数器</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS函数，col表示当前处理的列</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(col <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(col <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果所有列都已处理，找到一个解</span></span><br><span class="line">        <span class="keyword">if</span> col == n &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试在当前列的每一行放置皇后</span></span><br><span class="line">        <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; n; row++ &#123;</span><br><span class="line">            <span class="comment">// 检查位置(row, col)是否安全</span></span><br><span class="line">            <span class="keyword">if</span> rowUsed[row] || mainDiagUsed[row+col] || subDiagUsed[n+row-col] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 标记占用</span></span><br><span class="line">            rowUsed[row] = <span class="literal">true</span></span><br><span class="line">            mainDiagUsed[row+col] = <span class="literal">true</span></span><br><span class="line">            subDiagUsed[n+row-col] = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归处理下一列</span></span><br><span class="line">            dfs(col + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 回溯：撤销标记</span></span><br><span class="line">            rowUsed[row] = <span class="literal">false</span></span><br><span class="line">            mainDiagUsed[row+col] = <span class="literal">false</span></span><br><span class="line">            subDiagUsed[n+row-col] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第0列开始DFS</span></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="位运算优化实现">位运算优化实现</h3>
<p>现在，让我们使用位运算来优化解法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 解的计数器</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用位运算实现的DFS</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(col, rows, diags1, diags2 <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(col, rows, diags1, diags2 <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 完成了N列的放置，找到一个解</span></span><br><span class="line">        <span class="keyword">if</span> col == n &#123;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算当前列所有可放置皇后的位置</span></span><br><span class="line">        <span class="comment">// ~(rows | diags1 | diags2) 表示所有可用的位置（值为1的位）</span></span><br><span class="line">        <span class="comment">// &amp; ((1 &lt;&lt; n) - 1) 确保只考虑棋盘范围内的位（n位）</span></span><br><span class="line">        availablePositions := ^(rows | diags1 | diags2) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逐一尝试可放置的位置</span></span><br><span class="line">        <span class="keyword">for</span> availablePositions &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 获取最低位的1（表示一个可放置的位置）</span></span><br><span class="line">            position := availablePositions &amp; -availablePositions</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将这个位从可用位置中移除</span></span><br><span class="line">            availablePositions ^= position</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归处理下一列</span></span><br><span class="line">            <span class="comment">// rows | position: 更新已占用的行</span></span><br><span class="line">            <span class="comment">// (diags1 | position) &lt;&lt; 1: 更新主对角线，左移模拟对角线移动</span></span><br><span class="line">            <span class="comment">// (diags2 | position) &gt;&gt; 1: 更新副对角线，右移模拟对角线移动</span></span><br><span class="line">            dfs(col+<span class="number">1</span>, rows|position, (diags1|position)&lt;&lt;<span class="number">1</span>, (diags2|position)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不需要显式回溯，因为我们传递的是值而不是引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从第0列开始，初始时所有行和对角线都未被占用（都是0）</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="位运算解法详解">位运算解法详解</h2>
<p>位运算可能不那么直观，让我们详细解释其工作原理：</p>
<h3 id="状态表示">状态表示</h3>
<p>在位运算解法中，我们使用整数的二进制位来表示各行和对角线的占用情况：</p>
<ol>
<li><strong>rows</strong>：第i位表示第i行是否已放置皇后</li>
<li><strong>diags1</strong>：表示主对角线（左上至右下）的占用情况</li>
<li><strong>diags2</strong>：表示副对角线（右上至左下）的占用情况</li>
</ol>
<h3 id="位操作解释">位操作解释</h3>
<ol>
<li>
<p><strong>检查可用位置</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">availablePositions := ^(rows | diags1 | diags2) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rows | diags1 | diags2</code>：合并所有被占用的位</li>
<li><code>^</code>：按位取反，将0变为1，1变为0，这样1就表示可用位置</li>
<li><code>&amp; ((1 &lt;&lt; n) - 1)</code>：保留低n位，其他位置为0（因为棋盘大小为n）</li>
</ul>
</li>
<li>
<p><strong>获取一个可放置位置</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">position := availablePositions &amp; -availablePositions</span><br></pre></td></tr></table></figure>
<ul>
<li><code>availablePositions &amp; -availablePositions</code>：获取最低位的1，这是一个常用技巧</li>
<li>例如，如果 <code>availablePositions = 1010</code>，则 <code>-availablePositions = 0110</code>（二进制补码），<code>availablePositions &amp; -availablePositions = 0010</code></li>
</ul>
</li>
<li>
<p><strong>移除已使用的位置</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">availablePositions ^= position</span><br></pre></td></tr></table></figure>
<ul>
<li><code>^=</code>：按位异或，将已用位置从可用位置中移除</li>
</ul>
</li>
<li>
<p><strong>更新状态并递归</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dfs(col+<span class="number">1</span>, rows|position, (diags1|position)&lt;&lt;<span class="number">1</span>, (diags2|position)&gt;&gt;<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rows|position</code>：标记行为已使用</li>
<li><code>(diags1|position)&lt;&lt;1</code>：更新并左移主对角线占用状态</li>
<li><code>(diags2|position)&gt;&gt;1</code>：更新并右移副对角线占用状态</li>
</ul>
</li>
</ol>
<h3 id="位运算示例">位运算示例</h3>
<p>以棋盘大小n=4为例，显示第一步的操作：</p>
<ol>
<li>
<p>初始状态：</p>
<ul>
<li>rows = 0000（所有行未占用）</li>
<li>diags1 = 0000（所有主对角线未占用）</li>
<li>diags2 = 0000（所有副对角线未占用）</li>
</ul>
</li>
<li>
<p>检查第0列可放置位置：</p>
<ul>
<li>所有行都可用，availablePositions = 1111</li>
</ul>
</li>
<li>
<p>尝试在第0行第0列放置皇后：</p>
<ul>
<li>position = 0001（第0行）</li>
<li>更新状态：
<ul>
<li>rows = 0001</li>
<li>diags1 = 0010（左移）</li>
<li>diags2 = 0000（右移，最低位丢失）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>检查第1列可放置位置：</p>
<ul>
<li>rows | diags1 | diags2 = 0011</li>
<li>可用位置 = ~0011 &amp; 1111 = 1100（第2行和第3行）</li>
</ul>
</li>
</ol>
<p>依此类推，回溯过程会尝试所有可能的放置方式。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>两种实现的时间复杂度都是 $O(N!)$，因为：</p>
<ul>
<li>第一列有N个位置可选</li>
<li>第二列最多有N-1个位置可选</li>
<li>第三列最多有N-2个位置可选</li>
<li>以此类推</li>
</ul>
<p>实际上，由于剪枝的存在，实际运行时间会小于 $O(N!)$。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<ol>
<li>
<p><strong>标准回溯解法</strong>：</p>
<ul>
<li>空间复杂度为 $O(N)$，主要是三个标记数组和递归调用栈</li>
</ul>
</li>
<li>
<p><strong>位运算解法</strong>：</p>
<ul>
<li>空间复杂度为 $O(1)$，因为我们只使用固定的几个整数来表示状态</li>
<li>这是位运算解法的主要优势之一</li>
</ul>
</li>
</ol>
<p><strong>注意</strong>：位运算解法的空间优势在N很大时更加明显。但当N &gt; 32（或在64位系统上N &gt; 64）时，单个整数的位数不足以表示所有状态，可能需要使用大整数库或其他方法。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>标准回溯解法</th>
<th>位运算解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(N!)</td>
<td>O(N!)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>直观易懂</td>
<td>空间效率高，常数操作更快</td>
</tr>
<tr>
<td>缺点</td>
<td>空间消耗较大</td>
<td>可读性较差，仅适用于N≤32或64</td>
</tr>
<tr>
<td>适用场景</td>
<td>教学演示、代码可读性要求高</td>
<td>空间受限、追求极致性能</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>回溯与位运算结合</strong>：N皇后问题展示了如何将位运算与回溯算法结合，优化空间复杂度。</p>
</li>
<li>
<p><strong>位运算技巧</strong>：</p>
<ul>
<li>使用单个整数的二进制位表示多个布尔值</li>
<li>使用 <code>x &amp; -x</code> 获取最低位的1</li>
<li>使用位移操作模拟数据结构的变化</li>
</ul>
</li>
<li>
<p><strong>算法优化思路</strong>：有时不需要记录具体解的内容，只需记录解的数量，可以大幅简化代码和优化性能。</p>
</li>
<li>
<p><strong>两类问题的关联</strong>：N皇后I和N皇后II展示了两种常见的问题变体——“求所有解&quot;和&quot;求解的数量”，它们通常可以用相同的核心算法解决，但后者往往有额外的优化空间。</p>
</li>
</ol>
<p>位运算解法虽然在这个问题中能带来空间效率的提升，但也增加了代码复杂度和理解难度。在实际应用中，需要根据具体情况（如N的大小、性能要求、代码可维护性等）选择合适的实现方法。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>回溯</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 51 - N皇后（N-Queens）</title>
    <url>/2025/05/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-51-N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>N皇后问题是一个经典的回溯算法应用。根据国际象棋规则，皇后可以攻击与之处在同一行、同一列或同一斜线上的棋子。N皇后问题要求在N×N的棋盘上放置N个皇后，使得皇后之间互不攻击。</p>
<p>给定一个整数N，要求返回所有不同的N皇后问题的解决方案。每个解决方案包含一个不同的N皇后问题的棋子放置方案，其中’Q’表示皇后，'.'表示空位。</p>
<h3 id="示例-1">示例 1</h3>
<p><strong>输入</strong>：n = 4<br>
<strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  // 解法1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"> </span><br><span class="line"> [&quot;..Q.&quot;,  // 解法2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：4皇后问题存在两个不同解法。</p>
<p><img src="/2025/05/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-51-N%E7%9A%87%E5%90%8E/1746609894177.png" alt="1746609894177"></p>
<h3 id="示例-2">示例 2</h3>
<p><strong>输入</strong>：n = 1<br>
<strong>输出</strong>：[[“Q”]]</p>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>1 &lt;= n &lt;= 9</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>N皇后问题是回溯算法的经典应用。我们需要尝试在每一列放置一个皇后，同时保证它不会攻击到其他已放置的皇后。</p>
<h3 id="核心思想">核心思想</h3>
<p><strong>核心洞见</strong>：要快速判断一个位置是否可以放置皇后，我们需要高效检测该位置是否处于已有皇后的攻击范围内。</p>
<p>皇后的攻击路径有三种：</p>
<ol>
<li>同一行</li>
<li>同一列</li>
<li>同一斜线（包括主对角线和副对角线）</li>
</ol>
<p>为了高效检测，我们使用三个布尔数组来标记已经被占用的行和两种对角线：</p>
<ul>
<li><code>rowUsed[n]</code>：记录每一行是否已放置皇后</li>
<li><code>mainDiagUsed[2*n-1]</code>：记录主对角线（左上到右下）是否已放置皇后</li>
<li><code>subDiagUsed[2*n-1]</code>：记录副对角线（右上到左下）是否已放置皇后</li>
</ul>
<h3 id="对角线的数学特性">对角线的数学特性</h3>
<p>对角线的检测是本题的关键。对于棋盘上的任意一点(i, j)：</p>
<ol>
<li>主对角线（左上至右下）：同一主对角线上的所有点满足 <strong>i+j 值相同</strong><br>
例如：(0,0), (1,1), (2,2) 都在同一主对角线上，它们的 i+j 都等于0+0=1+1=2+2=…</li>
<li>副对角线（右上至左下）：同一副对角线上的所有点满足 <strong>i-j 值相同</strong><br>
例如：(0,2), (1,1), (2,0) 都在同一副对角线上，它们的 i-j 都等于0-2=1-1=2-0=…</li>
</ol>
<p>但是由于数组索引不能为负，对于副对角线，我们通常使用 <code>i-j+n-1</code> 或 <code>i-j+n</code> 来确保索引为非负值。</p>
<h3 id="回溯过程">回溯过程</h3>
<p>回溯算法的流程如下：</p>
<ol>
<li>按列递归，对于每一列，尝试在各行放置皇后</li>
<li>放置前检查当前位置是否安全（行、主对角线、副对角线都未被占用）</li>
<li>如果安全，则放置皇后，并递归处理下一列</li>
<li>递归返回后，回溯（撤销放置的皇后），继续尝试下一个位置</li>
<li>当成功放置了N个皇后（即处理完所有列），记录当前解</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>我们使用深度优先搜索(DFS)实现回溯算法。关键步骤如下：</p>
<ol>
<li>
<p>创建解决方案集和棋盘表示：</p>
<ul>
<li>使用二维字节数组表示棋盘，初始化为全’.’</li>
<li>使用三个布尔数组跟踪已占用的行和对角线</li>
</ul>
</li>
<li>
<p>定义DFS函数，按列递归：</p>
<ul>
<li>如果当前列等于n，说明找到一个解，将当前棋盘状态添加到结果中</li>
<li>否则，尝试在当前列的每一行放置皇后</li>
<li>检查位置(row, col)是否安全（行、主对角线、副对角线都未被占用）</li>
<li>如果安全，标记占用，放置皇后，递归下一列</li>
<li>递归返回后，撤销标记，移除皇后（回溯）</li>
</ul>
</li>
</ol>
<h3 id="实例演示">实例演示</h3>
<p>以n=4为例，展示部分搜索过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态：棋盘为空</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">尝试第0列第0行(0,0)：</span><br><span class="line">Q...  ✓ 可以放置</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">尝试第1列第0行(0,1)：</span><br><span class="line">QQ..  ✗ 同一行攻击，跳过</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">尝试第1列第1行(1,1)：</span><br><span class="line">Q...  ✗ 对角线攻击，跳过</span><br><span class="line">.Q..</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">尝试第1列第2行(2,1)：</span><br><span class="line">Q...  ✓ 可以放置</span><br><span class="line">..Q.</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">...依此类推</span><br></pre></td></tr></table></figure>
<h2 id="代码实现">代码实现</h2>
<p>下面是完整且易于理解的Go语言实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveNQueens</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 结果集</span></span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">string</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 标记数组，记录已占用的行和对角线</span></span><br><span class="line">    rowUsed := <span class="built_in">make</span>([]<span class="type">bool</span>, n)          <span class="comment">// 标记行是否已被占用</span></span><br><span class="line">    mainDiagUsed := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="number">2</span>*n)   <span class="comment">// 标记主对角线(i+j)是否已被占用</span></span><br><span class="line">    subDiagUsed := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="number">2</span>*n)    <span class="comment">// 标记副对角线(n+i-j)是否已被占用</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化棋盘，所有位置都是&#x27;.&#x27;</span></span><br><span class="line">    board := <span class="built_in">make</span>([][]<span class="type">byte</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> board &#123;</span><br><span class="line">        board[i] = <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> board[i] &#123;</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// DFS函数，col表示当前处理的列</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(col <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(col <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果所有列都已处理，则找到一个解</span></span><br><span class="line">        <span class="keyword">if</span> col == n &#123;</span><br><span class="line">            <span class="comment">// 将当前棋盘状态转换为字符串数组，并添加到结果中</span></span><br><span class="line">            solution := <span class="built_in">make</span>([]<span class="type">string</span>, n)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> solution &#123;</span><br><span class="line">                solution[i] = <span class="type">string</span>(board[i])</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">append</span>(result, solution)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 尝试在当前列的每一行放置皇后</span></span><br><span class="line">        <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; n; row++ &#123;</span><br><span class="line">            <span class="comment">// 检查位置(row, col)是否安全</span></span><br><span class="line">            <span class="comment">// 如果行、主对角线或副对角线已被占用，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> rowUsed[row] || mainDiagUsed[row+col] || subDiagUsed[n+row-col] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 标记占用</span></span><br><span class="line">            rowUsed[row] = <span class="literal">true</span></span><br><span class="line">            mainDiagUsed[row+col] = <span class="literal">true</span></span><br><span class="line">            subDiagUsed[n+row-col] = <span class="literal">true</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 放置皇后</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 递归处理下一列</span></span><br><span class="line">            dfs(col + <span class="number">1</span>)</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 回溯：撤销标记和皇后放置</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            rowUsed[row] = <span class="literal">false</span></span><br><span class="line">            mainDiagUsed[row+col] = <span class="literal">false</span></span><br><span class="line">            subDiagUsed[n+row-col] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从第0列开始DFS</span></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>时间复杂度为 $O(N!)$，其中N是棋盘的大小。这是因为：</p>
<ul>
<li>第一列有N个位置可选</li>
<li>第二列最多有N-1个位置可选</li>
<li>第三列最多有N-2个位置可选</li>
<li>以此类推</li>
</ul>
<p>实际上，由于剪枝的存在，实际运行时间会远小于 $O(N!)$，但理论上最坏情况仍为 $O(N!)$。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>空间复杂度为 $O(N)$，主要包括：</p>
<ul>
<li>三个标记数组：$O(N) + O(2N) + O(2N) = O(5N) = O(N)$</li>
<li>棋盘表示：$O(N^2)$</li>
<li>递归调用栈：$O(N)$</li>
</ul>
<p>由于N的取值范围较小(1≤N≤9)，$O(N^2)$ 实际上也可以视为 $O(N)$。</p>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>回溯算法的应用</strong>：N皇后问题展示了回溯算法在组合优化问题中的应用，通过尝试-验证-回溯的方式搜索解空间。</li>
<li><strong>高效的约束检查</strong>：使用三个布尔数组记录已占用的行和对角线，可以在 $O(1)$ 时间内判断位置是否安全，而不需要每次遍历整个棋盘。</li>
<li><strong>数学特性的利用</strong>：对角线的数学特性（i+j和i-j的不变性）使我们能够高效地检测对角线约束，这是解决此类问题的关键。</li>
<li><strong>递归与状态恢复</strong>：回溯算法的精髓在于&quot;状态恢复&quot;，即尝试一个选择后，如果不满足条件，则撤销这个选择，恢复到之前的状态，继续尝试其他选择。</li>
</ol>
<p>N皇后问题是组合优化中的NP难问题，没有多项式时间的解法。对于大规模的问题(N很大)，通常需要使用启发式算法或近似算法来解决。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 22 - 括号生成（Generate Parentheses）</title>
    <url>/2025/05/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<h3 id="示例：">示例：</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="提示：">提示：</h3>
<ul>
<li>1 &lt;= n &lt;= 8</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题目要求我们生成所有可能的有效括号组合，是一个典型的<strong>回溯（深度优先搜索）问题</strong>。我们也可以用<strong>动态规划</strong>的方式解决。下面我将详细介绍这两种方法。</p>
<h3 id="方法一：回溯算法（DFS）">方法一：回溯算法（DFS）</h3>
<p>回溯算法的核心思想是通过<strong>递归</strong>的方式，逐步构建解决方案，并在不满足条件的情况下进行回溯。</p>
<p>对于括号生成问题，我们可以通过以下思路解决：</p>
<ol>
<li>维护两个变量 <code>left</code> 和 <code>right</code>，分别表示已经放置的左括号和右括号的数量</li>
<li>对于每个位置，我们有两种选择：放置左括号或放置右括号</li>
<li><strong>放置左括号的条件</strong>：当前已放置的左括号数量小于 n</li>
<li><strong>放置右括号的条件</strong>：当前已放置的右括号数量小于左括号数量</li>
<li>当左括号和右括号的数量都等于 n 时，我们得到一个有效的括号组合</li>
</ol>
<p>这样，我们可以通过 DFS 遍历所有可能的组合，并只保留有效的组合。</p>
<p>让我们用一个简单的例子（n=2）来说明这个过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态：&quot;&quot;，left=0，right=0</span><br><span class="line">    选择左括号：&quot;(&quot;，left=1，right=0</span><br><span class="line">        选择左括号：&quot;((&quot;，left=2，right=0</span><br><span class="line">            选择右括号：&quot;(()&quot;，left=2，right=1</span><br><span class="line">                选择右括号：&quot;(())&quot;，left=2，right=2，得到一个有效组合</span><br><span class="line">        选择右括号：&quot;()&quot;，left=1，right=1</span><br><span class="line">            选择左括号：&quot;()(&quot;，left=2，right=1</span><br><span class="line">                选择右括号：&quot;()()&quot;，left=2，right=2，得到一个有效组合</span><br></pre></td></tr></table></figure>
<h3 id="方法二：动态规划">方法二：动态规划</h3>
<p>动态规划的思路是基于已知的结果推导出未知的结果。对于括号生成问题，我们可以这样思考：</p>
<p>设 <code>dp[i]</code> 表示 i 对括号的所有有效组合，那么对于 <code>dp[n]</code>，我们可以枚举左括号的位置，然后将问题分解为已知的子问题。</p>
<p>具体来说，我们可以通过以下公式来生成 <code>dp[n]</code>：</p>
<p>$$<br>
dp[n] = \sum_{i=0}^{n-1} (dp[i]) + dp[n-1-i]<br>
$$</p>
<p>其中 i 表示左括号内部包含的括号对数，n-1-i 表示右括号后面的括号对数。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="方法一：回溯算法（DFS）实现">方法一：回溯算法（DFS）实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    result := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 创建一个临时数组来存储当前构建的括号字符串</span></span><br><span class="line">    tmpArray := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>*n)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义 DFS 函数</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index, left, right <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(index, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当我们放满了所有括号时，添加到结果集</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">2</span>*n &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, <span class="type">string</span>(tmpArray))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果左括号数量小于 n，可以放置左括号</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; n &#123;</span><br><span class="line">            tmpArray[index] = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">            dfs(index+<span class="number">1</span>, left+<span class="number">1</span>, right)</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果右括号数量小于左括号数量，可以放置右括号</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left &#123;</span><br><span class="line">            tmpArray[index] = <span class="string">&#x27;)&#x27;</span></span><br><span class="line">            dfs(index+<span class="number">1</span>, left, right+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从第一个位置、零个左右括号开始 DFS</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：动态规划实现">方法二：动态规划实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// dp[i] 表示 i 对括号的所有有效组合</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">string</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = []<span class="type">string</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            <span class="comment">// 枚举左括号内部的括号对数 j</span></span><br><span class="line">            <span class="keyword">for</span> _, left := <span class="keyword">range</span> dp[j] &#123;</span><br><span class="line">                <span class="keyword">for</span> _, right := <span class="keyword">range</span> dp[i<span class="number">-1</span>-j] &#123;</span><br><span class="line">                    <span class="comment">// 将 &quot;(&quot; + dp[j] + &quot;)&quot; + dp[i-1-j] 添加到 dp[i]</span></span><br><span class="line">                    dp[i] = <span class="built_in">append</span>(dp[i], <span class="string">&quot;(&quot;</span> + left + <span class="string">&quot;)&quot;</span> + right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行示例">执行示例</h2>
<p>让我们以 n=3 为例，追踪方法一（回溯算法）的执行过程：</p>
<ol>
<li>初始状态：tmpArray = [_, _, _, _, _, _], index=0, left=0, right=0</li>
<li>放置左括号：tmpArray = [(, _, _, _, _, _], index=1, left=1, right=0</li>
<li>继续放置左括号：tmpArray = [(, (, _, _, _, _], index=2, left=2, right=0</li>
<li>继续放置左括号：tmpArray = [(, (, (, _, _, _], index=3, left=3, right=0</li>
<li>放置右括号：tmpArray = [(, (, (, ), _, _], index=4, left=3, right=1</li>
<li>继续放置右括号：tmpArray = [(, (, (, ), ), _], index=5, left=3, right=2</li>
<li>继续放置右括号：tmpArray = [(, (, (, ), ), )], index=6, left=3, right=3，添加到结果集：“((()))”</li>
<li>回溯到步骤 5，尝试放置另一个右括号…</li>
</ol>
<p>通过深度优先遍历所有可能的情况，我们最终得到所有有效的括号组合。</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>回溯算法（DFS）</th>
<th>动态规划</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(\frac{4^n}{\sqrt(n)})$</td>
<td>$O(\frac{4^n}{n^{3/2}})$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>$O(\frac{4^n}{n^{3/2}})$</td>
</tr>
<tr>
<td>优点</td>
<td>直观，易于理解</td>
<td>避免重复计算</td>
</tr>
<tr>
<td>缺点</td>
<td>可能有重复计算</td>
<td>需要额外的存储空间</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="回溯算法（DFS）">回溯算法（DFS）</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(\frac{4^n}{\sqrt{n}})$，这是第 n 个卡特兰数的近似值，表示长度为 2n 的合法括号序列的数量。</li>
<li><strong>空间复杂度</strong>：$O(n)$，递归的深度最多为 2n，而我们需要一个长度为 2n 的数组来存储当前构建的括号字符串。</li>
</ul>
<h3 id="动态规划">动态规划</h3>
<ul>
<li><strong>时间复杂度</strong>：$O(\frac{4^n}{n^{3/2}})$，同样是卡特兰数的近似值。</li>
<li><strong>空间复杂度</strong>：$O(\frac{4^n}{n^{3/2}})$，需要存储所有中间结果。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>回溯算法</strong>是解决生成所有可能组合问题的有力工具，特别适合有明确约束条件的问题。</li>
<li>在处理括号问题时，我们需要记住一个核心规则：<strong>右括号数量不能超过左括号数量</strong>。</li>
<li><strong>动态规划</strong>可以通过分解问题并复用子问题的解来解决复杂问题。</li>
<li>这个问题是<strong>卡特兰数</strong>在计算机科学中的一个应用实例，卡特兰数描述了许多组合问题中的计数。</li>
</ol>
<p>相关问题：</p>
<ul>
<li>LeetCode 20: 有效的括号</li>
<li>LeetCode 32: 最长有效括号</li>
<li>LeetCode 301: 删除无效的括号</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离级别的实现原理</title>
    <url>/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1>MySQL事务隔离级别的实现原理</h1>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF">问题背景</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">事务的特性(ACID)</a></li>
<li><a href="#%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">并发事务的问题</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B">事务的隔离级别</a></li>
<li><a href="#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">MVCC与Read View工作原理</a></li>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">可重复读的实现机制</a></li>
<li><a href="#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">读提交的实现机制</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h2 id="问题背景">问题背景</h2>
<p>想象一个简单的转账场景：A的钱包有100元，B的钱包有0元。A给B转账100元后，最终结果应该是A余额为0元，B余额为100元。</p>
<p>但实际上，转账在程序中会涉及多个操作步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 读取A的账户余额</span><br><span class="line">2. 从A的余额中减去转账金额</span><br><span class="line">3. 更新A的余额到数据库</span><br><span class="line">---</span><br><span class="line">4. 读取B的账户余额</span><br><span class="line">5. 给B的余额增加转账金额</span><br><span class="line">6. 更新B的余额到数据库</span><br></pre></td></tr></table></figure>
<p>如果在执行第3步之后系统突然崩溃，就会出现A账户已减去100元，但B账户没有增加相应金额的情况 —— <strong>钱凭空消失了！</strong></p>
<p>为了解决这个问题，数据库提供了「<strong>事务（Transaction）</strong>」机制，保证一系列操作要么全部成功执行，要么全部回滚到初始状态，不会出现中间状态。</p>
<h2 id="事务有哪些特性？">事务有哪些特性？</h2>
<p>事务由数据库引擎实现，MySQL的InnoDB引擎支持事务，而MyISAM引擎不支持。事务必须遵守四个基本特性（ACID）：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>专业术语</th>
<th>通俗解释</th>
<th>生活例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>原子性</strong></td>
<td>Atomicity</td>
<td>事务中的所有操作要么全部完成，要么全部不完成</td>
<td>购物时，要么成功付款并获得商品，要么交易取消，不会出现付了钱没收到商品的情况</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>Consistency</td>
<td>事务前后，数据库从一个一致状态转换到另一个一致状态</td>
<td>转账后，无论成功或失败，A和B的总金额应保持不变，不会凭空增加或减少</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>Isolation</td>
<td>多个事务并发执行时，彼此之间不会互相干扰</td>
<td>多人同时在网上商城购物，每个人的购物过程不会互相影响</td>
</tr>
<tr>
<td><strong>持久性</strong></td>
<td>Durability</td>
<td>事务一旦提交，对数据的修改就是永久的</td>
<td>银行转账成功后，即使系统崩溃，重启后你的转账记录依然存在</td>
</tr>
</tbody>
</table>
<p>InnoDB引擎通过不同的技术保证这四个特性：</p>
<ul>
<li><strong>持久性</strong>：通过 redo log（重做日志）实现</li>
<li><strong>原子性</strong>：通过 undo log（回滚日志）实现</li>
<li><strong>隔离性</strong>：通过 MVCC（多版本并发控制）或锁机制实现</li>
<li><strong>一致性</strong>：通过持久性 + 原子性 + 隔离性共同保证</li>
</ul>
<p>本文将<strong>重点介绍事务的隔离性</strong>，这也是面试中最常被问到的知识点。</p>
<h2 id="并行事务会引发什么问题？">并行事务会引发什么问题？</h2>
<p>MySQL服务器允许多个客户端同时连接，因此会同时处理多个事务。在没有适当隔离机制的情况下，会出现三种主要并发问题：</p>
<h3 id="三种并发问题对比">三种并发问题对比</h3>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>定义</th>
<th>发生条件</th>
<th>严重程度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>脏读</strong></td>
<td>读到其他事务未提交的数据</td>
<td>事务A读取了事务B修改但未提交的数据，之后事务B回滚</td>
<td>最严重</td>
</tr>
<tr>
<td><strong>不可重复读</strong></td>
<td>同一事务内，前后读取同一数据得到不同结果</td>
<td>事务A先读取数据，事务B修改并提交该数据，事务A再次读取得到不同结果</td>
<td>中等</td>
</tr>
<tr>
<td><strong>幻读</strong></td>
<td>同一事务内，用相同条件查询得到不同数量的记录</td>
<td>事务A查询符合条件的记录，事务B插入/删除符合该条件的记录并提交，事务A再次查询得到不同数量的记录</td>
<td>较轻</td>
</tr>
</tbody>
</table>
<p>下面通过图示来理解这些问题：</p>
<h4 id="脏读示例">脏读示例</h4>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746514159574.png" alt="脏读"></p>
<p>如图所示，事务B读取到事务A修改但未提交的数据。如果事务A之后回滚，则事务B读取到的数据就是&quot;脏&quot;的。</p>
<h4 id="不可重复读示例">不可重复读示例</h4>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746514175561.png" alt="不可重复读"></p>
<p>事务A两次读取同一数据，但因为中间事务B对数据进行了修改并提交，导致前后读取结果不一致。</p>
<h4 id="幻读示例">幻读示例</h4>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746514184290.png" alt="幻读"></p>
<p>事务A两次查询同一条件的记录数量，但因为中间事务B插入了新记录并提交，导致第二次查询结果集变多，就像出现了&quot;幻觉&quot;一样。</p>
<h2 id="事务的隔离级别有哪些？">事务的隔离级别有哪些？</h2>
<p>SQL标准定义了四种隔离级别，隔离级别越高，能解决的并发问题越多，但性能开销也越大：</p>
<h3 id="四种隔离级别对比">四种隔离级别对比</h3>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>性能影响</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>读未提交</strong><br>(Read Uncommitted)</td>
<td>可能发生</td>
<td>可能发生</td>
<td>可能发生</td>
<td>影响最小</td>
</tr>
<tr>
<td><strong>读提交</strong><br>(Read Committed)</td>
<td>不会发生</td>
<td>可能发生</td>
<td>可能发生</td>
<td>影响较小</td>
</tr>
<tr>
<td><strong>可重复读</strong><br>(Repeatable Read)</td>
<td>不会发生</td>
<td>不会发生</td>
<td>可能发生<br><em>(MySQL InnoDB基本避免)</em></td>
<td>影响中等</td>
</tr>
<tr>
<td><strong>串行化</strong><br>(Serializable)</td>
<td>不会发生</td>
<td>不会发生</td>
<td>不会发生</td>
<td>影响最大</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：MySQL InnoDB的默认隔离级别是「可重复读」，并且它对幻读问题有特殊处理。</p>
</blockquote>
<p>为了便于理解，我们通过一个具体例子来看不同隔离级别下的行为差异：</p>
<p>假设有一张账户表，里面有一条记录显示小林的余额为100万。现在有两个并发事务：</p>
<ul>
<li>事务A负责查询小林的余额</li>
<li>事务B将小林的余额从100万修改为200万</li>
</ul>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746515349988.png" alt="不同隔离级别下的行为"></p>
<p>在不同隔离级别下，事务A在三个时间点查询到的结果会有所不同：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>查询1结果<br>(事务B修改前)</th>
<th>查询2结果<br>(事务B修改后但未提交)</th>
<th>查询3结果<br>(事务B提交后)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>读未提交</strong></td>
<td>100万</td>
<td>200万</td>
<td>200万</td>
</tr>
<tr>
<td><strong>读提交</strong></td>
<td>100万</td>
<td>100万</td>
<td>200万</td>
</tr>
<tr>
<td><strong>可重复读</strong></td>
<td>100万</td>
<td>100万</td>
<td>100万<br><em>(事务A提交后再查询才能看到200万)</em></td>
</tr>
<tr>
<td><strong>串行化</strong></td>
<td>100万</td>
<td>100万<br><em>(事务B的修改会被阻塞直到事务A提交)</em></td>
<td>200万<br><em>(事务A提交后事务B才能执行)</em></td>
</tr>
</tbody>
</table>
<h3 id="隔离级别的实现原理">隔离级别的实现原理</h3>
<p>不同隔离级别的实现机制：</p>
<ul>
<li><strong>读未提交</strong>：直接读取最新数据，不做任何检查</li>
<li><strong>读提交</strong>：使用Read View机制，<strong>每次SELECT都创建新的Read View</strong></li>
<li><strong>可重复读</strong>：使用Read View机制，<strong>事务开始时创建Read View并在整个事务期间使用</strong></li>
<li><strong>串行化</strong>：使用锁机制，读写操作都会加锁</li>
</ul>
<p>MySQL InnoDB针对幻读问题的特殊处理：</p>
<ul>
<li>对于<strong>快照读</strong>（普通SELECT语句）：通过MVCC机制解决幻读</li>
<li>对于<strong>当前读</strong>（SELECT FOR UPDATE等语句）：通过next-key lock（记录锁+间隙锁）解决幻读</li>
</ul>
<blockquote>
<p><strong>名词解释</strong>：</p>
<ul>
<li><strong>快照读</strong>：读取数据的历史版本（快照），不会加锁，例如普通的SELECT语句</li>
<li><strong>当前读</strong>：读取数据的最新版本，会加锁，例如SELECT FOR UPDATE、UPDATE、DELETE等语句</li>
</ul>
</blockquote>
<h2 id="Read-View-在-MVCC-里如何工作的？">Read View 在 MVCC 里如何工作的？</h2>
<p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是MySQL实现事务隔离的关键技术，Read View是MVCC的核心概念。</p>
<h3 id="Read-View的结构">Read View的结构</h3>
<p>Read View是事务在访问数据时创建的一个&quot;快照&quot;，包含四个关键字段：</p>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746534208808.png" alt="Read View结构"></p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>m_ids</strong></td>
<td>创建Read View时，活跃事务的ID列表</td>
<td>判断记录版本对当前事务是否可见</td>
</tr>
<tr>
<td><strong>min_trx_id</strong></td>
<td>m_ids中最小的事务ID</td>
<td>快速判断记录是否对当前事务可见</td>
</tr>
<tr>
<td><strong>max_trx_id</strong></td>
<td>下一个将被分配的事务ID</td>
<td>判断记录是否由未来事务创建</td>
</tr>
<tr>
<td><strong>creator_trx_id</strong></td>
<td>创建Read View的事务ID</td>
<td>确保事务能看到自己的修改</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>活跃事务</strong>指的是已经开始但还未提交的事务</p>
</blockquote>
<h3 id="记录的隐藏列">记录的隐藏列</h3>
<p>InnoDB存储引擎的表记录中，除了我们定义的列外，还包含两个隐藏列：</p>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746534222507.png" alt="记录的隐藏列"></p>
<table>
<thead>
<tr>
<th>隐藏列</th>
<th>含义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>trx_id</strong></td>
<td>最后修改该记录的事务ID</td>
<td>用于判断记录版本对事务是否可见</td>
</tr>
<tr>
<td><strong>roll_pointer</strong></td>
<td>指向记录上一个版本的指针</td>
<td>用于构建版本链，实现回滚</td>
</tr>
</tbody>
</table>
<h3 id="版本可见性判断流程">版本可见性判断流程</h3>
<p>当事务通过Read View访问记录时，会按以下流程判断记录版本的可见性：</p>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746534236041.png" alt="版本可见性判断"></p>
<p>判断流程可简化为：</p>
<ol>
<li>如果记录的trx_id等于creator_trx_id，说明是当前事务自己修改的记录，<strong>可见</strong></li>
<li>如果记录的trx_id &lt; min_trx_id，说明修改该记录的事务在创建Read View前已提交，<strong>可见</strong></li>
<li>如果记录的trx_id &gt;= max_trx_id，说明修改该记录的事务在创建Read View后才开始，<strong>不可见</strong></li>
<li>如果min_trx_id &lt;= 记录的trx_id &lt; max_trx_id，需进一步判断：
<ul>
<li>如果trx_id在m_ids列表中，说明修改该记录的事务还未提交，<strong>不可见</strong></li>
<li>如果trx_id不在m_ids列表中，说明修改该记录的事务已提交，<strong>可见</strong></li>
</ul>
</li>
<li>如果当前版本不可见，会沿着版本链找更早的版本，重复以上判断</li>
</ol>
<p>这种通过<strong>版本链</strong>控制并发访问的机制就是MVCC的核心。</p>
<h2 id="可重复读是如何工作的？">可重复读是如何工作的？</h2>
<p><strong>可重复读隔离级别的特点</strong>：事务在启动时创建一个Read View，整个事务期间都使用这个Read View，确保事务看到的数据是事务启动时的快照。</p>
<h3 id="实际案例分析">实际案例分析</h3>
<p>假设有两个事务A和B，事务A的ID为51，事务B的ID为52：</p>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746534249252.png" alt="可重复读的Read View"></p>
<p>事务执行顺序：</p>
<ol>
<li>事务B读取小林余额，得到100万</li>
<li>事务A修改小林余额为200万（未提交）</li>
<li>事务B再次读取小林余额，依然是100万</li>
<li>事务A提交事务</li>
<li>事务B第三次读取小林余额，依然是100万</li>
</ol>
<h4 id="为什么事务B一直读到的都是100万？">为什么事务B一直读到的都是100万？</h4>
<p>事务B在启动时创建了Read View：</p>
<ul>
<li>m_ids = [51, 52] （活跃事务列表）</li>
<li>min_trx_id = 51</li>
<li>max_trx_id = 53</li>
<li>creator_trx_id = 52</li>
</ul>
<p>当事务A修改记录后，版本链变为：</p>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746534261267.png" alt="版本链示意图"></p>
<p>当事务B读取记录时：</p>
<ol>
<li>发现最新版本trx_id=51，在m_ids列表中</li>
<li>判断此版本<strong>不可见</strong></li>
<li>沿着版本链找到旧版本，trx_id=50</li>
<li>50 &lt; min_trx_id(51)，判断此版本<strong>可见</strong></li>
<li>返回余额100万</li>
</ol>
<p>即使事务A提交后，因为事务B仍然使用启动时的Read View，所以继续读到的还是旧版本的数据。</p>
<p>这就是<strong>可重复读</strong>的核心机制：<strong>同一事务内，多次读取同一数据会得到相同结果</strong>。</p>
<h2 id="读提交是如何工作的？">读提交是如何工作的？</h2>
<p><strong>读提交隔离级别的特点</strong>：每次SELECT都会创建新的Read View，因此能够读到其他已提交事务的最新修改。</p>
<h3 id="与可重复读的对比">与可重复读的对比</h3>
<p>我们还是用前面的例子来对比：</p>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746534277270.png" alt="读提交的Read View变化"></p>
<p>事务执行顺序：</p>
<ol>
<li>事务B第一次读取（创建Read View 1），读到余额100万</li>
<li>事务A修改余额为200万（未提交）</li>
<li>事务B第二次读取（创建Read View 2），读到余额100万</li>
<li>事务A提交事务</li>
<li>事务B第三次读取（创建Read View 3），读到余额200万</li>
</ol>
<h4 id="核心区别">核心区别</h4>
<p>事务B每次读取都创建新的Read View：</p>
<ul>
<li>Read View 1和2：因为事务A未提交，活跃事务列表包含事务A，所以读不到事务A的修改</li>
<li>Read View 3：事务A已提交，活跃事务列表中不包含事务A，所以能读到事务A的修改</li>
</ul>
<p><img src="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1746534287457.png" alt="读提交最终的Read View"></p>
<p>这就是<strong>读提交</strong>的核心机制：<strong>总是能读到其他已提交事务的最新修改</strong>。</p>
<h2 id="总结">总结</h2>
<h3 id="隔离级别与实现机制">隔离级别与实现机制</h3>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>Read View创建时机</th>
<th>能解决的问题</th>
<th>实现机制</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>读未提交</strong></td>
<td>不使用Read View</td>
<td>无</td>
<td>直接读取最新数据</td>
</tr>
<tr>
<td><strong>读提交</strong></td>
<td>每次SELECT时创建</td>
<td>脏读</td>
<td>MVCC（Read View）</td>
</tr>
<tr>
<td><strong>可重复读</strong></td>
<td>事务启动时创建</td>
<td>脏读、不可重复读</td>
<td>MVCC（Read View）</td>
</tr>
<tr>
<td><strong>串行化</strong></td>
<td>不使用Read View</td>
<td>脏读、不可重复读、幻读</td>
<td>加锁（读写锁）</td>
</tr>
</tbody>
</table>
<h3 id="MySQL-InnoDB对幻读的处理">MySQL InnoDB对幻读的处理</h3>
<p>MySQL InnoDB在可重复读隔离级别下通过两种方式处理幻读问题：</p>
<ol>
<li><strong>快照读</strong>（普通SELECT）：使用MVCC机制，事务只能看到事务开始前的数据状态</li>
<li><strong>当前读</strong>（SELECT FOR UPDATE等）：使用next-key lock锁机制（记录锁+间隙锁）阻止其他事务在查询范围内插入数据</li>
</ol>
<h3 id="核心技术总结">核心技术总结</h3>
<ol>
<li><strong>MVCC</strong>：通过记录的版本链和Read View实现事务隔离</li>
<li><strong>Read View</strong>：决定事务可以看到哪个版本的数据</li>
<li><strong>隐藏列</strong>：trx_id和roll_pointer构建了版本链的基础</li>
<li><strong>隔离级别差异</strong>：主要体现在创建Read View的时机不同</li>
</ol>
<p>理解事务隔离级别的实现原理，有助于我们在开发中选择合适的隔离级别，平衡数据一致性和系统性能。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>事务隔离级别</tag>
        <tag>并发控制</tag>
        <tag>MVCC</tag>
        <tag>锁机制</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 78 - 子集（Subsets）</title>
    <url>/2025/05/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-78-%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个整数数组 <code>nums</code>，数组中的元素 <strong>互不相同</strong>。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<h3 id="提示：">提示：</h3>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>子集问题是组合问题的典型案例，对于一个长度为 n 的数组，其子集的数量为 2^n。我们可以通过多种方法来生成所有可能的子集：</p>
<h3 id="方法一：基于位运算的迭代法">方法一：基于位运算的迭代法</h3>
<p>这个方法基于一个重要观察：对于长度为 n 的数组，可以用一个 n 位二进制数表示某个子集，其中第 i 位为 1 表示选择第 i 个元素，为 0 表示不选择。</p>
<p><strong>关键洞见</strong>：从 0 到 2^n-1 的每个二进制数都唯一对应一个子集。</p>
<h4 id="实现步骤">实现步骤</h4>
<ol>
<li>计算子集的总数：2^n。</li>
<li>遍历从 0 到 2^n-1 的每个数字，将其视为二进制掩码。</li>
<li>对于每个掩码，检查哪些位为 1，选择对应位置的元素加入到当前子集中。</li>
<li>将构建好的子集添加到结果中。</li>
</ol>
<h3 id="方法二：基于回溯的DFS递归法">方法二：基于回溯的DFS递归法</h3>
<p>回溯法是一种通过探索所有可能情况来找到所有解的方法。我们可以通过递归地考虑选择或不选择当前元素来构建所有子集。</p>
<p><strong>关键洞见</strong>：对于每个元素，我们有两种选择 - 选择它或不选择它。</p>
<h4 id="实现步骤-2">实现步骤</h4>
<ol>
<li>使用深度优先搜索 (DFS) 递归遍历所有可能的选择。</li>
<li>遍历数组中的每个元素，对于当前元素，我们可以：
<ul>
<li>选择它，然后递归处理剩余元素</li>
<li>不选择它，递归处理剩余元素</li>
</ul>
</li>
<li>当我们考虑完所有元素后，将当前构建的子集添加到结果中。</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<p>下面是两种方法的详细代码实现：</p>
<h3 id="方法一：基于位运算的迭代法-2">方法一：基于位运算的迭代法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 遍历从0到2^n-1的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> mask := <span class="number">0</span>; mask &lt; <span class="number">1</span>&lt;&lt;n; mask++ &#123;</span><br><span class="line">        tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="comment">// 检查mask的每一位是否为1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">// 如果第i位为1，则选择nums[i]</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span>&lt;&lt;i)&amp;mask != <span class="number">0</span> &#123;</span><br><span class="line">                tmp = <span class="built_in">append</span>(tmp, nums[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：基于回溯的DFS递归法-2">方法二：基于回溯的DFS递归法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(fromIndex, length <span class="type">int</span>)</span></span></span><br><span class="line">    <span class="comment">// 临时数组，用于存储当前构建的子集</span></span><br><span class="line">    tmpArray := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(fromIndex, length <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 确保索引不越界</span></span><br><span class="line">        <span class="keyword">if</span> fromIndex &gt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前子集添加到结果中</span></span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">        <span class="built_in">copy</span>(tmp, tmpArray)</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从fromIndex开始遍历，避免重复</span></span><br><span class="line">        <span class="keyword">for</span> i := fromIndex; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            tmpArray[length] = nums[i]  <span class="comment">// 选择当前元素</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, length+<span class="number">1</span>)         <span class="comment">// 递归处理下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法执行示例">方法执行示例</h2>
<p>以输入 <code>nums = [1,2,3]</code> 为例：</p>
<h3 id="方法一分析">方法一分析</h3>
<ul>
<li>mask = 0 (000)：选择 [] → 空集</li>
<li>mask = 1 (001)：选择 [1]</li>
<li>mask = 2 (010)：选择 [2]</li>
<li>mask = 3 (011)：选择 [1,2]</li>
<li>mask = 4 (100)：选择 [3]</li>
<li>mask = 5 (101)：选择 [1,3]</li>
<li>mask = 6 (110)：选择 [2,3]</li>
<li>mask = 7 (111)：选择 [1,2,3]</li>
</ul>
<h3 id="方法二分析">方法二分析</h3>
<p>回溯法的执行轨迹如下：</p>
<ol>
<li>初始状态：<code>[]</code></li>
<li>选择 1：<code>[1]</code> → 递归下去
<ul>
<li>选择 2：<code>[1,2]</code> → 递归下去
<ul>
<li>选择 3：<code>[1,2,3]</code> → 递归结束，添加子集</li>
</ul>
</li>
<li>选择 3：<code>[1,3]</code> → 递归结束，添加子集</li>
</ul>
</li>
<li>选择 2：<code>[2]</code> → 递归下去
<ul>
<li>选择 3：<code>[2,3]</code> → 递归结束，添加子集</li>
</ul>
</li>
<li>选择 3：<code>[3]</code> → 递归结束，添加子集</li>
</ol>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>位运算迭代法</th>
<th>回溯DFS递归法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n * 2^n)</td>
<td>O(n * 2^n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>实现简洁，直观</td>
<td>更灵活，适用于其他组合问题</td>
</tr>
<tr>
<td>缺点</td>
<td>基于位运算，不易扩展</td>
<td>递归开销可能较大</td>
</tr>
<tr>
<td>代码复杂度</td>
<td>较低</td>
<td>中等</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>对于两种方法，时间复杂度都是 O(n * 2^n)：</p>
<ul>
<li>方法一：我们需要生成 2^n 个子集，每个子集需要 O(n) 的时间来检查每位并构建。</li>
<li>方法二：总共有 2^n 个子集，每个子集需要 O(n) 的时间来构建。</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<p>两种方法的空间复杂度都为 O(n)，不考虑输出结果的空间：</p>
<ul>
<li>方法一：临时数组 tmp 的空间为 O(n)。</li>
<li>方法二：递归栈的深度最多为 O(n)，临时数组 tmpArray 的空间为 O(n)。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>组合问题的位运算技巧</strong>：使用二进制位表示选择状态是解决组合问题的有效技巧。</li>
<li><strong>回溯法的应用</strong>：回溯法是解决组合、排列问题的通用方法。</li>
<li><strong>数组复制的注意事项</strong>：在构建结果时，需要创建新的数组副本而不是直接添加引用。</li>
</ol>
<h2 id="相关问题">相关问题</h2>
<ul>
<li>LeetCode 90: 子集 II（包含重复元素的子集问题）</li>
<li>LeetCode 46: 全排列</li>
<li>LeetCode 77: 组合</li>
</ul>
<p>通过本题，我们可以掌握两种不同的思路来解决子集生成问题，并将这些思路应用到其他类似的组合和排列问题中。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>回溯</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 790 - 多米诺和托米诺平铺</title>
    <url>/2025/05/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。</p>
<p><img src="/2025/05/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/1746505479685.png" alt="1746505479685"></p>
<p>给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。</p>
<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: 五种不同的方法如下所示。</span><br></pre></td></tr></table></figure>
<p>下面是五种平铺方式的示意图：</p>
<p><img src="/2025/05/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/1746505493673.png" alt="1746505493673"></p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= n &lt;= 1000</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题目是一个典型的<strong>动态规划</strong>问题，关键在于如何定义状态和转移方程。</p>
<p>首先考虑我们要铺的是一个 2 x n 的面板，每一列的状态可以有四种情况：</p>
<ol>
<li>状态 0：当前列没有被覆盖</li>
<li>状态 1：当前列的上方格子被覆盖，下方格子未被覆盖</li>
<li>状态 2：当前列的下方格子被覆盖，上方格子未被覆盖</li>
<li>状态 3：当前列的两个格子都被覆盖</li>
</ol>
<p>对于状态 1 和 2，意味着有一个 L 形状的瓷砖的一部分从前一列延伸到当前列中的一个格子。</p>
<p>定义 dp[i][j] 表示铺到第 i 列，当前列的状态为 j 的方案数量。</p>
<h3 id="状态转移方程">状态转移方程</h3>
<p>观察不同状态之间的转移可以得到：</p>
<ol>
<li>$dp[i][0]$（当前列都没有被覆盖）只能从 $dp[i-1][3]$ 转移而来，因为前一列必须完全覆盖才能导致当前列都没有覆盖。</li>
<li>$dp[i][1]$（当前列上方被覆盖）可以从 $dp[i-1][0]$ 和 $dp[i-1][2]$ 转移而来。</li>
<li>$dp[i][2]$（当前列下方被覆盖）可以从 $dp[i-1][0]$ 和 $dp[i-1][1]$ 转移而来。</li>
<li>$dp[i][3]$（当前列都被覆盖）可以从所有四种状态 $dp[i-1][0]$、$dp[i-1][1]$、$dp[i-1][2]$ 和 $dp[i-1][3]$ 转移而来。</li>
</ol>
<p>转移方程如下：</p>
<ul>
<li>$dp[i][0] = dp[i-1][3]$</li>
<li>$dp[i][1] = dp[i-1][0] + dp[i-1][2]$</li>
<li>$dp[i][2] = dp[i-1][0] + dp[i-1][1]$</li>
<li>$dp[i][3] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3]$</li>
</ul>
<h3 id="初始状态设置">初始状态设置</h3>
<p>对于 $i = 0$ 的情况（即一个&quot;虚拟&quot;的前导列），我们需要设置合适的初始值：</p>
<ul>
<li>$dp[0][0] = 0$</li>
<li>$dp[0][1] = 0$</li>
<li>$dp[0][2] = 0$</li>
<li>$dp[0][3] = 1$（表示前导列已完全覆盖，这是唯一有效的开始状态）</li>
</ul>
<p>最终，$dp[n][3]$ 就是我们要找的答案，表示铺到第 $n$ 列且全部覆盖的方案数。</p>
<h2 id="实现细节">实现细节</h2>
<p>在实现中，需要注意以下几点：</p>
<ol>
<li>由于答案可能很大，需要对 $10^9 + 7$ 取模</li>
<li>我们需要特别处理 $n &lt; 3$ 的边界情况</li>
<li>动态规划数组需要初始化为 $(n+1) \times 4$ 的大小</li>
</ol>
<p>让我们通过一个简单的例子（$n = 3$）来说明算法的执行过程：</p>
<p>初始状态：$dp[0][3] = 1$，其他初始值均为 $0$</p>
<p>第一列（$i = 1$）：</p>
<ul>
<li>$dp[1][0] = dp[0][3] = 1$</li>
<li>$dp[1][1] = dp[0][0] + dp[0][2] = 0$</li>
<li>$dp[1][2] = dp[0][0] + dp[0][1] = 0$</li>
<li>$dp[1][3] = dp[0][0] + dp[0][1] + dp[0][2] + dp[0][3] = 1$</li>
</ul>
<p>第二列（$i = 2$）：</p>
<ul>
<li>$dp[2][0] = dp[1][3] = 1$</li>
<li>$dp[2][1] = dp[1][0] + dp[1][2] = 1$</li>
<li>$dp[2][2] = dp[1][0] + dp[1][1] = 1$</li>
<li>$dp[2][3] = dp[1][0] + dp[1][1] + dp[1][2] + dp[1][3] = 3$</li>
</ul>
<p>第三列（$i = 3$）：</p>
<ul>
<li>$dp[3][0] = dp[2][3] = 3$</li>
<li>$dp[3][1] = dp[2][0] + dp[2][2] = 2$</li>
<li>$dp[3][2] = dp[2][0] + dp[2][1] = 2$</li>
<li>$dp[3][3] = dp[2][0] + dp[2][1] + dp[2][2] + dp[2][3] = 5$</li>
</ul>
<p>因此，对于 $n = 3$，答案是 $dp[3][3] = 5$。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTilings</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 确保数组大小足够，至少为4</span></span><br><span class="line">    total := n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> total &lt; <span class="number">4</span> &#123;</span><br><span class="line">        total = <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建dp数组</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, total)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置初始状态</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">3</span>]</span><br><span class="line">        dp[i][<span class="number">1</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">2</span>]) % mod</span><br><span class="line">        dp[i][<span class="number">2</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>]) % mod</span><br><span class="line">        dp[i][<span class="number">3</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>] + dp[i<span class="number">-1</span>][<span class="number">2</span>] + dp[i<span class="number">-1</span>][<span class="number">3</span>]) % mod</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂解法">矩阵快速幂解法</h2>
<p>仔细观察状态转移方程，可以发现这是一个线性递推关系。当我们面对这类问题时，可以使用矩阵快速幂来优化时间复杂度。</p>
<h3 id="推导转移矩阵">推导转移矩阵</h3>
<p>根据状态转移方程：</p>
<ul>
<li>$dp[i][0] = dp[i-1][3]$</li>
<li>$dp[i][1] = dp[i-1][0] + dp[i-1][2]$</li>
<li>$dp[i][2] = dp[i-1][0] + dp[i-1][1]$</li>
<li>$dp[i][3] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3]$</li>
</ul>
<p>我们可以写成矩阵形式：</p>
<p>$$<br>
\begin{pmatrix}<br>
dp[i][0] \<br>
dp[i][1] \<br>
dp[i][2] \<br>
dp[i][3]<br>
\end{pmatrix} =<br>
\begin{pmatrix}<br>
0 &amp; 0 &amp; 0 &amp; 1 \<br>
1 &amp; 0 &amp; 1 &amp; 0 \<br>
1 &amp; 1 &amp; 0 &amp; 0 \<br>
1 &amp; 1 &amp; 1 &amp; 1<br>
\end{pmatrix} \times<br>
\begin{pmatrix}<br>
dp[i-1][0] \<br>
dp[i-1][1] \<br>
dp[i-1][2] \<br>
dp[i-1][3]<br>
\end{pmatrix}<br>
$$</p>
<p>设上述矩阵为 $M$，则有：</p>
<p>$$<br>
\begin{pmatrix}<br>
dp[n][0] \<br>
dp[n][1] \<br>
dp[n][2] \<br>
dp[n][3]<br>
\end{pmatrix} =<br>
\begin{pmatrix}<br>
0 &amp; 0 &amp; 0 &amp; 1 \<br>
1 &amp; 0 &amp; 1 &amp; 0 \<br>
1 &amp; 1 &amp; 0 &amp; 0 \<br>
1 &amp; 1 &amp; 1 &amp; 1<br>
\end{pmatrix}^n \times<br>
\begin{pmatrix}<br>
dp[0][0] \<br>
dp[0][1] \<br>
dp[0][2] \<br>
dp[0][3]<br>
\end{pmatrix} =<br>
M^n \times<br>
\begin{pmatrix}<br>
0 \<br>
0 \<br>
0 \<br>
1<br>
\end{pmatrix}<br>
$$</p>
<h3 id="使用矩阵快速幂解题">使用矩阵快速幂解题</h3>
<p>矩阵快速幂的核心思想是将 $M^n$ 的计算时间从 $O(n)$ 降低到 $O(\log n)$，类似于整数的快速幂算法。计算 $M^n$ 的过程如下：</p>
<ol>
<li>初始化结果矩阵 $R$ 为单位矩阵 $I$</li>
<li>当 $n &gt; 0$ 时：
<ul>
<li>如果 $n$ 是奇数，$R = R \times M$</li>
<li>$M = M \times M$</li>
<li>$n = \lfloor n/2 \rfloor$</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTilings</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义转移矩阵</span></span><br><span class="line">    m := [][]<span class="type">int</span>&#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算M^(n-1)</span></span><br><span class="line">    res := matrixPow(m, n<span class="number">-1</span>, mod)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始状态为[0,0,0,1]，经过矩阵乘法后第4个元素即为答案</span></span><br><span class="line">    <span class="comment">// 由于我们需要计算的是dp[n][3]，对应初始状态乘以矩阵M^n后的第4行</span></span><br><span class="line">    <span class="keyword">return</span> (res[<span class="number">3</span>][<span class="number">0</span>]*<span class="number">0</span> + res[<span class="number">3</span>][<span class="number">1</span>]*<span class="number">0</span> + res[<span class="number">3</span>][<span class="number">2</span>]*<span class="number">0</span> + res[<span class="number">3</span>][<span class="number">3</span>]*<span class="number">1</span>) % mod</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixPow</span><span class="params">(a [][]<span class="type">int</span>, n <span class="type">int</span>, mod <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    size := <span class="built_in">len</span>(a)</span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="type">int</span>, size)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        res[i] = <span class="built_in">make</span>([]<span class="type">int</span>, size)</span><br><span class="line">        res[i][i] = <span class="number">1</span> <span class="comment">// 初始化为单位矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快速幂计算</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">            res = matrixMultiply(res, a, mod)</span><br><span class="line">        &#125;</span><br><span class="line">        a = matrixMultiply(a, a, mod)</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixMultiply</span><span class="params">(a, b [][]<span class="type">int</span>, mod <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    size := <span class="built_in">len</span>(a)</span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>, size)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        result[i] = <span class="built_in">make</span>([]<span class="type">int</span>, size)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; size; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ &#123;</span><br><span class="line">                result[i][j] = (result[i][j] + a[i][k]*b[k][j]) % mod</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>动态规划方法</th>
<th>矩阵快速幂方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>$O(n)$</td>
<td>$O(\log n)$</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>$O(n)$ 或 $O(1)$（优化后）</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单，思路清晰</td>
<td>处理大数据时效率极高</td>
</tr>
<tr>
<td>缺点</td>
<td>对于 $n$ 很大时效率低</td>
<td>实现复杂，需要矩阵操作相关知识</td>
</tr>
<tr>
<td>适用情景</td>
<td>$n$ 较小或需要中间状态</td>
<td>$n$ 非常大且只需要最终结果</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h3 id="时间复杂度分析">时间复杂度分析</h3>
<ol>
<li><strong>动态规划方法</strong>：时间复杂度为 $O(n)$，因为我们需要从1到n遍历一次。</li>
<li><strong>矩阵快速幂方法</strong>：时间复杂度为 $O(\log n)$，由于矩阵快速幂的性质，我们只需要进行约 $\log n$ 次矩阵乘法操作。</li>
</ol>
<p>当 $n$ 非常大时（比如 $n=10^9$），动态规划方法会超时，而矩阵快速幂方法仍然可以高效计算结果。</p>
<h3 id="空间优化">空间优化</h3>
<p>对于动态规划方法，由于每一步只依赖前一步的状态，我们可以将空间复杂度优化为O(1)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTilingsOptimized</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mod = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只保存前一列的状态</span></span><br><span class="line">    dp := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        newDp := [<span class="number">4</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">        newDp[<span class="number">0</span>] = dp[<span class="number">3</span>]</span><br><span class="line">        newDp[<span class="number">1</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">2</span>]) % mod</span><br><span class="line">        newDp[<span class="number">2</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">1</span>]) % mod</span><br><span class="line">        newDp[<span class="number">3</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">1</span>] + dp[<span class="number">2</span>] + dp[<span class="number">3</span>]) % mod</span><br><span class="line">        dp = newDp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：$O(n)$，其中 $n$ 是给定的整数。我们只需要遍历一次从 1 到 $n$ 的所有列，对每一列进行常数时间的操作。</li>
<li><strong>空间复杂度</strong>：$O(n)$，需要一个 $(n+1) \times 4$ 的二维数组来存储动态规划的状态。</li>
</ul>
<h2 id="优化空间复杂度">优化空间复杂度</h2>
<p>注意到每一列的状态只与前一列的状态有关，因此我们可以使用滚动数组优化空间复杂度至 $O(1)$。这里为了代码清晰，保留了原始实现。</p>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>状态表示的重要性</strong>：这道题的关键在于如何表示每一列的状态，使得状态转移方程清晰明了。</li>
<li><strong>动态规划状态定义</strong>：本题中，我们定义了四种状态来描述每一列的覆盖情况，这是解决此类组合计数问题的典型方法。</li>
<li><strong>初始状态的设置</strong>：对于动态规划问题，正确设置初始状态对于得到正确结果至关重要。</li>
<li><strong>取模运算</strong>：对于可能产生大数的问题，需要在每一步都进行取模操作，而不是只在最后取模。</li>
<li><strong>线性递推关系识别</strong>：当发现状态转移存在线性递推关系时，可以考虑使用矩阵快速幂优化。</li>
<li><strong>算法选择的权衡</strong>：根据问题规模和需求，在动态规划与矩阵快速幂之间做出合适的选择。</li>
</ol>
<h2 id="相关问题">相关问题</h2>
<ul>
<li>LeetCode 70: 爬楼梯 (类似的动态规划问题)</li>
<li>LeetCode 62: 不同路径 (网格类动态规划)</li>
<li>LeetCode 91: 解码方法 (状态转移问题)</li>
<li>LeetCode 509: 斐波那契数 (可用矩阵快速幂优化)</li>
<li>LeetCode 1220: 统计元音字母序列的数目 (矩阵快速幂应用)</li>
</ul>
<p>通过这道题，我们可以学习到如何使用动态规划解决复杂的组合计数问题，特别是那些涉及到多种可能状态的问题。同时，我们也了解到当状态转移呈线性递推关系时，矩阵快速幂是一种强大的优化工具，能够将时间复杂度从 $O(n)$ 降低到 $O(\log n)$，这在处理大规模输入时尤为重要。</p>
<h2 id="矩阵快速幂解法的数学证明">矩阵快速幂解法的数学证明</h2>
<p>矩阵快速幂的正确性基于矩阵乘法的结合律：$(A \times B) \times C = A \times (B \times C)$。</p>
<p>对于计算 $M^n$，我们可以使用二进制分解的思想：<br>
$n = b_k 2^k + b_{k-1} 2^{k-1} + \ldots + b_1 2^1 + b_0 2^0$，其中 $b_i \in {0, 1}$</p>
<p>则 $M^n = M^{b_k 2^k} \times M^{b_{k-1} 2^{k-1}} \times \ldots \times M^{b_1 2^1} \times M^{b_0 2^0}$</p>
<p>例如，$M^{11} = M^8 \times M^2 \times M^1$，因为 $11 = 1011_2 = 2^3 + 2^1 + 2^0$</p>
<p>通过预计算 $M^1, M^2, M^4, M^8, \ldots, M^{2^k}$，我们可以在 $O(\log n)$ 的时间内计算 $M^n$。</p>
<p>而计算 $M^{2^i}$ 也非常简单：$M^{2^i} = M^{2^{i-1}} \times M^{2^{i-1}}$</p>
<p>这种算法的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function MatrixPow(M, n):</span><br><span class="line">    R = I  // 单位矩阵</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        if n is odd:</span><br><span class="line">            R = R × M</span><br><span class="line">        M = M × M</span><br><span class="line">        n = n / 2</span><br><span class="line">    return R</span><br></pre></td></tr></table></figure>
<p>通过这种方法，我们将 $O(n)$ 次矩阵乘法优化至 $O(\log n)$ 次，极大提高了算法效率。</p>
<h3 id="矩阵快速幂的实际应用">矩阵快速幂的实际应用</h3>
<p>矩阵快速幂在计算线性递推关系时非常有用。除了本题之外，它还可以应用于：</p>
<ol>
<li>斐波那契数列计算：$F_n = F_{n-1} + F_{n-2}$</li>
<li>计算一般形式的线性递推关系：$x_n = a_1 x_{n-1} + a_2 x_{n-2} + \ldots + a_k x_{n-k}$</li>
<li>某些图论问题，如计算从顶点 $i$ 到顶点 $j$ 长度为 $k$ 的路径数量</li>
</ol>
<p>在这些应用中，矩阵快速幂都可以将算法的时间复杂度从 $O(n)$ 优化至 $O(\log n)$，特别是当 $n$ 很大时，这种优化会带来巨大的性能提升。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>❌错题集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 131 - 分割回文串（Palindrome Partitioning）</title>
    <url>/2025/05/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是<strong>回文串</strong>。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong>是正着读和反着读都一样的字符串。</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>
<h3 id="约束条件：">约束条件：</h3>
<ul>
<li>1 &lt;= s.length &lt;= 16</li>
<li>s 仅由小写英文字母组成</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题的核心思路是使用<strong>回溯算法</strong>来枚举所有可能的分割方案，同时我们需要判断每个子串是否为回文串。为了高效判断子串是否为回文，我们可以使用两种优化方法：</p>
<ol>
<li><strong>预处理法</strong>：提前计算出所有子串是否为回文，使用动态规划自底向上填表</li>
<li><strong>记忆化搜索法</strong>：使用自顶向下的记忆化搜索，按需计算子串是否为回文</li>
</ol>
<p>两种方法都结合回溯算法来枚举所有可能的分割方案。下面分别详细介绍这两种解法。</p>
<h2 id="方法一：动态规划预处理-回溯">方法一：动态规划预处理 + 回溯</h2>
<h3 id="实现细节">实现细节</h3>
<p>这个方法分为两个主要步骤：</p>
<ol>
<li>
<p><strong>预处理回文判断</strong>：使用动态规划预先计算出字符串 <code>s</code> 的所有子串是否为回文</p>
<ul>
<li>定义 <code>isPalindrome[i][j]</code> 表示 <code>s[i:j+1]</code> 是否为回文串</li>
<li>单个字符一定是回文：<code>isPalindrome[i][i] = true</code></li>
<li>对于长度大于1的子串 <code>s[i:j+1]</code>，当且仅当 <code>s[i] == s[j]</code> 且 <code>s[i+1:j]</code> 为回文串时，该子串才是回文</li>
</ul>
</li>
<li>
<p><strong>使用回溯生成所有分割方案</strong>：</p>
<ul>
<li>从字符串起始位置开始，尝试不同的分割点</li>
<li>当找到一个回文子串时，将其加入当前路径，然后继续处理剩余部分</li>
<li>当处理到字符串末尾时，将当前路径加入结果集</li>
<li>回溯时移除最后添加的子串，尝试其他可能的分割点</li>
</ul>
</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// isPalindrome[i][j] 表示 s[i:j+1] 是否为回文串</span></span><br><span class="line">    isPalindrome := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> isPalindrome &#123;</span><br><span class="line">        isPalindrome[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">        <span class="comment">// 单个字符一定是回文</span></span><br><span class="line">        isPalindrome[i][i] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理所有子串是否为回文</span></span><br><span class="line">    <span class="comment">// 从下往上、从左往右填充，确保计算 isPalindrome[i][j] 时，isPalindrome[i+1][j-1] 已经计算好</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="comment">// 当前子串是回文的条件：两端字符相同且中间部分是回文（或长度为2）</span></span><br><span class="line">            isPalindrome[i][j] = (s[i] == s[j]) &amp;&amp; (j - i &lt;= <span class="number">2</span> || isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">string</span> <span class="comment">// 当前路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS回溯搜索所有可能的分割方案</span></span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 到达字符串末尾，找到一个有效方案</span></span><br><span class="line">        <span class="keyword">if</span> start == n &#123;</span><br><span class="line">            <span class="comment">// 拷贝当前路径并加入结果集</span></span><br><span class="line">            pathCopy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(pathCopy, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, pathCopy)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从start开始的每个可能的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> end := start; end &lt; n; end++ &#123;</span><br><span class="line">            <span class="comment">// 只有当前子串是回文时，才继续递归</span></span><br><span class="line">            <span class="keyword">if</span> isPalindrome[start][end] &#123;</span><br><span class="line">                <span class="comment">// 将当前回文子串加入路径</span></span><br><span class="line">                path = <span class="built_in">append</span>(path, s[start:end+<span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 递归处理剩余子串</span></span><br><span class="line">                backtrack(end + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 回溯，移除最后加入的子串</span></span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二：记忆化搜索-回溯">方法二：记忆化搜索 + 回溯</h2>
<h3 id="实现细节-2">实现细节</h3>
<p>这个方法同样分为两个主要步骤，但使用自顶向下的记忆化搜索来判断回文：</p>
<ol>
<li>
<p><strong>记忆化搜索判断回文</strong>：</p>
<ul>
<li>使用 <code>memo[i][j]</code> 记录 <code>s[i:j+1]</code> 是否为回文的结果</li>
<li>0 表示未计算，1 表示是回文，-1 表示不是回文</li>
<li>自顶向下地判断子串是否为回文，并将结果缓存起来避免重复计算</li>
</ul>
</li>
<li>
<p><strong>回溯生成所有分割方案</strong>：</p>
<ul>
<li>回溯部分与方法一相同，只是回文判断使用记忆化搜索的方式</li>
</ul>
</li>
</ol>
<h3 id="代码实现-2">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// memo[i][j] 表示 s[i:j+1] 是否为回文串的记忆化</span></span><br><span class="line">    <span class="comment">// 0:未计算 1:是回文 -1:不是回文</span></span><br><span class="line">    memo := <span class="built_in">make</span>([][]<span class="type">int8</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> memo &#123;</span><br><span class="line">        memo[i] = <span class="built_in">make</span>([]<span class="type">int8</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断子串 s[i:j+1] 是否为回文</span></span><br><span class="line">    <span class="keyword">var</span> isPalindrome <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">int8</span></span><br><span class="line">    isPalindrome = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">int8</span> &#123;</span><br><span class="line">        <span class="comment">// 单个字符或空串是回文</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经计算过，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> memo[i][j] != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认不是回文</span></span><br><span class="line">        memo[i][j] = <span class="number">-1</span></span><br><span class="line">        <span class="comment">// 如果两端字符相同，且中间部分是回文，则整体是回文</span></span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j] &amp;&amp; isPalindrome(i+<span class="number">1</span>, j<span class="number">-1</span>) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            memo[i][j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result [][]<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="type">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS回溯搜索所有可能的分割方案</span></span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 到达字符串末尾，找到一个有效方案</span></span><br><span class="line">        <span class="keyword">if</span> start == n &#123;</span><br><span class="line">            <span class="comment">// 拷贝当前路径并加入结果集</span></span><br><span class="line">            pathCopy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(pathCopy, path)</span><br><span class="line">            result = <span class="built_in">append</span>(result, pathCopy)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从start开始的每个可能的回文子串</span></span><br><span class="line">        <span class="keyword">for</span> end := start; end &lt; n; end++ &#123;</span><br><span class="line">            <span class="comment">// 只有当前子串是回文时，才继续递归</span></span><br><span class="line">            <span class="keyword">if</span> isPalindrome(start, end) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将当前回文子串加入路径</span></span><br><span class="line">                path = <span class="built_in">append</span>(path, s[start:end+<span class="number">1</span>])</span><br><span class="line">                <span class="comment">// 递归处理剩余子串</span></span><br><span class="line">                backtrack(end + <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 回溯，移除最后加入的子串</span></span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一：预处理DP+回溯</th>
<th>方法二：记忆化搜索+回溯</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n²) + O(n·2^n)</td>
<td>O(n²) + O(n·2^n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n²)</td>
<td>O(n²)</td>
</tr>
<tr>
<td>优点</td>
<td>预处理所有子串，判断回文更快</td>
<td>按需计算，可能不需要判断所有子串</td>
</tr>
<tr>
<td>缺点</td>
<td>需要预先计算所有子串</td>
<td>递归调用有额外开销</td>
</tr>
<tr>
<td>适用场景</td>
<td>字符串长度较短，需要判断大量子串</td>
<td>字符串长度较长，回文子串较少</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<p>两种方法的时间复杂度和空间复杂度如下：</p>
<h3 id="方法一：预处理DP-回溯">方法一：预处理DP+回溯</h3>
<ul>
<li>
<p><strong>时间复杂度</strong>：$O(n^2 + n \cdot 2^n)$</p>
<ul>
<li>预处理判断所有子串是否为回文需要 $O(n^2)$ 的时间</li>
<li>回溯生成所有分割方案的时间复杂度为 $O(n \cdot 2^n)$，因为对于长度为 n 的字符串，共有 $2^{n-1}$ 种可能的分割方案，每种方案需要 $O(n)$ 的时间来构建结果</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：$O(n^2)$</p>
<ul>
<li>存储所有子串的回文性质需要 $O(n^2)$ 的空间</li>
<li>递归调用栈深度和当前路径最多需要 $O(n)$ 的空间</li>
</ul>
</li>
</ul>
<h3 id="方法二：记忆化搜索-回溯-2">方法二：记忆化搜索+回溯</h3>
<ul>
<li>
<p><strong>时间复杂度</strong>：$O(n^2 + n \cdot 2^n)$</p>
<ul>
<li>记忆化搜索最多需要判断 $O(n^2)$ 个子串</li>
<li>回溯部分的时间复杂度与方法一相同，为 $O(n \cdot 2^n)$</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：$O(n^2)$</p>
<ul>
<li>存储记忆化搜索结果需要 $O(n^2)$ 的空间</li>
<li>递归调用栈深度和当前路径最多需要 $O(n)$ 的空间</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>回文串判断的优化</strong>：通过动态规划或记忆化搜索，我们可以高效判断子串是否为回文，避免重复计算。</p>
</li>
<li>
<p><strong>回溯算法的应用</strong>：通过回溯算法，我们可以系统地枚举所有可能的分割方案，这是一个经典的组合问题。</p>
</li>
<li>
<p><strong>两种策略比较</strong>：</p>
<ul>
<li>动态规划（自底向上）：预先计算所有结果，适用于需要大量查询的场景</li>
<li>记忆化搜索（自顶向下）：按需计算，适用于只需计算部分结果的场景</li>
</ul>
</li>
<li>
<p><strong>递归与迭代的选择</strong>：</p>
<ul>
<li>在字符串长度较短（如本题限制为 16）的情况下，两种方法的性能差异不大</li>
<li>对于更大规模的问题，预处理方法可能更有效，因为避免了递归调用的开销</li>
</ul>
</li>
<li>
<p><strong>Go语言技巧</strong>：</p>
<ul>
<li>使用闭包实现局部递归函数</li>
<li>通过切片操作实现回溯过程中的路径管理</li>
<li>深拷贝结果避免引用同一个切片</li>
</ul>
</li>
</ol>
<p>相关问题：</p>
<ul>
<li>LeetCode 132: 分割回文串 II</li>
<li>LeetCode 647: 回文子串</li>
<li>LeetCode 5: 最长回文子串</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>动态规划</tag>
        <tag>❌错题集</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL八股: COUNT(*)与COUNT(1)的区别与性能对比</title>
    <url>/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/</url>
    <content><![CDATA[<h1>COUNT(*) 和 COUNT(1) 有什么区别？哪个性能最好？</h1>
<h2 id="引言">引言</h2>
<p>在MySQL性能优化面试中，经常会被问到：“<code>COUNT(*)</code>和<code>COUNT(1)</code>有什么区别？哪个性能更好？”</p>
<p>这个问题看似简单，实则暗藏玄机。很多人（包括我曾经）都认为<code>COUNT(*)</code>效率较差，因为它会读取所有字段，就像<code>SELECT * FROM table</code>一样。网上也有许多文章持这种观点。</p>
<p>但当我深入研究后，发现事实并非如此！本文将揭开这个常见MySQL八股文的真相。</p>
<h2 id="结论先行">结论先行</h2>
<p>先给出明确结论，方便大家理解：</p>
<blockquote>
<p><strong>性能排序</strong>: COUNT(*) = COUNT(1) &gt; COUNT(主键字段) &gt; COUNT(普通字段)</p>
</blockquote>
<p>接下来，让我们一步步分析原理，看看为什么会有这样的结论。</p>
<h2 id="COUNT函数基础知识">COUNT函数基础知识</h2>
<h3 id="COUNT-是什么？">COUNT() 是什么？</h3>
<p>COUNT()是一个聚合函数，其作用是：<strong>统计符合查询条件的记录中，函数参数不为NULL的记录数量</strong>。</p>
<p>这个函数的参数可以是：</p>
<ul>
<li>字段名</li>
<li>常量表达式（如数字1）</li>
<li>特殊符号（如*）</li>
</ul>
<h3 id="不同COUNT用法的含义">不同COUNT用法的含义</h3>
<table>
<thead>
<tr>
<th>用法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT(字段名)</td>
<td>统计该字段不为NULL的记录数</td>
</tr>
<tr>
<td>COUNT(1)</td>
<td>统计表中的记录数（1永远不为NULL）</td>
</tr>
<tr>
<td>COUNT(*)</td>
<td>统计表中的记录数（MySQL特殊优化）</td>
</tr>
</tbody>
</table>
<p>举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计t_order表中name字段不为NULL的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(name) <span class="keyword">FROM</span> t_order;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计t_order表中的总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> t_order;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> t_order;</span><br></pre></td></tr></table></figure>
<h2 id="COUNT不同用法的执行原理">COUNT不同用法的执行原理</h2>
<p>为了理解性能差异，我们需要了解不同COUNT用法的执行过程。以下分析基于InnoDB存储引擎。</p>
<h3 id="执行过程概述">执行过程概述</h3>
<p>当执行COUNT函数时，MySQL服务器层会：</p>
<ol>
<li>维护一个计数变量count</li>
<li>从存储引擎读取记录</li>
<li>判断COUNT函数参数是否为NULL</li>
<li>如果不为NULL，count变量+1</li>
<li>读完所有记录后，返回count值</li>
</ol>
<p>关键差异在于：<strong>MySQL从哪里读取记录</strong>以及<strong>是否需要读取字段值</strong>。</p>
<h3 id="COUNT-主键字段-的执行过程">COUNT(主键字段)的执行过程</h3>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746455045381.png" alt="COUNT(id)执行过程"></p>
<p>执行<code>SELECT COUNT(id) FROM t_order</code>（id为主键）时：</p>
<ol>
<li>
<p><strong>如果只有主键索引</strong>：</p>
<ul>
<li>InnoDB遍历聚簇索引</li>
<li>读取每条记录的id值</li>
<li>判断id是否为NULL（通常主键不允许NULL）</li>
<li>如果不为NULL，计数+1</li>
</ul>
</li>
<li>
<p><strong>如果有二级索引</strong>：</p>
<ul>
<li>InnoDB会选择最小的二级索引进行遍历</li>
<li>因为二级索引通常比聚簇索引小，I/O成本更低</li>
</ul>
</li>
</ol>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746455063103.png" alt="使用二级索引"></p>
<h3 id="COUNT-1-的执行过程">COUNT(1)的执行过程</h3>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746455092896.png" alt="COUNT(1)执行过程"></p>
<p>执行<code>SELECT COUNT(1) FROM t_order</code>时：</p>
<ol>
<li>
<p><strong>选择索引</strong>：</p>
<ul>
<li>同样会优先选择最小的索引进行遍历</li>
</ul>
</li>
<li>
<p><strong>关键差异</strong>：</p>
<ul>
<li><strong>不需要读取记录中的任何字段值</strong></li>
<li>常量1永远不为NULL，直接计数+1</li>
</ul>
</li>
</ol>
<p>这就是为什么<code>COUNT(1)</code>比<code>COUNT(主键字段)</code>快一点 - 少了读取和判断字段值的步骤。</p>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746455233210.png" alt="COUNT(1)使用二级索引"></p>
<h3 id="COUNT-的执行过程">COUNT(*)的执行过程</h3>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746455281065.png" alt="COUNT(*)执行过程"></p>
<p>许多人误解的地方来了：<code>COUNT(*)</code>并不会读取所有字段！</p>
<p><strong>事实</strong>：MySQL对<code>COUNT(*)</code>做了特殊优化，将其视为<code>COUNT(0)</code>处理。</p>
<p>从MySQL 5.7官方手册：</p>
<blockquote>
<p><em>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</em></p>
<p><em>翻译：InnoDB以相同的方式处理SELECT COUNT(*)和SELECT COUNT(1)操作，没有性能差异。</em></p>
</blockquote>
<p>所以，<code>COUNT(*)</code>和<code>COUNT(1)</code>的执行过程基本相同，性能也几乎一样。</p>
<h3 id="COUNT-普通字段-的执行过程">COUNT(普通字段)的执行过程</h3>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746455424755.png" alt="COUNT(name)执行过程"></p>
<p>执行<code>SELECT COUNT(name) FROM t_order</code>（name是普通非索引字段）时：</p>
<ol>
<li>需要遍历表记录</li>
<li><strong>必须读取name字段的值</strong></li>
<li>判断name是否为NULL</li>
<li>如果不为NULL，计数+1</li>
</ol>
<p>这通常需要全表扫描，效率最低。</p>
<h2 id="为什么InnoDB必须遍历表来计数？">为什么InnoDB必须遍历表来计数？</h2>
<p>你可能会问：为什么不直接维护一个计数器？</p>
<p>这是因为存储引擎的设计差异：</p>
<h3 id="MyISAM-vs-InnoDB">MyISAM vs InnoDB</h3>
<ol>
<li>
<p><strong>MyISAM引擎</strong>：</p>
<ul>
<li>维护表的元数据，包括row_count值</li>
<li>执行<code>COUNT(*)</code>只需O(1)复杂度</li>
<li>直接返回row_count值</li>
</ul>
</li>
<li>
<p><strong>InnoDB引擎</strong>：</p>
<ul>
<li>支持事务和MVCC(多版本并发控制)</li>
<li>同一时刻的多个事务可能看到不同的行数</li>
<li>无法维护单一的row_count变量</li>
</ul>
</li>
</ol>
<h3 id="MVCC导致的计数差异">MVCC导致的计数差异</h3>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746455436512.png" alt="事务导致的COUNT差异"></p>
<p>如上图所示，在事务环境下：</p>
<ul>
<li>会话A开启事务，两次查询都是100条记录</li>
<li>会话B插入一条记录后进行查询，得到的是101条记录</li>
</ul>
<p>这就是为什么InnoDB必须遍历表来计数 - 每个事务可能看到不同的结果。</p>
<h2 id="如何优化大表的COUNT操作？">如何优化大表的COUNT操作？</h2>
<p>对大表执行COUNT操作会很慢。例如：</p>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746456443887.png" alt="大表COUNT耗时"></p>
<p>上面的例子中，一张有1200万记录的表，即使有二级索引，<code>COUNT(*)</code>仍需近5秒！</p>
<h3 id="优化方案一：使用近似值">优化方案一：使用近似值</h3>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746456461290.png" alt="搜索引擎的近似计数"></p>
<p>如果业务允许近似值，可以使用：</p>
<ul>
<li><code>SHOW TABLE STATUS</code> 命令</li>
<li><code>EXPLAIN</code> 命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看表状态，获取行数估计值</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;t_order&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用EXPLAIN获取行数估计值</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/05/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/2025-05-05-count-vs-count1/1746456489201.png" alt="EXPLAIN估算行数"></p>
<p>这些命令非常快，因为它们不会真正扫描表，而是基于统计信息估算。</p>
<h3 id="优化方案二：单独的计数表">优化方案二：单独的计数表</h3>
<p>如果需要精确计数，可以：</p>
<ol>
<li>创建专门的计数表</li>
<li>在数据表的增删操作中同步更新计数表</li>
<li>查询时直接从计数表获取数值</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建计数表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> t_counts (</span><br><span class="line">    table_name <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    row_count <span class="type">BIGINT</span> UNSIGNED</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化计数</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> t_counts <span class="keyword">VALUES</span> (<span class="string">&#x27;t_order&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在插入t_order时更新计数</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> t_order <span class="keyword">VALUES</span> (...);</span><br><span class="line"><span class="keyword">UPDATE</span> t_counts <span class="keyword">SET</span> row_count <span class="operator">=</span> row_count <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;t_order&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在删除t_order时更新计数</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="keyword">UPDATE</span> t_counts <span class="keyword">SET</span> row_count <span class="operator">=</span> row_count <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;t_order&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式需要在应用层确保数据一致性，但查询效率极高。</p>
<h2 id="最佳实践总结">最佳实践总结</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐做法</th>
</tr>
</thead>
<tbody>
<tr>
<td>需要统计表总行数</td>
<td>优先使用<code>COUNT(*)</code>或<code>COUNT(1)</code>，二者性能相当</td>
</tr>
<tr>
<td>需要统计某字段非NULL值</td>
<td>对该字段建立索引，然后使用<code>COUNT(字段名)</code></td>
</tr>
<tr>
<td>大表统计且允许近似值</td>
<td>使用<code>SHOW TABLE STATUS</code>或<code>EXPLAIN</code></td>
</tr>
<tr>
<td>大表需要精确统计且频繁查询</td>
<td>使用单独的计数表维护行数</td>
</tr>
<tr>
<td>有二级索引的表</td>
<td>MySQL优化器会自动选择最小的索引</td>
</tr>
</tbody>
</table>
<h2 id="结论">结论</h2>
<ol>
<li><strong><code>COUNT(*)</code>和<code>COUNT(1)</code>性能基本相同</strong>，都经过了MySQL的优化</li>
<li>都优于<code>COUNT(主键字段)</code>，因为不需要取值比较</li>
<li><code>COUNT(普通字段)</code>效率最低，除非你只想统计该字段非NULL的记录</li>
<li>大表统计时，考虑使用近似值或专门的计数表</li>
<li>针对特定业务场景，选择合适的计数方式才是王道</li>
</ol>
<p>希望本文能帮助你彻底理解这个常见的MySQL面试题，在实际工作中做出正确的选择！</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 46 - 全排列（Permutations）错误分析</title>
    <url>/2025/05/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p><a href="https://leetcode.cn/problems/permutations/">全排列</a>是一个经典的回溯算法问题：</p>
<p>给定一个不含重复数字的数组 <code>nums</code>，返回其所有可能的全排列。你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 6</li>
<li>-10 &lt;= nums[i] &lt;= 10</li>
<li>nums 中的所有整数互不相同</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我的初始解法使用了经典的回溯算法，但在实现过程中有一个值得注意的错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    flag := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    tmpArray := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            <span class="keyword">var</span> tmp []<span class="type">int</span>  <span class="comment">// ❌ 错误点：切片声明但未分配内存</span></span><br><span class="line">            <span class="built_in">copy</span>(tmp, tmpArray)  <span class="comment">// ❌ 复制操作无效，因为tmp长度为0</span></span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> !flag[i] &#123;</span><br><span class="line">                flag[i] = <span class="literal">true</span></span><br><span class="line">                tmpArray[index] = nums[i]</span><br><span class="line">                dfs(index + <span class="number">1</span>)</span><br><span class="line">                flag[i] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法在执行过程中会发现结果为空，因为我在复制切片时犯了一个常见错误。</p>
<h3 id="错误原因分析">错误原因分析</h3>
<p>错误发生在完成排列构建后添加结果到 <code>res</code> 的代码部分：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp []<span class="type">int</span></span><br><span class="line"><span class="built_in">copy</span>(tmp, tmpArray)</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br></pre></td></tr></table></figure>
<p><strong>错误原因：</strong></p>
<ol>
<li><code>var tmp []int</code> 声明了一个空切片，其长度和容量都为 0</li>
<li>Go语言的 <code>copy()</code> 函数只会复制目标切片能够容纳的元素数量</li>
<li>由于 <code>tmp</code> 的长度为 0，所以 <code>copy(tmp, tmpArray)</code> 实际上没有复制任何元素</li>
<li>结果是每次都将一个空切片追加到 <code>res</code> 中</li>
</ol>
<p>这是 Go 语言中处理切片时的一个常见陷阱。在 Go 中，切片是对底层数组的引用，不是独立的数据结构。<code>copy()</code> 函数需要目标切片有足够的长度才能复制元素。</p>
<h2 id="正确解法">正确解法</h2>
<p>经过分析，修复后的解法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> (res [][]<span class="type">int</span>) &#123;</span><br><span class="line">    flag := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    tmpArray := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(index <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))  <span class="comment">// ✅ 正确：为新切片分配足够的空间</span></span><br><span class="line">            <span class="built_in">copy</span>(tmp, tmpArray)  <span class="comment">// 现在复制操作会正确进行</span></span><br><span class="line">            res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> !flag[i] &#123;</span><br><span class="line">                flag[i] = <span class="literal">true</span></span><br><span class="line">                tmpArray[index] = nums[i]</span><br><span class="line">                dfs(index + <span class="number">1</span>)</span><br><span class="line">                flag[i] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这个解法可以工作">为什么这个解法可以工作</h3>
<p>修复方法很简单：使用 <code>make()</code> 函数为 <code>tmp</code> 切片分配适当的长度，确保它有足够的容量来接收复制的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))  <span class="comment">// 分配正确长度的内存</span></span><br></pre></td></tr></table></figure>
<p>这样，<code>copy(tmp, tmpArray)</code> 函数就能正确复制所有元素，而不是创建空结果。</p>
<h3 id="另一个可能的解决方案">另一个可能的解决方案</h3>
<p>另外，我们也可以直接使用切片的追加操作来创建一个新的切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tmp := <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, tmpArray...)  <span class="comment">// 通过追加创建新切片</span></span><br></pre></td></tr></table></figure>
<p>或者更简洁的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tmp := <span class="built_in">append</span>(<span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums)), tmpArray...)</span><br></pre></td></tr></table></figure>
<p>这些方法同样可以创建 <code>tmpArray</code> 的深拷贝，避免引用同一个底层数组。</p>
<h2 id="学习总结">学习总结</h2>
<p>从这个错误中，我们可以学到几个关于 Go 语言切片操作的重要知识点：</p>
<ol>
<li><strong>切片深拷贝需要注意内存分配</strong>：在 Go 中进行切片复制时，必须确保目标切片有足够的长度</li>
<li><strong><code>copy()</code> 函数的行为</strong>：<code>copy()</code> 只会复制目标切片能容纳的元素数量，不会自动扩展目标切片</li>
<li><strong>变量声明与内存分配的区别</strong>：<code>var tmp []int</code> 只是声明了变量，没有分配内存；而 <code>make([]int, len)</code> 会分配指定长度的内存</li>
<li><strong>回溯算法中的状态复制</strong>：在回溯算法中，将临时状态加入结果集时，必须创建深拷贝，否则后续的修改会影响已存储的结果</li>
</ol>
<p>这个错误提醒我们在 Go 语言编程中要特别注意切片的内存管理和复制操作，避免因引用共享导致的意外行为。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 208 - 实现 Trie (前缀树)</title>
    <url>/2025/05/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>Trie（发音类似 “try”）或者说前缀树，是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code>。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code>。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code>，返回 <code>true</code>；否则，返回 <code>false</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);     // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);       // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;);   // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);       // 返回 True</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数总计不超过 <code>3 * 10^4</code> 次</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>实现一个 Trie 前缀树需要我们理解其核心数据结构和操作原理。Trie 树是一种多叉树结构，每个节点代表字符串中的一个字符，从根节点到某一节点的路径上经过的字符连接起来，就是该节点对应的字符串。</p>
<h3 id="关键概念">关键概念</h3>
<ul>
<li><strong>节点结构</strong>：每个节点包含多个子节点（对应不同字符）和一个标志位（标记是否是单词结尾）</li>
<li><strong>路径表示</strong>：从根到任意节点的路径对应一个前缀</li>
<li><strong>查找效率</strong>：查找、插入操作的时间复杂度为 O(m)，其中 m 是字符串长度</li>
</ul>
<h3 id="基本实现思路">基本实现思路</h3>
<ol>
<li>创建一个 Trie 类，维护一个根节点</li>
<li>定义节点结构，包含子节点映射和单词结束标记</li>
<li>实现插入、查找、前缀匹配三个核心操作</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="初始实现及其问题">初始实现及其问题</h3>
<p>最初的实现使用了一个长度为 255 的数组来表示每个节点的所有可能子节点，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    children []*TrieNode <span class="comment">// 长度为 255 的数组</span></span><br><span class="line">    flag     <span class="type">bool</span>        <span class="comment">// 标记单词结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题分析</strong>：</p>
<ul>
<li><strong>空间浪费</strong>：对于只包含小写字母的题目，分配 255 个指针（覆盖整个 ASCII 范围）是极大的浪费</li>
<li><strong>缓存效率低</strong>：较大的节点结构会导致缓存命中率降低</li>
<li><strong>内存分配开销</strong>：每个新节点都需要分配大量内存，增加 GC 压力</li>
</ul>
<h3 id="优化方案">优化方案</h3>
<p><strong>方案1：减小子节点数组大小</strong></p>
<p>由于题目明确字符串仅由小写英文字母组成，可以将数组大小从 255 减少到 26：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    children [<span class="number">26</span>]*TrieNode <span class="comment">// 只针对小写字母 a-z</span></span><br><span class="line">    isEnd    <span class="type">bool</span>          <span class="comment">// 标记单词结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方案2：使用哈希表代替固定数组</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    children <span class="keyword">map</span>[<span class="type">rune</span>]*TrieNode <span class="comment">// 使用哈希表存储子节点</span></span><br><span class="line">    isEnd    <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方案比较</strong>：</p>
<ul>
<li>对于本题（字符集小且确定），固定大小的数组更优</li>
<li>当字符集较大或不确定时，哈希表方案更灵活</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<h3 id="优化后的-Trie-实现">优化后的 Trie 实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *TrieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    children [<span class="number">26</span>]*TrieNode <span class="comment">// 只针对小写字母 a-z</span></span><br><span class="line">    isEnd    <span class="type">bool</span>          <span class="comment">// 标记单词结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Trie &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;</span><br><span class="line">        root: &amp;TrieNode&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">    node := this.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span> <span class="comment">// 将字符映射到0-25的索引</span></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            node.children[index] = &amp;TrieNode&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span> <span class="comment">// 标记单词结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    node := this.searchPrefix(word)</span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nil</span> &amp;&amp; node.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.searchPrefix(prefix) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取公共查找逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span></span> searchPrefix(prefix <span class="type">string</span>) *TrieNode &#123;</span><br><span class="line">    node := this.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        index := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.children[index] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行示例">执行示例</h3>
<p>以 <code>insert(&quot;apple&quot;)</code> 为例，执行过程如下：</p>
<ol>
<li>从根节点开始</li>
<li>处理 ‘a’：计算索引(0)，创建对应子节点</li>
<li>处理 ‘p’：计算索引(15)，创建对应子节点</li>
<li>处理 ‘p’：使用已存在的索引15子节点</li>
<li>处理 ‘l’：计算索引(11)，创建对应子节点</li>
<li>处理 ‘e’：计算索引(4)，创建对应子节点</li>
<li>标记 ‘e’ 节点的 isEnd 为 true，表示 “apple” 是一个完整单词</li>
</ol>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>原始实现</th>
<th>优化实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(m)</td>
<td>O(m)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(255*n)</td>
<td>O(26*n)</td>
</tr>
<tr>
<td>内存使用</td>
<td>较高</td>
<td>降低约90%</td>
</tr>
<tr>
<td>缓存效率</td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>简单</td>
<td>简单</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li><strong>插入操作</strong>：O(m)，其中 m 是单词长度</li>
<li><strong>查找操作</strong>：O(m)</li>
<li><strong>前缀匹配</strong>：O(m)</li>
</ul>
<p>上述操作的时间复杂度都是线性的，与单词长度成正比，这是最优的。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li><strong>原始实现</strong>：O(255*n)，其中 n 是所有插入单词的字符总数</li>
<li><strong>优化实现</strong>：O(26*n)，减少了约 90% 的空间使用</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>空间优化很重要</strong>：在处理大量数据的树结构时，节点设计对整体性能影响巨大</li>
<li><strong>针对约束优化</strong>：根据题目约束（如字符集限制）有针对性地优化数据结构</li>
<li><strong>提取公共逻辑</strong>：将重复的搜索逻辑提取为单独方法，提高代码可维护性</li>
<li><strong>常量级优化</strong>：虽然复杂度级别相同，但常数级优化（如从255减少到26）在实际执行中能带来显著提升</li>
</ol>
<h2 id="Trie的常见应用">Trie的常见应用</h2>
<ul>
<li><strong>自动补全</strong>：搜索引擎、输入法的单词补全功能</li>
<li><strong>拼写检查</strong>：检查单词拼写是否正确</li>
<li><strong>字符串匹配</strong>：在大量字符串中快速查找</li>
<li><strong>路由匹配</strong>：Web服务器的URL路由</li>
</ul>
<p>Trie树虽然实现简单，但在处理字符串前缀查询方面有着无可比拟的优势，是一种非常实用的数据结构。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>树</tag>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解幂等性原理及应用</title>
    <url>/2025/05/05/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%B9%82%E7%AD%89%E6%80%A7/2025-05-05-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>在分布式系统和微服务架构日益普及的今天，系统的可靠性、一致性和容错性变得尤为重要。在这样的背景下，**幂等性(Idempotence)**作为一种核心设计原则，在确保系统可靠性方面发挥着至关重要的作用。</p>
<p>无论是设计RESTful API、消息队列处理系统、还是分布式事务处理，幂等性都是构建健壮系统的关键特性。本文将系统地介绍幂等性概念，并通过实际案例分析其在各种场景下的应用方法和最佳实践。</p>
<h2 id="幂等性的基本概念">幂等性的基本概念</h2>
<h3 id="定义与起源">定义与起源</h3>
<p>幂等性最初源自数学领域，描述了一种特殊的运算性质：对于操作 $f$，如果满足 $f(f(x)) = f(x)$，则称 $f$ 是幂等的。简单来说，就是无论对某个元素应用一次操作还是多次操作，结果都是相同的。</p>
<p>在计算机科学和系统设计中，幂等性被扩展为：<strong>对系统进行一次操作与多次重复同样的操作，产生的系统状态变化是一致的</strong>。</p>
<h3 id="幂等性的核心特征">幂等性的核心特征</h3>
<ol>
<li><strong>结果一致性</strong>：多次执行同一操作，最终系统状态相同</li>
<li><strong>副作用可控</strong>：重复操作不会产生意外的副作用</li>
<li><strong>状态收敛</strong>：无论执行多少次，系统最终会收敛到同一状态</li>
<li><strong>操作可重试</strong>：失败后可以安全地进行重试</li>
</ol>
<h3 id="幂等与非幂等操作对比">幂等与非幂等操作对比</h3>
<table>
<thead>
<tr>
<th>幂等操作</th>
<th>非幂等操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取资源 (GET)</td>
<td>创建新资源 (POST)</td>
</tr>
<tr>
<td>设置资源为特定状态</td>
<td>递增计数器</td>
</tr>
<tr>
<td>删除特定资源</td>
<td>向列表追加元素</td>
</tr>
<tr>
<td>根据条件更新资源</td>
<td>无条件追加数据</td>
</tr>
</tbody>
</table>
<h2 id="为什么幂等性如此重要？">为什么幂等性如此重要？</h2>
<p>在分布式系统设计中，幂等性解决了许多关键挑战：</p>
<h3 id="1-分布式系统的不确定性">1. 分布式系统的不确定性</h3>
<p>分布式环境中存在诸多不确定因素：网络延迟、分区、节点故障等。这些因素可能导致：</p>
<ul>
<li>客户端超时后进行重试，但原操作实际已成功</li>
<li>消息重复投递到消费者</li>
<li>服务之间的通信失败，需要重新发送请求</li>
</ul>
<p>在这些情况下，幂等操作确保系统不会因为重复处理而进入不一致状态。</p>
<h3 id="2-提升系统可靠性">2. 提升系统可靠性</h3>
<ul>
<li><strong>简化错误恢复</strong>：系统可以简单地重试失败的幂等操作，而无需复杂的补偿逻辑</li>
<li><strong>增强容错能力</strong>：即使某些操作重复执行，系统也能保持一致状态</li>
<li><strong>减少数据不一致风险</strong>：防止因重试导致的数据异常（如重复扣款、多次下单）</li>
</ul>
<h3 id="3-改善用户体验">3. 改善用户体验</h3>
<ul>
<li>防止用户因网络问题导致的&quot;双重提交&quot;</li>
<li>允许用户安全地刷新页面或重试操作</li>
<li>提供更可预测和一致的系统行为</li>
</ul>
<h2 id="HTTP方法的幂等性分析">HTTP方法的幂等性分析</h2>
<p>在RESTful API设计中，HTTP方法的幂等性是一个核心设计考量：</p>
<pre class="mermaid">graph TD
    A[HTTP方法] --&gt; B{是否幂等?}
    B --&gt;|幂等| C[GET]
    B --&gt;|幂等| D[PUT]
    B --&gt;|幂等| E[DELETE]
    B --&gt;|幂等| F[HEAD]
    B --&gt;|幂等| G[OPTIONS]
    B --&gt;|非幂等| H[POST]
    B --&gt;|通常非幂等| I[PATCH]</pre>
<h3 id="幂等的HTTP方法">幂等的HTTP方法</h3>
<table>
<thead>
<tr>
<th>HTTP方法</th>
<th>幂等性</th>
<th>安全性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>✅</td>
<td>✅</td>
<td>只检索资源，不修改服务器状态</td>
</tr>
<tr>
<td>HEAD</td>
<td>✅</td>
<td>✅</td>
<td>与GET类似，但只返回头信息</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>✅</td>
<td>✅</td>
<td>获取资源支持的方法，不修改状态</td>
</tr>
<tr>
<td>PUT</td>
<td>✅</td>
<td>❌</td>
<td>替换目标资源，重复操作结果相同</td>
</tr>
<tr>
<td>DELETE</td>
<td>✅</td>
<td>❌</td>
<td>删除资源，多次删除效果相同</td>
</tr>
</tbody>
</table>
<h3 id="非幂等的HTTP方法">非幂等的HTTP方法</h3>
<table>
<thead>
<tr>
<th>HTTP方法</th>
<th>幂等性</th>
<th>安全性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>❌</td>
<td>❌</td>
<td>通常用于创建资源，多次调用可能创建多个资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>❌/✅</td>
<td>❌</td>
<td>部分更新资源，根据实现可能是幂等的</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意: 这里的&quot;安全性&quot;指的是方法是否会修改服务器上的资源，而非安全防护措施。</p>
</blockquote>
<h2 id="API设计中的幂等性实现">API设计中的幂等性实现</h2>
<p>在API设计中实现幂等性有多种策略，以下是三种最常用的方法：</p>
<h3 id="1-使用幂等键-Idempotency-Keys">1. 使用幂等键 (Idempotency Keys)</h3>
<p>为每个请求分配唯一标识符，服务器记录和检查这些标识符以防止重复处理：</p>
<pre class="mermaid">sequenceDiagram
    participant 客户端
    participant 服务器
    participant 数据库
    
    客户端-&gt;&gt;服务器: POST /orders {idempotency-key: &quot;abc123&quot;, ...}
    服务器-&gt;&gt;数据库: 检查key &quot;abc123&quot; 是否已处理
    数据库--&gt;&gt;服务器: 未处理
    服务器-&gt;&gt;数据库: 创建订单并存储 key &quot;abc123&quot;
    数据库--&gt;&gt;服务器: 成功
    服务器--&gt;&gt;客户端: 201 Created
    
    Note over 客户端,服务器: 网络问题导致客户端超时
    
    客户端-&gt;&gt;服务器: 重试相同请求 {idempotency-key: &quot;abc123&quot;, ...}
    服务器-&gt;&gt;数据库: 检查key &quot;abc123&quot; 是否已处理
    数据库--&gt;&gt;服务器: 已处理
    服务器--&gt;&gt;客户端: 返回之前的响应结果</pre>
<p><strong>关键实现点</strong>：</p>
<ul>
<li>客户端生成全局唯一的幂等键（如UUID）</li>
<li>服务器存储已处理的幂等键及其响应</li>
<li>对于包含相同幂等键的请求，服务器返回存储的响应</li>
<li>设置幂等键的过期策略（TTL）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器端伪代码</span></span><br><span class="line"><span class="keyword">const</span> processedRequests = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processOrder</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> idempotencyKey = req.<span class="property">headers</span>[<span class="string">&#x27;idempotency-key&#x27;</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!idempotencyKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(<span class="string">&#x27;Missing idempotency key&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检查是否已处理过该请求</span></span><br><span class="line">  <span class="keyword">if</span> (processedRequests.<span class="title function_">has</span>(idempotencyKey)) &#123;</span><br><span class="line">    <span class="keyword">const</span> previousResponse = processedRequests.<span class="title function_">get</span>(idempotencyKey);</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(previousResponse.<span class="property">status</span>).<span class="title function_">send</span>(previousResponse.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理新请求</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建订单逻辑...</span></span><br><span class="line">    <span class="keyword">const</span> order = <span class="title function_">createOrder</span>(req.<span class="property">body</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存响应以备后续重试</span></span><br><span class="line">    processedRequests.<span class="title function_">set</span>(idempotencyKey, &#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">201</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123; <span class="attr">orderId</span>: order.<span class="property">id</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">201</span>).<span class="title function_">send</span>(&#123; <span class="attr">orderId</span>: order.<span class="property">id</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 处理错误...</span></span><br><span class="line">    processedRequests.<span class="title function_">set</span>(idempotencyKey, &#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="number">500</span>,</span><br><span class="line">      <span class="attr">data</span>: &#123; <span class="attr">error</span>: error.<span class="property">message</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: error.<span class="property">message</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-条件请求与乐观锁">2. 条件请求与乐观锁</h3>
<p>使用HTTP条件请求头和资源版本控制来确保幂等更新：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端代码示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">updateUser</span>(<span class="params">userId, userData</span>) &#123;</span><br><span class="line">  <span class="comment">// 先获取当前资源状态和ETag</span></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/users/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> etag = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;ETag&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用If-Match头进行条件更新</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">`/users/<span class="subst">$&#123;userId&#125;</span>`</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;If-Match&#x27;</span>: etag</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(userData)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优势</strong>：</p>
<ul>
<li>防止并发更新导致的数据覆盖</li>
<li>符合HTTP标准，不需要额外的存储机制</li>
<li>客户端可以检测到资源已被修改并作出相应处理</li>
</ul>
<h3 id="3-使用业务自然键">3. 使用业务自然键</h3>
<p>利用业务领域的自然唯一标识符来确保幂等性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用业务自然键作为资源标识符</span></span><br><span class="line"><span class="comment">// POST /users</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;email&quot;</span>: <span class="string">&quot;user@example.com&quot;</span>,  <span class="comment">// 用作自然键</span></span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;role&quot;</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端伪代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createUser</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; email, name, role &#125; = req.<span class="property">body</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 检查用户是否已存在</span></span><br><span class="line">  <span class="keyword">const</span> existingUser = <span class="title function_">findUserByEmail</span>(email);</span><br><span class="line">  <span class="keyword">if</span> (existingUser) &#123;</span><br><span class="line">    <span class="comment">// 用户已存在，返回现有用户</span></span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">send</span>(existingUser);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建新用户</span></span><br><span class="line">  <span class="keyword">const</span> newUser = <span class="title function_">createNewUser</span>(email, name, role);</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">201</span>).<span class="title function_">send</span>(newUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>适用场景</strong>：</p>
<ul>
<li>用户注册（邮箱作为自然键）</li>
<li>产品目录（产品编码作为自然键）</li>
<li>配置项（配置键作为自然键）</li>
</ul>
<h2 id="分布式系统中的幂等性">分布式系统中的幂等性</h2>
<p>在分布式系统中，幂等性是确保系统稳定性和数据一致性的关键机制。</p>
<h3 id="消息队列与事件处理">消息队列与事件处理</h3>
<p>消息队列系统（如Kafka、RabbitMQ）通常会在网络故障后重试消息投递，而消费者必须准备好处理重复消息：</p>
<pre class="mermaid">flowchart LR
    A[生产者] --&gt;|发送消息| B[消息队列]
    B --&gt;|投递消息| C[消费者]
    C --&gt;|处理消息| D{是否幂等处理?}
    D --&gt;|是| E[安全重复处理]
    D --&gt;|否| F[可能导致数据不一致]</pre>
<p><strong>非幂等与幂等消费者对比</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非幂等消费者示例（有问题）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(PaymentMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接处理付款 - 重复处理会导致多次付款</span></span><br><span class="line">    paymentService.deductAmount(message.getAccountId(), message.getAmount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂等消费者示例（安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(PaymentMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查支付ID是否已处理</span></span><br><span class="line">    <span class="keyword">if</span> (paymentRepository.existsById(message.getPaymentId())) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Payment &#123;&#125; already processed, skipping&quot;</span>, message.getPaymentId());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理付款并记录已处理的支付ID</span></span><br><span class="line">    paymentService.deductAmount(message.getAccountId(), message.getAmount());</span><br><span class="line">    paymentRepository.saveProcessedId(message.getPaymentId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现消息队列幂等性的策略">实现消息队列幂等性的策略</h3>
<ol>
<li><strong>唯一消息ID</strong>：为每条消息分配全局唯一ID</li>
<li><strong>消息去重表</strong>：在消费者端维护已处理消息ID的记录</li>
<li><strong>业务状态检查</strong>：基于业务状态判断是否已处理</li>
<li><strong>幂等性窗口期</strong>：仅在特定时间窗口内进行去重处理</li>
</ol>
<h3 id="分布式事务中的幂等性">分布式事务中的幂等性</h3>
<p>在分布式事务中，幂等操作可以极大简化补偿逻辑和故障恢复：</p>
<pre class="mermaid">sequenceDiagram
    participant 服务A
    participant 服务B
    participant 服务C
    
    Note over 服务A,服务C: 分布式事务开始
    
    服务A-&gt;&gt;服务B: 操作1 (幂等)
    服务B--&gt;&gt;服务A: 成功
    服务A-&gt;&gt;服务C: 操作2 (幂等)
    
    Note over 服务C: 服务C失败
    服务C--&gt;&gt;服务A: 失败
    
    Note over 服务A,服务C: 重试整个事务
    
    服务A-&gt;&gt;服务B: 操作1 (幂等重试)
    服务B--&gt;&gt;服务A: 成功 (无副作用)
    服务A-&gt;&gt;服务C: 操作2 (幂等重试)
    服务C--&gt;&gt;服务A: 成功
    
    Note over 服务A,服务C: 事务完成</pre>
<h3 id="微服务架构中的幂等性传播">微服务架构中的幂等性传播</h3>
<p>在微服务调用链中，幂等性应当从最外层API一直传播到所有下游服务：</p>
<ol>
<li><strong>幂等键传播</strong>：上游服务生成的幂等键通过请求头或消息属性传递给下游服务</li>
<li><strong>全链路跟踪</strong>：使用分布式追踪工具（如Jaeger、Zipkin）来跟踪请求在服务间的流转</li>
<li><strong>一致性哈希</strong>：确保相同请求始终路由到相同服务实例</li>
</ol>
<h2 id="基础设施中的幂等性">基础设施中的幂等性</h2>
<h3 id="Infrastructure-as-Code-IaC">Infrastructure as Code (IaC)</h3>
<p>现代基础设施工具如Terraform、Ansible通过声明式配置实现幂等性操作：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ansible幂等任务示例</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">确保Nginx已安装</span></span><br><span class="line">  <span class="attr">apt:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    </span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">确保Nginx服务运行</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>Terraform示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 幂等的Terraform配置</span><br><span class="line">resource &quot;aws_s3_bucket&quot; &quot;example_bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;example-bucket&quot;</span><br><span class="line">  acl    = &quot;private&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_iam_user&quot; &quot;example_user&quot; &#123;</span><br><span class="line">  name = &quot;example-user&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器编排与Kubernetes">容器编排与Kubernetes</h3>
<p>Kubernetes以声明式API为特色，使基础设施变更具有幂等性：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kubernetes幂等资源定义</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h2 id="幂等性实现的挑战与解决方案">幂等性实现的挑战与解决方案</h2>
<h3 id="常见挑战">常见挑战</h3>
<ol>
<li><strong>并发处理</strong>: 多个请求同时到达时如何确保幂等性</li>
<li><strong>幂等键存储</strong>: 如何高效存储和查询幂等键</li>
<li><strong>跨服务幂等</strong>: 如何在微服务架构中传播幂等性</li>
<li><strong>长时间运行的操作</strong>: 如何处理长时间运行操作的幂等性</li>
<li><strong>幂等与业务规则冲突</strong>: 某些业务场景可能本质上不是幂等的</li>
</ol>
<h3 id="解决方案">解决方案</h3>
<h4 id="1-并发问题">1. 并发问题</h4>
<p>多个客户端同时发送幂等请求时，可能导致竞态条件：</p>
<p><strong>解决方案</strong>:</p>
<ul>
<li><strong>分布式锁</strong>: 使用Redis、ZooKeeper实现分布式锁</li>
<li><strong>乐观锁</strong>: 使用版本号或条件更新防止并发冲突</li>
<li><strong>唯一约束</strong>: 在数据库层使用唯一约束确保幂等</li>
<li><strong>事务隔离</strong>: 选择适当的事务隔离级别（如SERIALIZABLE）</li>
</ul>
<h4 id="2-幂等键管理">2. 幂等键管理</h4>
<p>幂等键的生成、存储和过期策略需要仔细设计：</p>
<p><strong>解决方案</strong>:</p>
<ul>
<li><strong>客户端生成</strong>: 在客户端生成UUID作为幂等键</li>
<li><strong>TTL机制</strong>: 实现幂等键的自动过期机制</li>
<li><strong>分区存储</strong>: 根据时间或业务维度分区存储幂等键</li>
<li><strong>异步清理</strong>: 定期清理过期的幂等键记录</li>
</ul>
<h4 id="3-系统边界与幂等性传播">3. 系统边界与幂等性传播</h4>
<p>在复杂系统中维持端到端的幂等性：</p>
<p><strong>解决方案</strong>:</p>
<ul>
<li><strong>请求上下文</strong>: 在整个调用链中传递请求上下文（包含幂等键）</li>
<li><strong>分布式事务</strong>: 使用TCC或Saga模式确保分布式事务的一致性</li>
<li><strong>补偿逻辑</strong>: 为非幂等操作设计补偿逻辑</li>
<li><strong>异步确认</strong>: 使用确认/回执机制防止重复处理</li>
</ul>
<h2 id="实际应用案例">实际应用案例</h2>
<h3 id="案例1：支付系统的幂等性">案例1：支付系统的幂等性</h3>
<p>支付处理是幂等性的典型应用场景，同一笔支付不能重复执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> PaymentResponse <span class="title function_">processPayment</span><span class="params">(PaymentRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否已存在相同支付ID的记录</span></span><br><span class="line">    <span class="keyword">if</span> (paymentRepository.existsByPaymentId(request.getPaymentId())) &#123;</span><br><span class="line">        <span class="comment">// 返回已存在的支付结果</span></span><br><span class="line">        <span class="type">Payment</span> <span class="variable">existingPayment</span> <span class="operator">=</span> paymentRepository.findByPaymentId(request.getPaymentId());</span><br><span class="line">        <span class="keyword">return</span> mapToResponse(existingPayment);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理新支付</span></span><br><span class="line">    <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Payment</span>();</span><br><span class="line">    payment.setPaymentId(request.getPaymentId());</span><br><span class="line">    payment.setAmount(request.getAmount());</span><br><span class="line">    payment.setStatus(PaymentStatus.PROCESSING);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存初始状态</span></span><br><span class="line">    paymentRepository.save(payment);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用支付网关</span></span><br><span class="line">        <span class="type">PaymentGatewayResponse</span> <span class="variable">gatewayResponse</span> <span class="operator">=</span> paymentGateway.processPayment(</span><br><span class="line">            request.getPaymentMethod(),</span><br><span class="line">            request.getAmount()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新支付状态</span></span><br><span class="line">        payment.setStatus(gatewayResponse.isSuccessful() ? </span><br><span class="line">                          PaymentStatus.COMPLETED : PaymentStatus.FAILED);</span><br><span class="line">        payment.setTransactionId(gatewayResponse.getTransactionId());</span><br><span class="line">        paymentRepository.save(payment);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mapToResponse(payment);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 更新支付状态为失败</span></span><br><span class="line">        payment.setStatus(PaymentStatus.FAILED);</span><br><span class="line">        payment.setFailureReason(e.getMessage());</span><br><span class="line">        paymentRepository.save(payment);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PaymentException</span>(<span class="string">&quot;Payment processing failed&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例2：库存管理系统">案例2：库存管理系统</h3>
<p>电子商务系统中的库存管理必须确保不会多次扣减同一订单的库存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrderInventory</span><span class="params">(OrderInventoryRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查订单ID是否已处理</span></span><br><span class="line">    <span class="keyword">if</span> (inventoryTransactionRepository.existsByOrderId(request.getOrderId())) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Order &#123;&#125; inventory already processed&quot;</span>, request.getOrderId());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理库存</span></span><br><span class="line">    <span class="keyword">for</span> (OrderItem item : request.getItems()) &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productRepository.findById(item.getProductId())</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">ProductNotFoundException</span>(item.getProductId()));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查库存</span></span><br><span class="line">        <span class="keyword">if</span> (product.getAvailableStock() &lt; item.getQuantity()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientStockException</span>(product.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减少库存</span></span><br><span class="line">        product.setAvailableStock(product.getAvailableStock() - item.getQuantity());</span><br><span class="line">        productRepository.save(product);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录库存交易</span></span><br><span class="line">        <span class="type">InventoryTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InventoryTransaction</span>();</span><br><span class="line">        transaction.setOrderId(request.getOrderId());</span><br><span class="line">        transaction.setProductId(product.getId());</span><br><span class="line">        transaction.setQuantity(item.getQuantity());</span><br><span class="line">        transaction.setType(TransactionType.DEDUCT);</span><br><span class="line">        transaction.setTimestamp(LocalDateTime.now());</span><br><span class="line">        inventoryTransactionRepository.save(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="幂等性设计最佳实践">幂等性设计最佳实践</h2>
<h3 id="系统设计阶段">系统设计阶段</h3>
<ol>
<li><strong>明确幂等性需求</strong>：在设计阶段识别哪些操作需要幂等性</li>
<li><strong>选择合适的幂等策略</strong>：根据业务场景选择最适合的幂等实现方式</li>
<li><strong>统一幂等机制</strong>：在整个系统中使用统一的幂等性处理框架</li>
<li><strong>考虑性能影响</strong>：评估幂等性实现对系统性能的影响</li>
<li><strong>设计异常处理</strong>：合理处理幂等性检查过程中的异常情况</li>
</ol>
<h3 id="API设计">API设计</h3>
<ol>
<li><strong>优先使用幂等HTTP方法</strong>：尽可能使用GET、PUT、DELETE等幂等方法</li>
<li><strong>文档化幂等性行为</strong>：在API文档中明确说明每个接口的幂等性特性</li>
<li><strong>标准化幂等键处理</strong>：定义清晰的幂等键格式和处理规范</li>
<li><strong>实现请求去重</strong>：为非幂等接口实现请求去重机制</li>
<li><strong>重试策略</strong>：为客户端提供明确的重试指导</li>
</ol>
<h3 id="实现与测试">实现与测试</h3>
<ol>
<li><strong>编写幂等性测试</strong>：专门测试系统在重复操作下的行为</li>
<li><strong>模拟网络故障</strong>：测试在各种网络故障场景下的系统行为</li>
<li><strong>压力测试</strong>：在高并发场景下测试幂等性机制的有效性</li>
<li><strong>审计与监控</strong>：记录和监控幂等性相关的事件和指标</li>
<li><strong>定期审查</strong>：定期审查幂等机制的有效性和性能</li>
</ol>
<h2 id="结论">结论</h2>
<p>幂等性是现代分布式系统架构中确保可靠性和一致性的核心原则。通过在API设计、消息处理、分布式事务等各个层面实现幂等性，系统可以更好地应对网络不稳定性、服务故障和并发操作等挑战。</p>
<p>关键收益包括：</p>
<ol>
<li><strong>提高系统可靠性</strong>：即使在网络不稳定或服务故障的情况下，系统也能保持数据一致性</li>
<li><strong>简化错误处理</strong>：客户端可以安全地进行重试，而无需担心副作用</li>
<li><strong>改善用户体验</strong>：防止因网络问题或用户重复操作导致的数据错误</li>
<li><strong>支持自动化</strong>：使自动化脚本和工具能够安全地重复执行</li>
<li><strong>降低运维复杂度</strong>：简化故障恢复和系统维护流程</li>
</ol>
<p>幂等性不仅是一个技术概念，更是一种系统设计哲学。在设计新系统或改进现有系统时，将幂等性作为核心设计原则之一，可以大幅提高系统的健壮性和可靠性。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://medium.com/cache-me-out/understanding-idempotency-68a50a837fc1">Understanding Idempotency</a></li>
<li><a href="https://hackernoon.com/the-idempotence-principle-in-software-architecture">The Idempotence Principle in Software Architecture</a></li>
<li><a href="https://restfulapi.net/idempotent-rest-apis/">REST API Design: Idempotent Operations</a></li>
<li><a href="https://www.confluent.io/blog/idempotent-kafka-consumers/">Idempotency Patterns in Event-Driven Systems</a></li>
<li><a href="https://tools.ietf.org/html/rfc7231#section-4.2.2">HTTP Semantics: Idempotent Methods</a></li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>架构设计</tag>
        <tag>API设计</tag>
        <tag>分布式系统</tag>
        <tag>幂等性</tag>
        <tag>RESTful API</tag>
        <tag>消息队列</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中使用&#39;Like&#39;一定会导致索引失效吗？</title>
    <url>/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/</url>
    <content><![CDATA[<h1>MySQL 中使用 Like 一定会导致索引失效吗？</h1>
<p>在 MySQL 性能优化的讨论中，常有一种说法认为&quot;使用 Like 会导致索引失效&quot;。本文将通过实际案例分析，探究这一说法是否永远成立，以及影响索引使用的真正因素。</p>
<h2 id="问题引入">问题引入</h2>
<p>我们通过两个不同结构的数据表来探究 Like 查询与索引的关系：</p>
<ul>
<li><strong>表结构一</strong>：包含多个字段，其中 <code>id</code>是自增主键索引，<code>name</code>是二级索引，其他为非索引字段。</li>
<li><strong>表结构二</strong>：仅包含两个字段，<code>id</code>是自增主键索引，<code>name</code>是二级索引。</li>
</ul>
<p>对于这两张表，我们将分别测试以下四种模糊查询语句：</p>
<ol>
<li><code>select * from s where name like &quot;xxx&quot;</code>（精确匹配，等同于等值查询）</li>
<li><code>select * from s where name like &quot;xxx%&quot;</code>（右模糊匹配）</li>
<li><code>select * from s where name like &quot;%xxx&quot;</code>（左模糊匹配）</li>
<li><code>select * from s where name like &quot;%xxx%&quot;</code>（全模糊匹配）</li>
</ol>
<p>通过分析执行计划，我们可以清晰地看出哪些情况会利用索引，哪些情况会导致索引失效。</p>
<h2 id="表结构一的执行分析">表结构一的执行分析</h2>
<p>表结构一包含多个字段，其中只有 <code>id</code>和 <code>name</code>是索引字段：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/1746413509580.png" alt="表结构一"></p>
<p>执行四条模糊查询后，结果显示：</p>
<ol>
<li><code>name like &quot;xxx&quot;</code>：<strong>走索引</strong>（实际是等值查询）</li>
<li><code>name like &quot;xxx%&quot;</code>：<strong>走索引</strong>（范围查询，type=range）</li>
</ol>
<p>下图是第二条查询的执行计划，可以看到使用了 <code>index_name</code>索引：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/1746413531031.png" alt="右模糊匹配执行计划"></p>
<ol start="3">
<li><code>name like &quot;%xxx&quot;</code>：<strong>索引失效</strong>（全表扫描，type=ALL）</li>
<li><code>name like &quot;%xxx%&quot;</code>：<strong>索引失效</strong>（全表扫描，type=ALL）</li>
</ol>
<p>下图是第三条查询的执行计划，可以看到进行了全表扫描：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/1746413547558.png" alt="左模糊匹配执行计划"></p>
<p><strong>结论</strong>：在包含非索引字段的表中，左模糊和全模糊查询确实会导致索引失效，进而触发全表扫描。</p>
<h2 id="表结构二的执行分析">表结构二的执行分析</h2>
<p>表结构二只有两个字段，都是索引字段：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/1746413572653.png" alt="表结构二"></p>
<p>执行相同的四条查询，结果却有所不同：</p>
<ol>
<li><code>name like &quot;xxx&quot;</code>：<strong>走索引</strong>（等值查询）</li>
<li><code>name like &quot;xxx%&quot;</code>：<strong>走索引</strong>（范围查询，type=range）</li>
</ol>
<p>下图是第二条查询的执行计划，不仅使用了索引，还利用了覆盖索引优化（Using index）：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/1746413589599.png" alt="表二右模糊匹配执行计划"></p>
<ol start="3">
<li><code>name like &quot;%xxx&quot;</code>：<strong>走索引</strong>（索引全扫描，type=index）</li>
<li><code>name like &quot;%xxx%&quot;</code>：<strong>走索引</strong>（索引全扫描，type=index）</li>
</ol>
<p>这是最出人意料的结果！左模糊和全模糊查询竟然也走了索引：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/1746413603153.png" alt="表二左模糊匹配执行计划"></p>
<h2 id="深入分析表结构二的特殊情况">深入分析表结构二的特殊情况</h2>
<p>为什么表结构二中的左模糊查询没有导致索引失效？这涉及到几个关键概念：</p>
<h3 id="1-覆盖索引的作用">1. 覆盖索引的作用</h3>
<p>在表结构二中，由于表只有 <code>id</code>和 <code>name</code>两个字段，而这两个字段都包含在二级索引中（二级索引的叶子节点包含&quot;索引值+主键值&quot;），所以 <code>select *</code>等同于 <code>select id,name</code>，可以直接从二级索引获取所有数据，无需回表操作。这就是<strong>覆盖索引</strong>的应用。</p>
<h3 id="2-索引全扫描-vs-全表扫描">2. 索引全扫描 vs 全表扫描</h3>
<p>虽然执行计划显示使用了索引（key=index_name），但 type=index 表示这是一个<strong>索引全扫描</strong>操作，而非利用索引进行快速定位的范围查询（type=range）。</p>
<p>索引全扫描是指遍历整个索引树，而全表扫描是遍历整个数据表。由于索引树通常比数据表小得多（特别是在字段较多的表中），所以 MySQL 优化器判断索引全扫描的成本低于全表扫描，因此选择了前者。</p>
<h3 id="3-为什么不使用聚簇索引？">3. 为什么不使用聚簇索引？</h3>
<p>MySQL 选择扫描二级索引树而非聚簇索引树，是因为：</p>
<ul>
<li>二级索引只存储&quot;索引列+主键值&quot;，数据量小</li>
<li>聚簇索引包含所有列数据、事务 ID、回滚指针等，数据量大</li>
<li>本查询可以使用覆盖索引，不需要回表操作</li>
</ul>
<p>因此，尽管无法利用索引的有序性（因为是左模糊匹配），但全扫描二级索引树仍然比全表扫描高效。</p>
<h3 id="4-为什么表结构一中会导致索引失效？">4. 为什么表结构一中会导致索引失效？</h3>
<p>当表中存在非索引字段且查询需要这些字段时，即使使用二级索引定位数据，也必须回表到聚簇索引获取完整记录。对于左模糊匹配，无法利用索引的有序性快速定位，必须遍历整个索引树并频繁回表，这比直接全表扫描的成本还高，因此优化器选择了全表扫描。</p>
<h2 id="结论与实用建议">结论与实用建议</h2>
<p>通过以上分析，我们可以得出以下结论：</p>
<ol>
<li>
<p><strong>Like 查询并非一定导致索引失效</strong>，关键在于模糊匹配的位置和表的结构：</p>
<ul>
<li>精确匹配和右模糊匹配（<code>like 'xxx%'</code>）通常能高效利用索引</li>
<li>左模糊和全模糊匹配在特定条件下也可能使用索引（索引全扫描）</li>
</ul>
</li>
<li>
<p><strong>决定是否使用索引的关键因素</strong>：</p>
<ul>
<li>查询是否能利用索引的有序性（前缀匹配可以，后缀匹配不行）</li>
<li>是否符合覆盖索引的条件（查询字段是否都在索引中）</li>
<li>优化器对成本的评估（索引扫描 vs 全表扫描）</li>
</ul>
</li>
<li>
<p><strong>实用优化建议</strong>：</p>
<ul>
<li>尽可能使用右模糊而非左模糊查询</li>
<li>对于必须使用左模糊的场景，考虑建立合适的覆盖索引</li>
<li>在特定场景下，可以考虑使用全文索引或其他专门的搜索技术</li>
</ul>
</li>
</ol>
<p>补充一点：这个规律同样适用于联合索引。即使没有遵循最左匹配原则，在所有查询字段都是索引字段的情况下，MySQL 也可能选择索引全扫描而非全表扫描：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/Mysql%E4%B8%AD%E4%BD%BF%E7%94%A8Like%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%90%97/1746413628199.png" alt="联合索引示例"></p>
<p>理解这些细节，有助于我们在实际工作中更准确地预估查询性能，并做出更合理的索引设计决策。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试题</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>索引失效</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引失效的常见情况详解</title>
    <url>/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<p>在日常工作中，我们常常通过建立索引来提高 SQL 查询速度。但索引并不是万能的，有些情况下即使建立了索引，查询还是会变成全表扫描，导致性能大幅下降。</p>
<p>本文将用简单易懂的方式介绍索引失效的常见场景，并给出相应的解决方案。</p>
<h2 id="索引是怎么存储的？">索引是怎么存储的？</h2>
<p>先来简单了解一下 MySQL 的索引存储结构，这有助于我们理解为什么某些操作会导致索引失效。</p>
<p>MySQL 默认使用 InnoDB 存储引擎，它采用 B+树作为索引的数据结构。关于为什么选择 B+树作为索引结构，可以查看这篇文章：<a href="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/">为什么 MySQL 喜欢 B+树？</a></p>
<p>InnoDB 和 MyISAM 引擎在索引实现上有个关键区别：</p>
<ul>
<li>InnoDB：B+树索引的叶子节点直接存放数据本身</li>
<li>MyISAM：B+树索引的叶子节点只存放数据的物理地址</li>
</ul>
<p>下面通过一个简单的用户表来说明：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>张某</td>
<td>26</td>
<td>北京市海淀区</td>
</tr>
<tr>
<td>2</td>
<td>林某</td>
<td>18</td>
<td>深圳市南山区</td>
</tr>
<tr>
<td>3</td>
<td>陈某</td>
<td>30</td>
<td>广州市海珠区</td>
</tr>
<tr>
<td>4</td>
<td>周某</td>
<td>34</td>
<td>深圳市南山区</td>
</tr>
<tr>
<td>5</td>
<td>曾某</td>
<td>25</td>
<td>上海市松江区</td>
</tr>
<tr>
<td>6</td>
<td>黄某</td>
<td>28</td>
<td>深圳市宝安区</td>
</tr>
<tr>
<td>7</td>
<td>谢某</td>
<td>38</td>
<td>北京市海淀区</td>
</tr>
<tr>
<td>8</td>
<td>钟某</td>
<td>23</td>
<td>广州市海珠区</td>
</tr>
<tr>
<td>9</td>
<td>吴某</td>
<td>28</td>
<td>上海市浦东新区</td>
</tr>
</tbody>
</table>
<p>MyISAM 引擎的索引结构（叶子节点存放数据地址）：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355645568.png" alt="1746355645568"></p>
<p>InnoDB 引擎的主键索引结构（叶子节点直接存放数据）：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355653892.png" alt="1746355653892"></p>
<p>InnoDB 有两种索引类型：</p>
<ol>
<li><strong>聚簇索引</strong>：上图所示的主键索引，叶子节点存放完整数据</li>
<li><strong>二级索引</strong>：普通字段创建的索引，叶子节点只存放主键值</li>
</ol>
<p>如果在 name 字段上创建索引，二级索引的结构如下：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355703954.png" alt="1746355703954"></p>
<p>了解这些结构后，我们来看看查询时是如何使用索引的：</p>
<h3 id="主键查询">主键查询</h3>
<p>当使用主键查询时，直接通过聚簇索引找到数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- id是主键</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="普通索引查询（需要回表）">普通索引查询（需要回表）</h3>
<p>当使用普通索引查询完整数据时，需要两步：</p>
<ol>
<li>先在二级索引中找到主键值</li>
<li>再通过主键值到聚簇索引中查找完整数据</li>
</ol>
<p>这个过程叫做<strong>回表</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- name是普通索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;林某&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="覆盖索引查询（不需要回表）">覆盖索引查询（不需要回表）</h3>
<p>如果只查询索引中已有的数据，就不需要回表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只查询id，而id已在name索引的叶子节点中</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;林某&quot;;</span><br></pre></td></tr></table></figure>
<p>这种情况下，所有数据都能在索引中找到，称为<strong>覆盖索引</strong>。</p>
<p>接下来，我们重点看看哪些情况会导致索引失效。以下示例基于 MySQL 8.0.26 测试。</p>
<h2 id="一、模糊查询的左右匹配导致索引失效">一、模糊查询的左右匹配导致索引失效</h2>
<p>使用 <code>LIKE</code>进行左模糊（<code>%xx</code>）或者左右模糊（<code>%xx%</code>）查询时，索引会失效。</p>
<p>例如，查询 name 以&quot;林&quot;结尾的用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- name是索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%林&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>执行计划显示 <code>type=ALL</code>，表示进行了全表扫描：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355795323.png" alt="1746355795323"></p>
<p>但如果是查询 name 以&quot;林&quot;开头的用户，索引依然有效：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;林%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>执行计划显示 <code>type=range</code>，使用了索引：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355807374.png" alt="1746355807374"></p>
<p><strong>为什么会这样？</strong></p>
<p>因为 B+树索引是按照值的顺序排列的，只能高效地进行前缀匹配。当使用 <code>%林</code>这样的后缀匹配时，系统无法确定从哪个索引值开始查找，只能遍历整个表。</p>
<p>以下图中的二级索引为例：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1748185291563.png" alt="1748185291563"></p>
<p>查询 <code>name LIKE '林%'</code>时，系统可以直接定位到林开头的记录并向后遍历；而查询 <code>name LIKE '%林'</code>时，系统不知道从哪开始找，只能全表扫描。</p>
<h2 id="二、在索引列上使用函数导致索引失效">二、在索引列上使用函数导致索引失效</h2>
<p>当在索引列上使用函数时，索引会失效。</p>
<p>例如，查询 name 长度为 6 的用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- name是索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> LENGTH(name) <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>执行计划显示进行了全表扫描：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355829062.png" alt="1746355829062"></p>
<p><strong>为什么会这样？</strong></p>
<p>因为索引中存储的是原始值，而不是函数计算后的值。系统需要先取出每条记录，计算函数结果，再进行比较。</p>
<p><strong>解决方法</strong>：<br>
从 MySQL 8.0 开始，可以创建函数索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> t_user <span class="keyword">ADD</span> KEY idx_name_length ((LENGTH(name)));</span><br></pre></td></tr></table></figure>
<p>这样就能在查询时使用索引：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355864137.png" alt="1746355864137"></p>
<h2 id="三、在索引列上进行表达式计算导致索引失效">三、在索引列上进行表达式计算导致索引失效</h2>
<p>和使用函数类似，在索引列上进行表达式计算也会导致索引失效。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这会导致全表扫描：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355872950.png" alt="1746355872950"></p>
<p>但如果改成下面这样，就可以使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="operator">-</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355879246.png" alt="1746355879246"></p>
<p><strong>核心原则</strong>：将运算尽量放在等号右边（常量侧），不要对索引列做运算。</p>
<h2 id="四、索引列发生隐式类型转换导致索引失效">四、索引列发生隐式类型转换导致索引失效</h2>
<p>当索引列是字符串类型，而查询条件使用数字时，会发生隐式类型转换，导致索引失效。</p>
<p>例如，phone 是 varchar 类型的索引列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>
<p>执行计划显示全表扫描：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355897755.png" alt="1746355897755"></p>
<p>但有趣的是，当索引列是数字类型，而查询条件使用字符串时，索引依然有效：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- id是整型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355906989.png" alt="1746355906989"></p>
<p><strong>为什么会这样？</strong></p>
<p>这与 MySQL 的类型转换规则有关。可以通过一个简单测试了解：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &quot;10&quot; <span class="operator">&gt;</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p>结果是 1，说明 MySQL 将字符串转成了数字再比较。</p>
<p>所以在第一个例子中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> <span class="built_in">CAST</span>(phone <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>
<p>这实际上对索引列使用了函数，导致索引失效。</p>
<p>而第二个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">=</span> &quot;1&quot;;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>这里是对常量进行转换，不影响索引使用。</p>
<p><strong>解决方法</strong>：确保查询条件的数据类型与索引列一致。</p>
<h2 id="五、联合索引未遵循最左匹配原则导致索引失效">五、联合索引未遵循最左匹配原则导致索引失效</h2>
<p>联合索引必须遵循&quot;最左匹配原则&quot;才能有效使用。</p>
<p>假设有一个联合索引(a, b, c)，以下查询可以使用该索引：</p>
<ul>
<li>WHERE a = 1</li>
<li>WHERE a = 1 AND b = 2</li>
<li>WHERE a = 1 AND b = 2 AND c = 3</li>
</ul>
<p>但以下查询无法利用索引：</p>
<ul>
<li>WHERE b = 2</li>
<li>WHERE c = 3</li>
<li>WHERE b = 2 AND c = 3</li>
</ul>
<p>有个特殊情况：<code>WHERE a = 1 AND c = 3</code>（跳过 b）。这种情况下：</p>
<ul>
<li>MySQL 5.5 版本：只有 a 能走索引，找到记录后回表比对 c</li>
<li>MySQL 5.6 及更高版本：引入了&quot;索引下推&quot;功能，可以在索引中直接过滤 c 条件，减少回表次数</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>执行计划中显示 <code>Using index condition</code>表示使用了索引下推：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355930186.png" alt="1746355930186"></p>
<p><strong>为什么需要最左匹配？</strong></p>
<p>因为联合索引的排序方式是先按第一列排序，第一列相同时再按第二列排序，依此类推。如果没有第一列的条件，系统就无法利用索引的有序性。</p>
<h2 id="六、OR-条件导致索引失效">六、OR 条件导致索引失效</h2>
<p>当 WHERE 子句中使用 OR 连接的条件列中，有一个不是索引列时，整个查询会变成全表扫描。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- id是索引，age不是索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<p>执行计划显示全表扫描：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355938391.png" alt="1746355938391"></p>
<p><strong>为什么会这样？</strong></p>
<p>因为 OR 表示满足任一条件即可，如果有条件不能走索引，为确保结果完整，系统会选择全表扫描。</p>
<p><strong>解决方法</strong>：为所有 OR 条件列创建索引。例如给 age 也创建索引：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/1746355946123.png" alt="1746355946123"></p>
<p>执行计划中显示 <code>type=index_merge</code>，表示系统分别扫描了 id 和 age 的索引，然后合并结果，避免了全表扫描。</p>
<h2 id="总结">总结</h2>
<p>我们介绍了 6 种会导致 MySQL 索引失效的情况：</p>
<ol>
<li><strong>模糊查询的左右匹配</strong>：<code>LIKE '%xx'</code>或 <code>LIKE '%xx%'</code>会导致索引失效，而 <code>LIKE 'xx%'</code>可以使用索引。</li>
<li><strong>在索引列上使用函数</strong>：如 <code>LENGTH(name)</code>会导致索引失效，可以考虑使用 MySQL 8.0 的函数索引。</li>
<li><strong>在索引列上进行表达式计算</strong>：如 <code>id + 1 = 10</code>会导致索引失效，应改为 <code>id = 10 - 1</code>。</li>
<li><strong>隐式类型转换</strong>：当字符串索引列与数字比较时，会导致索引失效；但数字索引列与字符串比较不会有问题。</li>
<li><strong>联合索引未遵循最左匹配原则</strong>：如(a,b,c)索引，查询必须包含 a 列才能使用索引。</li>
<li><strong>OR 条件中有非索引列</strong>：需要确保 OR 两侧的条件都有索引，否则会走全表扫描。</li>
</ol>
<p>理解这些情况有助于我们优化 SQL 查询，避免索引失效导致的性能问题。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库优化</tag>
        <tag>索引</tag>
        <tag>索引失效</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL单表建议数据量</title>
    <url>/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/</url>
    <content><![CDATA[<p>我们经常听说，单表数据量不要超过 2000W，否则性能会下降。这个&quot;2000W&quot;的建议值是否真的可靠？它的依据是什么？本文将通过分析 MySQL 的存储结构、B+树索引特性，以及实际测试来探讨这个问题。</p>
<h2 id="实验"><strong>实验</strong></h2>
<p>先建立一个实验表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> person(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span> comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    person_id tinyint <span class="keyword">not null</span> comment <span class="string">&#x27;用户 id&#x27;</span>,</span><br><span class="line">    person_name <span class="type">VARCHAR</span>(<span class="number">200</span>) comment <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">    gmt_create datetime comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    gmt_modified datetime comment <span class="string">&#x27;修改时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;人员信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>插入一条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> person <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="string">&#x27;user_1&#x27;</span>, NOW(), now());</span><br></pre></td></tr></table></figure>
<h3 id="大数据量测试数据生成方法">大数据量测试数据生成方法</h3>
<p>为了测试单表在不同数据量下的性能，我们需要生成大量测试数据。下面介绍一种高效的数据生成方法：</p>
<h4 id="步骤-1：初始化计数器变量">步骤 1：初始化计数器变量</h4>
<p>首先，设置一个 MySQL 用户变量 <code>@i</code>作为数据生成的计数器：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这条语句创建一个名为rownum的列，其值为@i+1，同时设置@i的初始值为100</span></span><br><span class="line"><span class="keyword">select</span> (<span class="variable">@i</span>:<span class="operator">=</span><span class="variable">@i</span><span class="operator">+</span><span class="number">1</span>) <span class="keyword">as</span> rownum, person_name <span class="keyword">from</span> person, (<span class="keyword">select</span> <span class="variable">@i</span>:<span class="operator">=</span><span class="number">100</span>) <span class="keyword">as</span> init;</span><br><span class="line"><span class="comment">-- 重置@i的值为1，准备开始生成数据</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@i</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>MySQL 用户变量</strong>：以 <code>@</code>开头的变量是 MySQL 的用户定义变量，可以在会话中保存值并在多个 SQL 语句之间传递。</p>
</blockquote>
<h4 id="步骤-2：使用递归插入法生成大量数据">步骤 2：使用递归插入法生成大量数据</h4>
<p>下面这条 SQL 语句是关键，它利用表中现有的数据来生成更多数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert into</span> person(id, person_id, person_name, gmt_create, gmt_modified)</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@i</span>:<span class="operator">=</span><span class="variable">@i</span><span class="operator">+</span><span class="number">1</span>,                  <span class="comment">-- 为每行生成唯一ID，同时@i的值增加1</span></span><br><span class="line">       <span class="keyword">left</span>(rand()<span class="operator">*</span><span class="number">10</span>,<span class="number">10</span>) <span class="keyword">as</span> person_id,        <span class="comment">-- 生成随机的person_id</span></span><br><span class="line">       concat(<span class="string">&#x27;user_&#x27;</span>,<span class="variable">@i</span><span class="operator">%</span><span class="number">2048</span>),               <span class="comment">-- 生成用户名，循环使用2048个不同名称</span></span><br><span class="line">       date_add(gmt_create,<span class="type">interval</span> <span class="operator">+</span> <span class="variable">@i</span><span class="operator">*</span><span class="built_in">cast</span>(rand()<span class="operator">*</span><span class="number">100</span> <span class="keyword">as</span> signed) <span class="keyword">SECOND</span>),  <span class="comment">-- 生成递增的创建时间</span></span><br><span class="line">       date_add(date_add(gmt_modified,<span class="type">interval</span> <span class="operator">+</span><span class="variable">@i</span><span class="operator">*</span><span class="built_in">cast</span>(rand()<span class="operator">*</span><span class="number">100</span> <span class="keyword">as</span> signed) <span class="keyword">SECOND</span>), <span class="type">interval</span> <span class="operator">+</span> <span class="built_in">cast</span>(rand()<span class="operator">*</span><span class="number">1000000</span> <span class="keyword">as</span> signed) <span class="keyword">SECOND</span>)  <span class="comment">-- 生成修改时间</span></span><br><span class="line"><span class="keyword">from</span> person;  <span class="comment">-- 从person表中选择数据，每次执行会使表中数据量翻倍</span></span><br></pre></td></tr></table></figure>
<p><strong>数据量增长说明</strong>：</p>
<ul>
<li>每执行一次上述 SQL，表中的数据量就会翻倍</li>
<li>执行 20 次后，数据量约为 2^20≈1,048,576（约 100 万）条</li>
<li>执行 23 次后，数据量约为 2^23≈8,388,608（约 800 万）条</li>
<li>依此类推，可以生成任意数量的测试数据</li>
</ul>
<p><strong>小技巧</strong>：如果不想每次都翻倍增加数据，可以在 SQL 语句末尾添加 WHERE 条件，例如 <code>WHERE id &gt; 某个值</code>来控制新增的数据量。</p>
<h4 id="步骤-3：处理可能出现的内存问题">步骤 3：处理可能出现的内存问题</h4>
<p>当数据量达到较大规模（约 800 万或 1000 万）时，可能会遇到以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The total number of locks exceeds the lock table size</span><br></pre></td></tr></table></figure>
<p><strong>错误原因</strong>：这是因为 MySQL 的临时表空间和缓冲池空间不足导致的。</p>
<p><strong>解决方法</strong>：增加相关内存参数的设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加临时表大小到512MB</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> tmp_table_size <span class="operator">=</span> <span class="number">512</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span>;</span><br><span class="line"><span class="comment">-- 增加InnoDB缓冲池大小到1GB</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">1</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：这些参数需要根据您的服务器内存情况进行适当调整，不要设置得过大以免影响系统稳定性。</p>
</blockquote>
<p>接下来看看测试结果：</p>
<p>下图展示了在 MySQL 8.0 版本上进行的性能测试结果。测试环境为个人电脑，同时运行有 IDE、浏览器等应用程序，因此这些数据仅供参考，不代表生产环境的实际性能。</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746350930968.png" alt="1746350930968"></p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746350943788.png" alt="1746350943788"></p>
<p>从测试数据可以看出，当表中数据量达到 2000 万行后，查询响应时间出现明显上升。这与行业中流传的&quot;单表不超过 2000 万行&quot;的建议相符。但这是否是一条普适的规则？</p>
<h2 id="探究-2000-万行建议值的来源"><strong>探究 2000 万行建议值的来源</strong></h2>
<p>首先，让我们分析数据库单表行数的理论上限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> person(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span> comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    person_id tinyint <span class="keyword">not null</span> comment <span class="string">&#x27;用户 id&#x27;</span>,</span><br><span class="line">    person_name <span class="type">VARCHAR</span>(<span class="number">200</span>) comment <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">    gmt_create datetime comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    gmt_modified datetime comment <span class="string">&#x27;修改时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;人员信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>从建表语句可以看出，id 作为主键具有唯一性约束，主键类型决定了表的理论容量上限：</p>
<ul>
<li>若主键为 <code>int</code>类型（32 位），则最大支持 2^32-1（约 21.4 亿）行数据</li>
<li>若主键为 <code>bigint</code>类型（64 位），则最大支持 2^63-1（约 9.22×10^18）行数据，这个数值极其庞大，在实际应用中很难达到这一限制</li>
</ul>
<p>有研究表明，如果使用无符号 bigint 作为自增主键，其最大值为 18,446,744,073,709,551,615。按照每秒写入一条记录的速度，理论上需要约 5800 亿年才能用尽这个限制，远超宇宙的预计寿命。</p>
<table>
<thead>
<tr>
<th>一秒增加的记录数</th>
<th>大约多少年用完</th>
</tr>
</thead>
<tbody>
<tr>
<td>1/1 秒</td>
<td>584942417355 年</td>
</tr>
<tr>
<td>1w/秒</td>
<td>58494241 年</td>
</tr>
<tr>
<td>100w/秒</td>
<td>584942 年</td>
</tr>
<tr>
<td>1 亿/秒</td>
<td>5849 年</td>
</tr>
</tbody>
</table>
<h2 id="表空间"><strong>表空间</strong></h2>
<p>下面我们再来看看索引的结构，我们下面讲内容都是基于 Innodb 引擎的，大家都知道 Innodb 的索引内部用的是 B+ 树。</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351373593.png" alt="1746351373593"></p>
<p>这张表数据，在硬盘上存储也是类似如此的，它实际是放在一个叫 person.ibd（innodb data）的文件中，也叫做表空间；虽然数据表中，他们看起来是一条连着一条，但是实际上在文件中它被分成很多小份的数据页，而且每一份都是 16K。</p>
<p>大概就像下面这样，当然这只是我们抽象出来的，在表空间中还有段、区、组等很多概念，但是我们需要跳出来看。</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351388668.png" alt="1746351388668"></p>
<h2 id="页的数据结构"><strong>页的数据结构</strong></h2>
<p>实际页的内部结构像是下面这样的：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351399761.png" alt="1746351399761"></p>
<p>从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。</p>
<p>在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 <code>User Records</code> 部分。</p>
<p>但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分。</p>
<p>当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
<p>这个过程的图示如下：</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351415703.png" alt="1746351415703"></p>
<p>刚刚上面说到了数据的新增的过程。</p>
<p>那下面就来说说，数据的查找过程，假如我们需要查找一条记录，我们可以把表空间中的每一页都加载到内存中，然后对记录挨个判断是不是我们想要的。</p>
<p>在数据量小的时候，没啥问题，内存也可以撑。但是现实就是这么残酷，不会给你这个局面。</p>
<p>为了解决这问题，MySQL 中就有了索引的概念，大家都知道索引能够加快数据的查询，那到底是怎么个回事呢？下面我就来看看。</p>
<h2 id="索引的数据结构"><strong>索引的数据结构</strong></h2>
<p>在 MySQL 中索引的数据结构和刚刚描述的页几乎是一模一样的，而且大小也是 16K,。</p>
<p>但是在索引页中记录的是页 (数据页，索引页) 的最小主键 id 和页号，以及在索引页中增加了层级的信息，从 0 开始往上算，所以页与页之间就形成了层级结构关系。</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351427532.png" alt="1746351427532"></p>
<p>这种结构实际上呈现了树状结构的特征，类似于层次化的索引组织。在这里我们简单展示了三个节点，2 层结构，但随着数据增加，结构可能扩展至 3 层。这就是我们常说的 B+ 树，最下面那一层的 page level =0, 也就是叶子节点，其余都是非叶子节点。</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351436733.png" alt="1746351436733"></p>
<p>从上图中，我们分析一个非叶子节点（索引页），在非叶子节点的内容区中包含主键 ID 值和对应的页号指针两部分信息：</p>
<ul>
<li>id：对应页中记录的最小记录 id 值；</li>
<li>页号：指向对应页的指针；</li>
</ul>
<p>而数据页与此几乎大同小异，区别在于数据页记录的是真实的行数据而不是页地址，而且 id 的也是顺序的。</p>
<h2 id="单表建议值"><strong>单表建议值</strong></h2>
<p>下面我们就以 3 层，2 分叉（实际中是 M 分叉）的图例来说明一下查找一个行数据的过程。</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351449311.png" alt="1746351449311"></p>
<p>比如说我们需要查找一个 id=6 的行数据：</p>
<ul>
<li>因为在非叶子节点中存放的是页号和该页最小的 id，所以我们从顶层开始对比，首先看页号 10 中的目录，有 [id=1, 页号 = 20],[id=5, 页号 = 30], 说明左侧节点最小 id 为 1，右侧节点最小 id 是 5。6&gt;5, 那按照二分法查找的规则，肯定就往右侧节点继续查找；</li>
<li>找到页号 30 的节点后，发现这个节点还有子节点（非叶子节点），那就继续比对，同理，6&gt;5 &amp;&amp; 6&lt;7, 所以找到了页号 60；</li>
<li>找到页号 60 之后，发现此节点为叶子节点（数据节点），于是将此页数据加载至内存进行一一对比，结果找到了 id=6 的数据行。</li>
</ul>
<p>从上述的过程中发现，我们为了查找 id=6 的数据，总共查询了三个页，如果三个页都在磁盘中（未提前加载至内存），那么最多需要经历三次的磁盘 IO。</p>
<p>需要注意的是，图中的页号只是个示例，实际情况下并不是连续的，在磁盘中存储也不一定是顺序的。</p>
<p>至此，我们大概已经了解了表的数据是怎么个结构了，也大概知道查询数据是个怎么的过程了，这样我们也就能大概估算这样的结构能存放多少数据了。</p>
<p>从上面的图解我们知道 B+ 数的叶子节点才是存在数据的，而非叶子节点是用来存放索引数据的。</p>
<p>所以，同样一个 16K 的页，非叶子节点里的每条数据都指向新的页，而新的页有两种可能</p>
<ul>
<li>如果是叶子节点，那么里面就是一行行的数据</li>
<li>如果是非叶子节点的话，那么就会继续指向新的页</li>
</ul>
<p>假设</p>
<ul>
<li>非叶子节点内指向其他页的数量为 x</li>
<li>叶子节点内能容纳的数据行数为 y</li>
<li>B+ 数的层数为 z</li>
</ul>
<p>如下图中所示，<strong>总记录数 = $x^{z-1} \times y$，即总数等于 $x$ 的 $z-1$ 次方与 $y$ 的乘积</strong>。</p>
<p><img src="/2025/05/04/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/MYSQL%E5%8D%95%E8%A1%A8%E5%BB%BA%E8%AE%AE%E6%95%B0%E6%8D%AE%E9%87%8F/1746351464769.png" alt="1746351464769"></p>
<blockquote>
<p>X =？</p>
</blockquote>
<p>在文章的开头已经介绍了页的结构，索引也也不例外，都会有 File Header (38 byte)、Page Header (56 Byte)、Infimum + Supermum（26 byte）、File Trailer（8byte）, 再加上页目录，大概 1k 左右。</p>
<p>我们就当做它就是 1K, 那整个页的大小是 16K, 剩下 15k 用于存数据，在索引页中主要记录的是主键与页号，主键我们假设是 Bigint (8 byte), 而页号也是固定的（4Byte）, 那么索引页中的一条数据也就是 12byte。</p>
<p>所以 x=15*1024/12≈1280 行。</p>
<blockquote>
<p>Y=？</p>
</blockquote>
<p>叶子节点和非叶子节点的结构是一样的，同理，能放数据的空间也是 15k。</p>
<p>但是叶子节点中存放的是真正的行数据，这个影响的因素就会多很多，比如，字段的类型，字段的数量。每行数据占用空间越大，页中所放的行数量就会越少。</p>
<p>这边我们暂时按一条行数据 1k 来算，那一页就能存下 15 条，Y = 15*1024/1000 ≈15。</p>
<p>到这一步，我们已经可以开始推算总容量了。</p>
<p>根据上述的公式，总记录数 = $x^{z-1} \times y$，已知 $x=1280，y=15$：</p>
<ul>
<li>假设 B+ 树是两层，那就是 z = 2，Total = （1280 ^1）*15 = 19200</li>
<li>假设 B+ 树是三层，那就是 z = 3，Total = （1280 ^2） *15 = 24576000（约 2.45kw）</li>
</ul>
<p>这与文章开头提到的 2000W 行数建议值高度吻合。实际上，一般 B+ 树的层级最多也就是 3 层。</p>
<p>如果增加到 4 层，不仅查询时可能增加磁盘 IO 次数，而且总记录数将达到约 3 百多亿，这在大多数应用场景中并不实用。因此，3 层结构是较为合理的选择。</p>
<p>然而，我们的分析还需要继续深入。</p>
<p>我们刚刚在计算 Y 值时假设每行数据占用空间为 1K。但如果实际每行数据占用 5K，那每个数据页最多只能容纳 3 条记录。</p>
<p>同样按照 $z = 3$ 计算，总记录数 $= （1280 ^2） \times 3 = 4915200（约 500w）$</p>
<p>由此可见，在保持相同层级结构（即相似查询性能）的情况下，行数据大小的不同会显著影响最大建议记录数。此外，影响查询性能的还有诸多因素，如数据库版本、服务器配置、SQL 编写质量等。</p>
<p>MySQL 为了提高性能，会将表的索引装载到内存中。当 InnoDB buffer size 充足时，可以实现索引的全内存加载，查询性能不会受到明显影响。</p>
<p>然而，当单表数据量达到特定上限后，内存可能无法完全容纳索引，导致后续 SQL 查询产生额外的磁盘 IO，从而降低性能。因此，提升硬件配置（如增加内存）可能会显著提高查询性能。</p>
<h2 id="总结"><strong>总结</strong></h2>
<ul>
<li>MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。</li>
<li>页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。</li>
<li>在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</li>
<li>索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>B+树</tag>
        <tag>表空间</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 207 - 课程表（Course Schedule）</title>
    <url>/2025/05/03/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code>。</p>
<p>在选修某些课程之前需要一些先修课程。先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code>，表示如果要学习课程 <code>ai</code> 则<strong>必须</strong>先学习课程 <code>bi</code>。</p>
<p>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code>，你需要先完成课程 <code>1</code>。</p>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。这是可能的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>prerequisites[i]</code> 中的所有课程对<strong>互不相同</strong></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这个问题本质上是<strong>判断一个有向图是否存在环</strong>。我们可以将课程看作图中的节点，先修关系看作有向边。如果图中存在环，那么就无法完成所有课程（因为环意味着出现了循环依赖）。</p>
<p>对于这类问题，通常有两种解决方法：<strong>拓扑排序（BFS）</strong> 和 <strong>深度优先搜索（DFS）</strong>。</p>
<h3 id="方法一：BFS-拓扑排序">方法一：BFS 拓扑排序</h3>
<p>拓扑排序的基本思想是：</p>
<ol>
<li>计算图中每个节点的入度（有多少条边指向该节点）</li>
<li>将所有入度为 0 的节点（没有先修课程的课程）加入队列</li>
<li>逐个出队，将出队节点的所有相邻节点的入度减 1</li>
<li>如果相邻节点的入度变为 0，则将其加入队列</li>
<li>重复步骤 3-4，直到队列为空</li>
<li>如果最终访问的节点数等于总节点数，则说明不存在环，可以完成所有课程</li>
</ol>
<h3 id="方法二：DFS-检测环">方法二：DFS 检测环</h3>
<p>DFS 检测环的基本思想是：</p>
<ol>
<li>对图中的每个未访问过的节点进行 DFS</li>
<li>在 DFS 过程中，使用三种状态标记节点：
<ul>
<li>未访问（0）</li>
<li>访问中（1）：当前 DFS 路径上的节点</li>
<li>已完成（2）：节点及其所有后代都已被访问</li>
</ul>
</li>
<li>如果 DFS 过程中遇到一个「访问中」的节点，则说明存在环</li>
<li>如果所有节点都能被标记为「已完成」，则说明不存在环</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="BFS-拓扑排序实现">BFS 拓扑排序实现</h3>
<p>BFS 实现需要维护以下数据结构：</p>
<ul>
<li>邻接表（adjacency list）：表示图结构</li>
<li>入度数组：记录每个节点的入度</li>
<li>队列：存储入度为 0 的节点</li>
</ul>
<p>具体步骤：</p>
<ol>
<li>构建邻接表和入度数组</li>
<li>将所有入度为 0 的节点加入队列</li>
<li>BFS 处理队列中的节点：
<ul>
<li>出队一个节点，将学习的课程数加 1</li>
<li>将其所有相邻节点的入度减 1</li>
<li>如果相邻节点的入度变为 0，则加入队列</li>
</ul>
</li>
<li>检查学习的课程数是否等于总课程数</li>
</ol>
<h3 id="DFS-检测环实现">DFS 检测环实现</h3>
<p>DFS 实现需要以下数据结构：</p>
<ul>
<li>邻接表：表示图结构</li>
<li>访问状态数组：记录每个节点的访问状态</li>
</ul>
<p>具体步骤：</p>
<ol>
<li>构建邻接表</li>
<li>对每个未访问的节点进行 DFS：
<ul>
<li>如果节点在当前路径上被访问过（状态为 1），则存在环</li>
<li>如果节点已经被完全处理（状态为 2），则跳过</li>
<li>否则，标记节点为「访问中」（状态为 1）</li>
<li>递归访问所有相邻节点</li>
<li>标记节点为「已完成」（状态为 2）</li>
</ul>
</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<h3 id="方法一：BFS-拓扑排序-2">方法一：BFS 拓扑排序</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 构建邻接表和入度数组</span></span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="type">int</span>, numCourses)    <span class="comment">// 邻接表：graph[i] 表示学完课程i后可以学习的课程列表</span></span><br><span class="line">    inDegree := <span class="built_in">make</span>([]<span class="type">int</span>, numCourses)   <span class="comment">// 入度数组：inDegree[i] 表示学习课程i前需要完成的课程数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充邻接表和计算入度</span></span><br><span class="line">    <span class="keyword">for</span> _, prereq := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        course, prerequisite := prereq[<span class="number">0</span>], prereq[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">// 添加有向边：prerequisite -&gt; course</span></span><br><span class="line">        graph[prerequisite] = <span class="built_in">append</span>(graph[prerequisite], course)</span><br><span class="line">        <span class="comment">// 课程course的入度加1</span></span><br><span class="line">        inDegree[course]++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将所有入度为0的课程加入队列（没有先修课程的课程）</span></span><br><span class="line">    queue := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> inDegree[i] == <span class="number">0</span> &#123;</span><br><span class="line">            queue = <span class="built_in">append</span>(queue, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录已学习的课程数量</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BFS拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 出队一个课程</span></span><br><span class="line">        course := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        count++ <span class="comment">// 学习这门课程</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将其指向的课程的入度减1</span></span><br><span class="line">        <span class="keyword">for</span> _, nextCourse := <span class="keyword">range</span> graph[course] &#123;</span><br><span class="line">            inDegree[nextCourse]--</span><br><span class="line">            <span class="comment">// 如果入度变为0，加入队列</span></span><br><span class="line">            <span class="keyword">if</span> inDegree[nextCourse] == <span class="number">0</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, nextCourse)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果学完的课程数等于总课程数，则可以完成所有课程</span></span><br><span class="line">    <span class="keyword">return</span> count == numCourses</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：DFS-检测环-2">方法二：DFS 检测环</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="type">int</span>, prerequisites [][]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="type">int</span>, numCourses)</span><br><span class="line">    <span class="keyword">for</span> _, prereq := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">        course, prerequisite := prereq[<span class="number">0</span>], prereq[<span class="number">1</span>]</span><br><span class="line">        graph[prerequisite] = <span class="built_in">append</span>(graph[prerequisite], course)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问状态数组：0=未访问，1=访问中（当前路径上），2=已完成</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">int</span>, numCourses)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个节点进行DFS，检测环</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">0</span> &#123; <span class="comment">// 如果未访问</span></span><br><span class="line">            <span class="keyword">if</span> hasCycle(graph, visited, i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 存在环，无法完成所有课程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 不存在环，可以完成所有课程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS检测环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(graph [][]<span class="type">int</span>, visited []<span class="type">int</span>, course <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点在当前路径上被访问过，说明有环</span></span><br><span class="line">    <span class="keyword">if</span> visited[course] == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果节点已经被完全处理，无需再次检查</span></span><br><span class="line">    <span class="keyword">if</span> visited[course] == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记为访问中</span></span><br><span class="line">    visited[course] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归检查所有相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> _, nextCourse := <span class="keyword">range</span> graph[course] &#123;</span><br><span class="line">        <span class="keyword">if</span> hasCycle(graph, visited, nextCourse) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果找到环，立即返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记为已完成</span></span><br><span class="line">    visited[course] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 该路径上不存在环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>BFS拓扑排序</th>
<th>DFS检测环</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
</tr>
<tr>
<td>实现难度</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td>优点</td>
<td>直观理解入度和依赖关系，容易得到拓扑序列</td>
<td>递归实现简洁，可以更快检测到环</td>
</tr>
<tr>
<td>缺点</td>
<td>需要额外维护入度数组</td>
<td>递归调用可能导致栈溢出（但在此题约束下不会）</td>
</tr>
<tr>
<td>适用场景</td>
<td>需要拓扑序列，或初学者理解图算法</td>
<td>只需判断是否存在环，或递归思维更适合</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<p>两种方法的时间和空间复杂度都是：</p>
<ul>
<li>时间复杂度：O(V+E)，其中 V 是节点数（课程数），E 是边数（先修关系数）</li>
<li>空间复杂度：O(V+E)，用于存储图结构和辅助数组</li>
</ul>
<p>具体分析：</p>
<ul>
<li>BFS：需要邻接表 O(V+E)、入度数组 O(V) 和队列 O(V)</li>
<li>DFS：需要邻接表 O(V+E)、访问状态数组 O(V) 和递归调用栈 O(V)</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>图的表示方法</strong>：使用邻接表表示图结构，适合稀疏图</li>
<li><strong>拓扑排序应用</strong>：拓扑排序可以解决依赖关系问题，如课程安排、任务调度等</li>
<li><strong>状态标记技巧</strong>：在DFS中使用三种状态（未访问、访问中、已完成）可以有效检测环</li>
<li><strong>队列的应用</strong>：在BFS中使用队列管理入度为0的节点</li>
</ol>
<p><strong>常见陷阱</strong>：</p>
<ul>
<li>混淆了有向边的方向：注意 <code>[ai, bi]</code> 表示 <code>bi → ai</code>，即学习 <code>ai</code> 前必须完成 <code>bi</code></li>
<li>忘记检查最终访问的节点数：在BFS中，即使队列为空，也要检查是否访问了所有节点</li>
<li>DFS检测环时忘记标记节点状态：必须正确标记节点为&quot;访问中&quot;和&quot;已完成&quot;</li>
</ul>
<p><strong>相关问题</strong>：</p>
<ul>
<li>LeetCode 210：课程表 II（Course Schedule II）- 在本题基础上输出拓扑排序序列</li>
<li>LeetCode 802：找到最终的安全状态（Find Eventual Safe States）- 找出不在任何环中的节点</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 124 - 二叉树中的最大路径和（Binary Tree Maximum Path Sum）</title>
    <url>/2025/05/02/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-124-Binary-Tree-Maximum-Path-Sum/</url>
    <content><![CDATA[<div class="note danger">
            <p><strong>重点难题</strong>：本题是二叉树路径问题中的经典难题，需要理解后序遍历与递归返true回值的巧妙设计。</p>
          </div>
<h2 id="问题描述">问题描述</h2>
<p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[-10,9,20,null,null,15,7]</span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">输出：42</span><br></pre></td></tr></table></figure>
<h2 id="解题思路">解题思路</h2>
<p>这道题的关键在于理解二叉树中的&quot;路径&quot;概念。路径可以是：</p>
<ol>
<li>只包含一个节点</li>
<li>从一个节点向下到其子节点</li>
<li>从左子树某节点，经过父节点，再到右子树某节点（形成&quot;倒V&quot;形状）</li>
</ol>
<p><strong>核心思想</strong>：使用后序遍历（左-右-根）自底向上计算路径和，针对每个节点，我们需要考虑两个关键值：</p>
<ul>
<li><strong>当前节点的贡献值</strong>：节点自身值加上左右子树中较大的贡献值（如果子树贡献为负，则不选取）</li>
<li><strong>经过当前节点的最大路径和</strong>：节点值加上左右子树的贡献值（如为负则视为0）</li>
</ul>
<p>关键在于区分这两个概念：</p>
<ul>
<li>贡献值用于向上传递给父节点，只能选择一条路径（左或右）</li>
<li>最大路径和用于更新全局最大值，可以同时包含左右路径</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<ol>
<li>定义一个全局变量 <code>maxSum</code> 来记录最大路径和，初始值设为最小整数</li>
<li>定义递归函数 <code>maxGain</code>，计算节点的最大贡献值</li>
<li>对于每个节点，计算其左右子树的最大贡献值</li>
<li>如果贡献值为负，将其设为0（不选择这条路径）</li>
<li>计算经过当前节点的路径和，并更新全局最大值</li>
<li>返回当前节点的最大贡献值（只能选左或右子树中的一条）</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPathSum</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化最大和为最小整数</span></span><br><span class="line">    maxSum := math.MinInt32</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义递归函数计算节点的最大贡献值</span></span><br><span class="line">    <span class="keyword">var</span> maxGain <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">  </span><br><span class="line">    maxGain = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 递归计算左右子树的最大贡献值</span></span><br><span class="line">        leftVal := maxGain(node.Left)</span><br><span class="line">        rightVal := maxGain(node.Right)</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果子树贡献为负，则不选取</span></span><br><span class="line">        <span class="keyword">if</span> leftVal &lt; <span class="number">0</span> &#123;</span><br><span class="line">            leftVal = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> rightVal &lt; <span class="number">0</span> &#123;</span><br><span class="line">            rightVal = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 计算经过当前节点的路径和，并更新全局最大值</span></span><br><span class="line">        priceVal := leftVal + rightVal + node.Val</span><br><span class="line">        <span class="keyword">if</span> priceVal &gt; maxSum &#123;</span><br><span class="line">            maxSum = priceVal</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值（只能选左或右子树中的一条）</span></span><br><span class="line">        <span class="keyword">return</span> max(leftVal, rightVal) + node.Val</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    maxGain(root)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：O(N)，其中 N 是二叉树中的节点数。每个节点只被访问一次。</li>
<li><strong>空间复杂度</strong>：O(H)，其中 H 是二叉树的高度。空间复杂度主要取决于递归调用的栈空间。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>路径定义的理解</strong>：二叉树中的路径不一定要从根开始或结束，但必须是连续的。</li>
<li><strong>后序遍历应用</strong>：通过后序遍历可以自底向上收集路径信息。</li>
<li><strong>递归设计巧妙性</strong>：递归函数的返回值（节点贡献值）与函数内更新的全局变量（最大路径和）分别服务于不同目的。</li>
<li><strong>路径选择策略</strong>：对于负贡献值的子树，选择不纳入路径可以获得更大的路径和。</li>
</ol>
<p>相关问题：</p>
<ul>
<li>LeetCode 543: 二叉树的直径</li>
<li>LeetCode 687: 最长同值路径</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>❌错题集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 236 - 二叉树的最近公共祖先</title>
    <url>/2025/04/30/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 [2, 10^5] 内。</li>
<li>-10^9 &lt;= Node.val &lt;= 10^9</li>
<li>所有 Node.val 互不相同。</li>
<li>p != q</li>
<li>p 和 q 均存在于给定的二叉树中。</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这个问题看起来很复杂，但通过递归方法可以优雅地解决。<strong>关键洞见</strong>是：如果我们从根节点开始，对于任意节点：</p>
<ol>
<li>如果当前节点就是 p 或 q，那么这个节点就是它们的最近公共祖先（可能一个是另一个的后代）</li>
<li>如果当前节点不是 p 或 q，我们需要在左右子树中寻找 p 和 q：
<ul>
<li>如果 p 和 q 分别在当前节点的左右子树中，那么当前节点就是最近公共祖先</li>
<li>如果 p 和 q 都在左子树，那么最近公共祖先在左子树中</li>
<li>如果 p 和 q 都在右子树，那么最近公共祖先在右子树中</li>
</ul>
</li>
</ol>
<p>这个问题可以通过几种方法解决：</p>
<h3 id="方法一：递归-后序遍历">方法一：递归 - 后序遍历</h3>
<p>递归是解决这个问题最直观的方法。我们可以通过后序遍历（左、右、根）的方式，自底向上地寻找最近公共祖先。</p>
<h4 id="实现思路：">实现思路：</h4>
<ol>
<li>
<p><strong>基本情况</strong>：</p>
<ul>
<li>如果当前节点为空，返回 nil</li>
<li>如果当前节点等于 p 或 q，返回当前节点</li>
</ul>
</li>
<li>
<p><strong>递归调用</strong>：</p>
<ul>
<li>在左子树中递归寻找 p 和 q</li>
<li>在右子树中递归寻找 p 和 q</li>
</ul>
</li>
<li>
<p><strong>合并结果</strong>：</p>
<ul>
<li>如果左子树和右子树的递归调用都返回非空结果，说明 p 和 q 分别在当前节点的左右子树中，当前节点就是最近公共祖先</li>
<li>如果只有一个子树返回非空结果，则该结果就是最近公共祖先</li>
<li>如果两个子树都返回空，则返回空</li>
</ul>
</li>
</ol>
<h3 id="方法二：使用父节点映射">方法二：使用父节点映射</h3>
<p>我们也可以通过建立每个节点到其父节点的映射来解决这个问题：</p>
<ol>
<li>从根节点开始DFS，创建每个节点到其父节点的映射</li>
<li>从 p 开始，向上遍历至根，记录经过的所有节点</li>
<li>从 q 开始，向上遍历至根，找到第一个在 p 的路径中出现的节点，该节点即为最近公共祖先</li>
</ol>
<h3 id="方法三：路径比较法">方法三：路径比较法</h3>
<ol>
<li>找出从根节点到 p 的路径</li>
<li>找出从根节点到 q 的路径</li>
<li>比较这两条路径，找到最后一个相同的节点，即为最近公共祖先</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<h3 id="方法一：递归实现">方法一：递归实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 基本情况：空节点返回nil</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前节点是p或q，直接返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在左右子树中寻找p和q</span></span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果p和q分别在左右子树中，当前节点就是LCA</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左子树中没有找到p或q，则LCA在右子树中</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则LCA在左子树中（或两者都为空，此时返回nil）</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：父节点映射实现">方法二：父节点映射实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 建立父节点映射</span></span><br><span class="line">    parentMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*TreeNode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DFS遍历树，建立子节点到父节点的映射</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            parentMap[node.Left.Val] = node</span><br><span class="line">            dfs(node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            parentMap[node.Right.Val] = node</span><br><span class="line">            dfs(node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 收集从p到根的路径中的所有节点</span></span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> node := p; node != <span class="literal">nil</span>; node = parentMap[node.Val] &#123;</span><br><span class="line">        visited[node.Val] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从q向上遍历，找到第一个已访问过的节点</span></span><br><span class="line">    <span class="keyword">for</span> node := q; node != <span class="literal">nil</span>; node = parentMap[node.Val] &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[node.Val] &#123;</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 这里实际上不会被执行到，因为题目保证p和q在树中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：路径比较法-2">方法三：路径比较法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 找出从根到指定节点的路径</span></span><br><span class="line">    <span class="keyword">var</span> findPath <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, *TreeNode, []*TreeNode)</span></span> []*TreeNode</span><br><span class="line">    findPath = <span class="function"><span class="keyword">func</span><span class="params">(root, target *TreeNode, path []*TreeNode)</span></span> []*TreeNode &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前节点加入路径</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, root)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到目标节点，返回路径</span></span><br><span class="line">        <span class="keyword">if</span> root.Val == target.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> path</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在左子树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> left := findPath(root.Left, target, <span class="built_in">append</span>([]*TreeNode&#123;&#125;, path...)); left != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在右子树中寻找</span></span><br><span class="line">        <span class="keyword">if</span> right := findPath(root.Right, target, <span class="built_in">append</span>([]*TreeNode&#123;&#125;, path...)); right != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取从根到p和q的路径</span></span><br><span class="line">    pathP := findPath(root, p, []*TreeNode&#123;&#125;)</span><br><span class="line">    pathQ := findPath(root, q, []*TreeNode&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最后一个公共节点</span></span><br><span class="line">    <span class="keyword">var</span> lca *TreeNode</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(pathP) &amp;&amp; i &lt; <span class="built_in">len</span>(pathQ); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> pathP[i].Val == pathQ[i].Val &#123;</span><br><span class="line">            lca = pathP[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lca</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一：递归</th>
<th>方法二：父节点映射</th>
<th>方法三：路径比较法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(h)，h为树高</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>代码简洁，空间效率高</td>
<td>思路直观</td>
<td>容易理解</td>
</tr>
<tr>
<td>缺点</td>
<td>递归可能导致栈溢出</td>
<td>需要额外空间存储父节点映射</td>
<td>需要额外空间存储路径</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="方法一：递归">方法一：递归</h3>
<ul>
<li><strong>时间复杂度</strong>: O(n)，其中 n 是树中的节点数。在最坏情况下，我们需要访问树中的所有节点。</li>
<li><strong>空间复杂度</strong>: O(h)，其中 h 是树的高度。递归调用的栈深度与树的高度成正比。在最坏情况下（树是一条链），空间复杂度为 O(n)。</li>
</ul>
<h3 id="方法二：父节点映射">方法二：父节点映射</h3>
<ul>
<li><strong>时间复杂度</strong>: O(n)，我们需要遍历整棵树来构建父节点映射，然后在最坏情况下需要遍历从 p 和 q 到根的所有节点。</li>
<li><strong>空间复杂度</strong>: O(n)，需要额外空间存储父节点映射和访问集合。</li>
</ul>
<h3 id="方法三：路径比较法-3">方法三：路径比较法</h3>
<ul>
<li><strong>时间复杂度</strong>: O(n)，需要遍历树来找到从根到 p 和 q 的路径。</li>
<li><strong>空间复杂度</strong>: O(n)，需要存储从根到 p 和 q 的路径。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>递归思想在树问题中的应用</strong>：树的问题通常可以通过递归优雅地解决，尤其是自底向上的后序遍历。</p>
</li>
<li>
<p><strong>最近公共祖先的特性</strong>：</p>
<ul>
<li>如果两个节点在不同的子树中，它们的LCA就是子树的根节点</li>
<li>如果一个节点是另一个节点的祖先，那么这个祖先节点就是LCA</li>
</ul>
</li>
<li>
<p><strong>路径表示法</strong>：从根到节点的路径可以唯一确定一个节点，比较两条路径可以找到分叉点</p>
</li>
<li>
<p><strong>空返回值的处理</strong>：在递归中处理空返回值是很重要的，确保代码的健壮性</p>
</li>
</ol>
<p>这道题是树的经典问题，它不仅考察了树的遍历技巧，还考察了对递归的理解和应用。方法一（递归）是最简洁和高效的解法，也是面试中推荐使用的方法。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 437 - 路径总和 III (Path Sum III)</title>
    <url>/2025/04/30/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个二叉树的根节点 <code>root</code> 和一个整数 <code>targetSum</code>，求该二叉树里节点值之和等于 <code>targetSum</code> 的<strong>路径</strong>的数目。</p>
<p><strong>路径定义</strong>：不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>示例 1</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8<br>
<strong>输出</strong>：3<br>
<strong>解释</strong>：和为 8 的路径有 3 条</p>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<p><strong>示例 2</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p><strong>输入</strong>：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>
<strong>输出</strong>：3</p>
<p><strong>提示</strong>：</p>
<ul>
<li>二叉树的节点个数的范围是 [0,1000]</li>
<li>-10^9 &lt;= Node.val &lt;= 10^9</li>
<li>-1000 &lt;= targetSum &lt;= 1000</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我的初始解法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    dfsPathSum(root, targetSum, targetSum, &amp;cnt)</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsPathSum</span><span class="params">(node *TreeNode, targetSum, totalSum <span class="type">int</span>, cnt *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ❌ 错误点：只检查单个节点值等于目标和的情况</span></span><br><span class="line">    <span class="keyword">if</span> node.Val == targetSum &#123;</span><br><span class="line">        *cnt++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ❌ 错误点：混合了两种不同的递归逻辑，职责不清晰</span></span><br><span class="line">    dfsPathSum(node.Left, totalSum, totalSum, cnt)      <span class="comment">// 左子节点作为新起点</span></span><br><span class="line">    dfsPathSum(node.Left, targetSum-node.Val, totalSum, cnt)  <span class="comment">// 左子节点作为路径延续</span></span><br><span class="line">    dfsPathSum(node.Right, totalSum, totalSum, cnt)     <span class="comment">// 右子节点作为新起点 </span></span><br><span class="line">    dfsPathSum(node.Right, targetSum-node.Val, totalSum, cnt) <span class="comment">// 右子节点作为路径延续</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>通过示例 1 的树结构来详细分析错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br></pre></td></tr></table></figure>
<p>当我们查找目标和为 8 的路径时，预期结果是 3 条路径。但我的实现存在以下问题：</p>
<h4 id="1-递归职责混淆导致的重复计算">1. 递归职责混淆导致的重复计算</h4>
<p>从根节点 10 开始执行 <code>dfsPathSum(root, 8, 8, &amp;cnt)</code>：</p>
<ul>
<li>检查 10 是否等于 8：不等于，不增加计数</li>
<li>对左子节点 5 生成 <strong>两个递归调用</strong>：
<ul>
<li><code>dfsPathSum(5, 8, 8, &amp;cnt)</code> —— 视 5 为新路径起点</li>
<li><code>dfsPathSum(5, 8-10=-2, 8, &amp;cnt)</code> —— 视 5 为延续 10 的路径</li>
</ul>
</li>
</ul>
<p>这里问题就出现了：当我们访问节点 5，会同时以它作为<strong>新起点</strong>和<strong>路径延续点</strong>，产生两条不同处理路径。但函数内部的逻辑没有区分这两种不同的职责。</p>
<p>继续追踪 <code>dfsPathSum(5, 8, 8, &amp;cnt)</code> 的执行：</p>
<ul>
<li>检查 5 是否等于 8：不等于，不增加计数</li>
<li>又生成 4 个递归调用：
<ol>
<li><code>dfsPathSum(3, 8, 8, &amp;cnt)</code> —— 3 作为新起点</li>
<li><code>dfsPathSum(3, 8-5=3, 8, &amp;cnt)</code> —— 3 作为 5 的延续</li>
<li><code>dfsPathSum(2, 8, 8, &amp;cnt)</code> —— 2 作为新起点</li>
<li><code>dfsPathSum(2, 8-5=3, 8, &amp;cnt)</code> —— 2 作为 5 的延续</li>
</ol>
</li>
</ul>
<p>对于 <code>dfsPathSum(3, 3, 8, &amp;cnt)</code>：</p>
<ul>
<li>检查 3 是否等于 3：<strong>相等，计数加1</strong>（正确找到 5-&gt;3 路径）</li>
<li>但同时也会递归调用 <code>dfsPathSum(3, 3-3=0, 8, &amp;cnt)</code> 和 <code>dfsPathSum(-2, 0-3=-3, 8, &amp;cnt)</code></li>
</ul>
<p>这种不分职责的递归会导致：</p>
<ol>
<li><strong>指数级爆炸的递归调用</strong>——每个节点生成 4 个新的递归</li>
<li><strong>重复计算</strong>——同一路径会在不同递归分支中重复统计</li>
</ol>
<h4 id="2-路径判断逻辑不完整">2. 路径判断逻辑不完整</h4>
<p>考虑 <code>dfsPathSum(3, 3, 8, &amp;cnt)</code> 这种情况：</p>
<ul>
<li>代码判断 <code>node.Val == targetSum</code>，此处 3 == 3，所以 cnt++</li>
<li>但这只考虑了节点值等于目标和的&quot;叶子路径&quot;情况</li>
<li>没有考虑从 3 点开始，可能向下延伸的其他路径，应递归传递 targetSum-node.Val</li>
</ul>
<h4 id="3-递归终止时机和状态混乱">3. 递归终止时机和状态混乱</h4>
<p>在我的实现中，对于每个节点都创建 4 个递归调用，没有明确的层次和职责，导致计算路径时:</p>
<ul>
<li>统计结果不准确（可能重复计数）</li>
<li>递归分支数量爆炸式增长（对于 n 个节点的树，最坏情况接近 4^n 次递归调用）</li>
</ul>
<p><strong>具体示例错误</strong>：<br>
对于示例 1，目标和为 8，正确结果应该是 3 条路径。但使用我原始的代码，会产生大量重复计算和错误计数。例如路径 5-&gt;3 会被多条不同的递归路径重复发现和统计。</p>
<h2 id="正确解法">正确解法</h2>
<p>经过分析，我改进的解法是：</p>
<h3 id="方案一：双重递归实现">方案一：双重递归实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算以当前节点为起点的路径数</span></span><br><span class="line">    cnt := dfsPathSum(root, targetSum)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理左右子树，将每个节点都作为潜在起点</span></span><br><span class="line">    cnt += pathSum(root.Left, targetSum)</span><br><span class="line">    cnt += pathSum(root.Right, targetSum)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsPathSum</span><span class="params">(node *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化计数</span></span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前节点值等于目标和，找到一条路径</span></span><br><span class="line">    <span class="keyword">if</span> node.Val == targetSum &#123;</span><br><span class="line">        cnt++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归计算以子节点为路径延续的情况</span></span><br><span class="line">    cnt += dfsPathSum(node.Left, targetSum-node.Val)</span><br><span class="line">    cnt += dfsPathSum(node.Right, targetSum-node.Val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方案二：前缀和优化实现">方案二：前缀和优化实现</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 使用map存储前缀和及其出现次数</span></span><br><span class="line">    prefixSum := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="comment">// 初始前缀和为0，出现1次（空路径）</span></span><br><span class="line">    prefixSum[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用int64避免大数溢出</span></span><br><span class="line">    <span class="keyword">return</span> dfsWithPrefixSum(root, <span class="number">0</span>, <span class="type">int64</span>(targetSum), prefixSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsWithPrefixSum</span><span class="params">(node *TreeNode, currSum <span class="type">int64</span>, targetSum <span class="type">int64</span>, prefixSum <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新当前路径和</span></span><br><span class="line">    currSum += <span class="type">int64</span>(node.Val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找有多少个前缀和为 currSum-targetSum 的路径</span></span><br><span class="line">    <span class="comment">// 这些路径与当前路径一起，形成和为targetSum的路径</span></span><br><span class="line">    count := prefixSum[currSum-targetSum]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新前缀和出现次数</span></span><br><span class="line">    prefixSum[currSum]++</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理左右子树</span></span><br><span class="line">    count += dfsWithPrefixSum(node.Left, currSum, targetSum, prefixSum)</span><br><span class="line">    count += dfsWithPrefixSum(node.Right, currSum, targetSum, prefixSum)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回溯：移除当前节点的影响，避免影响其他分支的计算</span></span><br><span class="line">    prefixSum[currSum]--</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这些解法可以工作">为什么这些解法可以工作</h3>
<ol>
<li>
<p><strong>双重递归解法</strong>：</p>
<ul>
<li>将问题分解为清晰的两个子问题：遍历每个节点 + 统计从特定节点出发的路径</li>
<li>每个递归函数只有单一职责，避免逻辑混淆</li>
<li>使用返回值而非指针引用，使状态管理更清晰</li>
</ul>
</li>
<li>
<p><strong>前缀和解法</strong>：</p>
<ul>
<li>利用数学关系 <code>currentSum - x = targetSum</code>，只需寻找前缀和为 <code>x = currentSum - targetSum</code> 的路径</li>
<li>一次遍历就能统计所有路径，避免重复计算</li>
<li>使用回溯技术维护哈希表状态，确保正确统计不同分支的路径</li>
</ul>
</li>
</ol>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>双重递归法</th>
<th>前缀和法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n²)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(h)，h为树高</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>直观易懂，代码简洁</td>
<td>性能更优，只需一次遍历</td>
</tr>
<tr>
<td>缺点</td>
<td>对大型树性能较差</td>
<td>需要额外哈希表空间</td>
</tr>
<tr>
<td>适用场景</td>
<td>树节点数较少</td>
<td>大型树结构</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="学习总结">学习总结</h2>
<p>通过这个错误，我学到了以下重要经验：</p>
<ol>
<li>
<p><strong>递归设计原则</strong>：</p>
<ul>
<li>递归函数应当功能单一，职责明确</li>
<li>参数设计需要考虑清晰的意义和传递方式</li>
<li>复杂问题可以拆分为多个独立的递归函数配合解决</li>
</ul>
</li>
<li>
<p><strong>常见递归错误模式</strong>：</p>
<ul>
<li>混合不同职责的递归会导致计算路径混乱和重复</li>
<li>递归爆炸：每个节点产生过多递归调用会导致性能灾难</li>
<li>状态管理混乱：使用全局变量或指针引用时需特别小心</li>
</ul>
</li>
<li>
<p><strong>前缀和技术应用</strong>：</p>
<ul>
<li>前缀和不仅适用于数组，也适用于树结构</li>
<li>使用哈希表结合前缀和可以将时间复杂度从 O(n²) 降至 O(n)</li>
<li>回溯思想在树的遍历中的重要应用</li>
</ul>
</li>
<li>
<p><strong>代码质量提升</strong>：</p>
<ul>
<li>清晰的函数命名和参数设计对递归代码尤为重要</li>
<li>使用返回值代替指针引用通常能提高代码可读性</li>
<li>使用 <code>int64</code> 处理可能的整数溢出</li>
</ul>
</li>
</ol>
<p>这个错误也提醒我在处理树的路径问题时，需要特别注意不同路径的定义和计数方式，以避免重复或遗漏。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>哈希</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 105 - 从前序与中序遍历序列构造二叉树（Construct Binary Tree from Preorder and Inorder Traversal）</title>
    <url>/2025/04/30/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code>，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>，<code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>
<p>生成的二叉树如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure>
<h3 id="提示">提示</h3>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> 和 <code>inorder</code> 均无重复元素</li>
<li><code>inorder</code> 均出现在 <code>preorder</code></li>
<li><code>preorder</code> 保证为二叉树的前序遍历序列</li>
<li><code>inorder</code> 保证为二叉树的中序遍历序列</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题要求我们根据二叉树的前序遍历和中序遍历结果重构二叉树。解决这个问题的核心是理解前序遍历和中序遍历的特点：</p>
<ul>
<li><strong>前序遍历</strong>：根节点 → 左子树 → 右子树</li>
<li><strong>中序遍历</strong>：左子树 → 根节点 → 右子树</li>
</ul>
<p><strong>关键洞见</strong>：前序遍历的第一个元素始终是当前子树的根节点。而在中序遍历中，根节点将数组分成两部分：左边是左子树的所有节点，右边是右子树的所有节点。</p>
<p>以示例 1 为例：</p>
<ul>
<li>前序遍历：<code>[3, 9, 20, 15, 7]</code> - 第一个元素 <code>3</code> 是根节点</li>
<li>中序遍历：<code>[9, 3, 15, 20, 7]</code> - 根节点 <code>3</code> 将数组分成 <code>[9]</code>（左子树）和 <code>[15, 20, 7]</code>（右子树）</li>
</ul>
<p>通过这个特性，我们可以递归地构建二叉树：</p>
<ol>
<li>确定根节点：前序遍历的第一个元素</li>
<li>在中序遍历中找到根节点的位置</li>
<li>将中序遍历分成左右两部分，分别对应左右子树</li>
<li>相应地划分前序遍历（根据左右子树的大小）</li>
<li>递归地构建左右子树</li>
</ol>
<h3 id="方法一：递归-数组切片">方法一：递归 + 数组切片</h3>
<p>我们可以使用 Go 的切片特性方便地划分数组，然后递归构建子树。</p>
<h4 id="步骤详情">步骤详情</h4>
<ol>
<li>如果前序遍历数组为空，返回 <code>nil</code>（递归终止条件）</li>
<li>取前序遍历的第一个元素作为根节点</li>
<li>在中序遍历中找到根节点的位置</li>
<li>根据根节点位置，将中序遍历分为左子树和右子树</li>
<li>根据左子树的大小，确定前序遍历中左子树和右子树的范围</li>
<li>递归构建左子树和右子树</li>
</ol>
<h3 id="方法二：递归-哈希表优化">方法二：递归 + 哈希表优化</h3>
<p>方法一中，我们每次递归都要在中序遍历中线性查找根节点的位置，这导致了额外的时间复杂度。为了优化这一步骤，我们可以使用哈希表预先存储中序遍历中每个元素的位置。</p>
<h4 id="步骤详情-2">步骤详情</h4>
<ol>
<li>创建一个哈希表，记录中序遍历中每个元素的索引</li>
<li>定义一个辅助函数，接收前序和中序遍历的范围，以及哈希表</li>
<li>在辅助函数中：
<ul>
<li>如果当前范围为空，返回 <code>nil</code></li>
<li>取前序遍历起始位置的元素作为根节点</li>
<li>从哈希表中找到根节点在中序遍历中的位置</li>
<li>计算左子树的大小</li>
<li>递归构建左右子树，使用计算得到的范围</li>
</ul>
</li>
<li>返回根节点</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>对于方法一和方法二，主要的区别在于如何找到中序遍历中根节点的位置，以及如何划分数组。</p>
<p>在方法一中，我们使用 Go 的切片特性直接对数组进行切片操作，这使得代码简洁但会产生额外的内存开销。</p>
<p>在方法二中，我们避免了切片操作，而是使用索引来指定子数组的范围。同时，使用哈希表优化了查找操作，将查找根节点的时间复杂度从 O(n) 降低到 O(1)。</p>
<h3 id="代码实现">代码实现</h3>
<h4 id="方法一：递归-数组切片-2">方法一：递归 + 数组切片</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 处理空树的情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历的第一个元素是根节点的值</span></span><br><span class="line">    rootVal := preorder[<span class="number">0</span>]</span><br><span class="line">    root := &amp;TreeNode&#123;Val: rootVal&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">    rootIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, val := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> val == rootVal &#123;</span><br><span class="line">            rootIndex = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">    <span class="comment">// 左子树：前序遍历中 [1:rootIndex+1]，中序遍历中 [:rootIndex]</span></span><br><span class="line">    <span class="comment">// 右子树：前序遍历中 [rootIndex+1:]，中序遍历中 [rootIndex+1:]</span></span><br><span class="line">    root.Left = buildTree(preorder[<span class="number">1</span>:rootIndex+<span class="number">1</span>], inorder[:rootIndex])</span><br><span class="line">    root.Right = buildTree(preorder[rootIndex+<span class="number">1</span>:], inorder[rootIndex+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：递归-哈希表优化-2">方法二：递归 + 哈希表优化</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 创建中序遍历的值到索引的映射，加速查找</span></span><br><span class="line">    inorderMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, val := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        inorderMap[val] = i</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> buildTreeHelper(preorder, <span class="number">0</span>, <span class="built_in">len</span>(preorder)<span class="number">-1</span>, inorder, <span class="number">0</span>, <span class="built_in">len</span>(inorder)<span class="number">-1</span>, inorderMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTreeHelper</span><span class="params">(preorder []<span class="type">int</span>, preStart, preEnd <span class="type">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                    inorder []<span class="type">int</span>, inStart, inEnd <span class="type">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                    inorderMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> preStart &gt; preEnd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 前序遍历的第一个元素是根节点</span></span><br><span class="line">    rootVal := preorder[preStart]</span><br><span class="line">    root := &amp;TreeNode&#123;Val: rootVal&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">    rootIndex := inorderMap[rootVal]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算左子树的节点数量</span></span><br><span class="line">    leftSize := rootIndex - inStart</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">    <span class="comment">// 左子树：</span></span><br><span class="line">    <span class="comment">// - 前序遍历：[preStart+1 : preStart+leftSize+1)</span></span><br><span class="line">    <span class="comment">// - 中序遍历：[inStart : rootIndex)</span></span><br><span class="line">    root.Left = buildTreeHelper(</span><br><span class="line">        preorder, preStart+<span class="number">1</span>, preStart+leftSize, </span><br><span class="line">        inorder, inStart, rootIndex<span class="number">-1</span>, </span><br><span class="line">        inorderMap,</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 右子树：</span></span><br><span class="line">    <span class="comment">// - 前序遍历：[preStart+leftSize+1 : preEnd+1)</span></span><br><span class="line">    <span class="comment">// - 中序遍历：[rootIndex+1 : inEnd+1)</span></span><br><span class="line">    root.Right = buildTreeHelper(</span><br><span class="line">        preorder, preStart+leftSize+<span class="number">1</span>, preEnd, </span><br><span class="line">        inorder, rootIndex+<span class="number">1</span>, inEnd, </span><br><span class="line">        inorderMap,</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析">执行过程分析</h3>
<p>以示例 1 为例，我们来一步步分析方法二的执行过程：</p>
<ul>
<li>前序遍历：<code>[3, 9, 20, 15, 7]</code></li>
<li>中序遍历：<code>[9, 3, 15, 20, 7]</code></li>
</ul>
<ol>
<li>创建哈希表：<code>&#123;9:0, 3:1, 15:2, 20:3, 7:4&#125;</code></li>
<li>调用 <code>buildTreeHelper</code> 函数，范围是整个数组</li>
<li><code>rootVal = preorder[0] = 3</code></li>
<li><code>rootIndex = inorderMap[3] = 1</code></li>
<li><code>leftSize = 1 - 0 = 1</code>（左子树有 1 个节点）</li>
<li>递归构建左子树：
<ul>
<li>前序范围：<code>[1, 1]</code>，即 <code>[9]</code></li>
<li>中序范围：<code>[0, 0]</code>，即 <code>[9]</code></li>
<li>返回一个值为 9 的节点，没有子节点</li>
</ul>
</li>
<li>递归构建右子树：
<ul>
<li>前序范围：<code>[2, 4]</code>，即 <code>[20, 15, 7]</code></li>
<li>中序范围：<code>[2, 4]</code>，即 <code>[15, 20, 7]</code></li>
<li>这又是一个子问题，会递归解决</li>
</ul>
</li>
<li>最终返回构建好的树</li>
</ol>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一：递归 + 数组切片</th>
<th>方法二：递归 + 哈希表优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n²)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>代码简洁，易于理解</td>
<td>更高效，尤其是对于大型树</td>
</tr>
<tr>
<td>缺点</td>
<td>在递归过程中查找根节点位置较慢，且切片操作会增加内存开销</td>
<td>代码相对复杂</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="方法一：递归-数组切片-3">方法一：递归 + 数组切片</h3>
<ul>
<li>
<p><strong>时间复杂度</strong>：O(n²)</p>
<ul>
<li>最坏情况下，每次递归都需要 O(n) 时间来找到根节点在中序遍历中的位置</li>
<li>递归树的深度为 O(n)</li>
<li>因此总时间复杂度为 O(n²)</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：O(n)</p>
<ul>
<li>递归调用栈的深度为 O(n)</li>
<li>切片操作会创建新的数组，增加额外的空间开销</li>
</ul>
</li>
</ul>
<h3 id="方法二：递归-哈希表优化-3">方法二：递归 + 哈希表优化</h3>
<ul>
<li>
<p><strong>时间复杂度</strong>：O(n)</p>
<ul>
<li>预处理哈希表需要 O(n) 时间</li>
<li>每个节点只被访问一次，构建的时间为 O(n)</li>
<li>查找根节点位置的时间从 O(n) 优化到 O(1)</li>
<li>因此总时间复杂度为 O(n)</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：O(n)</p>
<ul>
<li>哈希表需要 O(n) 的空间</li>
<li>递归调用栈的深度为 O(n)</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>前序遍历和中序遍历的特性</strong>：理解这两种遍历方式的特点是解决此类问题的基础。前序遍历的第一个元素是根节点，中序遍历可以区分左右子树。</p>
</li>
<li>
<p><strong>递归思想</strong>：这道题是典型的递归问题，通过不断地将大问题分解为小问题来解决。</p>
</li>
<li>
<p><strong>空间时间权衡</strong>：方法二通过使用额外的哈希表空间换取时间效率，这是算法优化中常见的思路。</p>
</li>
<li>
<p><strong>索引计算</strong>：在方法二中，正确计算子数组的范围是关键，需要特别注意索引边界。</p>
</li>
<li>
<p><strong>常见陷阱</strong>：</p>
<ul>
<li>忘记考虑空树情况</li>
<li>计算子树范围时的索引错误</li>
<li>没有正确处理左右子树的划分</li>
</ul>
</li>
</ol>
<p>相关问题：</p>
<ul>
<li>LeetCode 106：从中序与后序遍历序列构造二叉树</li>
<li>LeetCode 889：根据前序和后序遍历构造二叉树</li>
<li>LeetCode 1008：前序遍历构造二叉搜索树</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>Hot100</tag>
        <tag>分治</tag>
        <tag>哈希</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 114 - 二叉树展开为链表</title>
    <url>/2025/04/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-114-Binary-Tree-Flatten/</url>
    <content><![CDATA[<h2 id="修订记录">修订记录</h2>
<table>
<thead>
<tr>
<th>版本</th>
<th>修订时间</th>
<th>修订内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>v1.0</td>
<td>2025-04-29 20:08:43</td>
<td>初始版本，包含错误解法分析和修正解法</td>
</tr>
<tr>
<td>v2.0</td>
<td>2025-06-15 13:11:33</td>
<td>添加进一步优化版本，完善解法对比和学习总结</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="问题描述">问题描述</h2>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2025/04/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-114-Binary-Tree-Flatten/1745928682533.png" alt="1745928682533"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 [0, 2000] 内</li>
<li>-100 &lt;= Node.val &lt;= 100</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我的初始解法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入参数为一颗子树的根节点，返回值为处理完后这颗子树的最后一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsFlatten</span><span class="params">(node *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    leftEnd := dfsFlatten(node.Left)</span><br><span class="line">    rightEnd := dfsFlatten(node.Right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> leftEnd != <span class="literal">nil</span> &#123;</span><br><span class="line">        leftEnd.Right = node.Right</span><br><span class="line">        node.Right = node.Left</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> rightEnd == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node  <span class="comment">// ❌ 错误点：当右子树为空时，应该返回leftEnd而不是node</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rightEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法在某些测试用例中失败了，主要有以下几个错误：</p>
<h3 id="错误原因分析">错误原因分析</h3>
<ol>
<li>
<p><strong>没有设置 <code>node.Left = nil</code></strong><br>
题目明确要求展开后的单链表<strong>左子指针始终为 <code>null</code></strong>。在我的错误代码中，当处理完左子树后（<code>leftEnd := dfsFlatten(node.Left)</code>），并且 <code>leftEnd != nil</code> 时，我执行了 <code>node.Right = node.Left</code>，将原来的左子树挂载到了右子树的位置。但是，我<strong>忘记了将 <code>node.Left</code> 设置为 <code>nil</code></strong>。这导致原本的左子树引用依然存在，不满足题目要求的链表结构。正确的做法是在 <code>node.Right = node.Left</code> 之后，紧接着执行 <code>node.Left = nil</code>，彻底断开左子树的连接。</p>
</li>
<li>
<p><strong>缺少对叶子节点的特殊处理（优化缺失）</strong><br>
虽然这不算一个导致结果错误的 bug，但它是一个重要的<strong>优化点</strong>。叶子节点（<code>node.Left == nil &amp;&amp; node.Right == nil</code>）是递归的最小单元，它们自身就是展开后的链表的末尾节点。在错误代码中，即使遇到叶子节点，仍然会继续递归调用 <code>dfsFlatten(nil)</code> 两次，然后才返回。正确的解法中增加了 <code>if node.Left == nil &amp;&amp; node.Right == nil &#123; return node &#125;</code> 的判断，可以直接返回叶子节点本身，避免了不必要的递归调用，提高了效率。</p>
</li>
<li>
<p><strong>返回值逻辑错误 (<code>rightEnd == nil</code> 的情况)</strong><br>
这是最关键的逻辑错误。<code>dfsFlatten</code> 函数的定义是：传入一个子树的根节点 <code>node</code>，将其原地展开为链表，并返回这个<strong>展开后链表的最后一个节点</strong>。</p>
<ul>
<li>当 <code>rightEnd == nil</code> 时，意味着当前节点 <code>node</code> 没有右子树（或者右子树递归展开后返回 <code>nil</code>）。</li>
<li>在这种情况下，如果 <code>leftEnd != nil</code>（即存在左子树且已展开），那么根据先序遍历的顺序，<code>node</code> 之后应该连接的是展开后的左子树。因此，整个以 <code>node</code> 为根的展开链表的最后一个节点，就应该是其左子树展开后的最后一个节点，即 <code>leftEnd</code>。</li>
<li>我的错误代码中返回了 <code>node</code>。这在只有左子树的情况下是错误的，因为 <code>node</code> 并不是展开后链表的最后一个节点。</li>
<li>如果 <code>leftEnd == nil</code>（左右子树都为空），此时 <code>node</code> 本身就是最后一个节点。看起来返回 <code>node</code> 似乎是对的。但是，这种情况其实已经被第 2 点提到的叶子节点判断覆盖了（在正确解法中）。在错误解法中，由于缺少叶子节点判断，即使左右子树都为空，也会执行到这里，并错误地返回 <code>node</code>，但这恰好在“叶子节点”这个特定场景下得到了“正确”的结果，掩盖了逻辑本身的缺陷。正确的逻辑应该是，当 <code>rightEnd == nil</code> 时，无论 <code>leftEnd</code> 是否为 <code>nil</code>，都应该返回 <code>leftEnd</code>（因为如果 <code>leftEnd</code> 为 <code>nil</code>，返回 <code>nil</code> 也是符合逻辑的，虽然会被叶子节点优化覆盖）。</li>
</ul>
</li>
</ol>
<h4 id="示例追踪">示例追踪</h4>
<p>让我们用一个具体的例子 <code>[1, 2, null, 3, 4]</code> 来追踪错误代码的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">3   4</span><br></pre></td></tr></table></figure>
<p>期望输出: <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> (所有左指针为 nil)</p>
<p><strong>错误代码追踪:</strong></p>
<ol>
<li><code>dfsFlatten(1)</code>
<ul>
<li><code>dfsFlatten(2)</code>
<ul>
<li><code>dfsFlatten(3)</code>: (叶子) -&gt; <strong>错误返回 node 3</strong></li>
<li><code>dfsFlatten(4)</code>: (叶子) -&gt; <strong>错误返回 node 4</strong></li>
<li>处理 node 2:
<ul>
<li><code>leftEnd = 3</code>, <code>rightEnd = 4</code></li>
<li><code>3.Right = 2.Right</code> (node 2 原右子节点 4) =&gt; <code>3.Right = 4</code></li>
<li><code>2.Right = 2.Left</code> (node 2 原左子节点 3) =&gt; <code>2.Right = 3</code></li>
<li><strong>遗漏 <code>2.Left = nil</code></strong></li>
<li>返回 <code>rightEnd</code> (node 4)</li>
</ul>
</li>
</ul>
</li>
<li><code>leftEnd = 4</code> (来自 <code>dfsFlatten(2)</code>)</li>
<li><code>dfsFlatten(nil)</code> (node 1 的右子节点) -&gt; 返回 <code>nil</code></li>
<li><code>rightEnd = nil</code></li>
<li>处理 node 1:
<ul>
<li><code>leftEnd = 4</code>, <code>rightEnd = nil</code></li>
<li><code>4.Right = 1.Right</code> (nil) =&gt; <code>4.Right = nil</code></li>
<li><code>1.Right = 1.Left</code> (node 2) =&gt; <code>1.Right = 2</code></li>
<li><strong>遗漏 <code>1.Left = nil</code></strong></li>
<li><code>rightEnd == nil</code> -&gt; <strong>错误返回 <code>node</code> (node 1)</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>最终结果:</strong> 函数返回 <code>node 1</code>，但链表结构是错误的：<code>1</code> 的 <code>Left</code> 仍然指向 <code>2</code>，<code>2</code> 的 <code>Left</code> 仍然指向 <code>3</code>。此外，由于返回值错误，如果上层还有调用，也会基于错误的末尾节点信息继续拼接，导致链表结构混乱。</p>
<h2 id="正确解法">正确解法</h2>
<p>经过分析，我改进的解法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsFlatten</span><span class="params">(node *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    leftEnd := dfsFlatten(node.Left)</span><br><span class="line">    rightEnd := dfsFlatten(node.Right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> leftEnd != <span class="literal">nil</span> &#123;</span><br><span class="line">        leftEnd.Right = node.Right</span><br><span class="line">        node.Right = node.Left</span><br><span class="line">        node.Left = <span class="literal">nil</span>  <span class="comment">// 确保左指针设为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> rightEnd == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftEnd  <span class="comment">// 如果右子树为空，返回leftEnd</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rightEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这个解法可以工作">为什么这个解法可以工作</h3>
<ol>
<li>
<p><strong>正确处理左子指针</strong>：将 <code>node.Left = nil</code> 确保了展开后的链表左子指针始终为null。</p>
</li>
<li>
<p><strong>叶子节点优化</strong>：添加了对叶子节点的判断，可以提前返回，减少不必要的处理。</p>
</li>
<li>
<p><strong>返回值逻辑正确</strong>：</p>
<ul>
<li>当右子树存在时，返回右子树展开后的末尾节点</li>
<li>当右子树为空时，返回左子树展开后的末尾节点</li>
<li>当左右子树都为空时，返回节点本身</li>
</ul>
</li>
</ol>
<h2 id="进一步优化版本-span-style-color-ff6b6b-font-size-0-8em-v2-0-新增-span">进一步优化版本 <span style="color: #ff6b6b; font-size: 0.8em;">[v2.0 新增]</span></h2>
<p>在深入理解问题后，我们可以写出一个更清晰的优化版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> *TreeNode</span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">        <span class="comment">// 空节点或叶子节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> || (root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存原始右子树</span></span><br><span class="line">        tmpRight := root.Right</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先处理左子树</span></span><br><span class="line">        leftLast := dfs(root.Left)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左子树存在，进行连接操作</span></span><br><span class="line">        <span class="keyword">if</span> leftLast != <span class="literal">nil</span> &#123;</span><br><span class="line">            leftLast.Right = root.Right    <span class="comment">// 左子树的末尾连接到原右子树</span></span><br><span class="line">            root.Right = root.Left         <span class="comment">// 左子树移到右边</span></span><br><span class="line">            root.Left = <span class="literal">nil</span>                <span class="comment">// 清空左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果原来没有右子树，返回左子树的末尾</span></span><br><span class="line">        <span class="keyword">if</span> tmpRight == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> leftLast</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理原右子树，返回其末尾节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(tmpRight)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化版本的核心思想">优化版本的核心思想</h3>
<ol>
<li><strong>分离处理</strong>：先处理左子树，完成左子树的连接操作，再处理右子树</li>
<li><strong>保存引用</strong>：使用 <code>tmpRight</code> 保存原始右子树，避免在连接过程中丢失引用</li>
<li><strong>清晰的逻辑流程</strong>：
<ul>
<li>处理左子树得到 <code>leftLast</code></li>
<li>如果左子树存在，执行连接操作</li>
<li>根据是否有原右子树决定返回值</li>
</ul>
</li>
</ol>
<h3 id="与之前解法的对比">与之前解法的对比</h3>
<table>
<thead>
<tr>
<th>方面</th>
<th>初始错误解法</th>
<th>修正解法</th>
<th>优化版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>左右子树处理</td>
<td>同时处理</td>
<td>同时处理</td>
<td>分离处理</td>
</tr>
<tr>
<td>右子树引用</td>
<td>直接使用</td>
<td>直接使用</td>
<td>提前保存</td>
</tr>
<tr>
<td>代码可读性</td>
<td>较差</td>
<td>良好</td>
<td>更好</td>
</tr>
<tr>
<td>逻辑清晰度</td>
<td>混乱</td>
<td>清晰</td>
<td>非常清晰</td>
</tr>
</tbody>
</table>
<h3 id="执行过程示例">执行过程示例</h3>
<p>以树 <code>[1,2,5,3,4,null,6]</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>
<p><strong>优化版本执行流程：</strong></p>
<ol>
<li>
<p><code>dfs(1)</code>:</p>
<ul>
<li><code>tmpRight = 5</code></li>
<li><code>leftLast = dfs(2)</code> 返回节点4</li>
<li>连接：<code>4.Right = 5</code>, <code>1.Right = 2</code>, <code>1.Left = nil</code></li>
<li><code>tmpRight != nil</code>，返回 <code>dfs(5)</code> 的结果</li>
</ul>
</li>
<li>
<p><code>dfs(2)</code>:</p>
<ul>
<li><code>tmpRight = null</code></li>
<li><code>leftLast = dfs(3)</code> 返回节点3</li>
<li>连接：<code>3.Right = null</code>, <code>2.Right = 3</code>, <code>2.Left = nil</code></li>
<li><code>tmpRight == nil</code>，返回 <code>leftLast</code> (节点3)</li>
<li>但还要处理右子树4，最终返回节点4</li>
</ul>
</li>
</ol>
<p>这个优化版本的逻辑更加直观，代码也更容易理解和维护。</p>
<h2 id="学习总结">学习总结</h2>
<ol>
<li>
<p><strong>细节很重要</strong>：在树和链表相关问题中，指针操作的细节非常重要，漏掉一步可能导致整个结构错误。</p>
</li>
<li>
<p><strong>返回值的含义要明确</strong>：在递归函数中，返回值的含义必须清晰且一致。我最初混淆了返回值的含义，导致了逻辑错误。</p>
</li>
<li>
<p><strong>多思考边界情况</strong>：叶子节点、空节点等边界情况需要特别注意。</p>
</li>
<li>
<p><strong>前序思考</strong>：在编写递归函数前，应该先明确函数参数和返回值的具体含义，并确保整个递归过程中这个含义保持一致。</p>
</li>
<li>
<p><strong>分离复杂逻辑</strong>：当处理逻辑较复杂时，可以考虑分离处理，如优化版本中先处理左子树再处理右子树的方式。</p>
</li>
<li>
<p><strong>保护重要引用</strong>：在进行指针操作时，要注意保护可能被修改的重要引用，避免在操作过程中丢失。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 230 - 二叉搜索树中第K小的元素（Kth Smallest Element in a BST）</title>
    <url>/2025/04/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-230-Kth-Smallest-Element-in-BST/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数为 n 。</li>
<li>1 &lt;= k &lt;= n &lt;= 10^4</li>
<li>0 &lt;= Node.val &lt;= 10^4</li>
</ul>
<p><strong>进阶：</strong> 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？</p>
<h2 id="解题思路">解题思路</h2>
<p>这道题要求我们找到二叉搜索树中第 k 小的元素，有几种不同的方法可以解决。</p>
<h3 id="方法一：中序遍历（递归法）">方法一：中序遍历（递归法）</h3>
<p>二叉搜索树的一个重要特性是：<strong>中序遍历的结果是按照节点值从小到大排列的</strong>。利用这个特性，我们可以通过中序遍历得到树中所有元素的有序序列，然后取第 k 个元素即可。</p>
<p>具体步骤：</p>
<ol>
<li>对树进行中序遍历（左 → 根 → 右）</li>
<li>使用计数器记录当前访问的是第几个节点</li>
<li>当计数器等于 k 时，返回当前节点的值</li>
</ol>
<p>这种方法的关键在于理解二叉搜索树的中序遍历性质，以及如何在遍历过程中及时停止以提高效率。</p>
<h3 id="方法二：中序遍历（迭代法）">方法二：中序遍历（迭代法）</h3>
<p>上述递归方法也可以用迭代的方式实现，使用栈来模拟递归过程。这种方法在某些情况下可能更高效，特别是当 k 很小而树很大时。</p>
<h3 id="方法三：计数优化（针对进阶问题）">方法三：计数优化（针对进阶问题）</h3>
<p>对于进阶问题，我们需要考虑如何在频繁修改的情况下高效查找第 k 小的元素。一种优化方法是在每个节点中维护额外信息：<strong>以该节点为根的子树中节点的数量</strong>。这样可以在 O(log n) 的时间复杂度内找到第 k 小的元素。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="方法一：中序遍历（递归法）-2">方法一：中序遍历（递归法）</h3>
<p>递归解法的核心思想是按顺序访问节点并计数：</p>
<ol>
<li>先遍历左子树</li>
<li>递增计数器，检查是否达到 k</li>
<li>如果达到 k，返回当前节点值</li>
<li>否则继续遍历右子树</li>
</ol>
<p>这种方法的实现简洁，且能在找到目标后立即返回，不需要遍历整棵树。</p>
<h3 id="方法二：中序遍历（迭代法）-2">方法二：中序遍历（迭代法）</h3>
<p>迭代解法使用栈来模拟递归过程：</p>
<ol>
<li>使用栈记录遍历路径</li>
<li>不断将左子节点入栈，直到没有左子节点</li>
<li>弹出栈顶节点，递增计数器</li>
<li>检查计数器是否等于 k，是则返回当前节点值</li>
<li>处理右子节点</li>
</ol>
<h3 id="方法三：节点计数优化">方法三：节点计数优化</h3>
<p>对于进阶问题的解决方案：</p>
<ol>
<li>扩展树节点结构，添加 count 字段表示左子树节点数量</li>
<li>插入/删除节点时更新 count 值</li>
<li>查找第 k 小元素时，根据 count 值决定向左还是向右子树移动</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<h3 id="方法一：中序遍历（递归法）-3">方法一：中序遍历（递归法）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(root *TreeNode, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> dfsKthSmallest(root, k, &amp;cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsKthSmallest</span><span class="params">(node *TreeNode, k <span class="type">int</span>, cnt *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 先遍历左子树</span></span><br><span class="line">    leftRes := dfsKthSmallest(node.Left, k, cnt)</span><br><span class="line">    <span class="keyword">if</span> leftRes != <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRes</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 访问当前节点</span></span><br><span class="line">    *cnt++</span><br><span class="line">    <span class="keyword">if</span> *cnt == k &#123;</span><br><span class="line">        <span class="keyword">return</span> node.Val</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历右子树</span></span><br><span class="line">    <span class="keyword">return</span> dfsKthSmallest(node.Right, k, cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：中序遍历（迭代法）-3">方法二：中序遍历（迭代法）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthSmallest</span><span class="params">(root *TreeNode, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    curr := root</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> curr != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 将所有左子节点入栈</span></span><br><span class="line">        <span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, curr)</span><br><span class="line">            curr = curr.Left</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 弹出栈顶节点</span></span><br><span class="line">        curr = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> count == k &#123;</span><br><span class="line">            <span class="keyword">return</span> curr.Val</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 处理右子节点</span></span><br><span class="line">        curr = curr.Right</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：节点计数优化（进阶问题的解决方案）">方法三：节点计数优化（进阶问题的解决方案）</h3>
<p>为了解决进阶问题，我们可以设计一个增强版的二叉搜索树：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增强的树节点结构</span></span><br><span class="line"><span class="keyword">type</span> EnhancedTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val       <span class="type">int</span></span><br><span class="line">    Left      *EnhancedTreeNode</span><br><span class="line">    Right     *EnhancedTreeNode</span><br><span class="line">    LeftCount <span class="type">int</span>  <span class="comment">// 左子树节点数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(root *EnhancedTreeNode, val <span class="type">int</span>)</span></span> *EnhancedTreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;EnhancedTreeNode&#123;Val: val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> val &lt; root.Val &#123;</span><br><span class="line">        root.Left = insert(root.Left, val)</span><br><span class="line">        root.LeftCount++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root.Right = insert(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找第k小的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthSmallest</span><span class="params">(root *EnhancedTreeNode, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当前节点的排名 = 左子树节点数 + 1</span></span><br><span class="line">    leftSize := root.LeftCount</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> k == leftSize + <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root.Val</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> k &lt;= leftSize &#123;</span><br><span class="line">        <span class="comment">// 第k小的元素在左子树中</span></span><br><span class="line">        <span class="keyword">return</span> findKthSmallest(root.Left, k)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第k小的元素在右子树中，需要调整k值</span></span><br><span class="line">        <span class="keyword">return</span> findKthSmallest(root.Right, k - leftSize - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>中序遍历（递归）</th>
<th>中序遍历（迭代）</th>
<th>节点计数优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(h)</td>
<td>O(h)</td>
<td>O(h)</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单直观</td>
<td>避免递归栈溢出风险</td>
<td>频繁查询时效率高</td>
</tr>
<tr>
<td>缺点</td>
<td>递归层数深时可能栈溢出</td>
<td>代码稍复杂</td>
<td>需要修改节点结构，维护成本高</td>
</tr>
<tr>
<td>适用场景</td>
<td>一般查询场景</td>
<td>树较深时的查询</td>
<td>频繁修改和查询</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★☆</td>
<td>★★★★☆</td>
<td>★★★★★（针对进阶问题）</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="方法一和方法二（中序遍历）：">方法一和方法二（中序遍历）：</h3>
<ul>
<li><strong>时间复杂度</strong>：O(n)，最坏情况下需要遍历整棵树，但平均情况下为 O(h + k)，其中 h 是树的高度。</li>
<li><strong>空间复杂度</strong>：O(h)，h 是树的高度，递归调用栈或迭代方法中的栈空间。</li>
</ul>
<h3 id="方法三（节点计数优化）：">方法三（节点计数优化）：</h3>
<ul>
<li><strong>时间复杂度</strong>：
<ul>
<li>查询：O(log n)，每次查询只需要遍历一条从根到叶的路径。</li>
<li>插入/删除：O(log n)，同时需要更新路径上节点的计数。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(h)，h 是树的高度。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>利用二叉搜索树的特性</strong>：中序遍历二叉搜索树可以得到有序序列，这是解决许多二叉搜索树问题的关键。</li>
<li><strong>数据结构增强</strong>：通过在节点中存储额外信息（如子树节点数量），可以显著优化特定操作的性能。这是解决进阶问题的常用技巧。</li>
<li><strong>权衡取舍</strong>：方法三通过增加存储空间和维护成本，换取查询时间的优化，这在频繁操作的场景下是值得的。</li>
<li><strong>递归与迭代</strong>：同一算法既可以用递归实现，也可以用迭代实现，不同场景下可能有不同的优势。</li>
</ol>
<p>相关问题：</p>
<ul>
<li>LeetCode 98: 验证二叉搜索树</li>
<li>LeetCode 173: 二叉搜索树迭代器</li>
<li>LeetCode 235: 二叉搜索树的最近公共祖先</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 MySQL 采用 B+ 树作为索引？</title>
    <url>/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/</url>
    <content><![CDATA[<h1>为什么 MySQL 采用 B+ 树作为索引？</h1>
<p>要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑磁盘 I/O 操作次数，因为 MySQL 的数据是存储在磁盘中的嘛。</p>
<h2 id="怎样的索引的数据结构是好的？">怎样的索引的数据结构是好的？</h2>
<p>MySQL 的数据是持久化的，意味着数据（索引 + 记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。</p>
<p>磁盘是一个慢的离谱的存储设备，有多离谱呢？</p>
<p>人家内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p>
<p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 <code>512B</code> 大小，操作系统一次会读写多个扇区，所以<strong>操作系统的最小读写单位是块（Block）。Linux 中的块大小为 <code>4KB</code></strong>，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。</p>
<p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p>
<p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p>
<p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p>
<p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<ul>
<li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li>
<li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li>
</ul>
<p>分析完要求后，我们针对每一个数据结构分析一下。</p>
<h2 id="什么是二分查找？">什么是二分查找？</h2>
<p>索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。</p>
<p>假设我们现在用数组来存储索引，比如下面有一个排序的数组，如果要从中找出数字 3，最简单办法就是从头依次遍历查询，这种方法的时间复杂度是 O(n)，查询效率并不高。因为该数组是有序的，所以我们可以采用二分查找法，比如下面这张采用二分法的查询过程图：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915426331.png" alt="1745915426331"></p>
<p>可以看到，二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断计算中间位置。</p>
<h2 id="什么是二分查找树？">什么是二分查找树？</h2>
<p>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p>
<p>因为插入一个元素，需要将这个元素之后的所有元素后移一位，如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢几十万倍，所以我们不能用一种线性结构将磁盘排序。</p>
<p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p>
<p>那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？</p>
<p>有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915426331.gif" alt="1745915426331"></p>
<p>怎么样？是不是变成了二叉树，不过它不是普通的二叉树，它是一个<strong>二叉查找树</strong>。</p>
<p><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。</p>
<p>假设，我们查找索引值为 key 的节点：</p>
<ol>
<li>如果 key 大于根节点，则在右子树中进行查找；</li>
<li>如果 key 小于根节点，则在左子树中进行查找；</li>
<li>如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。</li>
</ol>
<p>二叉查找树查找某个节点的动图演示如下，比如要查找节点 3：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915426332.gif" alt></p>
<p>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p>
<p>下面是二叉查找树插入某个节点的动图演示：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915426333.gif" alt></p>
<p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。</p>
<p>那是不是二叉查找树就可以作为索引的数据结构了呢？</p>
<p>不行不行，二叉查找树存在一个极端情况，会导致它变成一个瘸子！</p>
<p><strong>当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)</strong>，如下动图演示：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915426334.gif" alt></p>
<p>由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（<em>假设一个节点的大小「小于」操作系统的最小读写单位块的大小</em>），也就是说<strong>树的高度就等于每次查询数据时磁盘 IO 操作的次数</strong>，所以树的高度越高，就会影响查询性能。</p>
<p>二叉查找树由于存在退化成链表的可能性，会使得查询操作的时间复杂度从 O(logn) 升为 O(n)。</p>
<p>而且会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上不能范围查询，所以不适合作为数据库的索引结构。</p>
<h2 id="什么是自平衡二叉树？">什么是自平衡二叉树？</h2>
<p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p>
<p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) 。</p>
<p>下图是每次插入的元素都是平衡二叉查找树中最大的元素，可以看到，它会维持自平衡：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915426335.gif" alt></p>
<p>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，不是本篇的重点重点，大家可以看《数据结构》相关的书籍来了解红黑树的约束条件。</p>
<p>下面是红黑树插入节点的过程，这左旋右旋的操作，就是为了自平衡。</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915426336.gif" alt></p>
<p><strong>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率</strong>。</p>
<p>比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915816175.png" alt="1745915816175"></p>
<p>根本原因是因为它们都是二叉树，也就是每个节点只能保存 2 个子节点，如果我们把二叉树改成 M 叉树（M&gt;2）呢？</p>
<p>比如，当 M=3 时，在同样的节点个数情况下，三叉树比二叉树的树高要矮。</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915829974.png" alt="1745915829974"></p>
<p>因此，<strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。</p>
<h2 id="什么是-B-树">什么是 B 树</h2>
<p>自平衡二叉树虽然能保持查询操作的时间复杂度在 O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。</p>
<p>为了解决降低树的高度的问题，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p>
<p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。</p>
<p>假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1 个）数据和最多有 3 个（M 个）子节点，超过这些要求的话，就会分裂节点，比如下面的的动图：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915839975.gif" alt="1745915839975"></p>
<p>我们来看看一棵 3 阶的 B 树的查询过程是怎样的？</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915849976.gif" alt="1745915849976"></p>
<p>假设我们在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：</p>
<ol>
<li>与根节点的索引 (4，8）进行比较，9 大于 8，那么往右边的子节点走；</li>
<li>然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；</li>
<li>走到索引为 9 的节点，然后我们找到了索引值 9 的节点。</li>
</ol>
<p>可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3，所以在查询过程中会发生 3 次磁盘 I/O 操作。</p>
<p>而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。</p>
<p>但是 B 树的每个节点都包含数据（索引 + 记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。</p>
<p>而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p>
<p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p>
<h2 id="什么是-B-树？">什么是 B+ 树？</h2>
<p>B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915888730.png" alt="1745915888730"></p>
<p>B+ 树与 B 树差异的点，主要是以下这几点：</p>
<ul>
<li>叶子节点（最底部的节点）才会存放实际数据（索引 + 记录），非叶子节点只会存放索引；</li>
<li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li>
<li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li>
<li>非叶子节点中有多少个子节点，就有多少个索引；</li>
</ul>
<p>下面通过三个方面，比较下 B+ 和 B 树的性能区别。</p>
<h3 id="1、单点查询">1、单点查询</h3>
<p>B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。</p>
<p>但是 B 树的查询波动会比较大，因为每个节点既存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。</p>
<p><strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比既存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O 次数会更少</strong>。</p>
<h3 id="2、插入和删除效率">2、插入和删除效率</h3>
<p>B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快，</p>
<p>比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915908731.gif" alt="1745915908731"></p>
<blockquote>
<p>注意，：B+ 树对于非叶子节点的子节点和索引的个数，定义方式可能会有不同，有的是说非叶子节点的子节点的个数为 M 阶，而索引的个数为 M-1（这个是维基百科里的定义），因此我本文关于 B+ 树的动图都是基于这个。但是我在前面介绍 B+ 树与 B+ 树的差异时，说的是「非叶子节点中有多少个子节点，就有多少个索引」，主要是 MySQL 用到的 B+ 树就是这个特性。</p>
</blockquote>
<p>下面这个动图是删除 B 树 0008 节点的过程，可能会导致树的复杂变化：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915918732.gif" alt="1745915918732"></p>
<p>甚至，B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形，比如下面这个动图是删除 B+ 树根节点的过程：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915928733.gif" alt="1745915928733"></p>
<p>B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，比如下面这个动图是删除 B 树根节点的过程：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745915938734.gif" alt="1745915938734"></p>
<p>B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。</p>
<p>因此，<strong>B+ 树的插入和删除效率更高</strong>。</p>
<h3 id="3、范围查询">3、范围查询</h3>
<p>B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。</p>
<p>因为 <strong>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</strong>，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月 12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。</p>
<p>而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</p>
<p>因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的 MongoDB。</p>
<h3 id="MySQL-中的-B-树">MySQL 中的 B+ 树</h3>
<p>MySQL 的存储方式根据存储引擎的不同而不同，我们最常用的就是 Innodb 存储引擎，它就是采用了 B+ 树作为了索引的数据结构。</p>
<p>下图就是 Innodb 里的 B+ 树：</p>
<p><img src="/2025/04/29/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91/1745916000852.png" alt="1745916000852"></p>
<p>但是 Innodb 使用的 B+ 树有一些特别的点，比如：</p>
<ul>
<li>B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。</li>
<li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。</li>
</ul>
<p>Innodb 根据索引类型不同，分为聚簇和二级索引。他们区别在于，聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。</p>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。</p>
<p>更多关于 Innodb 的 B+ 树，可以看我之前的这篇文章：<a href="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/">InnoDB 的数据页</a>。</p>
<h2 id="总结">总结</h2>
<p>MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引擎使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。</p>
<p>要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。</p>
<p>二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn) 降低为 O(n)。</p>
<p>为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。</p>
<p>而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</p>
<p>B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。</p>
<p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：</p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比既存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O 次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li>
</ul>
<p>完！</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>B+树</tag>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 98 - 验证二叉搜索树 (Validate Binary Search Tree)</title>
    <url>/2025/04/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-98-validate-binary-search-tree/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在 [1, 10^4] 内</li>
<li>-2^31 &lt;= Node.val &lt;= 2^31 - 1</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我的初始解法是使用递归方法，为每个节点设定上下界来验证二叉搜索树的性质：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helplerIsValidBST(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helplerIsValidBST</span><span class="params">(node *TreeNode, low, high <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ❌ 错误点：使用了错误的比较运算符</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &lt; low || node.Val &gt; high &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> helplerIsValidBST(node.Left, low, node.Val) &amp;&amp; </span><br><span class="line">           helplerIsValidBST(node.Right, node.Val, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法在以下测试用例中失败了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[5,4,6,null,null,3,7]</span><br><span class="line">预期输出：false</span><br><span class="line">实际输出：true</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>这个测试用例表示一棵二叉树，其中根节点是 5，左子节点是 4，右子节点是 6，而 6 的左子节点是 3，右子节点是 7。</p>
<p>我的错误在于条件判断：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> node.Val &lt; low || node.Val &gt; high &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个判断条件有两个问题：</p>
<ol>
<li><strong>错误的不等号方向</strong>：根据二叉搜索树的定义，左子树的所有节点应该<strong>小于</strong>当前节点，右子树的所有节点应该<strong>大于</strong>当前节点。而我使用的条件是检查节点值是否在范围 [low, high] 之内，这与题目要求不符。</li>
<li><strong>没有处理相等的情况</strong>：二叉搜索树不允许出现相等的值。例如，当检查右子树时，所有节点值必须严格大于父节点，而我的判断条件并没有排除等于父节点值的情况。</li>
</ol>
<p>在测试用例 [5,4,6,null,null,3,7] 中，节点 6 的左子节点是 3，这违反了二叉搜索树的性质（6的左子树所有节点都应该大于5且小于6），但我的解法没有正确识别这个错误。</p>
<h2 id="正确解法">正确解法</h2>
<p>经过分析，我改进的解法是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helplerIsValidBST(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helplerIsValidBST</span><span class="params">(node *TreeNode, low, high <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ✓ 修复：使用正确的比较运算符，确保严格大于小于关系</span></span><br><span class="line">    <span class="keyword">if</span> node.Val &lt;= low || node.Val &gt;= high &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> helplerIsValidBST(node.Left, low, node.Val) &amp;&amp; </span><br><span class="line">           helplerIsValidBST(node.Right, node.Val, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这个解法可以工作">为什么这个解法可以工作</h3>
<p>修正后的代码使用了正确的比较运算符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> node.Val &lt;= low || node.Val &gt;= high &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个条件判断的含义是：</p>
<ol>
<li><code>node.Val &lt;= low</code> 检查当前节点值是否小于等于下界，如果是，违反了BST性质</li>
<li><code>node.Val &gt;= high</code> 检查当前节点值是否大于等于上界，如果是，同样违反了BST性质</li>
</ol>
<p>这样，我们确保了：</p>
<ul>
<li>左子树的所有节点值必须<strong>严格小于</strong>当前节点值（通过设置上界为当前节点值）</li>
<li>右子树的所有节点值必须<strong>严格大于</strong>当前节点值（通过设置下界为当前节点值）</li>
<li>整个树的每个节点值都必须严格遵循它的有效范围</li>
</ul>
<p>对于测试用例 [5,4,6,null,null,3,7]：</p>
<ul>
<li>根节点 5 的有效范围是 (-∞, +∞)</li>
<li>节点 4 的有效范围是 (-∞, 5)</li>
<li>节点 6 的有效范围是 (5, +∞)</li>
<li>节点 3 的有效范围是 (5, 6)，但 3 &lt; 5，所以不在有效范围内，返回 false</li>
</ul>
<h2 id="学习总结">学习总结</h2>
<p>通过这个错误，我学到了几个重要的教训：</p>
<ol>
<li><strong>理解问题定义的重要性</strong>：二叉搜索树定义中的&quot;大于&quot;和&quot;小于&quot;是严格的不等关系，不包含等于的情况。</li>
<li><strong>边界条件处理</strong>：在处理比较关系时，要特别注意是使用严格不等式（&lt; 和 &gt;）还是非严格不等式（&lt;= 和 &gt;=）。</li>
<li><strong>递归边界的设置</strong>：在递归检查二叉搜索树时，通过合适的上下界设置是确保正确性的关键。</li>
<li><strong>测试用例分析</strong>：特殊结构的测试用例（如包含特定路径上的值）可以帮助发现算法中的缺陷。</li>
</ol>
<p>这个错误提醒我在实现算法时要仔细审题，特别是对于有特定定义的数据结构，要确保实现符合其精确定义。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>深度优先搜索</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
      </tags>
  </entry>
  <entry>
    <title>❌ LeetCode 543 - 二叉树的直径</title>
    <url>/2025/04/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-543-Binary-Tree-Diameter/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一棵二叉树的根节点，返回该树的<strong>直径</strong>。</p>
<p>二叉树的<strong>直径</strong>是指树中任意两个节点之间最长路径的<strong>长度</strong>。这条路径可能经过也可能不经过根节点 root。</p>
<p>两节点之间路径的<strong>长度</strong>由它们之间边数表示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p><strong>输入：</strong> root = [1,2,3,4,5]<br>
<strong>输出：</strong> 3<br>
<strong>解释：</strong> 直径为 3，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>输入：</strong> root = [1,2]<br>
<strong>输出：</strong> 1</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 [1, 10^4] 内</li>
<li>-100 &lt;= Node.val &lt;= 100</li>
</ul>
<h2 id="错误解法与分析">错误解法与分析</h2>
<p>我最初对这个问题的理解是计算树的高度，而没有考虑到直径的特殊性质。我的初始思路是通过计算树的最大深度来解决问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误思路：仅计算树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    leftHeight := maxDepth(root.Left)</span><br><span class="line">    rightHeight := maxDepth(root.Right)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> leftHeight + rightHeight <span class="comment">// 错误：没有与当前已知最大直径做比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法在以下情况下失败：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line">     / \</span><br><span class="line">    6   7</span><br></pre></td></tr></table></figure>
<h3 id="错误原因分析">错误原因分析</h3>
<p>我的错误在于：</p>
<ol>
<li><strong>没有理解直径的完整定义</strong>：直径是树中任意两个节点之间的最长路径，这不一定穿过根节点。</li>
<li><strong>只计算了根节点的最大深度</strong>：我只计算了从根节点出发的左右子树深度和，但没有考虑到直径可能完全存在于左子树或右子树中。</li>
<li><strong>缺乏全局视角</strong>：没有在递归过程中维护全局的最大直径值，导致无法比较不同子树中可能的直径。</li>
</ol>
<p>最关键的错误是没有认识到：<strong>每个节点都可能是直径路径的&quot;拐点&quot;</strong>，需要比较所有可能的路径长度来找到最大直径。</p>
<h2 id="正确解法">正确解法</h2>
<p>经过分析，改进的解法是使用深度优先搜索（DFS），在递归计算每个节点的高度的同时，更新全局最大直径值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    dfsDiameterOfBinaryTree(root, &amp;res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsDiameterOfBinaryTree</span><span class="params">(node *TreeNode, res *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 递归计算左右子树的深度</span></span><br><span class="line">    leftDepth := dfsDiameterOfBinaryTree(node.Left, res)</span><br><span class="line">    rightDepth := dfsDiameterOfBinaryTree(node.Right, res)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 更新全局最大直径（左子树深度 + 右子树深度）</span></span><br><span class="line">    *res = max(*res, leftDepth + rightDepth)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回当前节点为根的子树的最大深度</span></span><br><span class="line">    <span class="keyword">return</span> max(leftDepth, rightDepth) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么这个解法可以工作">为什么这个解法可以工作</h3>
<ol>
<li><strong>使用DFS计算深度</strong>：通过深度优先搜索，我们可以计算每个节点的左右子树深度。</li>
<li><strong>全局变量记录最大直径</strong>：使用指针 <code>res</code> 在递归过程中持续更新最大直径值。</li>
<li><strong>比较每个可能的&quot;拐点&quot;</strong>：对于每个节点，我们计算:
<ul>
<li>当前节点作为&quot;拐点&quot;的路径长度 = 左子树深度 + 右子树深度</li>
<li>将这个值与已知的最大直径比较并更新</li>
</ul>
</li>
</ol>
<p>这种方法能够考虑到所有可能的路径，包括不经过根节点的路径，从而找到真正的最大直径。</p>
<h2 id="算法可视化">算法可视化</h2>
<p>考虑下面的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>执行过程如下：</p>
<ol>
<li>从根节点 1 开始DFS</li>
<li>计算节点 2 的深度:
<ul>
<li>节点 4 深度 = 1</li>
<li>节点 5 深度 = 1</li>
<li>节点 2 的左右子树最大深度和 = 1 + 1 = 2</li>
<li>更新最大直径 res = 2</li>
</ul>
</li>
<li>计算节点 3 的深度:
<ul>
<li>节点 3 没有子节点，深度 = 1</li>
</ul>
</li>
<li>根节点 1 的左右子树最大深度和 = 2 + 1 = 3
<ul>
<li>更新最大直径 res = 3</li>
</ul>
</li>
</ol>
<p>最终返回最大直径 3，对应路径 [4,2,1,3] 或 [5,2,1,3]。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是树中的节点数。每个节点只被访问一次。</li>
<li><strong>空间复杂度</strong>：O(h)，其中 h 是树的高度。在最坏情况下（树呈线性），空间复杂度为 O(n)。</li>
</ul>
<h2 id="学习总结">学习总结</h2>
<p>通过这道题，我学到了以下几点：</p>
<ol>
<li><strong>树的直径特性</strong>：树的直径不一定经过根节点，可能存在于任意子树中。</li>
<li><strong>DFS的巧妙应用</strong>：在计算节点高度的同时，可以顺便解决其它问题。</li>
<li><strong>全局变量在递归中的使用</strong>：通过传递指针，在递归过程中维护全局状态。</li>
<li><strong>问题转化思想</strong>：将直径问题转化为&quot;以每个节点为拐点的最长路径&quot;问题。</li>
</ol>
<p>这个问题提醒我，在解决树相关问题时，要注意考虑可能的路径是否需要经过根节点，以及如何在递归过程中高效地收集和更新全局信息。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>深度优先搜索</tag>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>❌错题集</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB的数据页</title>
    <url>/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="InnoDB-是如何存储数据？">InnoDB 是如何存储数据？</h2>
<p>InnoDB 的记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p>数据库的 I/O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>数据页包括七个部分，结构如下图：</p>
<p><img src="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/1745856192760.png" alt="1745856192760"></p>
<p>这七个部分的作用如下表:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Header（文件头）</td>
<td>38 B</td>
<td>存储页的元数据信息，如页号、校验和等</td>
</tr>
<tr>
<td>Page Header（页头）</td>
<td>56 B</td>
<td>存储页的状态信息，如记录数、空闲空间等</td>
</tr>
<tr>
<td>Infimum &amp; Supremum（最小/最大记录）</td>
<td>26 B</td>
<td>两条虚拟记录，分别代表页内最小和最大记录</td>
</tr>
<tr>
<td>User Records（用户记录）</td>
<td>不定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space（空闲空间）</td>
<td>不定</td>
<td>尚未被使用的空间，用于插入新记录</td>
</tr>
<tr>
<td>Page Directory（页目录）</td>
<td>不定</td>
<td>存储用户记录的相对位置，便于快速定位记录</td>
</tr>
<tr>
<td>File Trailer（文件尾）</td>
<td>8 B</td>
<td>用于校验页的完整性</td>
</tr>
</tbody>
</table>
<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，链接起来的页相当于一个双向的链表，如下图：</p>
<p><img src="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/1745856807064.png" alt="1745856807064"></p>
<p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p>
<hr>
<p>数据页的主要作用是存储记录，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。</p>
<p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p>
<p>页目录与记录的关系如下图：</p>
<p><img src="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/1745856959162.png" alt="1745856959162"></p>
<p>页目录的创建过程如下:</p>
<ol>
<li>将所有的纪录划分为几组，这些记录包括<strong>最小记录</strong>和<strong>最大记录</strong>，但是不包括标记为<strong>已删除</strong>的记录</li>
<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 <code>n_owned</code>字段（也就是上图中的粉红色字段）</li>
<li>页目录的作用是加快在数据页中查找记录的速度。它的实现方式是：将每一组的最后一条记录的地址（准确来说是该记录在数据页中的偏移量）保存下来，这些地址偏移量会按照记录在数据页中的顺序依次排列。每一个偏移量被称为一个“槽”（slot），可以理解为一个指针，指向对应组的最后一条记录。这样，当我们需要查找某条记录时，可以先通过页目录快速定位到可能所在的记录组，然后在该组内进行遍历查找，大大减少了需要遍历的记录数量，提高了查找效率。页目录本身通常存储在数据页的尾部，随着用户记录的插入和删除，页目录中的槽数量和内容也会动态变化。</li>
</ol>
<p>从图中可以看到，页目录就是由多个槽组成的，槽相当于分组记录的索引。然后，因为记录是按照「主键值」从小到大排序的，所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽(哪个记录分组),定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小纪录开始遍历整个页中的记录链表。</p>
<p>以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：</p>
<ul>
<li>先二分得出槽中间位是 (0+4)/2=2，2 号槽里最大的记录为 8。因为 11 &gt; 8，所以需要从 2 号槽后继续搜索记录；</li>
<li>再使用二分搜索出 2 号和 4 号槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 &lt; 12，所以主键为 11 的记录在 3 号槽里；</li>
<li>这里有个问题，<strong>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</strong>？比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。</li>
</ul>
<p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p>
<p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p>
<ul>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ul>
<h2 id="B-树的查询方式">B+树的查询方式</h2>
<p>上面我们说的都是在一个数据页内查找记录，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号(槽号)存储到页目录，使其起到索引作用，通过二分查找到方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p>
<p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时候我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p>
<p>为了解决这个问题，InnoDB 采用了 B+ 树的结构来存储记录。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更加倾向于采用矮胖的&quot;B+树&quot;结构，这样就可以大大减少磁盘的 I/O 操作次数，而且 B+树更加适合进行关键字的范围查询</p>
<p>InnoDB 中的 B+树中的每一个节点都是一个数据页，结构示意如下:</p>
<p><img src="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/1745913438020.png" alt="1745913438020"></p>
<p>通过上图，我们看出 B+ 树的特点：</p>
<ul>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<p>我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p>
<ul>
<li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7) 范围之间，所以到页 30 中查找更详细的目录项；</li>
<li>在非叶子节点（页 30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页 16）查找记录；</li>
<li>接着，在叶子节点（页 16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li>
</ul>
<p>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p>
<h2 id="聚簇索引和二级索引">聚簇索引和二级索引</h2>
<p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p>
<ul>
<li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li>
<li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p>
<p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li>
</ul>
<p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p>
<p>二级索引的 B+ 树如下图，数据部分为主键值：</p>
<p><img src="/2025/04/28/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/InnoDB%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5/1745913985845.png" alt="1745913985845"></p>
<p>因此，<strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p>
<h2 id="总结">总结</h2>
<p>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p>
<p>数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p>
<p>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</p>
<p>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p>
<p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
        <tag>索引</tag>
        <tag>数据页</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101 - 对称二叉树（Symmetric Tree）</title>
    <url>/2025/04/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-101-Symmetric-Tree/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个二叉树的根节点 <code>root</code>，检查它是否轴对称。</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>输入：<code>root = [1,2,2,3,4,4,3]</code><br>
输出：<code>true</code></p>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>输入：<code>root = [1,2,2,null,3,null,3]</code><br>
输出：<code>false</code></p>
<h3 id="提示：">提示：</h3>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶</strong>：你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h2 id="解题思路">解题思路</h2>
<p>对于二叉树的对称性问题，本质上是判断二叉树的左子树和右子树是否互为镜像。两个树互为镜像当且仅当：</p>
<ol>
<li>它们的根节点的值相等</li>
<li>每个树的左子树和另一个树的右子树互为镜像</li>
<li>每个树的右子树和另一个树的左子树互为镜像</li>
</ol>
<p>这个问题可以通过两种方式解决：<strong>递归</strong>和<strong>迭代</strong>。</p>
<h3 id="方法一：递归">方法一：递归</h3>
<p>递归方法的核心思想是以递归的方式检查树的对称性。我们定义一个辅助函数，同时遍历左子树和右子树，进行必要的对称比较。</p>
<p><strong>递归步骤</strong>：</p>
<ol>
<li>如果左节点和右节点都为空，返回 <code>true</code></li>
<li>如果只有一个节点为空，返回 <code>false</code></li>
<li>如果两个节点的值不相等，返回 <code>false</code></li>
<li>递归检查：
<ul>
<li>左节点的左子树与右节点的右子树是否对称</li>
<li>左节点的右子树与右节点的左子树是否对称</li>
</ul>
</li>
</ol>
<h3 id="方法二：迭代（使用队列）">方法二：迭代（使用队列）</h3>
<p>迭代方法使用队列来模拟递归过程。我们将需要比较的节点对依次放入队列，然后逐对取出进行比较。</p>
<p><strong>迭代步骤</strong>：</p>
<ol>
<li>初始化队列，放入根节点的左子节点和右子节点</li>
<li>当队列不为空时：
<ul>
<li>取出两个节点</li>
<li>如果都为空，继续下一轮循环</li>
<li>如果只有一个为空或值不相等，返回 <code>false</code></li>
<li>将左节点的左子节点和右节点的右子节点放入队列</li>
<li>将左节点的右子节点和右节点的左子节点放入队列</li>
</ul>
</li>
<li>队列为空时，返回 <code>true</code></li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="递归实现">递归实现</h3>
<p>在递归实现中，我们定义了一个辅助函数 <code>dfsIsSymmetric</code>，用于检查两个节点是否对称：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 特殊情况处理：如果根节点为空，则树是对称的</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用辅助函数检查左右子树是否对称</span></span><br><span class="line">    <span class="keyword">return</span> dfsIsSymmetric(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsIsSymmetric</span><span class="params">(left, right *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果两个节点都为空，则对称</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果一个节点为空而另一个不为空，则不对称</span></span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果两个节点的值不相等，则不对称</span></span><br><span class="line">    <span class="keyword">if</span> left.Val != right.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 递归检查：左的左与右的右对称，且左的右与右的左对称</span></span><br><span class="line">    <span class="keyword">return</span> dfsIsSymmetric(left.Left, right.Right) &amp;&amp; dfsIsSymmetric(left.Right, right.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代实现">迭代实现</h3>
<p>以下是使用队列的迭代实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用队列进行BFS</span></span><br><span class="line">    queue := []*TreeNode&#123;root.Left, root.Right&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 每次取出两个节点进行比较</span></span><br><span class="line">        left := queue[<span class="number">0</span>]</span><br><span class="line">        right := queue[<span class="number">1</span>]</span><br><span class="line">        queue = queue[<span class="number">2</span>:]</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 两个节点都为空，对称</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 一个为空，另一个不为空，或值不相等，不对称</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> || left.Val != right.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 将需要比较的节点对放入队列：左的左与右的右，左的右与右的左</span></span><br><span class="line">        queue = <span class="built_in">append</span>(queue, left.Left, right.Right)</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, left.Right, right.Left)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>递归方法</th>
<th>迭代方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(h)，h是树的高度</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>代码简洁，易于理解</td>
<td>避免递归栈溢出风险</td>
</tr>
<tr>
<td>缺点</td>
<td>可能导致栈溢出</td>
<td>代码相对复杂</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★★☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<p><strong>时间复杂度</strong>：两种方法都是 O(n)，其中 n 是树中节点的数量。我们需要遍历树中的每个节点，对每个节点执行常数级操作。</p>
<p><strong>空间复杂度</strong>：</p>
<ul>
<li>递归方法：O(h)，其中 h 是树的高度。在最坏情况下（树是一条链），空间复杂度为 O(n)。</li>
<li>迭代方法：O(n)，队列中最多包含树中的所有节点。</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>二叉树的镜像特性</strong>：理解如何判断两个树是否互为镜像是解决此类问题的关键。</li>
<li><strong>递归与迭代的转换</strong>：这道题展示了如何将递归算法转换为迭代算法，这是一种重要的技术。</li>
<li><strong>深度优先搜索（DFS）与广度优先搜索（BFS）</strong>：递归实现使用DFS，而队列实现使用BFS。</li>
</ol>
<p>对于初学者，建议先理解递归解法，因为它更直观。掌握后，再尝试理解如何使用队列的迭代方法实现相同的功能。这种转换思路在许多树和图的问题中都非常有用。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>Easy</tag>
        <tag>Hot100</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 146 - LRU 缓存</title>
    <url>/2025/04/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-146-LRU-Cache/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> - 以正整数作为容量 capacity 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> - 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1。</li>
<li><code>void put(int key, int value)</code> - 如果关键字 key 已经存在，则变更其数据值 value；如果不存在，则向缓存中插入该组 key-value。如果插入操作导致关键字数量超过 capacity，则应该逐出最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <strong>O(1)</strong> 的平均时间复杂度运行。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);  // 缓存容量为 2</span><br><span class="line">lRUCache.put(1, 1);                    // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2);                    // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);                       // 返回 1</span><br><span class="line">lRUCache.put(3, 3);                    // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);                       // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4);                    // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);                       // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);                       // 返回 3</span><br><span class="line">lRUCache.get(4);                       // 返回 4</span><br></pre></td></tr></table></figure>
<p><strong>约束</strong>:</p>
<ul>
<li>1 &lt;= capacity &lt;= 3000</li>
<li>0 &lt;= key &lt;= 10000</li>
<li>0 &lt;= value &lt;= 10^5</li>
<li>最多调用 2 * 10^5 次 get 和 put</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>LRU (Least Recently Used) 缓存是一种常见的缓存淘汰策略，它基于&quot;最近最少使用&quot;的原则来管理缓存空间。要实现 LRU 缓存，我们需要两个核心数据结构：</p>
<ol>
<li><strong>哈希表</strong>：用于 O(1) 时间复杂度查找键值对</li>
<li><strong>双向链表</strong>：用于维护缓存项的使用顺序</li>
</ol>
<p><strong>关键思路</strong>：</p>
<ul>
<li>双向链表按照使用顺序存储缓存项，链表头部是最近使用的，尾部是最久未使用的</li>
<li>哈希表以 key 为键，链表节点为值，用于快速定位链表中的节点</li>
<li>每当缓存被访问（get 或 put 操作），将对应节点移动到链表头部</li>
<li>当缓存满时，移除链表尾部的节点（最久未使用的项）</li>
</ul>
<p>下面是 LRU 缓存操作的流程图示意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 双向链表（使用顺序从左到右：最近使用 → 最久未使用）</span><br><span class="line">┌───────────────────────────────────────────────┐</span><br><span class="line">│  HEAD ↔ Node1 ↔ Node2 ↔ ... ↔ NodeN ↔ TAIL    │</span><br><span class="line">└───────────────────────────────────────────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">      │ 快速定位</span><br><span class="line">┌─────┴─────┐</span><br><span class="line">│  HashMap  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure>
<h2 id="实现细节">实现细节</h2>
<p>我们使用 Golang 实现 LRU 缓存，主要包含以下步骤：</p>
<ol>
<li>定义双向链表节点结构 <code>DLinkedNode</code>，包含 key、value 和指向前后节点的指针</li>
<li>定义 LRU 缓存结构 <code>LRUCache</code>，包含容量、大小、哈希表和双向链表的头尾节点</li>
<li>实现 <code>Constructor</code> 函数初始化 LRU 缓存</li>
<li>实现 <code>Get</code> 方法按键获取值并更新使用顺序</li>
<li>实现 <code>Put</code> 方法添加或更新键值对，并在必要时淘汰最久未使用的项</li>
</ol>
<p>关键实现细节：</p>
<ul>
<li>使用哈希表（map）存储 key 到节点的映射，实现 O(1) 查找</li>
<li>双向链表用于追踪元素的使用顺序，新节点或被访问的节点移到链表头部</li>
<li>创建两个伪节点（head 和 tail）简化边界情况处理</li>
<li>每次访问节点（Get 或 Put 操作）时，将节点移到链表头部</li>
<li>当缓存满时，移除链表尾部的节点（最久未使用的项）</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<p>下面是完整的 Golang 实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	key, value <span class="type">int</span></span><br><span class="line">	prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	capacity   <span class="type">int</span></span><br><span class="line">	size       <span class="type">int</span></span><br><span class="line">	cache      <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">	head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">	tmp := LRUCache&#123;</span><br><span class="line">		capacity: capacity,</span><br><span class="line">		size:     <span class="number">0</span>,</span><br><span class="line">		cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode),</span><br><span class="line">		head:     &amp;DLinkedNode&#123;&#125;,</span><br><span class="line">		tail:     &amp;DLinkedNode&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	tmp.head.next = tmp.tail</span><br><span class="line">	tmp.tail.prev = tmp.head</span><br><span class="line">	<span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 找不到就返回-1</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到就把这个cache更新到首部</span></span><br><span class="line">	cur := this.cache[key]</span><br><span class="line">	cur.prev.next = cur.next</span><br><span class="line">	cur.next.prev = cur.prev</span><br><span class="line">	cur.next = this.head.next</span><br><span class="line">	cur.prev = this.head</span><br><span class="line">	this.head.next.prev = cur</span><br><span class="line">	this.head.next = cur</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cur.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 有就直接更新</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := this.cache[key]; ok &#123;</span><br><span class="line">		cur := this.cache[key]</span><br><span class="line">		<span class="comment">// 断掉和之前位置的链接</span></span><br><span class="line">		cur.prev.next = cur.next</span><br><span class="line">		cur.next.prev = cur.prev</span><br><span class="line">		<span class="comment">// 连上新的位置</span></span><br><span class="line">		cur.next = this.head.next</span><br><span class="line">		cur.prev = this.head</span><br><span class="line">		this.head.next.prev = cur</span><br><span class="line">		this.head.next = cur</span><br><span class="line">		cur.value = value</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur := &amp;DLinkedNode&#123;</span><br><span class="line">		key:   key,</span><br><span class="line">		value: value,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> this.size &gt;= this.capacity &#123;</span><br><span class="line">		lastElement := this.tail.prev</span><br><span class="line">		lastElement.prev.next = lastElement.next</span><br><span class="line">		lastElement.next.prev = lastElement.prev</span><br><span class="line">		<span class="built_in">delete</span>(this.cache, lastElement.key)</span><br><span class="line">		this.size--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cur.next = this.head.next</span><br><span class="line">	cur.prev = this.head</span><br><span class="line">	this.head.next.prev = cur</span><br><span class="line">	this.head.next = cur</span><br><span class="line"></span><br><span class="line">	this.cache[key] = cur</span><br><span class="line">	this.size++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li><code>Get</code> 操作：O(1)，哈希表查找是 O(1)，移动节点到链表头部也是 O(1)</li>
<li><code>Put</code> 操作：O(1)，哈希表查找/插入是 O(1)，链表操作也是 O(1)</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：O(capacity)，存储 capacity 个键值对需要 O(capacity) 的空间</p>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<p>通过实现 LRU 缓存，我们学习了以下重要概念：</p>
<ol>
<li><strong>数据结构组合</strong>：哈希表和双向链表的组合可以创建高效的缓存机制</li>
<li><strong>缓存淘汰策略</strong>：LRU（最近最少使用）是一种常见且有效的缓存淘汰策略</li>
<li><strong>双向链表的应用</strong>：双向链表适合需要频繁在任意位置插入和删除的场景</li>
<li><strong>边界情况处理</strong>：使用伪头尾节点（dummy head/tail）可以简化链表操作</li>
</ol>
<p>LRU 缓存在实际应用中非常广泛，比如：</p>
<ul>
<li>浏览器的缓存管理</li>
<li>数据库的缓存层</li>
<li>操作系统的页面置换算法</li>
<li>分布式缓存系统（如 Redis）中的淘汰策略</li>
</ul>
<p>这种设计思想和实现技巧在许多系统设计问题中都有应用。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hot100</tag>
        <tag>哈希</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引简介</title>
    <url>/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="什么是索引？">什么是索引？</h2>
<p>索引是数据库中用于提高查询效率的数据结构，类似于书籍的目录，帮助数据库系统快速定位和访问数据。合理的索引设计可以显著提升查询性能，减少资源消耗。</p>
<h2 id="索引的分类">索引的分类</h2>
<h3 id="按数据结构分类">按数据结构分类</h3>
<ul>
<li><strong>B+tree 索引</strong>：MySQL 默认索引类型，适用于范围查询和排序</li>
<li><strong>Hash 索引</strong>：适合等值查询，不支持范围查询和排序</li>
<li><strong>Full-text 索引</strong>：用于全文搜索，支持复杂文本查询</li>
</ul>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745568387988.png" alt="1745568387988"></p>
<h4 id="B-tree-索引-InnoDB-默认索引类型">B+tree 索引(InnoDB 默认索引类型)</h4>
<p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li>
</ul>
<p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p>
<p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是<strong>按主键顺序存放</strong>的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。</p>
<p>举个例子，先创建一张商品表，id 为主键，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `product`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `product_no` <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">CHARACTER SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>
<p>商品表里，有这些行数据：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745570126359.png" alt="1745570126359"></p>
<p>主键索引的 B+Tree 如图所示(图中画的叶子节点用单向链表连接，但是有问题，实际上其实是一个 <code>&lt;font color=&quot;red&quot;&gt;</code>双向链表 <code>&lt;/font&gt;</code>)：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745570433361.png" alt="1745570433361"></p>
<h5 id="通过主键查询数据的过程">通过主键查询数据的过程</h5>
<p>比如我们执行了下面这条 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：</p>
<ul>
<li>将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree 的搜索逻辑，找到第二层的索引数据 (1，4，7)；</li>
<li>在第二层的索引数据 (1，4，7) 中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；</li>
<li>在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。</li>
</ul>
<p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。</p>
<p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4 次。</strong></p>
<h5 id="通过二级索引查询数据的过程">通过二级索引查询数据的过程</h5>
<blockquote>
<p>主键索引的 B+Tree 和二级索引的 B+Tree 的主要区别在于：</p>
<ul>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据</li>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值</li>
</ul>
</blockquote>
<p>假设我们将先前的商品表的 <code>product_no</code> 字段创建一个二级索引，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_product_no <span class="keyword">ON</span> product(product_no);</span><br></pre></td></tr></table></figure>
<p>那么，二级索引的 B+Tree 如图所示(图中画的叶子节点用单向链表连接，但是有问题，实际上其实是一个 <code>&lt;font color=&quot;red&quot;&gt;</code>双向链表 <code>&lt;/font&gt;</code>)：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745671468072.png" alt="1745671468072"></p>
<p>其中非叶子节点的 <code>key</code>值是 <code>product_no</code>(图中橙色部分),叶子节点存储的数据是 <code>主键值</code>(图中绿色部分)</p>
<p>如果我用 <code>product_no</code>二级索引查询，如下查询语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面的语句可以先检查二级索引中的 B+Tree 的索引值 <code>product_no</code>，找到对应的叶子节点，获取到主键值，然后拿着主键值去主键索引的 B+Tree 中查找，获取到完整的数据行。这个过程就叫做<strong>回表</strong>，也就是说要查两个 B+Tree 才能查到数据，如图所示(图中画的叶子节点用单向链表连接，但是有问题，实际上其实是一个 <code>&lt;font color=&quot;red&quot;&gt;</code>双向链表 <code>&lt;/font&gt;</code>)。</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745680784703.png" alt="1745680784703"></p>
<hr>
<p>不过，如果我执行的查询语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>那么，因为二级索引的叶子节点存储的是主键值，所以其实只需要查一个 B+Tree 就可以获取到数据，那就可以避免回表，这个过程就叫做<strong>覆盖索引</strong>，也就是只需要查一个 B+Tree 就可以获取到数据。</p>
<blockquote>
<p>因此，有时候我们可以利用覆盖索引，来避免回表，从而提高查询效率，比如对经常需要查询的列和查询条件建立联合索引，就可以利用覆盖索引，从而提高查询效率。</p>
</blockquote>
<h5 id="为什么-InnoDB-存储引擎选择使用-B-Tree-作为索引的数据结构？">为什么 InnoDB 存储引擎选择使用 B+Tree 作为索引的数据结构？</h5>
<p>前面已经讲了 B+Tree 的索引原理，现在就来回答一下 B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势在哪儿？</p>
<p><strong><em>1、B+Tree vs B Tree</em></strong></p>
<p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</p>
<p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p>
<p><strong><em>2、B+Tree vs 二叉树</em></strong></p>
<p>对于存储了 M 条数据记录的 B+Tree（其叶子节点数量 N 与 M 相关），其搜索复杂度约为 <code>O(logdN)</code>，其中 d 是节点允许的最大子节点个数（阶数）。</p>
<p>在实际应用中，d 值通常远大于 2（例如大于 100）。这保证了即使数据量 M 达到千万级别，B+Tree 的高度依然能维持在 3~4 层左右。这意味着一次数据查询操作通常只需要 3~4 次磁盘 I/O 即可完成。</p>
<p>相比之下，一个存储相同 M 条数据的平衡二叉搜索树，其节点总数也约为 M，搜索复杂度为 <code>O(logM)</code>（以 2 为底）。由于其分支因子固定为 2，树的高度会显著高于 B+Tree，导致检索目标数据需要经历更多的磁盘 I/O 次数。</p>
<p><strong><em>3, B+Tree vs Hash</em></strong></p>
<p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。但也有其局限性：</p>
<ul>
<li><strong>数据顺序性</strong>：哈希表无法提供数据的顺序访问，更适合做等值的查询。很多查询不仅需要找到特定的键值，还需要根据键值排序来返回结果，或者执行范围查询。B+Tree 可以很好地支持，Hash 表则无法做到。</li>
<li><strong>空间效率</strong>：可能导致空间利用效率不高，特别是在处理大量数据时。数据量变大时冲突也会增加。</li>
<li><strong>需要重新构建</strong>：哈希索引通常只存储在内存中，当数据库重启或发生崩溃时，需要重新构建。</li>
</ul>
<p>因此，B+Tree 索引要比 Hash 表索引有着更广泛的适用场景。</p>
<h4 id="Full-text-索引">Full-text 索引</h4>
<p>Full Text 索引（全文索引）是 MySQL 中专门用于高效处理大文本字段（如文章、描述等）内容检索的一种索引类型。它主要用于在大量文本数据中进行复杂的关键词搜索，支持模糊匹配、相关性排序等功能，远比传统的 LIKE 语句效率高，尤其适合需要全文检索的场景（如搜索引擎、商品描述搜索等）。</p>
<h5 id="工作原理">工作原理</h5>
<p>Full Text 索引通常基于倒排索引（inverted index）实现。倒排索引会将文本内容分词后，建立&quot;单词 → 文档 ID&quot;的映射关系，从而能快速定位包含某个关键词的所有记录。这种结构极大提升了模糊查询和多关键词检索的效率。</p>
<h5 id="主要特性">主要特性</h5>
<ul>
<li>适用于 <code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>等文本类型字段</li>
<li>仅支持 InnoDB 和 MyISAM 存储引擎（MySQL 5.6 及以上 InnoDB 支持）</li>
<li>支持三种检索模式：自然语言模式、布尔模式、查询扩展模式</li>
<li>典型用法：<code>MATCH(column) AGAINST('keyword' IN NATURAL LANGUAGE MODE)</code></li>
</ul>
<h5 id="示例">示例</h5>
<p>创建全文索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX idx_content <span class="keyword">ON</span> articles(content);</span><br></pre></td></tr></table></figure>
<p>使用全文检索：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> articles <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(content) AGAINST(<span class="string">&#x27;数据库 索引&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="参考">参考</h5>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html">MySQL 官方文档：全文索引</a></li>
<li><a href="https://blog.csdn.net/yangbindxj/article/details/122868100">CSDN: MySQL 全文索引用途及基本使用方法介绍</a></li>
</ul>
<p>简而言之，Full Text 索引让 MySQL 能够像搜索引擎一样高效地在大段文本中查找关键词，是处理复杂文本检索的利器。</p>
<h3 id="按物理存储分类">按物理存储分类</h3>
<ul>
<li><strong>聚集索引</strong>：数据和主键索引存储在一起，一个表只能有一个，通常是主键。聚集索引的叶子节点存储的是数据行。</li>
<li><strong>二级索引</strong>：又称非聚集索引，存储索引键和主键值，通过主键再查找数据，可以有多个。非聚集索引的叶子节点存储的是主键值，而不是数据行。</li>
</ul>
<h3 id="按字段特性分类">按字段特性分类</h3>
<ul>
<li>
<p><strong>主键索引</strong>：主键索引是聚集索引（Clustered Index），一个表只能有一个，通常对应主键。其叶子节点直接存储完整的数据行（即数据和索引在一起）。</p>
<p>创建主键索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `table_name` (</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>唯一索引</strong>：唯一索引也是二级索引，要求索引列的值唯一。叶子节点同样存储索引键和主键值，通过主键回表查找数据。</p>
<p>创建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `table_name` (</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_name` (`column1`, `column2`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>或者如果表已经存在，可以通过以下方式创建：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> KEY `idx_name` (`column1`, `column2`);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>普通索引</strong>：普通索引属于二级索引（Secondary/Non-Clustered Index），可以有多个。叶子节点存储的是索引键和主键值（InnoDB），通过主键回表查找完整数据。</p>
<p>创建普通索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `table_name` (</span><br><span class="line">  ...</span><br><span class="line">  INDEX `idx_name` (`column1`, `column2`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>或者如果表已经存在，可以通过以下方式创建：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX `idx_name` (`column1`, `column2`);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>前缀索引</strong>：前缀索引是一种特殊的二级索引，针对字符串类型字段，只索引字段的前 N 个字符。叶子节点存储前缀、主键值，通过主键回表查找数据。</p>
<p>创建前缀索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `table_name` (</span><br><span class="line">  ...</span><br><span class="line">  INDEX `idx_name` (`column_name`(N))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>或者如果表已经存在，可以通过以下方式创建：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX `idx_name` (`column_name`(N));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><strong>补充说明</strong>：</p>
<ul>
<li>InnoDB 存储引擎下，只有主键索引是聚集索引，其他索引（普通、唯一、前缀）都是二级索引，叶子节点都不直接存储完整数据行，而是存储主键值。</li>
<li>二级索引查找数据时需要&quot;回表&quot;，即先通过索引定位主键，再通过主键定位数据行。</li>
</ul>
</blockquote>
<h3 id="按字段个数分类">按字段个数分类</h3>
<ul>
<li><strong>单列索引</strong>：一个索引只包含一个列。</li>
<li><strong>联合索引</strong>：一个索引包含多个列。</li>
</ul>
<h4 id="联合索引">联合索引</h4>
<p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p>
<p>比如，将商品表中的 product_no 和 name 字段组合成联合索引 <code>(product_no, name)</code>，创建联合索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure>
<p>联合索引 <code>(product_no, name)</code> 的 B+Tree 示意图如下：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745724743165.png" alt="1745724743165"></p>
<p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p>
<p>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p>
<p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a=1.</li>
<li>where a=1 and b=2 and c=3.</li>
<li>where a=1 and b=2.</li>
<li>where a=1 and c=3.</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效：</p>
<ul>
<li>where b=2.</li>
<li>where c=3.</li>
<li>where b=2 and c=3.</li>
</ul>
<p>上面这些查询条件之所以会失效，是因为 <code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<p>我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745756546799.png" alt="1745756546799"></p>
<p>可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行 <code>where b = 2</code>这种查询条件没有办法利用联合索引的，<strong>利用索引的前提是索引里的 key 是有序的</strong>。</p>
<p>只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行 <code>where a = 2 and b = 7</code>是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。</p>
<p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p>
<p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
<p>范围查询有很多种，那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？</p>
<p>接下来，举例几个范围查例子。</p>
<ul>
<li>
<p>Q1: <code>select * from t_table where a &gt; 1 and b = 2</code></p>
<p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a &gt; 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a &gt; 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a &gt; 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p>
<p><strong>但是在符合 a &gt; 1 条件的二级索引记录的范围里，b 字段的值是无序的</strong>。比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 a 字段的值都符合 a &gt; 1 查询条件，而 b 字段的值是无序的：</p>
<ul>
<li>a 字段值为 5 的记录，该记录的 b 字段值为 8；</li>
<li>a 字段值为 6 的记录，该记录的 b 字段值为 10；</li>
<li>a 字段值为 7 的记录，该记录的 b 字段值为 5；</li>
</ul>
<p>因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。</p>
<p>所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a &gt; 1，与 b = 2 无关。</p>
<p>因此，<strong>这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p>
<p>我们也可以在执行计划中的 key_len 知道这一点，在使用联合索引进行查询的时候，通过 key_len 我们可以知道优化器具体使用了多少个字段的搜索条件来形成扫描区间的边界条件。</p>
<p>举例个例子，a 和 b 都是 int 类型且不为 NULL 的字段，那么这条查询语句执行计划如下，可以看到 key_len 为 4 字节（如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节），说明只有 a 字段用到了联合索引进行索引查询，而且可以看到，即使 b 字段没用到联合索引，key 为 idx_a_b，说明这条查询语句使用了 idx_a_b 联合索引。</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745756736801.png" alt="1745756736801"></p>
<p>通过这条查询语句我们可以知道，a 字段使用了 &gt; 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ &gt;）后就停止匹配了，因此 b 字段并没有使用到联合索引。</p>
</li>
<li>
<p>Q2: <code>select * from t_table where a &gt;= 1 and b = 2</code></p>
<p>Q2 和 Q1 的查询语句很像，唯一的区别就是 a 字段的查询条件「大于等于」。</p>
<p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 &gt;= 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 &gt;= 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a&gt;= 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p>
<p>虽然在符合 a&gt;= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的</strong>（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。</p>
<p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。</p>
<p>所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
<p>我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745756833265.png" alt="1745756833265"></p>
<p>通过 Q2 查询语句我们可以知道，虽然 a 字段使用了 &gt;= 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ &gt;=）后就停止匹配了，b 字段还是可以用到了联合索引的。</p>
</li>
<li>
<p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code></p>
<p>Q3 查询条件中 <code>a BETWEEN 2 AND 8</code> 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN … AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 &gt;= and =&lt;。而有的数据库则不包含 value1 和 value2 边界值（类似于 &gt; and &lt;）。</p>
<p>这里我们只讨论 MySQL。由于 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，所以类似于 Q2 查询语句，因此 <strong>Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
<p>我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745757708547.png" alt="1745757708547"></p>
<p>通过 Q3 查询语句我们可以知道，虽然 a 字段使用了 BETWEEN 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（BETWEEN）后就停止匹配了，b 字段还是可以用到了联合索引的。</p>
</li>
<li>
<p>Q4: <code>SELECT * FROM t_user WHERE name like 'j%' and age = 22</code></p>
<p>由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为’j’的 name 字段的二级索引记录都是相邻的，于是在进行索引扫描的时候，可以定位到符合前缀为’j’的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为’j’为止。</p>
<p>所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是[‘j’,‘k’)。注意，j 是闭区间。如下图：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745758372073.png" alt="1745758372073"></p>
<p>虽然在符合前缀为’j’的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，<strong>但是对于符合 name = j 的二级索引记录的范围里，age 字段的值是「有序」的</strong>（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）。</p>
<p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为’j’时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 <code>name = 'j' and age = 22</code> 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描。如下图的右边：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745758388661.png" alt="1745758388661"></p>
<p>所以，<strong>Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p>
<p>我们也可以在执行计划中的 key_len 知道这一点。本次例子中：</p>
<ul>
<li>name 字段的类型是 varchar(30) 且不为 NULL，数据库表使用了 utf8mb4 字符集，一个字符集为 utf8mb4 的字符是 4 个字节，因此 name 字段的实际数据最多占用的存储空间长度是 120 字节（30 x 4），然后因为 name 是变长类型的字段，需要再加 2，也就是 name 的 key_len 为 122。</li>
<li>age 字段的类型是 int 且不为 NULL，key_len 为 4。</li>
</ul>
<blockquote>
<p>可能有的同学对于「因为 name 是变长类型的字段，需要再加 2 字节」这句话有疑问。之前这篇文章说「如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示变长字段的长度」，而这里为什么是 2 字节？</p>
<p>key_len 的显示比较特殊，行格式是由 InnoDB 存储引擎实现的，而执行计划是在 server 层生成的，所以它不会去问 InnoDB 存储引擎可变字段的长度占用多少字节，而是不管三七二十一都使用 2 字节表示可变字段的长度。毕竟 key_len 的目的只是为了告诉你索引查询中用了哪些索引字段，而不是为了准确告诉这个字段占用多少字节空间。</p>
</blockquote>
<p>Q4 查询语句的执行计划如下，可以看到 key_len 为 126 字节，name 的 key_len 为 122，age 的 key_len 为 4，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 name 和 age 字段都用到了联合索引进行索引查询。</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745759125926.png" alt="1745759125926"></p>
<p>通过 Q4 查询语句我们可以知道，虽然 name 字段使用了 like 前缀匹配进行范围查询，但是联合索引的最左匹配原则并没有在遇到 name 字段的范围查询（like ‘j%’）后就停止匹配了，age 字段还是可以用到了联合索引的。</p>
<p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了</strong>。</p>
</li>
</ul>
<h4 id="索引下推">索引下推</h4>
<p>我们来举个例子，假设有一个联合索引 (a, b)，现在执行这样一条 SQL：<code>select * from table where a &gt; 1 and b = 2</code>。这时候，MySQL 会先用 a &gt; 1 这个条件在联合索引的 B+Tree 上定位到第一个符合条件的主键（比如 ID=2）。但是，b = 2 这个条件要怎么判断呢？是在索引里判断，还是要回表（到主键索引）去判断？</p>
<ul>
<li>在 MySQL 5.6 之前，MySQL 只能先通过索引找到所有 a &gt; 1 的主键值，然后每找到一条记录都要回表（到主键索引）去把整行数据取出来，再判断 b 是否等于 2。这样如果 a &gt; 1 的数据很多，回表次数就会很多，效率比较低。</li>
<li>从 MySQL 5.6 开始，引入了<strong>索引下推优化</strong>（Index Condition Pushdown，简称 ICP）。有了这个优化后，MySQL 在遍历联合索引的时候，就可以直接在索引里判断 b = 2 这个条件。只有当 a &gt; 1 并且 b = 2 都满足时，才会回表取出整行数据。这样可以大大减少回表的次数，提高查询效率。</li>
</ul>
<p>你可以在执行计划（explain）里看到 Extra 字段显示 <code>Using index condition</code>，这就说明 MySQL 用上了索引下推优化。</p>
<h4 id="索引区分度">索引区分度</h4>
<p>建立联合索引时的字段顺序对索引的效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立索引的时候，要把区分度搞的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</p>
<blockquote>
<p>区分度：某个字段 <code>column</code>不同值的个数除以表的总行数，计算公式如下:</p>
<p>$$<br>
区分度=\frac{distinct(column)}{count(*)}<br>
$$</p>
<p>比如性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 <code>UUID</code>这类字段就比较适合做索引或排在联合索引的靠前的位置</p>
<p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是&quot;30%&quot;）很高的时候，它一般会忽略索引，进行全表扫描。</p>
</blockquote>
<h4 id="联合索引进行排序">联合索引进行排序</h4>
<p>比如针对下面这个 SQL 语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<p>在实际开发中，如果我们的查询语句既有筛选条件（如 where status = 1），又有排序需求（如 order by create_time asc），那么在为表设计索引时，应该优先考虑建立联合索引。例如，可以为 status 和 create_time 两个字段一起建立联合索引 (status, create_time)。</p>
<blockquote>
<p>这里能不能建立为 (create_time, status) 联合索引？</p>
<p>答: 不推荐这样做，原因如下：</p>
<ol>
<li><strong>无法有效利用索引进行过滤</strong>：联合索引 <code>(create_time, status)</code> 是先按 <code>create_time</code> 排序，再按 <code>status</code> 排序。对于查询 <code>where status = 1</code>，由于 <code>status</code> 是索引的第二个字段，不符合最左前缀原则，MySQL 无法直接利用该索引快速定位 <code>status=1</code> 的记录，可能导致需要扫描大量索引数据甚至全表扫描。</li>
<li><strong>排序优化受限</strong>：虽然索引的第一列是 <code>create_time</code>，看似能满足 <code>order by create_time</code>，但前提是 <code>where</code> 条件能有效利用索引。如果 <code>where status = 1</code> 无法有效过滤，那么即使索引本身按 <code>create_time</code> 有序，优化器也可能无法避免额外的排序操作（filesort），因为需要先筛选出 <code>status=1</code> 的数据。</li>
</ol>
<p>而 <code>(status, create_time)</code> 索引则能完美匹配该查询：</p>
<ul>
<li><code>where status = 1</code> 可以利用索引的第一列快速定位数据。</li>
<li>在 <code>status=1</code> 的记录内部，数据已按 <code>create_time</code> 有序，<code>order by create_time</code> 可以直接利用索引顺序，避免 filesort。</li>
</ul>
</blockquote>
<p>这样做的原因是：MySQL 的联合索引本身是有序的，先按照 status 排序，再按照 create_time 排序。当我们执行上述 SQL 时，MySQL 可以直接利用联合索引，先根据 status 过滤数据，再按照 create_time 顺序返回结果，无需额外的排序操作。</p>
<p>如果只为 status 单独建索引，虽然可以加速 status 的过滤，但由于 create_time 没有参与索引，MySQL 还需要对筛选后的结果进行额外的排序（即 filesort），这会影响查询效率。</p>
<p>因此，合理设计联合索引，既能满足筛选条件，又能覆盖排序字段，可以充分发挥索引的有序性，避免不必要的文件排序操作，从而提升查询性能。</p>
<h2 id="索引的适用场景与注意事项">索引的适用场景与注意事项</h2>
<p>虽然索引能显著<strong>提高查询速度</strong>，但并非没有代价。创建和使用索引需要考虑以下几点：</p>
<ul>
<li><strong>空间成本</strong>：索引需要占用物理存储空间，索引越多、越大，占用的空间就越多。</li>
<li><strong>时间成本</strong>：创建和维护索引（尤其是在数据量大时）需要时间。</li>
<li><strong>维护成本</strong>：对表进行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>操作时，数据库需要<strong>同步更新索引</strong>以维持其有序性（如 B+Tree 的动态维护），这会<strong>降低数据修改操作的效率</strong>。</li>
</ul>
<p>因此，是否创建索引需要根据具体应用场景权衡利弊。</p>
<h4 id="什么时候建议创建索引？">什么时候建议创建索引？</h4>
<ul>
<li><strong>唯一性约束的字段</strong>：如主键、唯一键（UNIQUE KEY），数据库通常会自动为这些约束创建索引，以保证数据的唯一性并加速查找。例如商品编码。</li>
<li><strong>经常作为查询条件的字段</strong>：频繁出现在 <code>WHERE</code> 子句中的字段适合创建索引，以加速数据筛选。如果查询条件涉及多个字段，可以考虑创建<strong>联合索引</strong>。</li>
<li><strong>经常用于排序和分组的字段</strong>：频繁出现在 <code>ORDER BY</code> 或 <code>GROUP BY</code> 子句中的字段。利用索引的有序性，可以避免额外的排序操作（filesort），提高查询效率。</li>
</ul>
<h4 id="什么时候不建议创建索引（或需谨慎）？">什么时候不建议创建索引（或需谨慎）？</h4>
<ul>
<li><strong>不用于查询、排序、分组的字段</strong>：如果一个字段从未或很少在 <code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 中使用，那么为其创建索引通常是浪费空间和维护资源。</li>
<li><strong>区分度低的字段（低基数/低选择性）</strong>：字段中包含大量重复值时（即<strong>区分度</strong>很低，如性别字段）。即使为这类字段创建索引，查询优化器也可能因为扫描索引的成本接近全表扫描而选择<strong>放弃使用索引</strong>。例如，如果性别字段的值均匀分布，查询 <code>WHERE gender = 'male'</code> 可能会匹配接近一半的数据行，此时全表扫描可能更优。（这与前面提到的“索引区分度”概念相关）</li>
<li><strong>数据量过小的表</strong>：对于行数很少的表，全表扫描的速度可能已经足够快，甚至比通过索引查找更快，此时创建索引意义不大。</li>
<li><strong>频繁更新的字段</strong>：经常被修改的字段不适合创建索引。例如，电商系统中的用户余额字段，频繁的更新会导致索引树频繁调整，严重影响数据库的写入性能。</li>
</ul>
<h2 id="索引优化方法">索引优化方法</h2>
<p>索引优化主要有以下几种方法：</p>
<ol>
<li>前缀索引优化</li>
<li>覆盖索引优化</li>
<li>主键索引最好使用自增 ID</li>
<li>索引最好设置为 <code>NOT NULL</code></li>
<li>防止索引失效</li>
</ol>
<h3 id="前缀索引优化">前缀索引优化</h3>
<p>前缀索引其实就是使用某个字段的前缀部分来创建索引，而不是使用整个字段。</p>
<p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值的数量，从而减少索引树的高度，减少磁盘 IO，提高查询效率。</p>
<p>前缀索引的缺点：</p>
<ul>
<li><code>order by</code> 和 <code>group by</code> 无法使用前缀索引：因为前缀索引只包含原始列值的一部分，MySQL 无法使用它来完成需要完整列值的排序或分组操作。</li>
<li>无法把前缀索引用作覆盖索引：因为前缀索引只包含原始列值的一部分，当查询需要获取完整的列值时，MySQL 无法仅通过扫描索引就满足查询需求，必须回表查询获取完整数据。</li>
</ul>
<h3 id="覆盖索引优化">覆盖索引优化</h3>
<p>覆盖索引是指 SQL 中 query 的所有字段在索引 B+Tree 的叶子节点中都能找到，因此不需要回表查询。</p>
<p>假设我们只需要查询商品的名称、价格，有什么办法可以避免回表查询？</p>
<ul>
<li>创建一个(name, price)的联合索引</li>
<li>由于联合索引的最左匹配原则，查询时会优先使用 name 字段进行过滤，然后根据 name 字段排序，最后根据 price 字段排序</li>
<li>由于覆盖索引，查询时不需要回表查询，直接在联合索引的叶子节点中获取 name 和 price 字段的值</li>
</ul>
<p>通过这种方式，我们就可以避免回表查询，减少磁盘 IO，提高查询效率。</p>
<h3 id="主键索引最好使用自增-ID">主键索引最好使用自增 ID</h3>
<p>主键索引最好使用自增 ID，因为自增 ID 的插入性能比随机 ID 的插入性能要好。</p>
<p>InnoDB 创建主键索引的时候默认为聚簇索引，数据会被存储在叶子节点中，同一个叶子节点中的数据是按照主键顺序排序的，因此当有新的数据插入的时候，数据库会根据主键将其插入到对应的叶子节点中。</p>
<p>如果我们使用自增 ID 作为主键，那么每次插入的新数据都会<strong>按顺序</strong>被添加到当前索引节点的位置，<strong>不需要移动已有数据</strong>，当页面写满就会开辟一个新的页面。因为每次插入一条新纪录都是<strong>追加操作</strong>，不需要移动数据，因此<strong>插入性能很高</strong>。</p>
<p>相反，如果我们使用非自增 ID 作为主键，那么每次插入的新数据都会<strong>随机</strong>插入到当前索引节点的位置，因此很可能会插入到现有数据页的某个中间位置，导致不得不移动其他数据来满足新数据的插入，甚至需要进行<strong>页分裂</strong>，还要将数据从旧页移动到新页，而且这个过程还有可能会带来大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p>
<p>举个例子，假设某个数据页中的数据是 1、3、5、9，且数据页满了，现在准备插入一个数据 7，则需要把数据页分割为两个数据页：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745832584071.png" alt="1745832584071"></p>
<p>出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</p>
<p>而如果记录是顺序插入的，例如插入数据 11，则只需开辟新的数据页，也就不会发生页分裂：</p>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745832605883.png" alt="1745832605883"></p>
<p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。</p>
<p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p>
<h3 id="索引最好设置为-NOT-NULL">索引最好设置为 <code>NOT NULL</code></h3>
<p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p>
<ul>
<li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为 NULL 的行。</li>
<li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式 <code>COMPACT</code>，会用至少 1 字节空间存储 NULL 值列表，如下图的紫色部分：</li>
</ul>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745833140573.png" alt="1745833140573"></p>
<h3 id="防止索引失效">防止索引失效</h3>
<p>用上了索引并不意味着查询的时候一定会用到索引，所以我们要清楚什么时候索引会失效。从而避免在开发过程中写出索引实效的查询语句，否则这样的查询效率是很低的。</p>
<blockquote>
<p>这里留个坑，后面其他文章会详细介绍索引失效的场景。</p>
</blockquote>
<p>索引失效主要有以下几种情况：</p>
<ol>
<li>当我们使用左或者左右模糊匹配的时候，比如 <code>like '%hello'</code> 或者 <code>like '%hello%'</code>，索引会失效，导致全表扫描。</li>
<li>当我们在查询条件中对索引进行了<strong>计算</strong>、<strong>函数</strong>、<strong>类型转换</strong>等操作，索引会失效，导致全表扫描。</li>
<li>联合索引不遵守最左匹配原则。也就是没有从联合索引的最左字段开始匹配，索引会失效，导致全表扫描。</li>
<li>在 <code>WHERE</code>子句中，如果在 <code>OR</code>前面的条件列是索引列，而在 <code>OR</code>后面的条件列不是索引列，索引会失效，导致全表扫描。</li>
</ol>
<p>除此之外，还有很多场景会导致索引失效，这时候需要我们查看执行计划，通过执行计划显示的数据来判断查询语句是否用到了索引。</p>
<p>比如下面就是全表扫描的执行计划的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745840451803.png" alt="1745840451803"></p>
<p>对于执行计划，参数主要有：</p>
<ul>
<li>
<p><code>possible_keys</code>：优化器可能选择使用的索引列表。该字段存在的意义在于展示查询中<em>理论上可以被使用</em>的索引（基于 where 条件和表结构），但最终是否使用还要取决于优化器对数据分布、查询成本等因素的判断。当该字段为 NULL 时表示没有适用的索引。</p>
</li>
<li>
<p><code>key</code>：实际使用的索引。如果查询中没有使用索引，则该字段为 NULL。</p>
</li>
<li>
<p><code>key_len</code>：索引中使用的字段长度。</p>
</li>
<li>
<p><code>rows</code>：这个值表示 MySQL 根据表的统计信息和索引的使用情况，<strong>预估需要读取多少行数据</strong>才能找到满足条件的结果。比如 <code>rows=1000</code>，说明 MySQL 认为大约需要扫描 1000 行数据。这个值越小，说明查询效率越高。</p>
</li>
<li>
<p><code>filtered</code>：这个值表示<strong>经过 WHERE 条件过滤后，剩下的行数占总扫描行数的百分比</strong>。比如 <code>filtered=10</code>，表示最终只有 10%的数据能通过 WHERE 条件。它的计算公式是：filtered = (满足 WHERE 条件的行数 / rows) × 100%。这个值越高，说明过滤效果越好，返回的数据更精确。</p>
</li>
<li>
<p><code>type</code>：表示数据扫描的方式</p>
<p>常见的数据扫描方式有(从上到下，扫描效率从低到高)：</p>
<ul>
<li><code>ALL</code>：全表扫描，效率最低，需要遍历整张表的所有行。
<ul>
<li>例子：<code>SELECT * FROM users WHERE non_indexed_column = 'some_value';</code></li>
</ul>
</li>
<li><code>index</code>：全索引扫描，遍历整个索引，效率比全表扫描高，但仍需扫描所有索引项。
<ul>
<li>例子：<code>SELECT indexed_column FROM users ORDER BY indexed_column;</code> (当只需要扫描索引，不需要访问数据行时)</li>
</ul>
</li>
<li><code>range</code>：范围扫描，只扫描索引中满足条件的部分范围，效率较高。
<ul>
<li>例子：<code>SELECT * FROM users WHERE indexed_column &gt; 100;</code> 或 <code>SELECT * FROM users WHERE indexed_column BETWEEN 100 AND 200;</code></li>
</ul>
</li>
<li><code>ref</code>：非唯一索引等值扫描，通过索引查找匹配某个值的多行，效率较高。
<ul>
<li>例子：<code>SELECT * FROM users WHERE non_unique_indexed_column = 'some_value';</code></li>
</ul>
</li>
<li><code>eq_ref</code>：唯一索引等值扫描，通常出现在多表连接中，对于前一张表的每一行，在后一张表中只能找到一行。效率更高。
<ul>
<li>例子：<code>SELECT * FROM orders JOIN users ON orders.user_id = users.id WHERE orders.id = 123;</code> (假设 <code>users.id</code> 是主键或唯一索引)</li>
</ul>
</li>
<li><code>const</code>：常量扫描，直接通过主键或唯一索引定位到一条记录，效率最高。
<ul>
<li>例子：<code>SELECT * FROM users WHERE id = 123;</code> (假设 <code>id</code> 是主键或唯一索引)</li>
</ul>
</li>
</ul>
<blockquote>
<p>这些情况里面，<code>ALL</code>是最坏的情况，因为采用了全表扫描，需要遍历整张表的所有行。</p>
<p><code>index</code>和 <code>ALL</code>的情况其实差不多，只不过 index 只对索引进行全扫描，这样的好处是不再需要对数据进行排序，但是仍然需要对索引进行扫描。</p>
<p><code>range</code> 表示采用了索引范围扫描，一般在 <code>where</code>子句中使用 <code>&lt;</code>、<code>&gt;</code>、<code>between</code>、<code>in</code>等操作符时会采用这种方式，只扫描索引中满足条件的部分范围，效率较高。<strong>从这一级别开始，索引的作用会越来越明显</strong>，所以我们尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式。</p>
<p><code>ref</code> 类型表示采用了非唯一索引，或者是唯一索引的非唯一前缀，返回数据可能是多行，因为虽然使用了索引，但该索引列的值并不唯一，有重复，这样的话即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标附近的小范围扫描。但是它的好处是它并不需要扫描全表，因为索引是有序的，即使有重复值，也只是出现在目标附近，所以可以快速定位到目标附近，然后进行小范围扫描。</p>
<p><code>eq_ref</code> 类型是使用主键或者唯一索引时产品的访问方式，通常使用在多表联查中。比如对两张表进行联查，关联条件是两张表的 <code>user_id</code>字段，且 <code>user_id</code>字段是主键或者唯一索引，那么就会采用 <code>eq_ref</code>类型。</p>
<p><code>const</code> 类型表示通过主键或者唯一索引与常量值进行了比较</p>
</blockquote>
<blockquote>
<p>需要注意的是，虽然 <code>const</code>和 <code>eq_ref</code>都使用了主键或者唯一索引，但是这两个类型有所区别，<code>const</code>类型表示通过主键或者唯一索引与常量值进行了比较，而 <code>eq_ref</code>类型表示通过主键或者唯一索引与非常量值进行了比较（一般为关联查询）。</p>
</blockquote>
</li>
<li>
<p><code>extra</code>：表示查询的额外信息</p>
<blockquote>
<p>这里说几个重要的 extra 信息：</p>
<ul>
<li>
<p><code>Using filesort</code>：当查询语句中包含 <code>order by</code>，而且无法利用索引完成排序操作的时候，这时候就不得部选择相应的排序算法进行，甚至可能会通过文件排序的方式进行，效率很低</p>
<p>(文件排序：文件排序是 MySQL 中的一种排序方式，它通过创建临时文件来存储排序结果，然后对临时文件进行排序，最后返回排序后的结果。文件排序的效率很低，因为需要创建临时文件，而且需要读取和写入磁盘，所以效率很低。)</p>
</li>
<li>
<p><code>Using temporary</code>：使用了临时表保存中间结果，MySQL 在对查询结果排序的时候使用临时表，常见于 <code>order by</code>和 <code>group by</code>操作，效率很低。</p>
</li>
<li>
<p><code>Using index</code>：表示查询使用了覆盖索引，不需要回表查询。也就是所需的数据在索引中就可以全部获得，不需要再去表中读取数据，效率很高。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="总结">总结</h2>
<p><img src="/2025/04/25/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/1745845148865.png" alt="1745845148865"></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 138 - 随机链表的复制 (Copy List with Random Pointer)</title>
    <url>/2025/04/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-138-Copy-List-with-Random-Pointer/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的深拷贝。深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。</p>
<p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。</li>
</ul>
<p>你的代码只接受原链表的头节点 head 作为传入参数。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1:</strong></p>
<p><img src="/2025/04/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-138-Copy-List-with-Random-Pointer/1745570173396.png" alt="1745570173396"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<p><img src="/2025/04/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-138-Copy-List-with-Random-Pointer/1745570189622.png" alt="1745570189622"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<p><img src="/2025/04/25/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-138-Copy-List-with-Random-Pointer/1745570225789.png" alt="1745570225789"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>0 &lt;= n &lt;= 1000</li>
<li>-10^4 &lt;= Node.val &lt;= 10^4</li>
<li>Node.random 为 null 或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<h2 id="解决方案">解决方案</h2>
<p>这个问题可以通过几种不同的方法解决，下面介绍三种主要的解法：</p>
<h3 id="方法一：哈希表映射-两次遍历">方法一：哈希表映射 + 两次遍历</h3>
<p>最直观的方法是使用哈希表建立原节点到新节点的映射关系。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>第一次遍历：创建所有新节点，并建立原节点到新节点的映射</li>
<li>第二次遍历：根据映射关系设置新节点的 next 和 random 指针</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建原始节点到复制节点的映射</span></span><br><span class="line">    nodeMap := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]*Node)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次遍历：创建所有新节点</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        nodeMap[cur] = &amp;Node&#123;Val: cur.Val&#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次遍历：设置新节点的next和random指针</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        nodeMap[cur].Next = nodeMap[cur.Next]</span><br><span class="line">        nodeMap[cur].Random = nodeMap[cur.Random]</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nodeMap[head]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：原地修改-拆分（O-1-空间解法）">方法二：原地修改 + 拆分（O(1)空间解法）</h3>
<p>这种方法不使用额外的哈希表，而是通过修改原链表结构来实现深拷贝。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>第一步：在每个原节点后插入对应的复制节点，形成 A-&gt;A’-&gt;B-&gt;B’-&gt;… 的链表结构</li>
<li>第二步：设置复制节点的 random 指针，利用 cur.Random.Next 来获取对应的复制节点</li>
<li>第三步：将交错的链表拆分成原链表和复制链表</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：在每个原节点后创建一个新节点</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        copyNode := &amp;Node&#123;</span><br><span class="line">            Val:  cur.Val,</span><br><span class="line">            Next: cur.Next,</span><br><span class="line">        &#125;</span><br><span class="line">        cur.Next = copyNode</span><br><span class="line">        cur = copyNode.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：设置新节点的random指针</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Random != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur.Next.Random = cur.Random.Next</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：分离原链表和复制链表</span></span><br><span class="line">    cur = head</span><br><span class="line">    copyHead := head.Next</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        copyNode := cur.Next</span><br><span class="line">        cur.Next = copyNode.Next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> copyNode.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            copyNode.Next = copyNode.Next.Next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copyHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：递归-哈希表">方法三：递归 + 哈希表</h3>
<p>这种方法使用递归和哈希表结合的方式解决问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]*Node)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> deepCopy <span class="function"><span class="keyword">func</span><span class="params">(node *Node)</span></span> *Node</span><br><span class="line">    deepCopy = <span class="function"><span class="keyword">func</span><span class="params">(node *Node)</span></span> *Node &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果已经创建过该节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">copy</span>, ok := visited[node]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">copy</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新节点</span></span><br><span class="line">        <span class="built_in">copy</span> := &amp;Node&#123;Val: node.Val&#125;</span><br><span class="line">        visited[node] = <span class="built_in">copy</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归设置next和random指针</span></span><br><span class="line">        <span class="built_in">copy</span>.Next = deepCopy(node.Next)</span><br><span class="line">        <span class="built_in">copy</span>.Random = deepCopy(node.Random)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">copy</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> deepCopy(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误分析">错误分析</h2>
<h3 id="常见错误点和易错模式">常见错误点和易错模式</h3>
<p>在实现方法二（原地修改 + 拆分）时，有几个容易出错的地方：</p>
<h4 id="错误实现">错误实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    cur := head</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：创建交错链表</span></span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        copyNode := &amp;Node&#123;</span><br><span class="line">            Next: cur.Next,</span><br><span class="line">            Val:  cur.Val,</span><br><span class="line">        &#125;</span><br><span class="line">        cur.Next = copyNode</span><br><span class="line">        cur = copyNode.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：设置random指针</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur.Next.Random = cur.Random.Next  <span class="comment">// 错误：没有检查cur.Random是否为nil</span></span><br><span class="line">        cur = cur.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：拆分链表</span></span><br><span class="line">    cur = head</span><br><span class="line">    copy1 := cur.Next</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        tmpNext := cur.Next</span><br><span class="line">        cur.Next = tmpNext.Next</span><br><span class="line">        tmpNext.Next = cur.Next.Next  <span class="comment">// 错误：没有检查cur.Next是否为nil</span></span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="错误分析-2">错误分析</h4>
<p>上述实现有三个主要问题：</p>
<ol>
<li><strong>没有处理空链表</strong>：当 <code>head == nil</code> 时，应该直接返回 <code>nil</code></li>
<li><strong>没有处理 Random 指针为空</strong>：在设置 <code>cur.Next.Random</code> 时，如果 <code>cur.Random</code> 为 <code>nil</code>，会导致空指针异常</li>
<li><strong>链表拆分处理不当</strong>：在拆分链表最后阶段，没有正确处理尾节点的情况，可能导致 <code>nil</code> 指针解引用</li>
</ol>
<h4 id="修正实现">修正实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：创建交错链表</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        copyNode := &amp;Node&#123;</span><br><span class="line">            Next: cur.Next,</span><br><span class="line">            Val:  cur.Val,</span><br><span class="line">        &#125;</span><br><span class="line">        cur.Next = copyNode</span><br><span class="line">        cur = copyNode.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：设置random指针</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Random != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur.Next.Random = cur.Random.Next</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：拆分链表</span></span><br><span class="line">    cur = head</span><br><span class="line">    copyHead := head.Next</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        copyNode := cur.Next</span><br><span class="line">        cur.Next = copyNode.Next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> copyNode.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            copyNode.Next = copyNode.Next.Next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copyHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>优点</th>
<th>缺点</th>
<th>推荐度</th>
</tr>
</thead>
<tbody>
<tr>
<td>哈希表映射</td>
<td>O(n)</td>
<td>O(n)</td>
<td>实现简单，直观易懂</td>
<td>需要额外空间</td>
<td>★★★★☆</td>
</tr>
<tr>
<td>原地修改 + 拆分</td>
<td>O(n)</td>
<td>O(1)</td>
<td>常数空间复杂度</td>
<td>实现复杂，易出错</td>
<td>★★★★★</td>
</tr>
<tr>
<td>递归 + 哈希表</td>
<td>O(n)</td>
<td>O(n)</td>
<td>代码精简，逻辑清晰</td>
<td>递归栈可能导致栈溢出</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="关键学习点">关键学习点</h2>
<ol>
<li><strong>链表操作的边界条件处理</strong>：在链表问题中，始终要考虑空链表、单节点链表等边界情况</li>
<li><strong>空指针检查的重要性</strong>：对可能为空的指针进行操作前，必须进行非空检查</li>
<li><strong>不使用额外空间的技巧</strong>：如何通过修改原数据结构来避免使用额外空间</li>
<li><strong>深拷贝与浅拷贝的区别</strong>：深拷贝需要复制所有相关联的对象，而不仅仅是直接引用</li>
</ol>
<p>这道题是链表操作的经典问题，掌握它对理解更复杂的链表操作有很大帮助。原地修改的方法虽然实现复杂，但通过在原链表上巧妙地构建信息来降低空间复杂度，是一种值得学习的高级技巧。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>迭代</tag>
        <tag>Hot100</tag>
        <tag>哈希</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL行溢出的处理</title>
    <url>/2025/04/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A1%8C%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="行溢出">行溢出</h2>
<p>MYSQL 中磁盘和内存交互的基本单位是页，一页的大小为 16KB。</p>
<p>如果一个字段存储的内容超过了 16KB，那么这个字段就会发生行溢出。</p>
<blockquote>
<p>比如之前说过 VARCHAR 类型的最大长度是 65532（允许为 NULL），那么 Varchar 的长度明显是会超过一页的大小的，那么就会发生行溢出。</p>
<p><a href="/2025/04/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Varchar%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC/">VARCHAR 类型最大取值</a></p>
</blockquote>
<h2 id="行溢出的处理">行溢出的处理</h2>
<h3 id="Compact-行格式">Compact 行格式</h3>
<p>当在使用 Compact 行格式时，如果发生行溢出，MYSQL 会使用溢出页来存储溢出的数据。它会在真实数据处只会存储一部分数据，剩余的数据会存储在溢出页中。然后在真实数据处的最后 20 个字节存储溢出页的地址，从而方便快速定位到溢出页。</p>
<p><img src="/2025/04/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A1%8C%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86/1745566523989.png" alt="1745566523989"></p>
<h3 id="Compressed-和-Dynamic-行格式">Compressed 和 Dynamic 行格式</h3>
<p>Compressed 和 Dynamic 行格式与 Compact 行格式类似，但是在溢出的处理上有所不同。它不会在真实数据处存储部分数据，而是完全只存储溢出页的地址。真实数据完全存储在溢出页中。</p>
<p><img src="/2025/04/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A1%8C%E6%BA%A2%E5%87%BA%E7%9A%84%E5%A4%84%E7%90%86/1745566626788.png" alt="1745566626788"></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>MySQL</tag>
        <tag>行溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 25: K 个一组翻转链表（Reverse Nodes in k-Group）</title>
    <url>/2025/04/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-25-Reverse-Nodes-in-k-Group/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5], k = 2</span><br><span class="line">输出: [2,1,4,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5], k = 3</span><br><span class="line">输出: [3,2,1,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>约束条件:</strong></p>
<ul>
<li>链表中节点的数目为 n</li>
<li>1 &lt;= k &lt;= n &lt;= 5000</li>
<li>0 &lt;= Node.val &lt;= 1000</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>本题要求我们以 k 个节点为一组进行翻转，如果最后剩余的节点不足 k 个，则保持原样。这是链表操作中的一个典型问题，主要涉及链表的翻转操作。</p>
<p>解决这个问题的核心思想是：</p>
<ol>
<li>确定每组 k 个节点的范围</li>
<li>翻转这 k 个节点</li>
<li>将翻转后的组与前后部分连接起来</li>
<li>移动到下一组继续操作</li>
</ol>
<p>我们使用迭代的方式来解决这个问题，通过一个循环来处理每组 k 个节点。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="错误版本分析">错误版本分析</h3>
<p>首先，让我们看看出错的代码版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> || k == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dummyHead := &amp;ListNode&#123;</span><br><span class="line">		Next: head,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	first := dummyHead</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> prev, end *ListNode</span><br><span class="line">	cur := dummyHead.Next</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		end = first</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">			end = end.Next</span><br><span class="line">			<span class="keyword">if</span> end == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> end == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp := first.Next</span><br><span class="line">		cur = tmp.Next</span><br><span class="line">		prev = tmp</span><br><span class="line">		<span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur != end.Next &#123;</span><br><span class="line">			tmp2 := cur.Next</span><br><span class="line">			cur.Next = prev</span><br><span class="line">			prev = cur</span><br><span class="line">			cur = tmp2</span><br><span class="line">		&#125;</span><br><span class="line">		first.Next = end</span><br><span class="line">		tmp.Next = cur</span><br><span class="line"></span><br><span class="line">		first = tmp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本的主要问题出现在翻转链表的循环条件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur != end.Next &#123;</span><br><span class="line">    tmp2 := cur.Next</span><br><span class="line">    cur.Next = prev</span><br><span class="line">    prev = cur</span><br><span class="line">    cur = tmp2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误原因</strong>: 在翻转链表的过程中，我们修改了节点的 <code>Next</code> 指针。当我们在循环中检查 <code>cur != end.Next</code> 这个条件时，由于 <code>end</code> 是链表中的一个节点，其 <code>Next</code> 指针可能在循环过程中被修改，导致循环终止条件不符合预期。</p>
<h3 id="修复版本">修复版本</h3>
<p>修复后的代码版本：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> || k == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dummyHead := &amp;ListNode&#123;</span><br><span class="line">		Next: head,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	first := dummyHead</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> prev, end *ListNode</span><br><span class="line">	cur := dummyHead.Next</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		end = first</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">			end = end.Next</span><br><span class="line">			<span class="keyword">if</span> end == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> end == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp := first.Next</span><br><span class="line">		cur = tmp.Next</span><br><span class="line">		prev = tmp</span><br><span class="line">		afterEnd := end.Next</span><br><span class="line">		<span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur != afterEnd &#123;</span><br><span class="line">			tmp2 := cur.Next</span><br><span class="line">			cur.Next = prev</span><br><span class="line">			prev = cur</span><br><span class="line">			cur = tmp2</span><br><span class="line">		&#125;</span><br><span class="line">		first.Next = end</span><br><span class="line">		tmp.Next = cur</span><br><span class="line"></span><br><span class="line">		first = tmp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修复点</strong>: 通过在开始翻转前保存 <code>end.Next</code> 到 <code>afterEnd</code> 变量，我们确保了循环的终止条件不会受到链表结构变化的影响。这样，即使在翻转过程中修改了节点间的连接关系，我们仍然能正确地确定何时停止翻转当前组的节点。</p>
<h3 id="优化版本">优化版本</h3>
<p>虽然修复后的代码能够正确工作，但我们可以进一步优化代码，使其逻辑更清晰：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="comment">// 处理特殊情况</span></span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> || k == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建虚拟头节点简化边界处理</span></span><br><span class="line">	dummy := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// groupPrev 指向当前待翻转组的前一个节点</span></span><br><span class="line">	groupPrev := dummy</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 持续处理每组 k 个节点</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 1. 检查剩余节点是否有 k 个</span></span><br><span class="line">		groupEnd := groupPrev</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">			groupEnd = groupEnd.Next</span><br><span class="line">			<span class="keyword">if</span> groupEnd == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 剩余节点不足 k 个，不再翻转</span></span><br><span class="line">				<span class="keyword">return</span> dummy.Next</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2. 获取分组的起始和结束位置</span></span><br><span class="line">		groupStart := groupPrev.Next</span><br><span class="line">		groupNext := groupEnd.Next</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 3. 翻转 k 个节点</span></span><br><span class="line">		prev := groupNext  <span class="comment">// 翻转后尾节点指向的位置</span></span><br><span class="line">		curr := groupStart</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 经典链表翻转算法</span></span><br><span class="line">		<span class="keyword">for</span> curr != groupNext &#123;</span><br><span class="line">			next := curr.Next</span><br><span class="line">			curr.Next = prev</span><br><span class="line">			prev = curr</span><br><span class="line">			curr = next</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 4. 连接翻转后的组与之前的链表</span></span><br><span class="line">		groupPrev.Next = groupEnd  <span class="comment">// 前一个节点连接到翻转后的头</span></span><br><span class="line">		groupStart.Next = groupNext  <span class="comment">// 翻转后的尾连接到下一组的开始</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 5. 更新 groupPrev 为下一组的前节点</span></span><br><span class="line">		groupPrev = groupStart</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个优化版本中：</p>
<ol>
<li>使用了更有描述性的变量名（如 <code>groupStart</code>, <code>groupEnd</code>, <code>groupNext</code>, <code>groupPrev</code>）</li>
<li>添加了清晰的注释，解释每个步骤的目的</li>
<li>简化了链表翻转的实现，使用标准的三指针翻转方法</li>
<li>分离了不同的逻辑部分，使代码更易理解</li>
<li>直接返回 <code>dummy.Next</code> 而不是使用 <code>break</code> 和额外的控制变量</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>: O(n)，其中 n 是链表的长度。虽然有嵌套循环，但每个节点最多被访问两次。</li>
<li><strong>空间复杂度</strong>: O(1)，只使用了常数个额外变量，没有使用额外的数据结构。</li>
</ul>
<h2 id="关键要点">关键要点</h2>
<ol>
<li>
<p><strong>链表修改的注意点</strong>: 在修改链表结构时，需要特别注意那些依赖于链表当前结构的条件判断。在本例中，我们学到了在开始修改前保存关键节点引用的重要性。</p>
</li>
<li>
<p><strong>变量命名的重要性</strong>: 优化版代码通过使用更有描述性的变量名，极大地提高了代码的可读性，使人更容易理解算法的逻辑。</p>
</li>
<li>
<p><strong>分组处理的思想</strong>: 这种按组处理的思想在很多链表和数组问题中都很有用，可以将一个复杂问题分解为处理单个组和组之间连接的子问题。</p>
</li>
</ol>
<p>这个问题是链表操作的典型例子，掌握了这里的翻转技巧，可以应用到很多其他的链表问题中，如链表的部分翻转、两两交换节点等。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>Hot100</tag>
        <tag>❌错题集</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 24 - 两两交换链表中的节点 (Swap Nodes in Pairs)</title>
    <url>/2025/04/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-24-Swap-Nodes-in-Pairs/</url>
    <content><![CDATA[<h2 id="Problem-Description">Problem Description</h2>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>链表中节点的数目在范围 [0, 100] 内</li>
<li>0 &lt;= Node.val &lt;= 100</li>
</ul>
<h2 id="Solution-Approach">Solution Approach</h2>
<p>这是一个典型的链表操作问题，我们需要两两交换相邻节点。有两种常见的解决方法：迭代法和递归法。</p>
<h3 id="迭代法">迭代法</h3>
<p>迭代法的核心思想是使用三个指针来完成相邻节点的交换。我们需要：</p>
<ol>
<li>一个哑节点（dummy node）作为新链表的起点</li>
<li>一个前置指针（prev）指向已处理部分的最后一个节点</li>
<li>一个当前指针（curr）指向待处理的第一个节点</li>
</ol>
<p><strong>关键步骤</strong>:</p>
<ol>
<li>创建一个哑节点指向原链表头</li>
<li>初始化 prev 为哑节点，curr 为链表头</li>
<li>当 curr 和 curr.next 都非空时进行交换：
<ul>
<li>临时保存 curr.next.next</li>
<li>调整指针完成交换</li>
<li>移动 prev 和 curr 指针继续处理下一对节点</li>
</ul>
</li>
<li>返回哑节点的下一个节点作为新链表的头节点</li>
</ol>
<p>以示例 1 为例，交换过程可视化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4</span><br><span class="line">prev    curr</span><br><span class="line"></span><br><span class="line">交换后</span><br><span class="line">dummy -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4</span><br><span class="line">          |    |</span><br><span class="line">          |    curr (新的 curr)</span><br><span class="line">          |</span><br><span class="line">          prev (新的 prev)</span><br><span class="line"></span><br><span class="line">继续交换</span><br><span class="line">dummy -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 3</span><br><span class="line">                     |</span><br><span class="line">                     curr=nil (结束)</span><br></pre></td></tr></table></figure>
<h2 id="Code-Implementation">Code Implementation</h2>
<h3 id="1-迭代解法">1. 迭代解法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况：空链表或只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建哑节点指向链表头</span></span><br><span class="line">    dummyHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化指针</span></span><br><span class="line">    prev, curr := dummyHead, head</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当有一对节点可交换时进行交换</span></span><br><span class="line">    <span class="keyword">for</span> curr != <span class="literal">nil</span> &amp;&amp; curr.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 保存下一对节点的起始位置</span></span><br><span class="line">        nextPair := curr.Next.Next</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换当前一对节点</span></span><br><span class="line">        <span class="comment">// 1-&gt;2-&gt;3-&gt;4 变为 2-&gt;1-&gt;3-&gt;4</span></span><br><span class="line">        second := curr.Next     <span class="comment">// second = 2</span></span><br><span class="line">        second.Next = curr      <span class="comment">// 2-&gt;1</span></span><br><span class="line">        curr.Next = nextPair    <span class="comment">// 1-&gt;3</span></span><br><span class="line">        prev.Next = second      <span class="comment">// dummy-&gt;2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动指针，准备处理下一对节点</span></span><br><span class="line">        prev = curr             <span class="comment">// prev = 1</span></span><br><span class="line">        curr = nextPair         <span class="comment">// curr = 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummyHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-递归解法">2. 递归解法</h3>
<p>递归法更简洁，但需要理解递归思想：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 基本情况：空链表或只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存第二个节点</span></span><br><span class="line">    second := head.Next</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理剩余部分，从第三个节点开始</span></span><br><span class="line">    head.Next = swapPairs(second.Next)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换前两个节点</span></span><br><span class="line">    second.Next = head</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回新的头节点（原来的第二个节点）</span></span><br><span class="line">    <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Complexity-Analysis">Complexity Analysis</h2>
<h3 id="迭代法-2">迭代法</h3>
<ul>
<li><strong>时间复杂度</strong>: O(n)，其中 n 是链表的长度。我们需要遍历一次链表，每次处理两个节点。</li>
<li><strong>空间复杂度</strong>: O(1)，只使用了常数个额外变量。</li>
</ul>
<h3 id="递归法">递归法</h3>
<ul>
<li><strong>时间复杂度</strong>: O(n)，同样需要处理每个节点一次。</li>
<li><strong>空间复杂度</strong>: O(n/2) ≈ O(n)，递归栈的深度为链表长度的一半（每次递归处理两个节点）。</li>
</ul>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>迭代法</th>
<th>递归法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>代码复杂度</td>
<td>中等</td>
<td>简洁</td>
</tr>
<tr>
<td>优点</td>
<td>节省空间</td>
<td>代码简洁易懂</td>
</tr>
<tr>
<td>缺点</td>
<td>需要处理多个指针</td>
<td>大链表可能导致栈溢出</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="Key-Learnings">Key Learnings</h2>
<ol>
<li>
<p><strong>链表操作的关键在于指针管理</strong>：在处理链表时，合理使用指针变量可以极大简化操作。</p>
</li>
<li>
<p><strong>哑节点（Dummy Node）的使用</strong>：在许多链表问题中，使用哑节点可以统一操作，避免处理头节点的特殊情况。</p>
</li>
<li>
<p><strong>迭代vs递归</strong>：链表问题通常可以用这两种方法解决。递归往往代码更简洁，但空间复杂度更高。</p>
</li>
<li>
<p><strong>画图辅助理解</strong>：对于复杂的链表操作，画出节点和指针的变化过程有助于理解和调试。</p>
</li>
</ol>
<p>这个问题是链表操作的基础练习，掌握它对理解更复杂的链表问题很有帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql中Varchar最大取值</title>
    <url>/2025/04/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Varchar%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>在看这篇文章之前，需要先了解 Mysql 的记录存储方式，可以看这篇文章：<a href="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/">Mysql 记录存储方式</a></p>
<p>然后，我们需要先知道一个知识点:MYSQL 中规定，<strong>除了 <code>Text</code>、<code>Blob</code>类型，其他类型其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>，这里注意一下，65535 是<font color="red">一行</font>的最大字节数，而不是一个列的最大字节数。</p>
</blockquote>
<p>需要说明的是，varchar 最大的长度其实是达不到 <code>65535</code>的，因为这一行中除了 <code>varchar</code>的真实数据，还包含了<strong>变长字段长度列表</strong>、<strong>NULL 值列表</strong>所占用的字节数</p>
<p>在我们创建一个 <code>varchar</code>类型的时候,实际上创建了三个部分:</p>
<ol>
<li>真实数据</li>
<li>真实数据占用的字节数</li>
<li>NULL 标识(如果不允许为 NULL，则不需要)</li>
</ol>
<p>比如我们在创建下面的表的时候:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> test(</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">65532</span>) <span class="keyword">NULL</span></span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>
<p>就比如我们创建上面这个表的时候，由于允许为 NULL，所以需要（因为不满 8 位，所以需要一个字节来标识）一个字节来标识</p>
<p>紧接着，变长字段长度列表，需要占用 2 个字节来标识，因为它的规则是：</p>
<p>1.如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」； 2.如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；</p>
<p>我们这个例子里面的 varchar(65532)，所以需要用 2 个字节来标识，所以这一行总共占用的字节数为：1+2+65532=65535，正好达到 65535 的限制。</p>
<p>因此我们可以得知，varchar 在可以为 NULL 的情况下，最大长度为 65532。</p>
<p>在不允许为 NULL 的情况下，由于不需要 NULL 标识字节，所以只需要 2 个字节来表示变长字段长度列表。因此实际可存储的最大数据字节数为 65535 - 2 = 65533 字节，即 <code>VARCHAR(65533)</code> 达到上限。</p>
<hr>
<p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 &lt;= 65535。</p>
<p><img src="/2025/04/24/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Varchar%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC/1745466102232.png" alt="1745466102232"></p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>记录存储方式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2 - 两数相加（Add Two Numbers）</title>
    <url>/2025/04/23/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<h3 id="示例-3：">示例 3：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>
<h3 id="提示：">提示：</h3>
<ul>
<li>每个链表中的节点数在范围 [1, 100] 内</li>
<li>0 &lt;= Node.val &lt;= 9</li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题考察的是链表操作和数字加法。由于两个链表已经是逆序存储，与我们正常从低位到高位进行加法计算的顺序相同，所以可以直接对两个链表进行遍历并相加。主要需要处理的点是：</p>
<ol>
<li>两个数字相加可能产生进位</li>
<li>两个链表可能长度不同</li>
<li>最高位相加后可能还有进位，需要额外增加一个节点</li>
</ol>
<p>解题的核心思想是<strong>模拟加法运算的过程</strong>，按位相加并处理进位。</p>
<h2 id="初始实现分析（有待优化的代码）">初始实现分析（有待优化的代码）</h2>
<p>下面是一个可以通过但有待优化的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	oneFlag := <span class="literal">false</span></span><br><span class="line">	res := &amp;ListNode&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	cur := res</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp := l1.Val + l2.Val</span><br><span class="line">		<span class="keyword">if</span> oneFlag &#123;</span><br><span class="line">			tmp += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur.Val = tmp % <span class="number">10</span></span><br><span class="line">		<span class="keyword">if</span> tmp &gt;= <span class="number">10</span> &#123;</span><br><span class="line">			oneFlag = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			oneFlag = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur.Next = &amp;ListNode&#123;&#125;</span><br><span class="line">		prev = cur</span><br><span class="line">		cur = cur.Next</span><br><span class="line">		l1 = l1.Next</span><br><span class="line">		l2 = l2.Next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp := l1.Val</span><br><span class="line">		<span class="keyword">if</span> oneFlag &#123;</span><br><span class="line">			tmp += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur.Val = tmp % <span class="number">10</span></span><br><span class="line">		<span class="keyword">if</span> tmp &gt;= <span class="number">10</span> &#123;</span><br><span class="line">			oneFlag = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			oneFlag = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur.Next = &amp;ListNode&#123;&#125;</span><br><span class="line">		prev = cur</span><br><span class="line">		cur = cur.Next</span><br><span class="line">		l1 = l1.Next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp := l2.Val</span><br><span class="line">		<span class="keyword">if</span> oneFlag &#123;</span><br><span class="line">			tmp += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur.Val = tmp % <span class="number">10</span></span><br><span class="line">		<span class="keyword">if</span> tmp &gt;= <span class="number">10</span> &#123;</span><br><span class="line">			oneFlag = <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			oneFlag = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		cur.Next = &amp;ListNode&#123;&#125;</span><br><span class="line">		prev = cur</span><br><span class="line">		cur = cur.Next</span><br><span class="line">		l2 = l2.Next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> oneFlag &#123;</span><br><span class="line">		cur.Val = <span class="number">1</span></span><br><span class="line">		prev = cur</span><br><span class="line">	&#125;</span><br><span class="line">	prev.Next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在的问题">存在的问题</h3>
<p>这段代码虽然可以解决问题，但存在以下几个问题：</p>
<ol>
<li><strong>代码冗余</strong>：有三个几乎相同的循环，处理逻辑重复</li>
<li><strong>效率不高</strong>：每次循环都创建了新节点，包括可能无用的节点</li>
<li><strong>可读性差</strong>：变量名不够直观（如 <code>oneFlag</code> 表示进位）</li>
<li><strong>代码结构</strong>：循环后的收尾处理逻辑不够清晰</li>
</ol>
<h2 id="优化实现">优化实现</h2>
<p>我们可以通过以下几点优化代码：</p>
<ol>
<li>合并重复的三个循环，使用一个循环处理所有情况</li>
<li>使用更清晰的变量名（如 <code>carry</code> 代替 <code>oneFlag</code>）</li>
<li>只在确实需要新节点时才创建</li>
<li>简化进位的处理逻辑</li>
</ol>
<h3 id="优化后的代码">优化后的代码</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="comment">// 创建虚拟头节点，简化操作</span></span><br><span class="line">	dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">	current := dummy</span><br><span class="line">	carry := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只要有一个链表还有节点或者有进位，就继续循环</span></span><br><span class="line">	<span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">		sum := carry</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加当前节点的值（如果存在）</span></span><br><span class="line">		<span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">			sum += l1.Val</span><br><span class="line">			l1 = l1.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">			sum += l2.Val</span><br><span class="line">			l2 = l2.Next</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算进位和当前位的值</span></span><br><span class="line">		carry = sum / <span class="number">10</span></span><br><span class="line">		current.Next = &amp;ListNode&#123;Val: sum % <span class="number">10</span>&#125;</span><br><span class="line">		current = current.Next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化说明">优化说明</h3>
<ol>
<li><strong>使用虚拟头节点（dummy head）</strong>：通过创建一个虚拟头节点，我们可以简化链表操作，避免处理头节点为空的特殊情况。</li>
<li><strong>合并循环</strong>：将三个循环合并为一个循环，只要有一个链表还有节点或者有进位，就继续循环。</li>
<li><strong>改进变量命名</strong>：使用 <code>carry</code> 代替 <code>oneFlag</code>，使代码更易理解。</li>
<li><strong>按需创建节点</strong>：只在确实需要添加新节点时才创建，而不是提前创建可能无用的节点。</li>
<li><strong>简化进位计算</strong>：使用 <code>sum / 10</code> 计算进位，<code>sum % 10</code> 计算当前位的值，代码更简洁清晰。</li>
</ol>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：O(max(n, m))，其中 n 和 m 分别是两个链表的长度。我们需要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。</li>
<li><strong>空间复杂度</strong>：O(max(n, m))，新链表的长度最多为 max(n, m) + 1（当有进位时）。不考虑返回值所占用的空间，空间复杂度为 O(1)。</li>
</ul>
<h2 id="优化前后对比">优化前后对比</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>优化前</th>
<th>优化后</th>
</tr>
</thead>
<tbody>
<tr>
<td>代码行数</td>
<td>~50 行</td>
<td>~20 行</td>
</tr>
<tr>
<td>循环次数</td>
<td>3个循环</td>
<td>1个循环</td>
</tr>
<tr>
<td>可读性</td>
<td>较差</td>
<td>良好</td>
</tr>
<tr>
<td>变量命名</td>
<td>不直观</td>
<td>清晰明了</td>
</tr>
<tr>
<td>节点创建</td>
<td>可能创建无用节点</td>
<td>按需创建</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(max(n, m))</td>
<td>O(max(n, m))</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(max(n, m))</td>
<td>O(max(n, m))</td>
</tr>
</tbody>
</table>
<h2 id="学习要点">学习要点</h2>
<ol>
<li><strong>代码简化</strong>：通过合并相似的逻辑，可以大幅减少代码量，提高可读性。</li>
<li><strong>虚拟头节点技巧</strong>：在处理链表问题时，使用虚拟头节点可以简化边界情况的处理。</li>
<li><strong>条件合并</strong>：将多个条件合并到一个循环中，使代码更加简洁。</li>
<li><strong>变量命名</strong>：使用清晰的变量名可以提高代码可读性，如使用 <code>carry</code> 表示进位。</li>
<li><strong>按需分配内存</strong>：只在必要时创建新的节点，避免无用的内存分配和释放。</li>
</ol>
<p>这种链表加法的模式在处理大数加法等问题时也很常见，掌握这种模式对解决类似问题很有帮助。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Model Context Protocol (MCP) 介绍</title>
    <url>/2025/04/23/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/AI%E5%B7%A5%E7%A8%8B/2025-04-23-Introduction-to-MCP/</url>
    <content><![CDATA[<h1>Model Context Protocol (MCP) 介绍</h1>
<h2 id="为什么我们需要MCP">为什么我们需要MCP</h2>
<p>当今的大型语言模型(LLM)虽然功能强大，但在与外部世界交互时仍面临诸多挑战：</p>
<ul>
<li><strong>上下文窗口限制</strong>：模型能接收的信息量有限，导致处理大型代码库或数据集困难</li>
<li><strong>数据隐私问题</strong>：敏感数据需要发送到云端处理，增加了隐私和安全风险</li>
<li><strong>工具集成碎片化</strong>：每个LLM提供商有不同的工具集成方式，导致开发者需维护多套代码</li>
<li><strong>本地资源访问受限</strong>：很难让LLM安全地访问本地文件系统、数据库或应用程序</li>
<li><strong>多系统协作困难</strong>：让LLM与多个不同服务协同工作缺乏统一标准</li>
</ul>
<p>Model Context Protocol (MCP)正是为解决这些问题而诞生的技术标准，它提供了一种统一、安全、灵活的方式，让语言模型能够与各种外部系统和资源进行交互。</p>
<h2 id="MCP是什么">MCP是什么</h2>
<p>Model Context Protocol (MCP) 是一种用于构建LLM（大型语言模型）应用程序的客户端-服务器架构协议，它允许AI模型与外部数据源和工具进行交互。</p>
<blockquote>
<p><strong>名词解释</strong>：</p>
<ul>
<li><strong>客户端-服务器架构</strong>：一种计算模型，其中一个程序(客户端)请求服务，另一个程序(服务器)提供服务。就像餐厅中顾客(客户端)点餐，厨房(服务器)准备食物。</li>
<li><strong>协议</strong>：一套规则，定义了系统间如何交换信息。类似于人们交流的语言和礼仪规范。</li>
<li><strong>API(应用程序接口)</strong>：软件组件之间的连接点，允许不同程序相互通信。就像电源插座是电器与电网的接口。</li>
</ul>
</blockquote>
<p>MCP的核心思想是通过标准化的协议，让语言模型能够安全、灵活地访问各种本地和远程资源。这不仅仅是一个简单的API或函数调用系统，而是一个完整的架构模式，具有以下核心特征：</p>
<ol>
<li><strong>协议驱动</strong>: MCP 定义了客户端和服务器之间通信的标准协议，使不同组件能够无缝协作</li>
<li><strong>资源抽象</strong>: 将各种数据源、工具和服务抽象为统一的资源接口</li>
<li><strong>分布式设计</strong>: 支持多个服务器并行提供不同功能，实现功能解耦</li>
<li><strong>安全隔离</strong>: 明确的安全边界，数据保持在服务器端，只有结果返回给客户端</li>
<li><strong>可组合性</strong>: 不同MCP服务器可以组合使用，形成复杂的工作流</li>
</ol>
<h2 id="日常使用场景：MCP如何改变我们使用AI的方式">日常使用场景：MCP如何改变我们使用AI的方式</h2>
<h3 id="场景一：本地文档助手">场景一：本地文档助手</h3>
<p><strong>问题</strong>：王先生有大量存储在本地电脑上的工作文档，他想让AI助手帮忙整理和总结，但又担心文档内容上传到云端会有安全风险。</p>
<p><strong>MCP解决方案</strong>：</p>
<ol>
<li>王先生在电脑上安装了支持MCP的Claude Desktop应用和文件系统MCP服务器</li>
<li>当他询问&quot;帮我总结所有2025年第一季度的会议记录&quot;时</li>
<li>Claude会通过MCP服务器安全地搜索本地文件系统</li>
<li>文档内容不会离开王先生的电脑，只有搜索结果返回给Claude</li>
<li>Claude根据获取的会议内容生成总结报告</li>
</ol>
<p>这一过程对王先生来说完全透明，他只需正常与AI交谈，但所有数据处理都在本地完成，保证了信息安全。</p>
<h3 id="场景二：代码开发助手">场景二：代码开发助手</h3>
<p><strong>问题</strong>：张女士是一名软件开发人员，使用AI助手编写代码，但发现AI无法访问她的本地代码库、运行测试或执行Git操作。</p>
<p><strong>MCP解决方案</strong>：</p>
<ol>
<li>张女士在IDE中使用支持MCP的AI编码助手</li>
<li>IDE运行多个MCP服务器，分别处理代码访问、测试运行和版本控制</li>
<li>当张女士要求&quot;根据单元测试结果修复这个bug&quot;时</li>
<li>AI通过代码访问MCP服务器读取相关文件</li>
<li>通过测试MCP服务器运行测试并获取结果</li>
<li>分析问题并生成修复方案</li>
<li>通过Git MCP服务器创建修复分支和提交更改</li>
</ol>
<p>整个过程在张女士的本地环境完成，无需将完整代码库上传到云端，同时AI助手能够与她的开发工具流完美集成。</p>
<h2 id="详细协议结构">详细协议结构</h2>
<p>MCP协议主要包含以下关键组件：</p>
<ul>
<li><strong>连接管理</strong>: 建立和维护客户端与服务器之间的连接</li>
<li><strong>资源发现</strong>: 允许客户端发现服务器提供的资源和功能</li>
<li><strong>资源请求</strong>: 客户端向服务器请求特定资源</li>
<li><strong>资源响应</strong>: 服务器处理请求并返回结果</li>
<li><strong>元数据交换</strong>: 交换有关资源和功能的元数据</li>
<li><strong>安全机制</strong>: 保护传输中的数据并验证请求的合法性</li>
</ul>
<h2 id="基本原理与架构">基本原理与架构</h2>
<p>MCP采用客户端-服务器架构，其中：</p>
<ul>
<li><strong>MCP主机（Hosts）</strong>：如Claude Desktop、IDE或AI工具，希望通过MCP访问数据的程序</li>
<li><strong>MCP客户端（Clients）</strong>：维护与服务器1:1连接的协议客户端，负责发送请求和接收响应</li>
<li><strong>MCP服务器（Servers）</strong>：通过标准化的Model Context Protocol公开特定功能的轻量级程序，负责处理请求并返回结果</li>
<li><strong>本地数据源</strong>：MCP服务器可以安全访问的计算机文件、数据库和服务</li>
<li><strong>远程服务</strong>：MCP服务器可以连接的外部系统（如通过API）</li>
</ul>
<p>这种架构可以通过以下Mermaid图表表示：</p>
<h2 id="MCP通信流程">MCP通信流程</h2>
<p>MCP通信过程是如何实现LLM与各种资源交互的关键。以下是一个典型的MCP通信流程：</p>
<pre class="mermaid">sequenceDiagram
    participant User as 用户
    participant LLM as 语言模型
    participant Host as 主机应用
    participant Client as MCP客户端
    participant Server as MCP服务器
    participant DataSource as 数据源
  
    User-&gt;&gt;Host: 提出请求
    Host-&gt;&gt;LLM: 转发用户请求
    LLM--&gt;&gt;Host: 需要访问外部资源
  
    Host-&gt;&gt;Client: 资源请求
    Client-&gt;&gt;Server: 发送MCP请求
    Server-&gt;&gt;DataSource: 数据访问
    DataSource--&gt;&gt;Server: 返回数据
    Server--&gt;&gt;Client: MCP响应
    Client--&gt;&gt;Host: 返回资源
  
    Host-&gt;&gt;LLM: 提供资源
    LLM--&gt;&gt;Host: 基于资源的响应
    Host-&gt;&gt;User: 显示结果</pre>
<h2 id="资源接口设计">资源接口设计</h2>
<p>MCP定义了一套资源接口，使客户端能够统一访问各种不同类型的资源：</p>
<pre class="mermaid">classDiagram
    class Resource {
        +String resourceId
        +String resourceType
        +Metadata metadata
        +request(parameters)
    }
  
    class FileResource {
        +String path
        +readContent()
        +writeContent(data)
    }
  
    class DatabaseResource {
        +String connectionString
        +query(sql)
        +update(sql)
    }
  
    class APIResource {
        +String endpoint
        +call(parameters)
    }
  
    Resource &lt;|-- FileResource
    Resource &lt;|-- DatabaseResource
    Resource &lt;|-- APIResource</pre>
<h2 id="MCP与Function-Call的区别">MCP与Function Call的区别</h2>
<p>MCP和Function Call都是扩展LLM能力的技术，但它们在设计和实现上存在显著差异：</p>
<h3 id="Function-Call">Function Call</h3>
<p>Function Call（函数调用）是一种让LLM能够调用预定义函数的能力，主要特点：</p>
<ul>
<li>通常在单一环境中运行</li>
<li>函数定义必须嵌入到模型的上下文中，占用token空间</li>
<li>典型的实现是在LLM生成函数调用JSON后，由应用程序执行相应函数</li>
<li>安全边界通常由应用程序自身定义</li>
<li>通常需要为每个LLM提供商实现不同的集成方式</li>
</ul>
<pre class="mermaid">sequenceDiagram
    participant User as 用户
    participant App as 应用程序
    participant LLM as 语言模型
    participant Functions as 函数库
  
    User-&gt;&gt;App: 提出请求
    App-&gt;&gt;LLM: 请求(包含函数定义)
    Note over App,LLM: 函数定义占用上下文空间
  
    LLM-&gt;&gt;App: 函数调用JSON
    App-&gt;&gt;Functions: 执行函数
    Functions-&gt;&gt;App: 返回结果
    App-&gt;&gt;LLM: 结果作为新上下文
    LLM-&gt;&gt;App: 生成最终响应
    App-&gt;&gt;User: 显示结果</pre>
<h3 id="MCP">MCP</h3>
<p>MCP则提供了一个更加分布式、标准化的架构：</p>
<ul>
<li>采用客户端-服务器架构，明确分离责任</li>
<li>多个专用服务器可以并行提供不同功能，支持横向扩展</li>
<li>通过标准协议实现互操作性，与LLM提供商无关</li>
<li>明确的安全边界，数据保持在服务器端</li>
<li>可以跨应用程序和环境重用，提高代码复用性</li>
<li>资源动态发现，无需预先定义所有功能</li>
</ul>
<pre class="mermaid">sequenceDiagram
    participant User as 用户
    participant Host as 主机应用
    participant LLM as 语言模型
    participant Client as MCP客户端
    participant ServerA as MCP服务器A
    participant ServerB as MCP服务器B
    participant DataA as 数据源A
    participant DataB as 数据源B
  
    User-&gt;&gt;Host: 提出请求
    Host-&gt;&gt;LLM: 转发请求
  
    LLM-&gt;&gt;Host: 需要资源A
    Host-&gt;&gt;Client: 请求资源A
    Client-&gt;&gt;ServerA: MCP请求
    ServerA-&gt;&gt;DataA: 访问数据
    DataA--&gt;&gt;ServerA: 返回数据
    ServerA--&gt;&gt;Client: MCP响应
    Client--&gt;&gt;Host: 返回资源A
    Host-&gt;&gt;LLM: 提供资源A
  
    LLM-&gt;&gt;Host: 需要资源B
    Host-&gt;&gt;Client: 请求资源B
    Client-&gt;&gt;ServerB: MCP请求
    ServerB-&gt;&gt;DataB: 访问数据
    DataB--&gt;&gt;ServerB: 返回数据
    ServerB--&gt;&gt;Client: MCP响应
    Client--&gt;&gt;Host: 返回资源B
    Host-&gt;&gt;LLM: 提供资源B
  
    LLM-&gt;&gt;Host: 生成最终响应
    Host-&gt;&gt;User: 显示结果</pre>
<h2 id="MCP的优势">MCP的优势</h2>
<p>MCP相比传统Function Call和其他工具集成方法有以下优势：</p>
<ol>
<li><strong>灵活性</strong>：可以轻松切换LLM提供商和供应商，无需重写集成</li>
<li><strong>安全性</strong>：数据保持在您的基础设施内，明确的安全边界</li>
<li><strong>可扩展性</strong>：可以根据需要连接多个专用服务器，支持复杂功能</li>
<li><strong>互操作性</strong>：标准化协议确保不同系统间的兼容，避免供应商锁定</li>
<li><strong>本地计算</strong>：可以在本地环境中执行计算，无需将敏感数据发送到云端</li>
<li><strong>分布式架构</strong>：不同服务可以在不同位置运行，提高系统弹性和可用性</li>
<li><strong>动态发现</strong>：客户端可以动态发现服务器提供的资源，无需硬编码</li>
<li><strong>隔离性</strong>：不同服务器之间相互隔离，一个服务器的问题不会影响其他服务器</li>
</ol>
<h2 id="实际应用场景">实际应用场景</h2>
<p>MCP可以应用于多种场景：</p>
<ul>
<li><strong>开发环境集成</strong>：在IDE中通过MCP访问本地代码库、运行测试、执行版本控制操作</li>
<li><strong>数据分析</strong>：安全访问和处理本地数据库或文件系统中的数据，执行复杂分析</li>
<li><strong>企业应用</strong>：与内部系统安全集成，访问企业知识库、CRM系统、ERP系统等</li>
<li><strong>个人助手</strong>：访问个人文件和应用程序，同时保持数据隐私，如日历、邮件、笔记</li>
<li><strong>混合云部署</strong>：在本地和云端之间无缝集成资源，实现数据和功能的最佳分配</li>
<li><strong>多模型协作</strong>：允许多个不同的LLM通过相同的接口访问相同的资源，实现模型协作</li>
</ul>
<h2 id="MCP实现示例">MCP实现示例</h2>
<p>以下是一个简化的MCP服务器实现示例，展示了如何创建一个提供文件系统访问的MCP服务器：</p>
<pre class="mermaid">flowchart TD
    A[初始化MCP服务器] --&gt; B{注册资源处理器}
    B --&gt; C[文件读取处理器]
    B --&gt; D[文件写入处理器]
    B --&gt; E[目录列表处理器]
    C &amp; D &amp; E --&gt; F[启动HTTP服务]
    F --&gt; G{处理客户端请求}
    G --&gt; H[解析请求类型]
    H --&gt; I{资源类型?}
    I --&gt;|读取文件| J[调用文件读取处理器]
    I --&gt;|写入文件| K[调用文件写入处理器]
    I --&gt;|列出目录| L[调用目录列表处理器]
    J &amp; K &amp; L --&gt; M[格式化响应]
    M --&gt; N[返回结果给客户端]</pre>
<h2 id="MCP的发展现状">MCP的发展现状</h2>
<p>MCP是一项相对新兴的技术标准，目前正处于快速发展阶段：</p>
<ul>
<li><strong>提出与标准化</strong>：由Anthropic公司于2023年底提出并开始标准化</li>
<li><strong>当前版本</strong>：最新的MCP规范版本为2025-03-26，提供了完整的协议定义</li>
</ul>
<h3 id="支持MCP的平台和工具">支持MCP的平台和工具</h3>
<p>目前已有多个平台和工具支持MCP：</p>
<ul>
<li><strong>Claude Desktop</strong>：Anthropic的桌面应用是首个广泛支持MCP的平台，允许用户连接各种MCP服务器</li>
<li><strong>各类IDE插件</strong>：如Visual Studio Code和JetBrains系列IDE的插件开始支持MCP，提供代码编辑助手功能</li>
<li><strong>开发工具包</strong>：提供了Python、TypeScript、Java等多种语言的SDK，方便开发者构建MCP服务器</li>
<li><strong>样例实现</strong>：官方提供了文件系统、数据库连接、API调用等多种MCP服务器示例实现</li>
</ul>
<h3 id="社区与生态系统">社区与生态系统</h3>
<p>MCP正在形成活跃的开发者社区：</p>
<ul>
<li><strong>GitHub组织</strong>：ModelContextProtocol组织托管了官方规范和SDK代码</li>
<li><strong>开源贡献</strong>：社区开发者积极贡献各种MCP服务器实现和客户端集成</li>
<li><strong>商业应用</strong>：一些企业开始开发基于MCP的商业产品和服务，尤其是在企业AI和数据分析领域</li>
</ul>
<p>虽然MCP仍在发展中，但其已经显示出成为AI系统与外部世界交互的重要标准的潜力。随着更多平台和工具加入支持，MCP的生态系统有望在未来几年内迅速扩大。</p>
<h2 id="结论">结论</h2>
<p>Model Context Protocol (MCP) 代表了LLM工具集成的一种新方向，它通过标准化、分布式架构解决了许多传统方法的限制。通过将功能拆分到专用服务器，同时保持统一的协议接口，MCP为构建更强大、更安全、更灵活的AI应用程序提供了坚实的基础。</p>
<p>MCP的出现标志着AI工具集成从简单的函数调用向成熟的分布式系统架构演进，为构建下一代AI应用提供了更完善的基础设施支持。随着LLM继续融入各种应用程序和工作流程，MCP这样的标准将变得越来越重要，它使开发人员能够在保持数据安全的同时，充分发挥语言模型的潜力。<br>
言模型的潜力。</p>
]]></content>
      <categories>
        <category>前沿技术</category>
        <category>AI工程</category>
      </categories>
      <tags>
        <tag>MCP</tag>
        <tag>LLM</tag>
        <tag>工具集成</tag>
        <tag>AI架构</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 页类型详解</title>
    <url>/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/MySQL%E9%A1%B5%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="MySQL-页的概念">MySQL 页的概念</h2>
<p>在 InnoDB 存储引擎中，页(Page)是数据存储的基本单位，默认大小为 16KB。MySQL 以页为单位进行磁盘与内存之间的数据交换，这种设计可以显著减少 I/O 操作次数，提高数据库性能。</p>
<h2 id="InnoDB-页的通用结构">InnoDB 页的通用结构</h2>
<p>每个 InnoDB 页都包含以下几个部分：</p>
<ul>
<li><strong>文件头(File Header)</strong>: 记录页的控制信息，占 38 字节</li>
<li><strong>页头(Page Header)</strong>: 记录页的状态信息，占 56 字节</li>
<li><strong>主体数据区(Body)</strong>: 存储实际数据</li>
<li><strong>文件尾(File Trailer)</strong>: 用于页面完整性检查，占 8 字节</li>
</ul>
<h2 id="MySQL-中的主要页类型">MySQL 中的主要页类型</h2>
<h3 id="1-数据页-B-tree-Node">1. 数据页(B-tree Node)</h3>
<p>数据页是最常见的页类型，用于存储表中的实际数据记录。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>使用 B+树结构组织</li>
<li>包含多条记录</li>
<li>记录按主键顺序排列</li>
<li>叶子节点包含完整的用户数据</li>
<li>非叶子节点只包含索引键值和指向子页的指针</li>
</ul>
<p>数据页结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">| File Header      |</span><br><span class="line">+------------------+</span><br><span class="line">| Page Header      |</span><br><span class="line">+------------------+</span><br><span class="line">| Infimum Record   |</span><br><span class="line">+------------------+</span><br><span class="line">| User Records     |</span><br><span class="line">+------------------+</span><br><span class="line">| Free Space       |</span><br><span class="line">+------------------+</span><br><span class="line">| Supremum Record  |</span><br><span class="line">+------------------+</span><br><span class="line">| Page Directory   |</span><br><span class="line">+------------------+</span><br><span class="line">| File Trailer     |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>
<h3 id="2-索引页-Index-Page">2. 索引页(Index Page)</h3>
<p>索引页专门用于存储索引信息，加速数据检索。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>也使用 B+树结构</li>
<li>非聚集索引的叶子节点存储主键值</li>
<li>非叶子节点存储索引键值和指向子页的指针</li>
</ul>
<h3 id="3-撤销页-Undo-Log-Page">3. 撤销页(Undo Log Page)</h3>
<p>撤销页用于存储撤销日志记录，支持事务回滚和 MVCC(多版本并发控制)。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>记录数据修改前的状态</li>
<li>按事务分组组织</li>
<li>支持事务的原子性和隔离性</li>
</ul>
<h3 id="4-系统页-System-Page">4. 系统页(System Page)</h3>
<p>系统页用于存储 InnoDB 内部系统信息。</p>
<p><strong>主要系统页</strong>：</p>
<ul>
<li><strong>数据字典页</strong>: 存储表定义等元数据</li>
<li><strong>双写缓冲页</strong>: 用于防止部分写失效</li>
<li><strong>插入缓冲位图页</strong>: 记录哪些索引页包含插入缓冲记录</li>
<li><strong>事务系统页</strong>: 存储活跃事务信息</li>
</ul>
<h3 id="5-溢出页-Overflow-Page">5. 溢出页(Overflow Page)</h3>
<p>当记录太长无法完全存储在数据页中时，使用溢出页存储额外数据。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>用于存储大字段(如 TEXT, BLOB)</li>
<li>通过指针从主数据页链接</li>
<li>可能有多个连续的溢出页形成链表</li>
</ul>
<h3 id="6-压缩页-Compressed-Page">6. 压缩页(Compressed Page)</h3>
<p>针对表启用压缩特性时使用的特殊页格式。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>节省磁盘空间</li>
<li>支持 1KB, 2KB, 4KB, 8KB 等多种压缩页大小</li>
<li>包含额外的解压缩信息</li>
</ul>
<h3 id="7-临时页-Temporary-Page">7. 临时页(Temporary Page)</h3>
<p>用于临时表或排序等操作的页。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>存储在临时表空间</li>
<li>仅在会话期间有效</li>
<li>不写入 redo 日志</li>
</ul>
<h3 id="8-碎片页-Fragment-Page">8. 碎片页(Fragment Page)</h3>
<p>用于管理表空间中空闲空间的页。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>记录可用于分配的空闲空间</li>
<li>避免产生碎片</li>
<li>提高空间利用率</li>
</ul>
<h2 id="页类型对性能的影响">页类型对性能的影响</h2>
<p>不同类型的页在 MySQL 性能中扮演着重要角色：</p>
<ol>
<li><strong>数据页和索引页</strong>: 直接影响查询性能，缓冲池中的这些页越多，命中率越高，性能越好</li>
<li><strong>撤销页</strong>: 过多的撤销页可能表明有长时间运行的事务，可能影响并发性能</li>
<li><strong>压缩页</strong>: 减少 I/O 但增加 CPU 开销，需权衡</li>
<li><strong>溢出页</strong>: 访问大字段时可能导致额外 I/O，影响性能</li>
</ol>
<h2 id="如何查看页信息">如何查看页信息</h2>
<p>可以使用 InnoDB 监控工具和性能模式查看页的使用情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看InnoDB buffer pool中的页统计信息</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表的页信息(MySQL 8.0+)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TABLES</span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;database_name/table_name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引的页信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_INDEXES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_ID <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>MySQL 的页是其存储系统的核心组件，不同类型的页协同工作，确保数据的完整性、一致性和高效访问。理解这些页类型有助于优化数据库设计和性能调优。对于大型数据库系统，优化页的使用和配置(如缓冲池大小、页压缩等)可以显著提高性能。</p>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>MySQL</tag>
        <tag>记录存储方式</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL 记录存储方式</title>
    <url>/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="MYSQL-数据文件存放位置">MYSQL 数据文件存放位置</h2>
<p>使用 <code>show variables like 'datadir';</code> 命令查看数据文件存放位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;datadir&#x27;</span>;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br></pre></td></tr></table></figure>
<p>比如我们的数据库是 <code>test</code>，那么数据文件存放位置就是 <code>/var/lib/mysql/test/</code>。</p>
<p>该目录下有以下文件：</p>
<ul>
<li><code>db.opt</code>：数据库选项文件，记录了数据库的字符集和校验规则</li>
<li><code>test.frm</code>：表结构文件，记录了表的结构</li>
<li><code>test.ibd</code>：表数据文件，记录了表的数据，包括数据页和索引页，它也被称作 <code>InnoDB</code> 存储引擎的 <code>表空间文件</code></li>
</ul>
<h2 id="表空间文件结构">表空间文件结构</h2>
<p>表空间主要由 <strong>段(segment)</strong>、<strong>区(extent)</strong>、<strong>页(page)</strong>、<strong>行(row)</strong> 组成。</p>
<ul>
<li>
<p><strong>行(row)</strong>：行是表空间的最小存储单位，是 <code>InnoDB</code> 存储引擎中数据存储的基本单位。</p>
</li>
<li>
<p><strong>页(page)</strong>：页是 <code>InnoDB</code> 存储引擎中数据存储的基本单位，一个页默认大小为 <code>16KB</code>,页是为了方便管理数据，否则直接以行来存储数据，那么每次存取数据都要进行 <code>I/O</code> 操作，效率低下。每次数据库的读写操作都是以页为单位进行的。页的类型有很多，比如数据页、索引页、回滚页、溢出页、临时页、系统页、事务数据页、文件页等，具体参考<a href="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/MySQL%E9%A1%B5%E7%B1%BB%E5%9E%8B/">MySQL 页类型</a>。</p>
</li>
<li>
<p><strong>区(extent)</strong>：区是 <code>InnoDB</code> 存储引擎中数据存储的基本单位，一个区默认大小为 <code>1MB</code>，一个区由 <code>64</code> 个页组成。</p>
<blockquote>
<p>首先我们知道 <code>InnoDB</code> 存储引擎是 <code>B+</code> 树结构，<code>B+</code> 树结构的最后一层是使用双向链表连接的，那么如果链表中相邻的页的物理位置很远，那么磁盘查询会带来大量的<strong>随机 I/O</strong>（跟磁盘的机械运动有关），影响查询效率。</p>
<p>因此 <code>InnoDB</code> 存储引擎引入了区的概念，一个区由 <code>64</code> 个页组成，这样就可以将物理位置相邻的页放到一个区中，从而减少磁盘的随机 <code>I/O</code> 操作，提高<strong>顺序 I/O</strong>的频率，提高查询效率。</p>
</blockquote>
</li>
<li>
<p><strong>段(segment)</strong>：表空间是由多个段组成的，段是由多个区组成的，一般来说，段分为数据段、索引段、回滚段等。</p>
<ul>
<li>数据段：存放 <code>InnoDB</code> 存储引擎中叶子节点的区的集合。</li>
<li>索引段：存放 <code>InnoDB</code> 存储引擎中非叶子节点的区的集合。</li>
<li>回滚段：存放 <code>InnoDB</code> 存储引擎中表的回滚数据的集合。就是事务隔离部分，使用 <code>MVCC</code> 机制，就利用了回滚段来实现多版本查询数据。</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745323847902.png" alt="1745323847902"></p>
<h2 id="InnoDB-行格式">InnoDB 行格式</h2>
<p>InnoDB 提供了 <code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>、<code>Compressed</code> 四种行格式，5.1 版本后默认使用 <code>Compact</code> 行格式，5.7 版本后默认使用 <code>Dynamic</code> 行格式。</p>
<blockquote>
<p>这里的 <code>Redundant</code> 行格式是 <code>InnoDB</code> 早期版本使用的行格式，现在已经不再使用。因为 Redundant 不是一种紧凑的行格式，所以现在使用 <code>Compact</code> 行格式。</p>
<p><code>Dynamic</code> 和 <code>Compressed</code> 行格式都和 <code>Compact</code> 行格式类似，都是对 <code>Compact</code> 行格式的一种优化。</p>
</blockquote>
<h3 id="Compact-行格式">Compact 行格式</h3>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/COMPACT-ROW.png" alt="1745324130903"></p>
<p>如上图所示，一条完整的记录被分为了“记录的额外信息”和“记录的真实数据”两部分。</p>
<ul>
<li>
<p>“记录的额外信息”：</p>
<ul>
<li><code>变长字段长度列表</code>：表示该条记录中变长字段的长度。</li>
<li><code>NULL 值列表</code>：表示该条记录中哪些字段为 <code>NULL</code>。</li>
<li><code>记录头信息</code>：表示该条记录的一些信息，比如记录的类型、长度、是否被删除等。</li>
</ul>
</li>
<li>
<p>“记录的真实数据”：</p>
<ul>
<li><code>row_id</code>：表示该条记录的唯一标识，如果表中没有定义主键，那么 <code>InnoDB</code> 会自动生成一个 <code>row_id</code> 作为主键。</li>
<li><code>事务ID</code>：表示该条记录的事务 ID。</li>
<li><code>回滚指针</code>：表示该条记录的回滚指针。</li>
<li><code>列1...列N</code>：表示该条记录的列数据。</li>
</ul>
</li>
</ul>
<h4 id="变长字段长度列表">变长字段长度列表</h4>
<p>比如 <code>varchar</code>、<code>varbinary</code>、<code>text</code>、<code>blob</code> 等这种属于变长字段，就需要把它的长度存起来，因此需要一个列表来记录每个变长字段的长度。</p>
<p>假设我们有如下的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> <span class="keyword">CHARACTER SET</span> <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> COMPACT;</span><br></pre></td></tr></table></figure>
<p>假设这里有三条记录:</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>phone</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>123</td>
<td>18</td>
</tr>
<tr>
<td>2</td>
<td>bb</td>
<td>1234</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>ccc</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<p>我们先来看第一条记录：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>phone</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>123</td>
<td>18</td>
</tr>
</tbody>
</table>
<p><code>name</code> 列的值为 a，真实数据占用 1 字节，十六进制为 0x01，<code>phone</code> 列的值为 123，真实数据占用 3 字节，十六进制为 0x03，<code>age</code> 和 <code>id</code> 列都是定长字段，这里不用记录长度。</p>
<p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「03 01」，而不是「01 03」。</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459344704.png" alt="1745459344704"></p>
<p>同样的道理，我们也可以得出<strong>第二条记录</strong>的行格式中，「变长字段长度列表」里的内容是「04 02」，如下图：</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459442389.png" alt="1745459442389"></p>
<p><strong>第三条记录</strong>中 phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459442389.png" alt="1745459442389"></p>
<blockquote>
<p>为什么「变长字段长度列表」的信息要按照逆序存放？</p>
</blockquote>
<p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p>
<p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p>
<p>同样的道理，NULL 值列表的信息也需要逆序存放。</p>
<p>如果你不知道什么是 CPU Cache，可以看<a href="https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html">这篇文章</a>，这属于计算机组成的知识。</p>
<blockquote>
<p>每个数据库表的行格式都有「变长字段字节数列表」吗？</p>
</blockquote>
<p>其实变长字段字节数列表不是必须的。</p>
<p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p>
<p>所以「变长字段长度列表」只出现在数据表有变长字段的时候。</p>
<h4 id="2-NULL-值列表">2. NULL 值列表</h4>
<p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL 值列表中。</p>
<p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p>
<ul>
<li>二进制位的值为 <code>1</code>时，代表该列的值为 NULL。</li>
<li>二进制位的值为 <code>0</code>时，代表该列的值不为 NULL。</li>
</ul>
<p>另外，NULL 值列表必须用整数个字节的位表示（1 字节 8 位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p>
<p>还是以 t_user 表的这三条记录作为例子：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>phone</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>a</td>
<td>123</td>
<td>18</td>
</tr>
<tr>
<td>2</td>
<td>bb</td>
<td>1234</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>ccc</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<p>接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。</p>
<p>先来看<strong>第一条记录</strong>，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459724424.png" alt="1745459724424"></p>
<p>但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459735372.png" alt="1745459735372"></p>
<p>所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。</p>
<p>接下来看<strong>第二条记录</strong>，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL 值列表用十六进制表示是 0x04。</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459744703.png" alt="1745459744703"></p>
<p>最后<strong>第三条记录</strong>，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459751962.png" alt="1745459751962"></p>
<p>我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459765680.png" alt="1745459765680"></p>
<blockquote>
<p>每个数据库表的行格式都有「NULL 值列表」吗？</p>
</blockquote>
<p>NULL 值列表也不是必须的。</p>
<p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p>
<p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p>
<blockquote>
<p>「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？</p>
</blockquote>
<p>「NULL 值列表」的空间不是固定 1 字节的。</p>
<p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p>
<h4 id="3-记录头信息">3. 记录头信息</h4>
<p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p>
<ul>
<li>delete_mask：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li>
<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li>record_type：表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶子节点记录，2 表示最小记录，3 表示最大记录</li>
</ul>
<h3 id="记录的真实数据">记录的真实数据</h3>
<p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745459796350.png" alt="1745459796350"></p>
<ul>
<li>row_id</li>
</ul>
<p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id 不是必需的，占用 6 个字节。</p>
<ul>
<li>trx_id</li>
</ul>
<p>事务 id，表示这个数据是由哪个事务生成的。trx_id 是必需的，占用 6 个字节。</p>
<ul>
<li>roll_pointer</li>
</ul>
<p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p>
<p>如果你熟悉 MVCC 机制，你应该就清楚 trx_id 和 roll_pointer 的作用了，如果你还不知道 MVCC 机制，可以看完<a href="/2025/05/06/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E4%BA%8B%E5%8A%A1/2025-05-06-MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">这篇文章</a>，一定要掌握，面试也很经常问 MVCC 是怎么实现的。</p>
<blockquote>
<p>Mysql 中规定，<strong>除了 <code>Text</code>、<code>Blob</code>类型，其他类型其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>，这里注意一下，65535 是 <code>&lt;font color=&quot;red&quot;&gt;</code>一行 <code>&lt;/font&gt;</code>的最大字节数，而不是一个列的最大字节数。</p>
<p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 &lt;= 65535。</p>
<p><img src="/2025/04/22/%E5%85%AB%E8%82%A1%E6%96%87/MYSQL/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/1745466102232.png" alt="1745466102232"></p>
</blockquote>
]]></content>
      <categories>
        <category>八股文</category>
        <category>MySQL</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>MySQL</tag>
        <tag>记录存储方式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 142 - 环形链表 II (Linked List Cycle II)</title>
    <url>/2025/04/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-142-Linked-List-Cycle-II/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个链表的头节点 <code>head</code>，返回链表开始入环的第一个节点。如果链表无环，则返回 <code>null</code>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改链表</strong>。</p>
<h3 id="示例">示例</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>链表可视化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 → 2 → 0 → -4</span><br><span class="line">    ↑     ↓</span><br><span class="line">    ← ← ← ←</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p>链表可视化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 → 2</span><br><span class="line">↑   ↓</span><br><span class="line">← ← ←</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p>链表可视化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 → null</span><br></pre></td></tr></table></figure>
<h3 id="约束条件">约束条件</h3>
<ul>
<li>链表中节点的数目范围在范围 [0, 10^4] 内</li>
<li>-10^5 &lt;= Node.val &lt;= 10^5</li>
<li>pos 的值为 -1 或者链表中的一个有效索引</li>
</ul>
<h3 id="进阶">进阶</h3>
<p>你是否可以使用 O(1) 空间解决此题？</p>
<h2 id="解题思路">解题思路</h2>
<h3 id="方法一：快慢指针（Floyd-判圈算法）">方法一：快慢指针（Floyd 判圈算法）</h3>
<p>本题的核心思路是使用<strong>快慢指针</strong>（也称为 Floyd 判圈算法或龟兔赛跑算法）来解决。这是一种<strong>检测链表中是否存在环</strong>并找到环入口点的经典算法。</p>
<h4 id="算法分析和数学证明">算法分析和数学证明</h4>
<p>这个算法分为两个阶段：</p>
<ol>
<li><strong>检测环的存在</strong>：使用快慢指针，如果它们相遇，则存在环</li>
<li><strong>寻找环的入口</strong>：通过数学关系确定环的入口点</li>
</ol>
<p>让我们详细解析这个过程，并进行数学推导：</p>
<p><strong>第一阶段：检测环的存在</strong></p>
<ol>
<li>设置两个指针 <code>slow</code> 和 <code>fast</code>，初始时都指向链表头节点 <code>head</code></li>
<li><code>slow</code> 指针每次移动 1 步，<code>fast</code> 指针每次移动 2 步</li>
<li>如果链表中存在环，这两个指针最终会在环中某个节点相遇</li>
<li>如果 <code>fast</code> 指针到达了链表末尾（即 <code>fast</code> 或 <code>fast.next</code> 为 <code>null</code>），则链表不存在环</li>
</ol>
<p><strong>第二阶段：寻找环的入口</strong></p>
<p>数学推导是这个算法的关键。假设：</p>
<ul>
<li>链表头到环入口点的距离为 <code>a</code> 步</li>
<li>环入口点到相遇点的距离为 <code>b</code> 步</li>
<li>相遇点回到环入口点的距离为 <code>c</code> 步</li>
</ul>
<p>那么环的总长度为 <code>b + c</code> 步。</p>
<h4 id="环形链表示意图">环形链表示意图</h4>
<h5 id="Mermaid-图示">Mermaid 图示</h5>
<pre class="mermaid">graph LR
    Head((Head)) --&gt; A((A))
    A --&gt; B((B))
    B --&gt; C((C))
    C --&gt; D((D))
    D --&gt; E((E))
    E --&gt; F((F))
    F --&gt; C
  
    style C fill:#f96,stroke:#333
    style F fill:#69f,stroke:#333
  
    Head -.-&gt; |&quot;链表头&quot;|A
    C -.-&gt; |&quot;环入口点&quot;|C
    F -.-&gt; |&quot;相遇点&quot;|F
  
    A -.-&gt; |&quot;距离 a&quot;|C
    C -.-&gt; |&quot;距离 b&quot;|F
    F -.-&gt; |&quot;距离 c&quot;|C</pre>
<h5 id="纯文本图示">纯文本图示</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                 环入口</span><br><span class="line">                    ↓</span><br><span class="line">head → A → B → C → D → E</span><br><span class="line">                ↑       ↓</span><br><span class="line">                ↑       ↓</span><br><span class="line">                ↑       ↓</span><br><span class="line">                G ← F ← F ← 相遇点</span><br><span class="line">              </span><br><span class="line">距离标记:</span><br><span class="line">head到环入口C的距离: a</span><br><span class="line">环入口C到相遇点F的距离: b</span><br><span class="line">相遇点F返回环入口C的距离: c</span><br></pre></td></tr></table></figure>
<p>另一种表示方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      a         b</span><br><span class="line">    +---+     +---+</span><br><span class="line">    ↓   ↓     ↓   ↓</span><br><span class="line">head → → → → → → → +</span><br><span class="line">            ↑     ↓</span><br><span class="line">            ↑     ↓</span><br><span class="line">            ↑     ↓</span><br><span class="line">            + ← ← +</span><br><span class="line">            ↑</span><br><span class="line">            +</span><br><span class="line">            c</span><br></pre></td></tr></table></figure>
<p>当 <code>slow</code> 和 <code>fast</code> 指针相遇时：</p>
<ul>
<li><code>slow</code> 走了 <code>a + b</code> 步</li>
<li><code>fast</code> 走了 <code>a + b + n(b + c)</code> 步，其中 <code>n</code> 是 <code>fast</code> 指针在环中绕的圈数</li>
</ul>
<p>由于 <code>fast</code> 指针走的步数是 <code>slow</code> 指针的 2 倍，所以有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a + b + n(b + c) = 2(a + b)</span><br></pre></td></tr></table></figure>
<p>化简：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a + b + n(b + c) = 2a + 2b</span><br><span class="line">n(b + c) = a + b</span><br><span class="line">a = n(b + c) - b = (n-1)(b + c) + c</span><br></pre></td></tr></table></figure>
<p>对于 n=1 的情况（即 fast 指针绕环一圈就与 slow 相遇），我们有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = c</span><br></pre></td></tr></table></figure>
<p>这个结论非常重要：<strong>从链表头到环入口的距离，等于从相遇点继续前进到环入口的距离</strong>。</p>
<p>基于这个发现，我们的算法第二阶段为：</p>
<ol>
<li>将 <code>fast</code> 指针重新指向链表头节点</li>
<li>保持 <code>slow</code> 指针在相遇点</li>
<li>让两个指针每次都移动 1 步</li>
<li>它们最终会在环的入口点相遇</li>
</ol>
<p>这种方法的巧妙之处在于我们不需要知道环的长度或链表的长度，也不需要额外的空间来记录已访问过的节点。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 阶段一：检测环的存在</span></span><br><span class="line">    slow, fast := head, head</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 如果到达链表末尾，则无环</span></span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 快指针移动两步，慢指针移动一步</span></span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果两指针相遇，则存在环</span></span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 阶段二：寻找环的入口</span></span><br><span class="line">    <span class="comment">// 重置快指针到链表头，慢指针保持在相遇点</span></span><br><span class="line">    fast = head</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 两个指针每次都移动一步</span></span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当两指针再次相遇时，就是环的入口点</span></span><br><span class="line">    <span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是链表中节点的数量。在最坏情况下，需要遍历整个链表一次才能确定是否有环，然后再遍历部分链表找到环的入口。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用了两个指针，不需要额外的空间。</li>
</ul>
<h2 id="不同方法比较">不同方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>快慢指针法</th>
<th>哈希表法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>空间效率高</td>
<td>实现简单直观</td>
</tr>
<tr>
<td>缺点</td>
<td>数学分析较复杂</td>
<td>需要额外空间</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>Floyd 判圈算法</strong>是解决链表环检测问题的经典算法，它不仅可以检测环的存在，还能找到环的入口点。</li>
<li>该算法的数学推导很巧妙：从链表头到环入口的距离等于从相遇点继续前进到环入口的距离。</li>
<li>我们可以用 O(1) 的空间复杂度解决此问题，这比使用哈希表需要 O(n) 空间的方法更加高效。</li>
<li>这种双指针的技巧在链表问题中非常常见，掌握这种思想可以帮助解决许多类似问题，如寻找链表中点、检测环、寻找倒数第 k 个节点等。</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 234 - 回文链表（Palindrome Linked List）</title>
    <url>/2025/04/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-234-Palindrome-Linked-List/</url>
    <content><![CDATA[<h2 id="Problem-Description">Problem Description</h2>
<p>给你一个单链表的头节点 <code>head</code>，请你判断该链表是否为回文链表。如果是，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p>回文链表指的是从前往后读和从后往前读是一样的链表。例如，<code>1-&gt;2-&gt;2-&gt;1</code> 是回文链表，而 <code>1-&gt;2</code> 不是回文链表。</p>
<h3 id="Examples">Examples</h3>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>可视化表示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>可视化表示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 -&gt; 2</span><br></pre></td></tr></table></figure>
<h3 id="Constraints">Constraints</h3>
<ul>
<li>链表中节点数目在范围 [1, 10^5] 内</li>
<li>0 &lt;= Node.val &lt;= 9</li>
</ul>
<p><strong>进阶</strong>：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h2 id="Solution-Approach">Solution Approach</h2>
<p>对于回文链表的判断，我们需要考虑几个关键点：</p>
<ol>
<li>链表不能像数组那样随机访问，无法直接从两端同时向中间比较</li>
<li>直观思路是将链表转为数组，但这需要 O(n) 额外空间</li>
<li>最优解法需要找到链表中点，反转后半部分，然后比较两半部分</li>
</ol>
<p>以下我会介绍多种解决此问题的方法，从简单到优化逐步讲解。</p>
<h3 id="方法一：转换为数组">方法一：转换为数组</h3>
<p>最直观的方法是将链表节点值复制到数组中，然后使用双指针判断数组是否回文。</p>
<h4 id="实现细节">实现细节</h4>
<ol>
<li>遍历链表，将所有节点值存入数组</li>
<li>使用双指针从数组两端向中间移动并比较</li>
</ol>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 将链表值复制到数组</span></span><br><span class="line">    vals := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> node := head; node != <span class="literal">nil</span>; node = node.Next &#123;</span><br><span class="line">        vals = <span class="built_in">append</span>(vals, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 使用双指针判断数组是否回文</span></span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(vals)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> vals[i] != vals[j] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：使用栈">方法二：使用栈</h3>
<p>利用栈的特性，我们可以先将前半部分节点值入栈，然后与后半部分比较。</p>
<h4 id="实现细节-2">实现细节</h4>
<ol>
<li>使用快慢指针找到链表中点</li>
<li>将前半部分节点值入栈</li>
<li>比较栈中元素与后半部分节点值</li>
</ol>
<h4 id="代码实现-2">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 快慢指针找中点</span></span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    stack := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将前半部分入栈</span></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, slow.Val)</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果链表长度为奇数，跳过中间节点</span></span><br><span class="line">    <span class="keyword">if</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 比较栈顶元素与后半部分</span></span><br><span class="line">    <span class="keyword">for</span> slow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != slow.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：原地反转（原始实现）">方法三：原地反转（原始实现）</h3>
<p>这是用户提供的原始解法，使用 O(n) 时间和 O(1) 空间。</p>
<h4 id="实现细节-3">实现细节</h4>
<ol>
<li>使用快慢指针找到链表中点</li>
<li>反转后半部分链表</li>
<li>比较前半部分和反转后的后半部分</li>
</ol>
<h4 id="代码实现（原始版本）">代码实现（原始版本）</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">        <span class="keyword">if</span> fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head2 := slow.Next</span><br><span class="line">    slow.Next = <span class="literal">nil</span></span><br><span class="line">    head2 = reverseListTmp(head2)</span><br><span class="line"></span><br><span class="line">    cur1, cur2 := head, head2</span><br><span class="line">    <span class="keyword">for</span> cur2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur1.Val != cur2.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = cur1.Next</span><br><span class="line">        cur2 = cur2.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseListTmp</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cur, prev *ListNode</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        tmp := cur.Next</span><br><span class="line">        cur.Next = prev</span><br><span class="line">        prev = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法四：优化的原地反转（最优解）">方法四：优化的原地反转（最优解）</h3>
<p>在原始实现的基础上，我们可以进行一些优化，使代码更加健壮和易读。</p>
<h4 id="实现细节-4">实现细节</h4>
<ol>
<li>更清晰地处理边界情况</li>
<li>简化找中点的逻辑</li>
<li>明确区分奇偶长度链表的处理</li>
<li>模块化功能，提高代码可读性</li>
<li>提供可选的链表恢复功能</li>
</ol>
<h4 id="代码实现（优化版本）">代码实现（优化版本）</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找链表中点</span></span><br><span class="line">    fast, slow := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理奇数长度链表的情况</span></span><br><span class="line">    <span class="keyword">var</span> secondHalf *ListNode</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 偶数长度</span></span><br><span class="line">        secondHalf = slow</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 奇数长度，中间节点不参与比较</span></span><br><span class="line">        secondHalf = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 断开链表</span></span><br><span class="line">    firstHalfEnd := slow</span><br><span class="line">    <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">        firstHalfEnd = findPredecessor(head, slow)</span><br><span class="line">    &#125;</span><br><span class="line">    firstHalfEnd.Next = <span class="literal">nil</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 反转后半部分</span></span><br><span class="line">    secondHalf = reverseList(secondHalf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两半部分</span></span><br><span class="line">    result := compareHalves(head, secondHalf)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可选：恢复链表结构</span></span><br><span class="line">    <span class="comment">// firstHalfEnd.Next = reverseList(secondHalf)</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到前驱节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPredecessor</span><span class="params">(head, target *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    curr := head</span><br><span class="line">    <span class="keyword">for</span> curr != <span class="literal">nil</span> &amp;&amp; curr.Next != target &#123;</span><br><span class="line">        curr = curr.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareHalves</span><span class="params">(first, second *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> first != <span class="literal">nil</span> &amp;&amp; second != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> first.Val != second.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        first = first.Next</span><br><span class="line">        second = second.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> prev *ListNode</span><br><span class="line">    curr := head</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := curr.Next</span><br><span class="line">        curr.Next = prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = next</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法五：递归解法">方法五：递归解法</h3>
<p>递归方法也可以用来解决此问题，但需要 O(n) 的栈空间。</p>
<h4 id="实现细节-5">实现细节</h4>
<ol>
<li>使用递归遍历到链表末尾</li>
<li>回溯时，与前面的节点比较</li>
</ol>
<h4 id="代码实现-3">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    frontPointer := head</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> recursiveCheck <span class="function"><span class="keyword">func</span><span class="params">(*ListNode)</span></span> <span class="type">bool</span></span><br><span class="line">    recursiveCheck = <span class="function"><span class="keyword">func</span><span class="params">(currentNode *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> currentNode != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !recursiveCheck(currentNode.Next) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> frontPointer.Val != currentNode.Val &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> recursiveCheck(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Comparison-of-Approaches">Comparison of Approaches</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>方法一：数组</th>
<th>方法二：栈</th>
<th>方法三：原始反转</th>
<th>方法四：优化反转</th>
<th>方法五：递归</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单</td>
<td>直观易懂</td>
<td>空间效率高</td>
<td>代码健壮，易于理解</td>
<td>简洁优雅</td>
</tr>
<tr>
<td>缺点</td>
<td>空间开销大</td>
<td>空间开销大</td>
<td>代码结构不够清晰</td>
<td>略微复杂</td>
<td>使用了隐式栈空间</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★☆☆☆</td>
<td>★★☆☆☆</td>
<td>★★★★☆</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="Complexity-Analysis">Complexity Analysis</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>所有方法的时间复杂度都是 O(n)，其中 n 是链表的长度。这是因为所有方法都需要至少遍历一次链表。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li>方法一（数组）：需要 O(n) 额外空间存储数组</li>
<li>方法二（栈）：需要 O(n) 额外空间存储栈</li>
<li>方法三和方法四（反转）：只需要几个指针变量，空间复杂度为 O(1)</li>
<li>方法五（递归）：由于递归调用栈，需要 O(n) 空间</li>
</ul>
<h2 id="Key-Learnings">Key Learnings</h2>
<ol>
<li><strong>快慢指针</strong>：找链表中点的有效技术，对于链表操作很常用</li>
<li><strong>原地反转</strong>：链表反转是一个重要的基本操作，可以不使用额外空间完成</li>
<li><strong>空间与时间权衡</strong>：此题展示了如何通过算法优化将空间复杂度从 O(n) 降至 O(1)</li>
<li><strong>代码模块化</strong>：将复杂功能拆分为多个函数可以提高代码的可读性和可维护性</li>
<li><strong>边界条件处理</strong>：链表操作中需要特别注意空链表、单节点链表等边界条件</li>
</ol>
<p>在实际应用中，方法四（优化的原地反转）是最推荐的解法，因为它既满足了进阶要求的 O(1) 空间复杂度，又保持了代码的清晰性和健壮性。值得注意的是，如果链表结构在操作后需要保持不变，可以考虑添加链表恢复步骤。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 206 - 反转链表（Reverse Linked List）</title>
    <url>/2025/04/21/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-206-Reverse-Linked-List/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你单链表的头节点 <code>head</code>，请你反转链表，并返回反转后的链表。</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>
<h3 id="示例-3：">示例 3：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<h3 id="约束条件：">约束条件：</h3>
<ul>
<li>链表中节点的数目范围是 [0, 5000]</li>
<li>-5000 &lt;= Node.val &lt;= 5000</li>
</ul>
<p><strong>进阶</strong>：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h2 id="解题思路">解题思路</h2>
<p>反转链表是一个经典问题，有两种主要的解法：迭代法和递归法。</p>
<h3 id="方法一：迭代法">方法一：迭代法</h3>
<p>迭代法的核心思想是：遍历链表，将当前节点的 <code>next</code> 指针改为指向前一个节点。由于单链表只能从前往后遍历，我们需要使用额外的指针来记录当前节点的前一个节点和后一个节点。</p>
<p>基本步骤：</p>
<ol>
<li>初始化三个指针：<code>prev</code>（前一个节点）初始为 <code>nil</code>，<code>curr</code>（当前节点）初始为 <code>head</code>，<code>next</code>（下一个节点）在循环中赋值。</li>
<li>在遍历过程中，我们首先保存当前节点的下一个节点，防止链表断开后无法继续遍历。</li>
<li>将当前节点的 <code>next</code> 指针指向 <code>prev</code>。</li>
<li>将 <code>prev</code> 和 <code>curr</code> 指针向前移动一步。</li>
<li>重复步骤 2-4，直到 <code>curr</code> 指向 <code>nil</code>，表示已经遍历完整个链表。</li>
</ol>
<h3 id="方法二：递归法">方法二：递归法</h3>
<p>递归法的核心思想是：假设链表后面的部分已经反转完成，我们只需要处理当前节点和子问题的关系。</p>
<p>基本思路：</p>
<ol>
<li>终止条件：当链表为空或只有一个节点时，反转后的结果就是它本身，直接返回。</li>
<li>递归调用：对除了头节点以外的其他节点进行反转，并得到新的头节点（反转后链表的头）。</li>
<li>处理当前节点：将当前节点的下一个节点的 <code>next</code> 指向当前节点，并将当前节点的 <code>next</code> 设为 <code>nil</code>。</li>
<li>返回新的头节点。</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<h3 id="递归实现">递归实现</h3>
<p>在递归方法中，关键在于理解子问题的边界和如何处理当前节点与子问题的关系。</p>
<p>当我们递归地反转 <code>head.Next</code> 及其后面的节点时，我们得到了一个新的头节点 <code>newHead</code>，它是原链表的最后一个节点。此时，除了 <code>head</code> 节点外，其他所有节点都已反转完成。我们只需要将 <code>head.Next.Next</code> 指向 <code>head</code>（让原来的下一个节点指向自己），然后将 <code>head.Next</code> 设为 <code>nil</code>（断开原来的连接），就完成了整个链表的反转。</p>
<h3 id="迭代实现">迭代实现</h3>
<p>在迭代方法中，我们需要小心处理指针的移动，确保不会丢失链表的任何部分。特别是在反转当前节点的 <code>next</code> 指针之前，我们需要先保存下一个节点的引用。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="递归解法">递归解法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line">	newHead := reverseList(head.Next)</span><br><span class="line"></span><br><span class="line">	head.Next.Next = head</span><br><span class="line">	head.Next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代解法">迭代解法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cur, prev *ListNode</span><br><span class="line">	prev = head</span><br><span class="line">	cur = head.Next</span><br><span class="line">	prev.Next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		tmp := cur.Next</span><br><span class="line">		cur.Next = prev</span><br><span class="line">		prev = cur</span><br><span class="line">		cur = tmp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化建议">优化建议</h2>
<p>对于上述迭代解法，虽然结果是正确的，但有几点可以优化：</p>
<ol>
<li><strong>初始化指针</strong>：标准的做法是将 <code>prev</code> 初始化为 <code>nil</code>，<code>cur</code> 初始化为 <code>head</code>，这样可以更简洁地处理各种情况，包括空链表和只有一个节点的链表。</li>
<li><strong>特殊情况处理</strong>：虽然代码中有对 <code>head == nil || head.Next == nil</code> 的特殊情况处理，但使用标准的初始化方式后，这个特殊处理是不必要的，因为迭代过程会自然地处理这些情况。</li>
<li><strong>代码简化</strong>：可以将初始化和迭代过程简化，减少不必要的步骤。</li>
</ol>
<p>优化后的迭代版本如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">var</span> prev *ListNode</span><br><span class="line">	curr := head</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">		next := curr.Next    <span class="comment">// 临时保存下一个节点</span></span><br><span class="line">		curr.Next = prev     <span class="comment">// 反转当前节点的指针</span></span><br><span class="line">		prev = curr          <span class="comment">// 移动 prev 指针</span></span><br><span class="line">		curr = next          <span class="comment">// 移动 curr 指针</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> prev  <span class="comment">// prev 现在指向新的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个优化版本的特点是：</p>
<ul>
<li>代码更简洁，逻辑更清晰</li>
<li>不需要特殊处理空链表或单节点链表的情况</li>
<li>变量命名更规范，使用 <code>curr</code> 和 <code>next</code> 更容易理解</li>
</ul>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li><strong>递归解法</strong>：O(n)，其中 n 是链表的长度。我们需要对每个节点调用一次递归函数。</li>
<li><strong>迭代解法</strong>：O(n)，其中 n 是链表的长度。我们需要遍历整个链表一次。</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<ul>
<li><strong>递归解法</strong>：O(n)，其中 n 是链表的长度。主要是由于递归调用栈的开销。</li>
<li><strong>迭代解法</strong>：O(1)，只需要常数级别的额外空间。</li>
</ul>
<h2 id="两种方法的比较">两种方法的比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>递归解法</th>
<th>迭代解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>代码简洁，思路清晰</td>
<td>空间效率高</td>
</tr>
<tr>
<td>缺点</td>
<td>空间开销大，可能栈溢出</td>
<td>代码稍复杂，需要多个指针</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li>
<p><strong>指针操作</strong>：链表问题的核心是指针操作，需要小心处理指针的移动和更新，避免链表断裂或形成环。</p>
</li>
<li>
<p><strong>迭代与递归</strong>：链表问题通常可以使用迭代和递归两种方式解决，迭代方法通常更高效，而递归方法则更直观。</p>
</li>
<li>
<p><strong>技巧</strong>：</p>
<ul>
<li>使用多个指针（如 <code>prev</code>、<code>curr</code>、<code>next</code>）可以有效地处理链表的反转操作</li>
<li>在修改指针前，务必先保存必要的引用，防止链表丢失</li>
<li>对于特殊情况（如空链表、单节点链表），可以单独处理或设计算法使其自然包含在一般情况中</li>
</ul>
</li>
<li>
<p><strong>空间效率</strong>：在实际应用中，通常优先考虑迭代解法，因为它的空间复杂度更低，特别是对于长链表，可以避免递归造成的栈溢出问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 160 - 相交链表（Intersection of Two Linked Lists）</title>
    <url>/2025/04/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-160-Intersection-of-Two-Linked-Lists/</url>
    <content><![CDATA[<h2 id="Problem-Description">Problem Description</h2>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:      a1 → a2</span><br><span class="line">                ↘</span><br><span class="line">                  c1 → c2 → c3</span><br><span class="line">                ↗          </span><br><span class="line">B: b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>题目数据保证整个链式结构中不存在环，函数返回结果后，链表必须保持其原始结构。</p>
<h3 id="示例-1：">示例 1：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        4 → 1</span><br><span class="line">              ↘</span><br><span class="line">                8 → 4 → 5</span><br><span class="line">              ↗          </span><br><span class="line">5 → 6 → 1</span><br></pre></td></tr></table></figure>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3<br>
输出：Intersected at ‘8’<br>
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<h3 id="示例-2：">示例 2：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 → 9 → 1</span><br><span class="line">          ↘</span><br><span class="line">            2 → 4</span><br><span class="line">          ↗   </span><br><span class="line">    3</span><br></pre></td></tr></table></figure>
<p>输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>
输出：Intersected at ‘2’</p>
<h3 id="示例-3：">示例 3：</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 → 6 → 4</span><br><span class="line"></span><br><span class="line">1 → 5</span><br></pre></td></tr></table></figure>
<p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>
输出：No intersection</p>
<h3 id="约束条件：">约束条件：</h3>
<ul>
<li>listA 中节点数目为 m</li>
<li>listB 中节点数目为 n</li>
<li>1 &lt;= m, n &lt;= 3 * 10^4</li>
<li>1 &lt;= Node.val &lt;= 10^5</li>
<li>0 &lt;= skipA &lt;= m</li>
<li>0 &lt;= skipB &lt;= n</li>
<li>如果 listA 和 listB 没有交点，intersectVal 为 0</li>
<li>如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</li>
</ul>
<p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p>
<h2 id="Solution-Approach">Solution Approach</h2>
<p>这个问题有几种解法，我们将逐一介绍，并分析各自的优缺点。</p>
<h3 id="方法一：哈希表法">方法一：哈希表法</h3>
<p><strong>核心思想</strong>：使用哈希表存储第一个链表的所有节点，然后遍历第二个链表，检查每个节点是否在哈希表中存在。</p>
<h4 id="实现步骤：">实现步骤：</h4>
<ol>
<li>创建一个哈希表（Go中可以使用map）</li>
<li>将链表A的所有节点添加到哈希表中</li>
<li>遍历链表B，对于每个节点，检查它是否已经存在于哈希表中</li>
<li>如果找到匹配的节点，则返回该节点作为交点</li>
<li>如果遍历完链表B仍未找到匹配节点，则返回nil</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    nodeMap := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="type">bool</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将链表A的所有节点添加到哈希表</span></span><br><span class="line">    <span class="keyword">for</span> curr := headA; curr != <span class="literal">nil</span>; curr = curr.Next &#123;</span><br><span class="line">        nodeMap[curr] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历链表B，检查节点是否在哈希表中</span></span><br><span class="line">    <span class="keyword">for</span> curr := headB; curr != <span class="literal">nil</span>; curr = curr.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> nodeMap[curr] &#123;</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：双指针法（最优解）">方法二：双指针法（最优解）</h3>
<p><strong>核心思想</strong>：使用两个指针 pA 和 pB 分别遍历链表 A 和链表 B。当一个指针到达链表末尾时，将其重定向到另一个链表的头部。最终，两个指针会在相交点相遇，或者在遍历完两个链表后同时为 nil。</p>
<h4 id="重定向过程的深入解释">重定向过程的深入解释</h4>
<p><strong>为什么需要重定向？</strong></p>
<p>这个问题的核心挑战在于两个链表可能长度不同。如果不进行重定向，两个指针永远不会在正确的位置相遇。</p>
<p><strong>直观理解：</strong></p>
<p>想象两个人在两条不同的道路上跑步，这两条道路在某一点相交。如果两个人以相同的速度跑步，但起点不同，他们可能永远不会在相交点相遇。重定向就像是让一个人跑完自己的路后，立即从另一个人的起点开始跑，这样他们最终会在相交点相遇。</p>
<p><strong>数学证明：</strong></p>
<p>设链表A的长度为m，链表B的长度为n，从交点到末尾的公共部分长度为k。</p>
<ul>
<li>链表A中交点到末尾的距离：m-k</li>
<li>链表B中交点到末尾的距离：n-k</li>
</ul>
<p>重定向后，两个指针走过的总路径：</p>
<ul>
<li>pA: m + (n-k) = m + n - k</li>
<li>pB: n + (m-k) = n + m - k</li>
</ul>
<p>所以两个指针走过的总距离是相等的！这就是为什么它们会在交点相遇。</p>
<p><img src="/2025/04/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-160-Intersection-of-Two-Linked-Lists/1753799854872.png" alt="1753799854872"></p>
<p><strong>具体例子演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A: a1 → a2 → c1 → c2 → c3</span><br><span class="line">B: b1 → b2 → b3 → c1 → c2 → c3</span><br></pre></td></tr></table></figure>
<p>其中c1是交点。</p>
<p><strong>步骤详解：</strong></p>
<ol>
<li>
<p><strong>初始状态</strong>：</p>
<ul>
<li>pA = a1, pB = b1</li>
</ul>
</li>
<li>
<p><strong>第一次遍历</strong>：</p>
<ul>
<li>pA: a1 → a2 → c1 → c2 → c3 → nil</li>
<li>pB: b1 → b2 → b3 → c1 → c2 → c3 → nil</li>
</ul>
</li>
<li>
<p><strong>重定向过程</strong>：</p>
<ul>
<li>pA到达nil，重定向到b1</li>
<li>pB到达nil，重定向到a1</li>
</ul>
</li>
<li>
<p><strong>第二次遍历</strong>：</p>
<ul>
<li>pA: b1 → b2 → b3 → c1</li>
<li>pB: a1 → a2 → c1</li>
</ul>
</li>
<li>
<p><strong>相遇</strong>：两个指针在c1相遇！</p>
</li>
</ol>
<p><strong>为什么重定向有效？</strong></p>
<ol>
<li><strong>长度相同的情况</strong>：重定向确保两个指针在相同的相对位置开始比较</li>
<li><strong>长度不同的情况</strong>：重定向让较短的链表的指针&quot;等待&quot;较长的链表的指针，直到它们在相同的相对位置</li>
<li><strong>没有交点的情况</strong>：重定向确保两个指针都会遍历完两个链表，最终同时变为nil</li>
</ol>
<p><strong>重定向的巧妙之处：</strong></p>
<ul>
<li><strong>无需预计算长度</strong>：不需要先遍历链表计算长度</li>
<li><strong>空间复杂度O(1)</strong>：只需要两个指针</li>
<li><strong>时间复杂度O(m+n)</strong>：每个指针最多遍历两个链表各一次</li>
<li><strong>自动处理边界情况</strong>：自然地处理了空链表、单节点等特殊情况</li>
</ul>
<h4 id="实现步骤：-2">实现步骤：</h4>
<ol>
<li>初始化两个指针 pA 和 pB 分别指向链表 A 和链表 B 的头节点</li>
<li>同时移动这两个指针，每次移动一步</li>
<li>当 pA 到达链表 A 的末尾时，将其重定向到链表 B 的头部</li>
<li>当 pB 到达链表 B 的末尾时，将其重定向到链表 A 的头部</li>
<li>如果两个链表相交，pA 和 pB 最终会在相交点相遇</li>
<li>如果两个链表不相交，pA 和 pB 最终都会变为 nil</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> headA == <span class="literal">nil</span> || headB == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    pA, pB := headA, headB</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> pA != pB &#123;</span><br><span class="line">        <span class="comment">// 当到达链表末尾时，切换到另一个链表的头部</span></span><br><span class="line">        <span class="keyword">if</span> pA == <span class="literal">nil</span> &#123;</span><br><span class="line">            pA = headB</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pA = pA.Next</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> pB == <span class="literal">nil</span> &#123;</span><br><span class="line">            pB = headA</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pB = pB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> pA <span class="comment">// pA 要么是相交点，要么是 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：计算长度差法">方法三：计算长度差法</h3>
<p><strong>核心思想</strong>：计算两个链表的长度，然后让较长的链表先移动差值步数，之后两个指针同步前进，最终会在相交点相遇。</p>
<h4 id="实现步骤：-3">实现步骤：</h4>
<ol>
<li>分别计算链表 A 和链表 B 的长度</li>
<li>计算两个链表的长度差 diff</li>
<li>让较长的链表的指针先移动 diff 步</li>
<li>然后两个指针同步前进，每次都移动一步</li>
<li>检查两个指针是否相等，如果相等，则返回该节点</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 计算链表长度的辅助函数</span></span><br><span class="line">    getLength := <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        length := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> curr := head; curr != <span class="literal">nil</span>; curr = curr.Next &#123;</span><br><span class="line">            length++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    lenA, lenB := getLength(headA), getLength(headB)</span><br><span class="line">    pA, pB := headA, headB</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 让较长的链表先移动差值步数</span></span><br><span class="line">    <span class="keyword">if</span> lenA &gt; lenB &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenA - lenB; i++ &#123;</span><br><span class="line">            pA = pA.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenB - lenA; i++ &#123;</span><br><span class="line">            pB = pB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同步前进，寻找相交点</span></span><br><span class="line">    <span class="keyword">for</span> pA != pB &#123;</span><br><span class="line">        pA = pA.Next</span><br><span class="line">        pB = pB.Next</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> pA <span class="comment">// pA 要么是相交点，要么是 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误解法分析">错误解法分析</h2>
<p>我之前的解法存在以下问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> headA == <span class="literal">nil</span> || headB == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fast, slow := headA, headB</span><br><span class="line">    <span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">            fast = headB</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = fast.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">            fast = headB</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = fast.Next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> slow == <span class="literal">nil</span> &#123;</span><br><span class="line">            slow = headA</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slow = slow.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>错误点</strong>：</p>
<ol>
<li><strong>算法思路混淆</strong>：这个解法似乎混合了检测环形链表的快慢指针法和检测相交链表的双指针法。在相交链表问题中，不应该使用不同速度的指针。</li>
<li><strong>指针移动逻辑错误</strong>：fast 指针尝试每次移动两步，而 slow 指针每次移动一步。这种方式在没有环的情况下可能导致无法正确找到相交点。</li>
<li><strong>重置逻辑问题</strong>：代码中 fast 指针可能在同一次循环中被重置两次，这不符合算法的要求。</li>
<li><strong>可能的无限循环</strong>：如果两个链表不相交，并且长度不同，这种实现可能导致指针永远不会相等，从而陷入无限循环。</li>
</ol>
<h2 id="解法比较">解法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>哈希表法</th>
<th>双指针法</th>
<th>长度差法</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(m+n)</td>
<td>O(m+n)</td>
<td>O(m+n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(m)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>简单直观，容易实现</td>
<td>空间复杂度最优，代码简洁</td>
<td>思路清晰，易于理解</td>
</tr>
<tr>
<td>缺点</td>
<td>需要额外空间</td>
<td>初次理解可能有难度</td>
<td>代码略长，需要计算长度</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★☆☆</td>
<td>★★★★★</td>
<td>★★★★☆</td>
</tr>
</tbody>
</table>
<h2 id="Key-Learnings">Key Learnings</h2>
<ol>
<li><strong>双指针技巧</strong>：此问题展示了双指针在解决链表问题中的强大作用，特别是方法二的解法巧妙且优雅。</li>
<li><strong>空间时间权衡</strong>：哈希表法虽然直观，但需要额外空间；而双指针法和长度差法只需O(1)空间，展示了算法设计中空间与时间的权衡。</li>
<li><strong>边界条件处理</strong>：在处理链表问题时，总是需要考虑空链表、单节点链表等边界情况。</li>
<li><strong>问题简化</strong>：通过重定向指针（方法二）或提前移动（方法三），我们能够简化问题，使不同长度的链表在同步点相遇。</li>
<li><strong>错误分析</strong>：理解错误解法的缺陷能够帮助我们更深入地理解问题的本质和解决方案的要求。在此问题中，不恰当地混用算法模式（快慢指针和双指针）导致了解法的失败。</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Hot100</tag>
        <tag>哈希</tag>
        <tag>❌错题集</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 240 - 搜索二维矩阵 II（Search a 2D Matrix II）</title>
    <url>/2025/04/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-240-Search-a-2D-Matrix-II/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p>输入：matrix =</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,  4,  7,  11, 15],</span><br><span class="line">  [2,  5,  8,  12, 19],</span><br><span class="line">  [3,  6,  9,  16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>target = 5</p>
<p>输出：true</p>
<p><strong>示例 2：</strong></p>
<p>输入：matrix =</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,  4,  7,  11, 15],</span><br><span class="line">  [2,  5,  8,  12, 19],</span><br><span class="line">  [3,  6,  9,  16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>target = 20</p>
<p>输出：false</p>
<p><strong>提示：</strong></p>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= n, m &lt;= 300</li>
<li>-10^9 &lt;= matrix[i][j] &lt;= 10^9</li>
<li>每行的所有元素从左到右升序排列</li>
<li>每列的所有元素从上到下升序排列</li>
<li>-10^9 &lt;= target &lt;= 10^9</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题目提供了一个特殊性质的二维矩阵，要求我们查找一个目标值。矩阵的特性是每行从左到右升序，每列从上到下升序。根据这个特性，我们可以有多种解题思路。</p>
<h3 id="方法一：角落搜索法">方法一：角落搜索法</h3>
<p><strong>核心思想</strong>: 利用矩阵的排序特性，从右上角或左下角开始搜索，每次能够排除一行或一列。</p>
<p>从右上角（或左下角）开始搜索的原理：</p>
<ul>
<li>若当前元素等于目标值，直接返回 true</li>
<li>若当前元素大于目标值，则可以排除当前列（因为当前列下方的元素更大）</li>
<li>若当前元素小于目标值，则可以排除当前行（因为当前行左侧的元素更小）</li>
</ul>
<p>这种方法的时间复杂度是 O(m + n)，其中 m 是行数，n 是列数，因为每次操作都会排除一行或一列。</p>
<h4 id="实现细节">实现细节</h4>
<p>我们从矩阵的右上角开始搜索：</p>
<ol>
<li>初始化指针位置为右上角坐标 (0, columns-1)</li>
<li>当指针在矩阵范围内时，比较当前元素与目标值：
<ul>
<li>如果相等，返回 true</li>
<li>如果当前元素大于目标值，则向左移动（列索引减一）</li>
<li>如果当前元素小于目标值，则向下移动（行索引加一）</li>
</ul>
</li>
<li>如果搜索结束后仍未找到目标值，返回 false</li>
</ol>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵的行数和列数</span></span><br><span class="line">    rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">if</span> rows == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    columns := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从右上角开始搜索</span></span><br><span class="line">    row, col := <span class="number">0</span>, columns<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当指针在矩阵范围内时继续搜索</span></span><br><span class="line">    <span class="keyword">for</span> row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        currentValue := matrix[row][col]</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> currentValue == target &#123;</span><br><span class="line">            <span class="comment">// 找到目标值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> currentValue &gt; target &#123;</span><br><span class="line">            <span class="comment">// 当前值大于目标值，排除当前列</span></span><br><span class="line">            col--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前值小于目标值，排除当前行</span></span><br><span class="line">            row++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 搜索完毕未找到目标值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：二分查找法">方法二：二分查找法</h3>
<p><strong>核心思想</strong>: 由于每一行都是排序的，我们可以对每一行使用二分查找。</p>
<h4 id="实现细节-2">实现细节</h4>
<ol>
<li>遍历矩阵的每一行</li>
<li>对每一行使用二分查找寻找目标值</li>
<li>如果在任一行中找到目标值，返回 true</li>
<li>否则，返回 false</li>
</ol>
<p>这种方法的时间复杂度是 O(m log n)，其中 m 是行数，n 是列数。</p>
<h4 id="代码实现-2">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵行数</span></span><br><span class="line">    rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">if</span> rows == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 对每一行使用二分查找</span></span><br><span class="line">    <span class="keyword">for</span> _, row := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">        <span class="comment">// 如果在当前行找到目标值，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> binarySearch(row, target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 所有行都搜索完毕未找到目标值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：分治法">方法三：分治法</h3>
<p><strong>核心思想</strong>: 利用矩阵的特性，将矩阵划分为四个子矩阵，递归搜索。</p>
<h4 id="实现细节-3">实现细节</h4>
<ol>
<li>找到矩阵中心点 (midRow, midCol)</li>
<li>将矩阵分为四个区域：左上、右上、左下、右下</li>
<li>比较中心点的值与目标值：
<ul>
<li>如果等于目标值，返回 true</li>
<li>如果大于目标值，则目标值可能在左上区域或左下区域或右上区域</li>
<li>如果小于目标值，则目标值可能在右下区域或右上区域或左下区域</li>
</ul>
</li>
<li>递归搜索可能包含目标值的子矩阵</li>
</ol>
<p>这种方法的时间复杂度在最坏情况下可能接近 O(m*n)，但在平均情况下表现较好。</p>
<h4 id="代码实现-3">代码实现</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵的行数和列数</span></span><br><span class="line">    rows := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">if</span> rows == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    columns := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调用递归搜索函数</span></span><br><span class="line">    <span class="keyword">return</span> searchMatrixRecursively(matrix, target, <span class="number">0</span>, <span class="number">0</span>, rows<span class="number">-1</span>, columns<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归搜索函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrixRecursively</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>, rowStart, colStart, rowEnd, colEnd <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 基本情况：超出矩阵范围</span></span><br><span class="line">    <span class="keyword">if</span> rowStart &gt; rowEnd || colStart &gt; colEnd &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 基本情况：矩阵只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> rowStart == rowEnd &amp;&amp; colStart == colEnd &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[rowStart][colStart] == target</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算中心点坐标</span></span><br><span class="line">    rowMid := rowStart + (rowEnd-rowStart)/<span class="number">2</span></span><br><span class="line">    colMid := colStart + (colEnd-colStart)/<span class="number">2</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 中心点值</span></span><br><span class="line">    midValue := matrix[rowMid][colMid]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果找到目标值，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> midValue == target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 根据中心点值与目标值的关系，决定搜索哪些子矩阵</span></span><br><span class="line">    <span class="keyword">if</span> midValue &gt; target &#123;</span><br><span class="line">        <span class="comment">// 搜索左上区域（行结束和列结束都是中心点）</span></span><br><span class="line">        <span class="keyword">return</span> searchMatrixRecursively(matrix, target, rowStart, colStart, rowMid, colMid) ||</span><br><span class="line">               <span class="comment">// 搜索右上区域（行从开始到中心，列从中心+1到结束）</span></span><br><span class="line">               searchMatrixRecursively(matrix, target, rowStart, colMid+<span class="number">1</span>, rowMid, colEnd) ||</span><br><span class="line">               <span class="comment">// 搜索左下区域（行从中心+1到结束，列从开始到中心）</span></span><br><span class="line">               searchMatrixRecursively(matrix, target, rowMid+<span class="number">1</span>, colStart, rowEnd, colMid)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 搜索右下区域（行开始和列开始都是中心点+1）</span></span><br><span class="line">        <span class="keyword">return</span> searchMatrixRecursively(matrix, target, rowMid+<span class="number">1</span>, colMid+<span class="number">1</span>, rowEnd, colEnd) ||</span><br><span class="line">               <span class="comment">// 搜索右上区域（行从开始到中心，列从中心+1到结束）</span></span><br><span class="line">               searchMatrixRecursively(matrix, target, rowStart, colMid+<span class="number">1</span>, rowMid, colEnd) ||</span><br><span class="line">               <span class="comment">// 搜索左下区域（行从中心+1到结束，列从开始到中心）</span></span><br><span class="line">               searchMatrixRecursively(matrix, target, rowMid+<span class="number">1</span>, colStart, rowEnd, colMid)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>角落搜索法</td>
<td>O(m + n)</td>
<td>O(1)</td>
<td>非常高效，实现简单</td>
<td>需要理解特定的搜索策略</td>
</tr>
<tr>
<td>二分查找法</td>
<td>O(m log n)</td>
<td>O(1)</td>
<td>易于理解，二分查找是常见算法</td>
<td>对于大矩阵，比角落搜索法慢</td>
</tr>
<tr>
<td>分治法</td>
<td>最坏 O(m*n)</td>
<td>O(log(m*n))</td>
<td>适用于更一般的搜索问题</td>
<td>实现复杂，递归调用开销大</td>
</tr>
</tbody>
</table>
<p>综合考虑，角落搜索法（方法一）是解决此问题最高效的方法，它充分利用了矩阵的特性，时间复杂度为 O(m + n)，空间复杂度为 O(1)。</p>
<h2 id="关键学习点">关键学习点</h2>
<ol>
<li><strong>利用数据结构特性</strong>：矩阵的排序特性使我们能够设计出 O(m+n) 的算法。在解决问题时，充分理解并利用数据的特殊性质往往能找到最优解。</li>
<li><strong>搜索空间缩减</strong>：角落搜索法的核心思想是每次操作都能排除一行或一列，有效地缩小搜索空间。</li>
<li><strong>多种解法思考</strong>：同一个问题可以有多种解法，从暴力法到优化解法，通过比较不同算法的复杂度，可以找到最适合的解决方案。</li>
<li><strong>二维空间的搜索技巧</strong>：对于二维空间的搜索问题，可以考虑从特殊点（如角落）开始，利用排序特性引导搜索方向。</li>
</ol>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>分治</tag>
        <tag>Medium</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 2563 - 统计公平数对的数目（Count the Number of Fair Pairs）</title>
    <url>/2025/04/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-2563-%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个下标从 0 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 和两个整数 <code>lower</code> 和 <code>upper</code>，返回公平数对的数目。</p>
<p>如果 <code>(i, j)</code> 数对满足以下情况，则认为是一个公平数对：</p>
<ul>
<li><code>0 ≤ i &lt; j &lt; n</code> 且</li>
<li><code>lower ≤ nums[i] + nums[j] ≤ upper</code></li>
</ul>
<h3 id="示例-1">示例 1:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,7,4,4,5], lower = 3, upper = 6</span><br><span class="line">输出: 6</span><br><span class="line">解释: 共计 6 个公平数对: (0,3), (0,4), (0,5), (1,3), (1,4) 和 (1,5)。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2">示例 2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,7,9,2,5], lower = 11, upper = 11</span><br><span class="line">输出: 1</span><br><span class="line">解释: 只有单个公平数对: (2,3)。</span><br></pre></td></tr></table></figure>
<h3 id="提示">提示:</h3>
<ul>
<li><code>1 ≤ nums.length ≤ 10^5</code></li>
<li><code>nums.length == n</code></li>
<li><code>-10^9 ≤ nums[i] ≤ 10^9</code></li>
<li><code>-10^9 ≤ lower ≤ upper ≤ 10^9</code></li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>这道题目要求统计符合条件的数对数量，主要难点在于如何高效地找出所有满足 <code>lower ≤ nums[i] + nums[j] ≤ upper</code> 的数对。</p>
<p>一个常见的思路是使用嵌套循环枚举所有可能的数对，但这种方法的时间复杂度为 O(n²)，在数组长度较大时会超时。</p>
<p>我们可以利用<strong>排序 + 二分查找</strong>来优化解法：</p>
<ol>
<li>首先对数组 <code>nums</code> 进行排序</li>
<li>对于每个元素 <code>nums[j]</code>，我们需要找出有多少个索引 <code>i (i &lt; j)</code> 满足：
<ul>
<li><code>lower ≤ nums[i] + nums[j] ≤ upper</code></li>
<li>即 <code>lower - nums[j] ≤ nums[i] ≤ upper - nums[j]</code></li>
</ul>
</li>
<li>由于数组已排序，我们可以使用二分查找：
<ul>
<li>找到第一个满足 <code>nums[i] ≥ lower - nums[j]</code> 的位置 <code>left</code></li>
<li>找到第一个满足 <code>nums[i] &gt; upper - nums[j]</code> 的位置 <code>right</code></li>
<li>则满足条件的元素个数为 <code>right - left</code></li>
</ul>
</li>
</ol>
<h3 id="具体实现步骤">具体实现步骤</h3>
<p>实现这个解法，我们可以按照以下步骤操作：</p>
<ol>
<li>对 <code>nums</code> 数组排序</li>
<li>初始化计数器 <code>res = 0</code></li>
<li>遍历数组中的每个位置 <code>j</code>：
<ul>
<li>对于当前元素 <code>nums[j]</code>，在 <code>nums[0...j-1]</code> 中二分查找：
<ul>
<li>找到第一个大于等于 <code>lower - nums[j]</code> 的位置 <code>left</code></li>
<li>找到第一个大于 <code>upper - nums[j]</code> 的位置 <code>right</code></li>
</ul>
</li>
<li>将 <code>right - left</code> 加到结果 <code>res</code> 上</li>
</ul>
</li>
<li>返回最终的 <code>res</code></li>
</ol>
<p>在 Golang 中，我们可以使用标准库中的 <code>sort.SearchInts</code> 函数来执行二分查找。</p>
<p>但实际上，这里有一个小问题需要注意：在题目中，我们需要找的是 <code>nums[i] ≤ upper - nums[j]</code> 的最右边界，而 <code>sort.SearchInts</code> 找的是第一个 <code>&gt;=</code> 目标值的位置。所以我们需要查找的是 <code>upper - nums[j] + 1</code>，即找到第一个大于 <code>upper - nums[j]</code> 的位置。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countFairPairs</span><span class="params">(nums []<span class="type">int</span>, lower <span class="type">int</span>, upper <span class="type">int</span>)</span></span> (res <span class="type">int64</span>) &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">		right := sort.SearchInts(nums[:j], upper-nums[j]+<span class="number">1</span>)</span><br><span class="line">		left := sort.SearchInts(nums[:j], lower-nums[j])</span><br><span class="line">		res += <span class="type">int64</span>(right - left)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程分析">执行过程分析</h3>
<p>让我们以示例 1 为例，跟踪代码的执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [0,1,7,4,4,5], lower = 3, upper = 6</span><br></pre></td></tr></table></figure>
<p>排序后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [0,1,4,4,5,7]</span><br></pre></td></tr></table></figure>
<p>遍历每个位置 j：</p>
<ul>
<li>j = 0: 没有比 0 更小的索引，跳过</li>
<li>j = 1: nums[1] = 1
<ul>
<li>在 nums[0:1] = [0] 中查找 ≥ lower-nums[1] = 3-1 = 2 的位置 left = 1</li>
<li>在 nums[0:1] = [0] 中查找 ≥ upper-nums[1]+1 = 6-1+1 = 6 的位置 right = 1</li>
<li>添加 right-left = 1-1 = 0 对</li>
</ul>
</li>
<li>j = 2: nums[2] = 4
<ul>
<li>在 nums[0:2] = [0,1] 中查找 ≥ lower-nums[2] = 3-4 = -1 的位置 left = 0</li>
<li>在 nums[0:2] = [0,1] 中查找 ≥ upper-nums[2]+1 = 6-4+1 = 3 的位置 right = 2</li>
<li>添加 right-left = 2-0 = 2 对: (0,2), (1,2)</li>
</ul>
</li>
<li>j = 3: nums[3] = 4
<ul>
<li>在 nums[0:3] = [0,1,4] 中查找 ≥ lower-nums[3] = 3-4 = -1 的位置 left = 0</li>
<li>在 nums[0:3] = [0,1,4] 中查找 ≥ upper-nums[3]+1 = 6-4+1 = 3 的位置 right = 2</li>
<li>添加 right-left = 2-0 = 2 对: (0,3), (1,3)</li>
</ul>
</li>
<li>j = 4: nums[4] = 5
<ul>
<li>在 nums[0:4] = [0,1,4,4] 中查找 ≥ lower-nums[4] = 3-5 = -2 的位置 left = 0</li>
<li>在 nums[0:4] = [0,1,4,4] 中查找 ≥ upper-nums[4]+1 = 6-5+1 = 2 的位置 right = 2</li>
<li>添加 right-left = 2-0 = 2 对: (0,4), (1,4)</li>
</ul>
</li>
<li>j = 5: nums[5] = 7
<ul>
<li>在 nums[0:5] = [0,1,4,4,5] 中查找 ≥ lower-nums[5] = 3-7 = -4 的位置 left = 0</li>
<li>在 nums[0:5] = [0,1,4,4,5] 中查找 ≥ upper-nums[5]+1 = 6-7+1 = 0 的位置 right = 0</li>
<li>添加 right-left = 0-0 = 0 对</li>
</ul>
</li>
</ul>
<p>最终结果: 0 + 0 + 2 + 2 + 2 + 0 = 6 对，符合预期。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度</strong>: O(n log n)</p>
<ul>
<li>排序的时间复杂度为 O(n log n)</li>
<li>遍历数组需要 O(n)，每次遍历中进行两次二分查找，每次二分查找的时间复杂度为 O(log n)</li>
<li>总时间复杂度为 O(n log n)</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>: O(log n) 或 O(n)</p>
<ul>
<li>除了输入数组外，排序可能需要 O(log n) 的栈空间</li>
<li>如果排序算法就地进行，则额外空间复杂度为 O(log n)</li>
<li>如果使用额外空间进行排序，则空间复杂度为 O(n)</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>排序 + 二分查找</strong>: 这是解决区间查询问题的一种常见技巧。先将数组排序，然后通过二分查找快速确定符合条件的元素范围。</li>
<li><strong>等价转换</strong>: 将条件 <code>lower ≤ nums[i] + nums[j] ≤ upper</code> 转换为 <code>lower - nums[j] ≤ nums[i] ≤ upper - nums[j]</code>，这样可以对固定的 <code>nums[j]</code> 查找符合条件的 <code>nums[i]</code>。</li>
<li><strong>边界处理</strong>: 在使用标准库的二分查找函数时，需要正确理解函数的行为和边界处理。例如，<code>sort.SearchInts</code> 返回的是第一个大于等于目标值的位置，如果想找最后一个小于等于目标值的位置，需要做相应调整。</li>
<li><strong>索引范围控制</strong>: 在二分查找中，需要明确在哪个范围内查找。在本题中，我们只在 <code>nums[0:j]</code> 范围内查找，确保 <code>i &lt; j</code>。</li>
</ol>
<p>这道题是对二分查找和排序应用的一个很好的例子，展示了如何通过预处理和高效的查找算法将时间复杂度从 O(n²) 优化到 O(n log n)。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>双指针</tag>
        <tag>排序</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 48 - 旋转图像（Rotate Image）</title>
    <url>/2025/04/19/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-48-Rotate-Image/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个 n × n 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>
<p>旋转前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<p>旋转后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 4 1</span><br><span class="line">8 5 2</span><br><span class="line">9 6 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure>
<p>旋转前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 5  1  9 11</span><br><span class="line"> 2  4  8 10</span><br><span class="line">13  3  6  7</span><br><span class="line">15 14 12 16</span><br></pre></td></tr></table></figure>
<p>旋转后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 13  2  5</span><br><span class="line">14  3  4  1</span><br><span class="line">12  6  8  9</span><br><span class="line">16  7 10 11</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>n == matrix.length == matrix[i].length</li>
<li>1 &lt;= n &lt;= 20</li>
<li>-1000 &lt;= matrix[i][j] &lt;= 1000</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>旋转图像是一个经典的矩阵操作问题。关键在于：<strong>如何在不使用额外空间的情况下完成矩阵的旋转</strong>。</p>
<p>首先，让我们理解一下顺时针旋转 90 度对矩阵元素位置的影响：</p>
<ul>
<li>对于位置 (i, j) 的元素，旋转后它将位于 (j, n-1-i)</li>
</ul>
<p>这个规律可以帮助我们直接交换元素，但直接这样操作会导致覆盖其他元素。因此，我们可以采用<strong>分解为多个简单变换</strong>的方法。</p>
<h3 id="方法：转置-水平翻转">方法：转置 + 水平翻转</h3>
<p>这个方法将 90 度旋转分解为两个简单的矩阵操作：</p>
<ol>
<li><strong>矩阵转置</strong>（沿主对角线翻转）</li>
<li><strong>水平翻转</strong>（左右列交换）</li>
</ol>
<h4 id="步骤详解：">步骤详解：</h4>
<ol>
<li>
<p><strong>矩阵转置</strong>：</p>
<ul>
<li>遍历矩阵的一半（对角线以下部分），交换 matrix[i][j] 和 matrix[j][i]</li>
<li>这一步将行变为列，列变为行</li>
</ul>
</li>
<li>
<p><strong>水平翻转</strong>：</p>
<ul>
<li>对每一行进行左右翻转</li>
<li>将第 j 列和第 n-1-j 列交换</li>
</ul>
</li>
</ol>
<p>这两步操作组合起来，正好等同于将矩阵顺时针旋转 90 度。</p>
<p>我们可以通过一个例子来说明这个过程：</p>
<p>原始矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<p>转置后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 4 7</span><br><span class="line">2 5 8</span><br><span class="line">3 6 9</span><br></pre></td></tr></table></figure>
<p>水平翻转后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 4 1</span><br><span class="line">8 5 2</span><br><span class="line">9 6 3</span><br></pre></td></tr></table></figure>
<p>可以看到，最终结果正是原矩阵顺时针旋转 90 度后的结果。</p>
<h2 id="实现细节">实现细节</h2>
<p>实现过程中，需要注意以下几点：</p>
<ol>
<li>在转置操作中，我们只需要遍历矩阵的一半（主对角线以下的部分），避免重复交换</li>
<li>在水平翻转中，只需要遍历每行的前一半列</li>
<li>所有操作都是原地进行的，不需要额外的空间</li>
</ol>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先沿着主对角线进行对称反转</span></span><br><span class="line">	n := <span class="built_in">len</span>(matrix)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后每一行进行水平翻转</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n/<span class="number">2</span>; j++ &#123;</span><br><span class="line">			matrix[i][n<span class="number">-1</span>-j], matrix[i][j] = matrix[i][j], matrix[i][n<span class="number">-1</span>-j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：O(n²)，其中 n 是矩阵的边长。需要遍历整个矩阵两次。</li>
<li><strong>空间复杂度</strong>：O(1)，只使用了常数级别的额外空间。</li>
</ul>
<h2 id="其他可能的方法">其他可能的方法</h2>
<p>除了上述方法外，还有另一种旋转方法：<strong>层层旋转</strong>。</p>
<p>此方法的思路是：</p>
<ol>
<li>将矩阵看作由多个同心方形环组成</li>
<li>对每一层的四条边上的元素进行旋转交换</li>
<li>从外到内依次处理每一层</li>
</ol>
<p>代码实现会稍微复杂一些，需要小心处理索引，但时间和空间复杂度与上述方法相同。</p>
<h2 id="比较">比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>转置+水平翻转</th>
<th>层层旋转</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n²)</td>
<td>O(n²)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单，思路清晰</td>
<td>直观对应旋转过程</td>
</tr>
<tr>
<td>缺点</td>
<td>分解为两步不直观</td>
<td>索引处理复杂</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="关键收获">关键收获</h2>
<ol>
<li><strong>矩阵操作的分解思想</strong>：将复杂的矩阵操作分解为简单操作的组合</li>
<li><strong>原地算法的实现技巧</strong>：如何通过元素交换实现空间优化</li>
<li><strong>矩阵转置和水平翻转</strong>：这是两个常用的矩阵操作，在其他问题中也经常用到</li>
</ol>
<p>对于矩阵旋转问题，关键是找到元素变换前后位置的对应关系，然后利用这种关系设计高效的算法。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 54 - 螺旋矩阵（Spiral Matrix）解题思路与错误分析</title>
    <url>/2025/04/19/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-54-Spiral-Matrix/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个 m 行 n 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>上面这个示例中，螺旋顺序遍历的过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">→ → →</span><br><span class="line">↑   ↓</span><br><span class="line">↑ ← ↓</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<p>这个例子中，螺旋遍历的路径是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">→ → → →</span><br><span class="line">↑     ↓</span><br><span class="line">↑ ← ← ↓</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 10</li>
<li>-100 &lt;= matrix[i][j] &lt;= 100</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>螺旋矩阵是一个典型的数组遍历问题，核心在于如何控制遍历的方向和边界。我们需要按照顺时针螺旋的顺序（右 → 下 → 左 → 上）依次访问矩阵中的所有元素。</p>
<h3 id="方法一：按层模拟（边界法）">方法一：按层模拟（边界法）</h3>
<p>这个方法的核心思想是：<strong>将整个矩阵看作由多个&quot;环&quot;（层）组成，从外到内一层一层地剥离遍历</strong>。</p>
<p><img src="https://raw.githubusercontent.com/doocs/leetcode/main/solution/0000-0099/0054.Spiral%20Matrix/images/spiral1.jpg" alt="螺旋矩阵遍历示意图"></p>
<h4 id="步骤详解：">步骤详解：</h4>
<ol>
<li>
<p><strong>初始化四个边界</strong>：</p>
<ul>
<li><code>left</code> = 0：左边界</li>
<li><code>right</code> = 列数-1：右边界</li>
<li><code>top</code> = 0：上边界</li>
<li><code>bottom</code> = 行数-1：下边界</li>
</ul>
</li>
<li>
<p><strong>循环遍历各层</strong>，直到 <code>left &gt; right</code> 或 <code>top &gt; bottom</code>：</p>
<p>a. <strong>从左到右</strong>遍历上边界上的元素：</p>
<ul>
<li>遍历 <code>matrix[top][j]</code>，其中 <code>j</code> 从 <code>left</code> 到 <code>right</code></li>
<li>遍历完后，上边界下移：<code>top++</code></li>
</ul>
<p>b. <strong>从上到下</strong>遍历右边界上的元素：</p>
<ul>
<li>遍历 <code>matrix[i][right]</code>，其中 <code>i</code> 从 <code>top</code> 到 <code>bottom</code></li>
<li>遍历完后，右边界左移：<code>right--</code></li>
</ul>
<p>c. <strong>检查是否还有行需要遍历</strong>（防止单行情况重复遍历）：</p>
<ul>
<li>如果 <code>top &lt;= bottom</code>，<strong>从右到左</strong>遍历下边界上的元素：</li>
<li>遍历 <code>matrix[bottom][j]</code>，其中 <code>j</code> 从 <code>right</code> 到 <code>left</code></li>
<li>遍历完后，下边界上移：<code>bottom--</code></li>
</ul>
<p>d. <strong>检查是否还有列需要遍历</strong>（防止单列情况重复遍历）：</p>
<ul>
<li>如果 <code>left &lt;= right</code>，<strong>从下到上</strong>遍历左边界上的元素：</li>
<li>遍历 <code>matrix[i][left]</code>，其中 <code>i</code> 从 <code>bottom</code> 到 <code>top</code></li>
<li>遍历完后，左边界右移：<code>left++</code></li>
</ul>
</li>
<li>
<p>重复第 2 步，直到所有元素都被遍历完。</p>
</li>
</ol>
<h4 id="关键注意点：">关键注意点：</h4>
<ul>
<li>在每一轮遍历中，边界会收缩，形成一个逐渐缩小的矩形</li>
<li>需要特别注意单行或单列的情况，避免重复访问元素</li>
</ul>
<h3 id="方法二：方向数组法">方法二：方向数组法</h3>
<p>这种方法使用方向数组来模拟螺旋过程，关键在于知道何时改变方向。</p>
<h4 id="步骤详解：-2">步骤详解：</h4>
<ol>
<li>
<p><strong>定义方向数组</strong>：表示四种移动方向（右、下、左、上）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">directions := [][]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>创建访问标记数组</strong>：避免重复访问</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, rows)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">    visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, cols)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>遍历矩阵</strong>：</p>
<ul>
<li>从(0,0)开始，按当前方向移动</li>
<li>记录已访问的位置</li>
<li>当需要转向时（即下一步会越界或已访问过），顺时针旋转方向</li>
</ul>
</li>
</ol>
<h2 id="我的错误实现及分析">我的错误实现及分析</h2>
<p>我最初的实现采用了方向数组的方法，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    row := <span class="built_in">len</span>(matrix)</span><br><span class="line">    col := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    dirX, dirY := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    x, y, cnt := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, row*col)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cnt &lt; row*col &#123;</span><br><span class="line">        res[cnt] = matrix[x][y]</span><br><span class="line">        nextX := x + dirX[index]</span><br><span class="line">        nextY := y + dirY[index]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nextX &lt; <span class="number">0</span> || nextX &gt;= row || nextY &lt; <span class="number">0</span> || nextY &gt;= col &#123;</span><br><span class="line">            index = (index + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            nextX = x + dirX[index]</span><br><span class="line">            nextY = y + dirY[index]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x = nextX</span><br><span class="line">        y = nextY</span><br><span class="line">        cnt++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误分析：">错误分析：</h3>
<p>让我们通过一个简单的例子来分析这段代码的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>按照代码的执行逻辑：</p>
<ol>
<li>首先访问 (0,0)：值为 1，添加到结果</li>
<li>按照右方向移动到 (0,1)：值为 2，添加到结果</li>
<li>继续按照右方向移动到 (0,2)：值为 3，添加到结果</li>
<li>继续按照右方向尝试移动到 (0,3)，但这超出了边界</li>
<li>改变方向为下，移动到 (1,2)：值为 6，添加到结果</li>
<li>继续按照下方向移动到 (2,2)：值为 9，添加到结果</li>
<li>继续按照下方向尝试移动到 (3,2)，但这超出了边界</li>
<li>改变方向为左，移动到 (2,1)：值为 8，添加到结果</li>
<li>继续按照左方向移动到 (2,0)：值为 7，添加到结果</li>
<li>继续按照左方向尝试移动到 (2,-1)，但这超出了边界</li>
<li>改变方向为上，移动到 (1,0)：值为 4，添加到结果 - <strong>这里出现了问题！</strong></li>
</ol>
<p>我们再次访问了 (0,0)，造成了死循环！因为代码只检查了边界条件，没有检查是否已经访问过该位置。正确的做法应该是使用一个额外的数组来标记已访问的位置。</p>
<h2 id="我的另一个错误实现及分析">我的另一个错误实现及分析</h2>
<p>在尝试实现边界法的过程中，我还犯了另一个常见错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    row := <span class="built_in">len</span>(matrix)</span><br><span class="line">    col := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, row*col)</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    left, right, top, bottom := <span class="number">0</span>, col<span class="number">-1</span>, <span class="number">0</span>, row<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cnt &lt; row*col &#123;</span><br><span class="line">        <span class="comment">// 向右遍历</span></span><br><span class="line">        <span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">            res[cnt] = matrix[top][i]</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">        top++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下遍历</span></span><br><span class="line">        <span class="keyword">for</span> i := top; i &lt;= bottom; i++ &#123;</span><br><span class="line">            res[cnt] = matrix[i][right]</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">        right--</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向左遍历</span></span><br><span class="line">        <span class="keyword">for</span> i := right; i &gt;= left; i-- &#123;</span><br><span class="line">            res[cnt] = matrix[bottom][i]</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上遍历</span></span><br><span class="line">        <span class="keyword">for</span> i := bottom; i &gt;= top; i-- &#123;</span><br><span class="line">            res[cnt] = matrix[i][left]</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误分析：-2">错误分析：</h3>
<p>这段代码的主要问题是<strong>缺少边界检查</strong>。以矩阵 <code>[[1,2,3],[4,5,6]]</code>（2 行 3 列）为例，分析执行过程：</p>
<ol>
<li>初始状态：<code>left=0, right=2, top=0, bottom=1, cnt=0</code></li>
<li>向右遍历：添加 <code>[1,2,3]</code>，<code>cnt=3, top=1</code></li>
<li>向下遍历：添加 <code>[6]</code>，<code>cnt=4, right=1</code></li>
<li>向左遍历：添加 <code>[5,4]</code>，<code>cnt=6, bottom=0</code></li>
<li><strong>问题出现</strong>：此时 <code>top=1, bottom=0</code>，已经交叉，但代码没有检查就继续执行向上遍历</li>
</ol>
<p>当 <code>top &gt; bottom</code> 或 <code>left &gt; right</code> 时，说明当前层已经遍历完毕，应该结束循环。但这个实现中缺少了这一关键检查，导致在单行或单列等特殊情况下会重复访问元素，甚至可能发生数组越界。</p>
<p>另一个问题是，当矩阵只有一行或一列时，执行完一个方向的遍历后，立即执行下一个方向的遍历可能会重复处理元素。例如，对于一个单行矩阵 <code>[[1,2,3]]</code>：</p>
<ol>
<li>向右遍历后 <code>top</code> 增加，此时 <code>top &gt; bottom</code></li>
<li>但代码仍会执行向下、向左和向上遍历，导致越界或重复访问</li>
</ol>
<h3 id="修复方法：">修复方法：</h3>
<p>在每个方向遍历后，需要检查更新后的边界条件是否仍然有效：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrderFixed</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    row := <span class="built_in">len</span>(matrix)</span><br><span class="line">    col := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, row*col)</span><br><span class="line">    left, right, top, bottom := <span class="number">0</span>, col<span class="number">-1</span>, <span class="number">0</span>, row<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;</span><br><span class="line">        <span class="comment">// 向右遍历</span></span><br><span class="line">        <span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, matrix[top][i])</span><br><span class="line">        &#125;</span><br><span class="line">        top++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下遍历（需要先检查边界）</span></span><br><span class="line">        <span class="keyword">if</span> top &lt;= bottom &#123;</span><br><span class="line">            <span class="keyword">for</span> i := top; i &lt;= bottom; i++ &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, matrix[i][right])</span><br><span class="line">            &#125;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向左遍历（需要先检查边界）</span></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;</span><br><span class="line">            <span class="keyword">for</span> i := right; i &gt;= left; i-- &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, matrix[bottom][i])</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上遍历（需要先检查边界）</span></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;</span><br><span class="line">            <span class="keyword">for</span> i := bottom; i &gt;= top; i-- &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, matrix[i][left])</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误的根本原因：">错误的根本原因：</h3>
<p>这个错误的根本原因是<strong>没有考虑边界条件</strong>。在处理矩阵类问题时，尤其需要注意：</p>
<ol>
<li><strong>边界交叉检查</strong>：确保索引边界（如 <code>left &lt;= right</code> 和 <code>top &lt;= bottom</code>）始终有效</li>
<li><strong>特殊情况处理</strong>：矩阵可能是单行、单列、甚至空矩阵</li>
<li><strong>方向转换条件</strong>：每次改变遍历方向前需要验证还有元素需要遍历</li>
</ol>
<p>这是矩阵遍历问题中最容易被忽视的细节，也是导致代码出错的常见原因。</p>
<h2 id="正确实现">正确实现</h2>
<h3 id="方法一：按层模拟（推荐）">方法一：按层模拟（推荐）</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    row := <span class="built_in">len</span>(matrix)</span><br><span class="line">    col := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, row*col)</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化四个边界</span></span><br><span class="line">    left, right, top, bottom := <span class="number">0</span>, col<span class="number">-1</span>, <span class="number">0</span>, row<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;</span><br><span class="line">        <span class="comment">// 1. 从左到右遍历上边界</span></span><br><span class="line">        <span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">            res[cnt] = matrix[top][i]</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">        top++ <span class="comment">// 上边界下移一行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从上到下遍历右边界</span></span><br><span class="line">        <span class="keyword">for</span> i := top; i &lt;= bottom; i++ &#123;</span><br><span class="line">            res[cnt] = matrix[i][right]</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">        right-- <span class="comment">// 右边界左移一列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从右到左遍历下边界（需要检查是否还有行要遍历）</span></span><br><span class="line">        <span class="keyword">if</span> top &lt;= bottom &#123;</span><br><span class="line">            <span class="keyword">for</span> i := right; i &gt;= left; i-- &#123;</span><br><span class="line">                res[cnt] = matrix[bottom][i]</span><br><span class="line">                cnt++</span><br><span class="line">            &#125;</span><br><span class="line">            bottom-- <span class="comment">// 下边界上移一行</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 从下到上遍历左边界（需要检查是否还有列要遍历）</span></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">            <span class="keyword">for</span> i := bottom; i &gt;= top; i-- &#123;</span><br><span class="line">                res[cnt] = matrix[i][left]</span><br><span class="line">                cnt++</span><br><span class="line">            &#125;</span><br><span class="line">            left++ <span class="comment">// 左边界右移一列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行过程分析：">执行过程分析：</h4>
<p>对于示例矩阵 <code>[[1,2,3],[4,5,6],[7,8,9]]</code>：</p>
<p><strong>第一轮循环</strong>：</p>
<ul>
<li>初始边界：<code>left=0, right=2, top=0, bottom=2</code></li>
<li>从左到右：添加 <code>[1,2,3]</code>，<code>top</code> 变为 1</li>
<li>从上到下：添加 <code>[6,9]</code>，<code>right</code> 变为 1</li>
<li>从右到左：添加 <code>[8,7]</code>，<code>bottom</code> 变为 1</li>
<li>从下到上：添加 <code>[4]</code>，<code>left</code> 变为 1</li>
</ul>
<p><strong>第二轮循环</strong>：</p>
<ul>
<li>边界：<code>left=1, right=1, top=1, bottom=1</code></li>
<li>从左到右：添加 <code>[5]</code></li>
<li>结束循环，因为所有元素都已访问</li>
</ul>
<p>最终结果：<code>[1,2,3,6,9,8,7,4,5]</code></p>
<h3 id="方法二：改进的方向数组方法">方法二：改进的方向数组方法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    rows, cols := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    total := rows * cols</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建结果数组</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">int</span>, total)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建访问标记数组</span></span><br><span class="line">    visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, rows)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">        visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, cols)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义四个方向：右、下、左、上</span></span><br><span class="line">    directions := [][]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">    dirIndex := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    row, col := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total; i++ &#123;</span><br><span class="line">        <span class="comment">// 添加当前元素到结果</span></span><br><span class="line">        result[i] = matrix[row][col]</span><br><span class="line">        <span class="comment">// 标记当前位置为已访问</span></span><br><span class="line">        visited[row][col] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算下一个位置</span></span><br><span class="line">        nextRow, nextCol := row + directions[dirIndex][<span class="number">0</span>], col + directions[dirIndex][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否需要改变方向</span></span><br><span class="line">        <span class="keyword">if</span> nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextCol &lt; <span class="number">0</span> || nextCol &gt;= cols || visited[nextRow][nextCol] &#123;</span><br><span class="line">            <span class="comment">// 改变方向（顺时针）</span></span><br><span class="line">            dirIndex = (dirIndex + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            nextRow, nextCol = row + directions[dirIndex][<span class="number">0</span>], col + directions[dirIndex][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row, col = nextRow, nextCol</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行过程分析：-2">执行过程分析：</h4>
<p>对于同样的示例，方法二的执行过程：</p>
<ol>
<li>从 (0,0) 开始，标记为已访问，添加值 1</li>
<li>当前方向为右，下一步是 (0,1)，有效且未访问，移动并添加值 2</li>
<li>继续向右到 (0,2)，添加值 3</li>
<li>尝试继续向右到 (0,3)，超出边界，方向改为向下，移动到 (1,2)，添加值 6</li>
<li>继续向下到 (2,2)，添加值 9</li>
<li>尝试继续向下，超出边界，方向改为向左，移动到 (2,1)，添加值 8</li>
<li>继续向左到 (2,0)，添加值 7</li>
<li>尝试继续向左，超出边界，方向改为向上，移动到 (1,0)，添加值 4</li>
<li>尝试继续向上到 (0,0)，已经访问过，方向改为向右，移动到 (1,1)，添加值 5</li>
<li>所有单元格都已访问，结束循环</li>
</ol>
<p>最终结果：<code>[1,2,3,6,9,8,7,4,5]</code></p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>按层模拟（边界法）</th>
<th>方向数组法</th>
</tr>
</thead>
<tbody>
<tr>
<td>思路</td>
<td>将矩阵分为多层，由外向内遍历</td>
<td>使用方向数组控制移动，遇到边界或已访问位置时转向</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)（不计算结果数组）</td>
<td>O(m×n)（需要访问标记数组）</td>
</tr>
<tr>
<td>易理解性</td>
<td>更直观，易于可视化</td>
<td>需要理解方向变化逻辑</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>需要处理边界条件和单行/单列情况</td>
<td>需要维护访问标记</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<p>对于两种方法：</p>
<ul>
<li><strong>时间复杂度</strong>：O(m×n)，其中 m 和 n 分别是矩阵的行数和列数。矩阵中的每个元素都被访问一次。</li>
<li><strong>空间复杂度</strong>：
<ul>
<li>按层模拟：O(1)，只需要常数级别的额外空间（不计算结果数组）。</li>
<li>方向数组方法：O(m×n)，需要一个与矩阵大小相同的访问标记数组。</li>
</ul>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>螺旋矩阵问题是一个经典的矩阵遍历问题，有两种主要解法：</p>
<ol>
<li><strong>按层模拟（边界法）</strong>：通过控制四个边界（左、右、上、下）来模拟螺旋遍历过程，空间效率高，思路直观。</li>
<li><strong>方向数组法</strong>：使用方向数组和已访问标记来控制遍历方向，需要额外空间但思路也较为清晰。</li>
</ol>
<p>在实际应用中，按层模拟的方法通常是更好的选择，因为它不需要额外的访问标记数组，空间复杂度更低，并且逻辑也相对直观。</p>
<p>这道题目的核心在于理解如何控制边界和方向，以及如何处理遍历过程中的边界情况。解决此类问题的关键是清晰地定义状态变量并正确地更新它们。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>Medium</tag>
        <tag>❌错题集</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 42 - 接雨水（Trapping Rain Water）</title>
    <url>/2025/04/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-42-trapping-rain-water/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
<p>示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       #</span><br><span class="line">#      #</span><br><span class="line">#  #   #</span><br><span class="line">#  #   #</span><br><span class="line">####  ##</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>n == height.length</li>
<li>1 &lt;= n &lt;= 2 * 10^4</li>
<li>0 &lt;= height[i] &lt;= 10^5</li>
</ul>
<h2 id="解题思路">解题思路</h2>
<p>接雨水问题的核心在于理解：<strong>对于每个位置，它能接的雨水量等于该位置左右两侧最高柱子的较小值减去该位置的高度</strong>。</p>
<p>这个问题有多种解法，我们将介绍三种主要方法：动态规划、双指针和单调栈。</p>
<h3 id="方法一：动态规划">方法一：动态规划</h3>
<p><strong>核心思想</strong>：预处理每个位置的左侧最大高度和右侧最大高度，然后计算每个位置能接的雨水量。</p>
<h4 id="步骤详解：">步骤详解：</h4>
<ol>
<li>创建两个数组 <code>leftMax</code> 和 <code>rightMax</code>，分别存储每个位置的左侧最大高度和右侧最大高度</li>
<li>从左到右遍历数组，计算每个位置的左侧最大高度</li>
<li>从右到左遍历数组，计算每个位置的右侧最大高度</li>
<li>再次遍历数组，对于每个位置 i，计算 min(leftMax[i], rightMax[i]) - height[i]，累加得到总雨水量</li>
</ol>
<p>这种方法直观易懂，适合初学者理解问题。</p>
<h3 id="方法二：双指针法">方法二：双指针法</h3>
<p><strong>核心思想</strong>：使用左右两个指针从两端向中间移动，同时记录左右两侧遇到的最大高度，优化空间复杂度。</p>
<h4 id="步骤详解：-2">步骤详解：</h4>
<ol>
<li>初始化左指针 <code>left = 0</code> 和右指针 <code>right = n-1</code></li>
<li>记录左侧和右侧的最大高度 <code>leftMax = 0</code> 和 <code>rightMax = 0</code></li>
<li>当左指针小于右指针时，执行以下操作：
<ul>
<li>如果 height[left] &lt; height[right]：
<ul>
<li>如果 height[left] &gt;= leftMax，更新 leftMax</li>
<li>否则，累加 leftMax - height[left] 到结果中</li>
<li>左指针向右移动</li>
</ul>
</li>
<li>否则：
<ul>
<li>如果 height[right] &gt;= rightMax，更新 rightMax</li>
<li>否则，累加 rightMax - height[right] 到结果中</li>
<li>右指针向左移动</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这种方法优化了空间复杂度，只需要常数额外空间。</p>
<h3 id="方法三：单调栈">方法三：单调栈</h3>
<p><strong>核心思想</strong>：使用单调递减栈来找到&quot;凹&quot;形区域，计算能接的雨水量。</p>
<h4 id="步骤详解：-3">步骤详解：</h4>
<ol>
<li>维护一个单调递减栈，栈中存储柱子的下标</li>
<li>遍历数组，对于每个柱子：
<ul>
<li>当栈不为空且当前柱子高度大于栈顶柱子高度时：
<ul>
<li>弹出栈顶元素 top（作为凹槽的底部）</li>
<li>如果栈为空，无法形成凹槽，继续</li>
<li>计算宽度：当前下标 - 新栈顶下标 - 1</li>
<li>计算高度：min(当前柱子高度, 新栈顶柱子高度) - 底部高度</li>
<li>累加 宽度 × 高度 到结果中</li>
</ul>
</li>
<li>将当前下标入栈</li>
</ul>
</li>
</ol>
<p>单调栈方法适合理解雨水积累的过程，特别是对于理解&quot;凹&quot;形区域的积水计算。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="方法一：动态规划-2">方法一：动态规划</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(height)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理左右最大高度</span></span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个位置的左侧最大高度</span></span><br><span class="line">    leftMax[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        leftMax[i] = max(leftMax[i<span class="number">-1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个位置的右侧最大高度</span></span><br><span class="line">    rightMax[n<span class="number">-1</span>] = height[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        rightMax[i] = max(rightMax[i+<span class="number">1</span>], height[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算总雨水量</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        result += min(leftMax[i], rightMax[i]) - height[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：双指针法-2">方法二：双指针法</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    leftMax, rightMax := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            <span class="keyword">if</span> height[left] &gt;= leftMax &#123;</span><br><span class="line">                leftMax = height[left]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += leftMax - height[left]</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> height[right] &gt;= rightMax &#123;</span><br><span class="line">                rightMax = height[right]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += rightMax - height[right]</span><br><span class="line">            &#125;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：单调栈-2">方法三：单调栈</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(height)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// 当栈不为空且当前高度大于栈顶高度时，可以形成凹槽</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; height[i] &gt; height[stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]] &#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶，作为凹槽底部</span></span><br><span class="line">            top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果栈为空，无法形成凹槽</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算凹槽的宽度和高度</span></span><br><span class="line">            left := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            width := i - left - <span class="number">1</span></span><br><span class="line">            h := min(height[i], height[left]) - height[top]</span><br><span class="line">            res += width * h</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前索引入栈</span></span><br><span class="line">        stack = <span class="built_in">append</span>(stack, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行过程分析">执行过程分析</h2>
<p>以示例 [0,1,0,2,1,0,1,3,2,1,2,1] 分析双指针法的执行过程：</p>
<p><strong>初始状态</strong>：</p>
<ul>
<li>left = 0, right = 11</li>
<li>leftMax = 0, rightMax = 0</li>
<li>result = 0</li>
</ul>
<p><strong>执行过程</strong>：</p>
<ol>
<li>
<p>height[0] = 0 &lt; height[11] = 1</p>
<ul>
<li>leftMax = max(0, 0) = 0</li>
<li>result += 0 - 0 = 0</li>
<li>left = 1</li>
</ul>
</li>
<li>
<p>height[1] = 1 = height[11] = 1 (相等，任选一边)</p>
<ul>
<li>leftMax = max(0, 1) = 1</li>
<li>left = 2</li>
</ul>
</li>
<li>
<p>height[2] = 0 &lt; height[11] = 1</p>
<ul>
<li>result += 1 - 0 = 1</li>
<li>left = 3</li>
</ul>
</li>
<li>
<p>height[3] = 2 &gt; height[11] = 1</p>
<ul>
<li>rightMax = max(0, 1) = 1</li>
<li>result += 1 - 1 = 0</li>
<li>right = 10</li>
</ul>
</li>
<li>
<p>height[3] = 2 = height[10] = 2</p>
<ul>
<li>rightMax = max(1, 2) = 2</li>
<li>right = 9</li>
</ul>
</li>
</ol>
<p>… (继续执行直到 left &gt;= right)</p>
<p><strong>最终结果</strong>：result = 6</p>
<h2 id="方法比较">方法比较</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>动态规划</th>
<th>双指针法</th>
<th>单调栈</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>易理解性</td>
<td>最直观，容易理解</td>
<td>抽象，需要理解左右边界</td>
<td>适合理解凹槽积水过程</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>简单</td>
<td>中等</td>
<td>较复杂</td>
</tr>
<tr>
<td>优点</td>
<td>思路清晰</td>
<td>空间效率最高</td>
<td>能处理多种地形</td>
</tr>
<tr>
<td>缺点</td>
<td>需要额外空间</td>
<td>思路不够直观</td>
<td>实现复杂</td>
</tr>
<tr>
<td>推荐度</td>
<td>★★★★☆</td>
<td>★★★★★</td>
<td>★★★☆☆</td>
</tr>
</tbody>
</table>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li>动态规划：O(n)，需要三次遍历数组</li>
<li>双指针：O(n)，只需一次遍历</li>
<li>单调栈：O(n)，每个元素最多入栈出栈各一次</li>
</ul>
</li>
<li>
<p><strong>空间复杂度</strong>：</p>
<ul>
<li>动态规划：O(n)，需要两个额外数组</li>
<li>双指针：O(1)，只使用常数额外空间</li>
<li>单调栈：O(n)，最坏情况下栈的大小为 n</li>
</ul>
</li>
</ul>
<h2 id="核心要点">核心要点</h2>
<ol>
<li><strong>理解积水条件</strong>：对于位置 i，能接的水量取决于 min(左侧最高，右侧最高) - 当前高度</li>
<li><strong>优化思路</strong>：从空间 O(n) 到 O(1) 的优化是本题的一个亮点</li>
<li><strong>双指针技巧</strong>：利用双指针避免使用额外空间，是解决此类问题的重要技巧</li>
</ol>
<h2 id="相关题目">相关题目</h2>
<ul>
<li>LeetCode 11: 盛最多水的容器</li>
<li>LeetCode 407: 接雨水 II（三维版本）</li>
<li>LeetCode 238: 除自身以外数组的乘积（类似的预处理思想）</li>
</ul>
<h2 id="总结">总结</h2>
<p>接雨水问题展示了多种算法思想：动态规划的预处理、双指针的空间优化、单调栈处理特定形状。通过分析每个位置能接的雨水量，我们可以得到整体的结果。在实际应用中，双指针法因其 O(1) 的空间复杂度而被认为是最优解，但动态规划法更易于理解和实现。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 41 - 缺失的第一个正数（First Missing Positive）</title>
    <url>/2025/04/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-41-first-missing-positive/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给你一个未排序的整数数组 <code>nums</code>，请你找出其中没有出现的最小的正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>约束条件：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 5 * 10^5</li>
<li>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</li>
</ul>
<p>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
<h2 id="解题思路">解题思路</h2>
<p>这道题的关键在于理解一个重要的性质：<strong>如果长度为 n 的数组包含所有 1 到 n 的数字，那么缺失的第一个正数就是 n+1。如果存在缺失，那么答案一定在 1 到 n+1 之间。</strong></p>
<p>基于这个性质，我们可以利用数组本身作为哈希表，实现原地哈希。思路是将值 x 放到索引 x-1 的位置，这样当我们再次遍历数组时，第一个不满足 nums[i] == i+1 的位置就是缺失的第一个正数。</p>
<h3 id="原地哈希的核心思想">原地哈希的核心思想</h3>
<p>假设我们有一个完美的数组，其中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums[0] = 1</span><br><span class="line">nums[1] = 2</span><br><span class="line">nums[2] = 3</span><br><span class="line">...</span><br><span class="line">nums[i] = i+1</span><br></pre></td></tr></table></figure>
<p>这样的数组中，每个正数都在&quot;家&quot;（正确的位置）。对于值 x，它的&quot;家&quot;是索引 x-1。</p>
<p>当数组中有缺失的正数时，我们就能通过查找哪个位置上的数不是&quot;应该在那里的数&quot;来找到答案。</p>
<h3 id="算法步骤：">算法步骤：</h3>
<ol>
<li>
<p><strong>原地哈希排序</strong>：</p>
<ul>
<li>遍历数组，将每个在 [1, n] 范围内的数放到其对应的位置</li>
<li>对于每个元素 nums[i]，如果 1 ≤ nums[i] ≤ n 并且 nums[i] ≠ nums[nums[i]-1]，则交换 nums[i] 和 nums[nums[i]-1]</li>
<li>继续检查交换后的 nums[i]，直到不需要交换为止</li>
</ul>
</li>
<li>
<p><strong>查找缺失的最小正数</strong>：</p>
<ul>
<li>再次遍历数组，找到第一个不满足 nums[i] = i+1 的位置</li>
<li>该位置的索引 +1 就是答案</li>
</ul>
</li>
</ol>
<h3 id="图示说明">图示说明</h3>
<p>对于数组 [3,4,-1,1]，原地哈希过程：</p>
<p>初始状态: [ 3, 4, -1, 1]<br>
↓<br>
排序过程: [-1, 1, 3, 4]<br>
↓ ↓<br>
最终状态: [ 1, -1, 3, 4]<br>
↓<br>
缺失的是 2</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：将每个数放到正确的位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// nums[i] 应该放在索引 nums[i]-1 的位置</span></span><br><span class="line">        <span class="comment">// 只处理在 [1,n] 范围内的值，且目标位置没有正确的值</span></span><br><span class="line">        <span class="keyword">for</span> nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i]<span class="number">-1</span>] != nums[i] &#123;</span><br><span class="line">            <span class="comment">// 交换 nums[i] 和 nums[nums[i]-1]</span></span><br><span class="line">            nums[i], nums[nums[i]<span class="number">-1</span>] = nums[nums[i]<span class="number">-1</span>], nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二阶段：找出第一个不满足 nums[i] == i+1 的位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i+<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数组包含了 1 到 n 的所有数，则缺失的第一个正数是 n+1</span></span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行过程分析">执行过程分析</h2>
<p>以数组 <code>[3, 4, -1, 1]</code> 为例，详细分析执行过程：</p>
<p><strong>第一阶段：原地哈希排序</strong></p>
<ol>
<li>i=0, nums[0]=3
<ul>
<li>3 应该在索引 2 的位置</li>
<li>交换 nums[0] 和 nums[2]：[3, 4, -1, 1] → [-1, 4, 3, 1]</li>
</ul>
</li>
<li>i=0, nums[0]=-1
<ul>
<li>-1 不在范围 [1, n] 内，跳过</li>
</ul>
</li>
<li>i=1, nums[1]=4
<ul>
<li>4 应该在索引 3 的位置</li>
<li>交换 nums[1] 和 nums[3]：[-1, 4, 3, 1] → [-1, 1, 3, 4]</li>
</ul>
</li>
<li>i=1, nums[1]=1
<ul>
<li>1 应该在索引 0 的位置</li>
<li>交换 nums[1] 和 nums[0]：[-1, 1, 3, 4] → [1, -1, 3, 4]</li>
</ul>
</li>
<li>i=1, nums[1]=-1
<ul>
<li>-1 不在范围 [1, n] 内，跳过</li>
</ul>
</li>
<li>i=2, nums[2]=3
<ul>
<li>3 已经在正确的位置（索引 2），跳过</li>
</ul>
</li>
<li>i=3, nums[3]=4
<ul>
<li>4 已经在正确的位置（索引 3），跳过</li>
</ul>
</li>
</ol>
<p>排序完成后的数组：[1, -1, 3, 4]</p>
<p><strong>第二阶段：查找缺失的最小正数</strong></p>
<ol>
<li>i=0, nums[0]=1 == 0+1 ✓</li>
<li>i=1, nums[1]=-1 != 1+1 ✗</li>
</ol>
<p>找到了第一个不满足条件的位置 i=1，因此答案是 1+1 = 2。</p>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><strong>时间复杂度</strong>：O(n)
<ul>
<li>虽然有嵌套循环，但每个元素最多被交换一次到正确位置，一旦到达正确位置就不会再移动</li>
<li>第二次遍历是线性的 O(n)</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(1)
<ul>
<li>原地修改数组，不使用额外空间</li>
</ul>
</li>
</ul>
<h2 id="常见错误与优化">常见错误与优化</h2>
<ol>
<li>
<p><strong>死循环问题</strong>：</p>
<ul>
<li>在内层循环的交换条件中，必须包含 <code>nums[nums[i]-1] != nums[i]</code></li>
<li>否则当 nums[i] 等于 nums[nums[i]-1] 时会陷入无限交换的死循环</li>
</ul>
</li>
<li>
<p><strong>提前返回问题</strong>：</p>
<ul>
<li>不能在第一阶段结束前判断结果，必须完成整个排序过程</li>
<li>因为数组可能还没有完全排好序</li>
</ul>
</li>
<li>
<p><strong>边界处理</strong>：</p>
<ul>
<li>注意处理负数和超出数组长度的值，它们不需要参与交换</li>
</ul>
</li>
</ol>
<h2 id="相关题目">相关题目</h2>
<ul>
<li>LeetCode 268: 丢失的数字</li>
<li>LeetCode 287: 寻找重复数</li>
<li>LeetCode 448: 找到所有数组中消失的数字</li>
</ul>
<h2 id="总结">总结</h2>
<p>缺失的第一个正数问题是一个经典的原地哈希问题。关键洞察在于：对于长度为 n 的数组，答案一定在 1 到 n+1 之间，这使得我们可以利用数组本身作为哈希表，将值 x 放在索引 x-1 的位置上。</p>
<p>这种方法的精妙之处在于它既满足了 O(n) 的时间复杂度要求，又满足了 O(1) 的空间复杂度要求。它展示了如何通过巧妙地利用问题约束来设计高效算法的思想。</p>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>Hot100</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>数组</tag>
        <tag>Hot100</tag>
        <tag>哈希</tag>
        <tag>❌错题集</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 34 - 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2024/07/30/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p><strong>进阶：</strong> 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
<p><strong>示例 1:</strong></p>
<ul>
<li><strong>输入:</strong> <code>nums = [5,7,7,8,8,10]</code>, <code>target = 8</code></li>
<li><strong>输出:</strong> <code>[3,4]</code></li>
</ul>
<p><strong>示例 2:</strong></p>
<ul>
<li><strong>输入:</strong> <code>nums = [5,7,7,8,8,10]</code>, <code>target = 6</code></li>
<li><strong>输出:</strong> <code>[-1,-1]</code></li>
</ul>
<p><strong>示例 3:</strong></p>
<ul>
<li><strong>输入:</strong> <code>nums = []</code>, <code>target = 0</code></li>
<li><strong>输出:</strong> <code>[-1,-1]</code></li>
</ul>
<p><strong>约束条件:</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
</ul>
<h2 id="核心设计思想：为何选择两次二分搜索？">核心设计思想：为何选择两次二分搜索？</h2>
<p>要解决这个问题并满足 O(log n) 的时间复杂度，<strong>二分搜索</strong>是唯一可行的路径。但标准的二分搜索只能判断一个元素是否存在，或者找到它的任意一个位置。我们的问题更复杂：需要找到一个可能重复出现的目标值的<strong>确切左右边界</strong>。</p>
<h4 id="方案一：一次二分搜索-线性扫描（被否决）">方案一：一次二分搜索 + 线性扫描（被否决）</h4>
<p>一个自然而然的想法是：</p>
<ol>
<li>用一次标准的二分搜索找到 <code>target</code> 的<strong>任意一个</strong>位置 <code>p</code>。</li>
<li>从 <code>p</code> 开始，向左线性扫描找到起始位置 <code>start</code>。</li>
<li>从 <code>p</code> 开始，向右线性扫描找到结束位置 <code>end</code>。</li>
</ol>
<p>这种方法在 <code>target</code> 不重复或重复次数很少时表现良好。但是，考虑最坏情况：<code>nums = [8, 8, 8, ..., 8]</code>。此时，线性扫描的复杂度会退化到 O(n)，导致整个算法的时间复杂度变为 O(log n + n) = O(n)，不符合题目的进阶要求。</p>
<h4 id="方案二：两次独立的二分搜索（最终选择）">方案二：两次独立的二分搜索（最终选择）</h4>
<p>为了保证 O(log n) 的复杂度，我们必须在查找边界的过程中也使用对数时间复杂度的算法。这就引出了最终的设计：<strong>执行两次独立的、经过特殊改造的二分搜索</strong>。</p>
<ol>
<li><strong>第一次搜索</strong>：专门设计用于查找<strong>左边界</strong>（起始位置）。</li>
<li><strong>第二次搜索</strong>：专门设计用于查找<strong>右边界</strong>（结束位置）。</li>
</ol>
<p>这种&quot;分而治之&quot;的思想，将一个复杂问题（寻找一个区间）分解为两个独立的、更简单的子问题（分别寻找左、右边界），每次查找都保持 O(log n) 的效率，从而确保总体复杂度达标。</p>
<h2 id="解题思路与实现细节">解题思路与实现细节</h2>
<h3 id="🚀-二分搜索的精髓：循环不变量与边界收敛">🚀 二分搜索的精髓：循环不变量与边界收敛</h3>
<blockquote>
<p><strong>重点标记：</strong><br>
这道题是学习二分搜索的绝佳范例。它考察的不是你是否会写二分搜索，而是你是否真正理解其<strong>核心原理</strong>，特别是<strong>循环不变量 (loop invariant)</strong> 和<strong>边界收敛</strong>。</p>
<p><strong>循环不变量</strong>是指在循环的每次迭代之前和之后都保持为真的一个条件。在我们的二分搜索中，这个不变量就是 <strong>“目标值（如果存在）一定在闭区间 <code>[left, right]</code> 内”</strong>。</p>
<ul>
<li>循环条件 <code>while (left &lt;= right)</code> 保证了只要这个区间有效（<code>left</code> 不大于 <code>right</code>），我们就继续搜索。当 <code>left &gt; right</code> 时，区间 <code>[left, right]</code> 变为空，说明搜索结束。</li>
<li>边界更新 <code>left = mid + 1</code> 或 <code>right = mid - 1</code> 的设计，正是为了在排除 <code>mid</code> 后，继续维持这个不变量。</li>
</ul>
<p>理解了这一点，你就能自信地调整边界更新逻辑，以满足不同的查找目标（左边界、右边界，或第一个大于/小于某值的元素）。</p>
</blockquote>
<h3 id="第一次搜索：查找起始位置（左边界）">第一次搜索：查找起始位置（左边界）</h3>
<p><strong>目标</strong>：找到第一个<strong>大于或等于</strong> <code>target</code> 的位置。</p>
<ul>
<li><strong><code>nums[mid] &lt; target</code></strong>: 这意味着 <code>mid</code> 以及其左边的所有元素都<strong>绝对不是</strong>起始位置。因此，我们将搜索区间的左边界移动到 <code>mid</code> 的右边：<code>left = mid + 1</code>。</li>
<li><strong><code>nums[mid] &gt;= target</code></strong>: 这意味着 <code>mid</code> <strong>可能是</strong>起始位置，但它左边可能还有更早的 <code>target</code>。我们不能排除 <code>mid</code>，但可以肯定起始位置<strong>不会在 <code>mid</code> 的右边</strong>。因此，我们将搜索区间的右边界收缩到 <code>mid</code> 的左边：<code>right = mid - 1</code>，并期望在下一轮找到更靠左的位置。</li>
</ul>
<p><strong>指针收敛过程</strong>：<br>
当循环结束时（<code>left &gt; right</code>），<code>left</code> 指针将停在这样一个位置：它是数组中第一个值大于或等于 <code>target</code> 的索引。我们只需在循环后检查 <code>nums[left]</code> 是否确实等于 <code>target</code>，即可确认是否找到了起始位置。</p>
<h3 id="第二次搜索：查找结束位置（右边界）">第二次搜索：查找结束位置（右边界）</h3>
<p><strong>目标</strong>：找到最后一个<strong>小于或等于</strong> <code>target</code> 的位置。</p>
<ul>
<li><strong><code>nums[mid] &lt;= target</code></strong>: 这意味着 <code>mid</code> <strong>可能是</strong>结束位置，或者结束位置在它的右边。我们不能排除 <code>mid</code>，但可以肯定结束位置<strong>不会在 <code>mid</code> 的左边</strong>。因此，我们将搜索区间的左边界移动到 <code>mid</code> 的右边：<code>left = mid + 1</code>，并期望在下一轮找到更靠右的位置。</li>
<li><strong><code>nums[mid] &gt; target</code></strong>: 这意味着 <code>mid</code> 以及其右边的所有元素都<strong>绝对不是</strong>结束位置。因此，我们将搜索区间的右边界收缩到 <code>mid</code> 的左边：<code>right = mid - 1</code>。</li>
</ul>
<p><strong>指针收敛过程</strong>：<br>
当循环结束时（<code>left &gt; right</code>），<code>right</code> 指针将停在这样一个位置：它是数组中最后一个值小于或等于 <code>target</code> 的索引。这个位置就是我们要找的结束位置。</p>
<h2 id="代码实现">代码实现</h2>
<p>这是使用 Go 语言实现的完整代码，其中包含了两次二分搜索。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=34 lang=golang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [34] 在排序数组中查找元素的第一个和最后一个位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> start, end <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 第一次二分搜索：查找起始位置 ---</span></span><br><span class="line">	left, right := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		mid := left + (right-left)&gt;&gt;<span class="number">1</span> <span class="comment">// 防止溢出</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt;= target</span></span><br><span class="line">			<span class="comment">// 即使找到 target，也继续向左寻找更早出现的位置</span></span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环结束后，left 是第一个 &gt;= target 的位置</span></span><br><span class="line">	<span class="comment">// 检查左边界是否合法</span></span><br><span class="line">	<span class="keyword">if</span> left &gt;= n || nums[left] != target &#123;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	start = left</span><br><span class="line"></span><br><span class="line">	<span class="comment">// --- 第二次二分搜索：查找结束位置 ---</span></span><br><span class="line">	left, right = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		mid := left + (right-left)&gt;&gt;<span class="number">1</span> <span class="comment">// 防止溢出</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &lt;= target &#123;</span><br><span class="line">			<span class="comment">// 即使找到 target，也继续向右寻找更晚出现的位置</span></span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt; target</span></span><br><span class="line">			right = mid - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 循环结束后，right 是最后一个 &lt;= target 的位置</span></span><br><span class="line">	end = right</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> []<span class="type">int</span>&#123;start, end&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>
<p><strong>时间复杂度:</strong> O(log n)</p>
<ul>
<li>我们执行了两次独立的二分搜索，每次的时间复杂度都是 O(log n)。</li>
<li>因此，总的时间复杂度为 O(log n) + O(log n) = O(log n)。</li>
</ul>
</li>
<li>
<p><strong>空间复杂度:</strong> O(1)</p>
<ul>
<li>我们只使用了有限的几个变量 (<code>start</code>, <code>end</code>, <code>left</code>, <code>right</code>, <code>mid</code>, <code>n</code>)，没有使用额外的存储空间。</li>
</ul>
</li>
</ul>
<h2 id="关键收获">关键收获</h2>
<ul>
<li><strong>分治思想</strong>：将&quot;寻找一个区间&quot;的复杂问题，拆分为&quot;寻找左边界&quot;和&quot;寻找右边界&quot;两个独立的、更简单的问题，是解决复杂问题的有效策略。</li>
<li><strong>理解循环不变量</strong>：二分搜索的核心是维护&quot;目标在 <code>[left, right]</code> 区间内&quot;这个不变量。理解这一点，可以帮助你正确地设计循环条件和边界更新逻辑。</li>
<li><strong>边界调整的艺术</strong>：通过微调 <code>if</code> 条件和 <code>left</code>/<code>right</code> 的更新方式，二分搜索可以实现多种查找目标（如第一个大于X的数，最后一个小于X的数等），这是其强大灵活性的体现。</li>
<li><strong>代码健壮性</strong>：计算 <code>mid</code> 时使用 <code>left + (right-left)&gt;&gt;1</code> 而不是 <code>(left+right)&gt;&gt;1</code>，可以有效防止当 <code>left</code> 和 <code>right</code> 都很大时可能发生的整数溢出问题。</li>
</ul>
]]></content>
      <categories>
        <category>算法刷题</category>
        <category>LeetCode</category>
        <category>面试经典150</category>
      </categories>
      <tags>
        <tag>面试经典150</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>Medium</tag>
        <tag>二分搜索</tag>
      </tags>
  </entry>
</search>
